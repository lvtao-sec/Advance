[{"API_info": {"var": ["sqlite3*", "onoff"], "API_desc": " The sqlite3_extended_result_codes_APIName routine enables or disables the extended result codes feature of SQLite.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_extended_result_codes_APIName routine enables or disables the extended result codes feature of SQLite.The extended result codes are disabled by default for historical compatibility.", "key": "sqlite3_extended_result_codes", "sent": "The sqlite3_extended_result_codes_APIName routine enables or disables the extended result codes feature of SQLite."}, {"API_info": {"var": ["sqlite3*", "onoff"], "API_desc": " The sqlite3_extended_result_codes_APIName routine enables or disables the extended result codes feature of SQLite.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_extended_result_codes_APIName routine enables or disables the extended result codes feature of SQLite.The extended result codes are disabled by default for historical compatibility.", "key": "sqlite3_extended_result_codes", "sent": "The extended result codes are disabled by default for historical compatibility."}, {"API_info": {"var": ["sqlite3*", "const char *", "int (*callback)(void*,int,char**,char**)", "void *", "char **"], "API_desc": "The sqlite3_exec interface is a convenience wrapper", "var_type": ["sqlite3*", "const char *", "int (*callback)(void*,int,char**,char**)", "void *", "char **"], "ret_type": "int"}, "paraph": "The application must ensure that the 1_APIConstant parameter to sqlite3_exec_APIName is a valid and open database connection.", "key": "sqlite3_exec", "sent": "The application must ensure that the 1_APIConstant parameter to sqlite3_exec_APIName is a valid and open database connection."}, {"API_info": {"var": ["void"], "API_desc": " This interface disables all automatic extensions previously registered using sqlite3_auto_extension_APIName.", "var_type": ["void"], "ret_type": "void"}, "paraph": "This interface disables all automatic extensions previously registered using sqlite3_auto_extension_APIName.", "key": "sqlite3_reset_auto_extension", "sent": "This interface disables all automatic extensions previously registered using sqlite3_auto_extension_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " This interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_mutex *"}, "paraph": "This interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized.If the threading mode is Single-thread or Multi-thread then this routine returns a NULL pointer.", "key": "sqlite3_db_mutex", "sent": "If the threading mode is Single-thread or Multi-thread then this routine returns a NULL pointer."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.These counters can be used to monitor the performance characteristics of the prepared statements.For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.", "key": "sqlite3_stmt_status", "sent": "These counters can be used to monitor the performance characteristics of the prepared statements."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve and reset counter values from a prepared statement.The first argument is the prepared statement object to be interrogated.The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated.The current value of the requested counter be returned by sqlite3_stmt_status_APIName.If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns.", "key": "sqlite3_stmt_status", "sent": "This interface is used to retrieve and reset counter values from a prepared statement."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve and reset counter values from a prepared statement.The first argument is the prepared statement object to be interrogated.The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated.The current value of the requested counter be returned by sqlite3_stmt_status_APIName.If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns.", "key": "sqlite3_stmt_status", "sent": "The first argument is the prepared statement object to be interrogated."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Summary:", "key": "sqlite3_column_blob", "sent": "Summary:"}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve and reset counter values from a prepared statement.The first argument is the prepared statement object to be interrogated.The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated.The current value of the requested counter be returned by sqlite3_stmt_status_APIName.If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns.", "key": "sqlite3_stmt_status", "sent": "The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.These counters can be used to monitor the performance characteristics of the prepared statements.For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.", "key": "sqlite3_stmt_status", "sent": "Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve and reset counter values from a prepared statement.The first argument is the prepared statement object to be interrogated.The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated.The current value of the requested counter be returned by sqlite3_stmt_status_APIName.If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns.", "key": "sqlite3_stmt_status", "sent": "The current value of the requested counter be returned by sqlite3_stmt_status_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "See also: sqlite3_status_APIName and sqlite3_db_status_APIName.", "key": "sqlite3_stmt_status", "sent": "See also: sqlite3_status_APIName and sqlite3_db_status_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Details:", "key": "sqlite3_column_blob", "sent": "Details:"}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve and reset counter values from a prepared statement.The first argument is the prepared statement object to be interrogated.The second argument is an integer code for a specific SQLITE_STMTSTATUS counter to be interrogated.The current value of the requested counter be returned by sqlite3_stmt_status_APIName.If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns.", "key": "sqlite3_stmt_status", "sent": "If the sqlite3_stmt_status_APIParam_3 is true, then the counter is reset to zero after this interface call returns."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " This interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_mutex *"}, "paraph": "This interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized.If the threading mode is Single-thread or Multi-thread then this routine returns a NULL pointer.", "key": "sqlite3_db_mutex", "sent": "This interface returns a pointer the sqlite3_mutex object that serializes access to the database connection given in the argument when the threading mode is Serialized."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "These routines return information about a single column of the current result row of a query.In every case sqlite3_column_int_APIParam_1 is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that be returned by sqlite3_column_int_APIName from sqlite3_prepare_v2_APIName or one of its variants) and sqlite3_column_int_APIParam_2 is the index of the column for which information should be returned.The leftmost column of the result set has the index 0.The number of columns in the result can be determined using sqlite3_column_count_APIName.", "key": "sqlite3_column_text16", "sent": "The leftmost column of the result set has the index 0."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "These routines return information about a single column of the current result row of a query.In every case sqlite3_column_int_APIParam_1 is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that be returned by sqlite3_column_int_APIName from sqlite3_prepare_v2_APIName or one of its variants) and sqlite3_column_int_APIParam_2 is the index of the column for which information should be returned.The leftmost column of the result set has the index 0.The number of columns in the result can be determined using sqlite3_column_count_APIName.", "key": "sqlite3_column_bytes", "sent": "The number of columns in the result can be determined using sqlite3_column_count_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "These routines return information about a single column of the current result row of a query.In every case sqlite3_column_int_APIParam_1 is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that be returned by sqlite3_column_int_APIName from sqlite3_prepare_v2_APIName or one of its variants) and sqlite3_column_int_APIParam_2 is the index of the column for which information should be returned.The leftmost column of the result set has the index 0.The number of columns in the result can be determined using sqlite3_column_count_APIName.", "key": "sqlite3_column_blob", "sent": "These routines return information about a single column of the current result row of a query."}, {"API_info": {"var": ["sqlite3*", "sqlite3_int64"], "API_desc": " The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid_APIName to R without inserting a row into the database.", "var_type": ["sqlite3*", "sqlite3_int64"], "ret_type": "void"}, "paraph": "The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid_APIName to R without inserting a row into the database.", "key": "sqlite3_set_last_insert_rowid", "sent": "The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid_APIName to R without inserting a row into the database."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "These routines return information about a single column of the current result row of a query.In every case sqlite3_column_int_APIParam_1 is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that be returned by sqlite3_column_int_APIName from sqlite3_prepare_v2_APIName or one of its variants) and sqlite3_column_int_APIParam_2 is the index of the column for which information should be returned.The leftmost column of the result set has the index 0.The number of columns in the result can be determined using sqlite3_column_count_APIName.", "key": "sqlite3_column_int", "sent": "In every case sqlite3_column_int_APIParam_1 is a pointer to the prepared statement that is being evaluated and sqlite3_column_int_APIParam_2 is the index of the column  ."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const unsigned char *"}, "paraph": "The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format.If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text_APIName interface is used to extract the value) then an automatic type conversion is performed.", "key": "sqlite3_column_text", "sent": "The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const unsigned char *"}, "paraph": "The first six interfaces (_blob, _double, _int, _int64, _text, and _text16) each return the value of a result column in a specific data format.If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text_APIName interface is used to extract the value) then an automatic type conversion is performed.", "key": "sqlite3_column_text", "sent": "If the result column is not initially in the requested format (for example, if the query returns an integer but the sqlite3_column_text_APIName interface is used to extract the value) then an automatic type conversion is performed."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined.These routines may only be called when the most recent call to sqlite3_step_APIName has returned SQLITE_ROW_API_constant and neither sqlite3_reset_APIName nor sqlite3_finalize_APIName have been called subsequently.If any of these routines are called after sqlite3_reset_APIName or sqlite3_finalize_APIName or after sqlite3_step_APIName has returned something other than SQLITE_ROW_API_constant, the results are undefined.If sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName are called from a different thread while any of these routines are pending, then the results are undefined.", "key": "sqlite3_column_int", "sent": "These routines may only be called when the most recent call to sqlite3_step_APIName has returned SQLITE_ROW_API_constant and neither sqlite3_reset_APIName nor sqlite3_finalize_APIName have been called subsequently."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined.These routines may only be called when the most recent call to sqlite3_step_APIName has returned SQLITE_ROW_API_constant and neither sqlite3_reset_APIName nor sqlite3_finalize_APIName have been called subsequently.If any of these routines are called after sqlite3_reset_APIName or sqlite3_finalize_APIName or after sqlite3_step_APIName has returned something other than SQLITE_ROW_API_constant, the results are undefined.If sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName are called from a different thread while any of these routines are pending, then the results are undefined.", "key": "sqlite3_column_text16", "sent": "If any of these routines are called after sqlite3_reset_APIName or sqlite3_finalize_APIName or after sqlite3_step_APIName has returned something other than SQLITE_ROW_API_constant, the results are undefined."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined.These routines may only be called when the most recent call to sqlite3_step_APIName has returned SQLITE_ROW_API_constant and neither sqlite3_reset_APIName nor sqlite3_finalize_APIName have been called subsequently.If any of these routines are called after sqlite3_reset_APIName or sqlite3_finalize_APIName or after sqlite3_step_APIName has returned something other than SQLITE_ROW_API_constant, the results are undefined.If sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName are called from a different thread while any of these routines are pending, then the results are undefined.", "key": "sqlite3_column_blob", "sent": "If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined.These routines may only be called when the most recent call to sqlite3_step_APIName has returned SQLITE_ROW_API_constant and neither sqlite3_reset_APIName nor sqlite3_finalize_APIName have been called subsequently.If any of these routines are called after sqlite3_reset_APIName or sqlite3_finalize_APIName or after sqlite3_step_APIName has returned something other than SQLITE_ROW_API_constant, the results are undefined.If sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName are called from a different thread while any of these routines are pending, then the results are undefined.", "key": "sqlite3_column_bytes", "sent": "If sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName are called from a different thread while any of these routines are pending, then the results are undefined."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question."}, {"API_info": {"var": ["sqlite3_stmt*", "op", "resetFlg"], "API_desc": " Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.", "var_type": ["sqlite3_stmt*", "int", "int"], "ret_type": "int"}, "paraph": "Each prepared statement maintains various SQLITE_STMTSTATUS counters that measure the number of times it has performed specific operations.These counters can be used to monitor the performance characteristics of the prepared statements.For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index.", "key": "sqlite3_stmt_status", "sent": "For example, if the number of table steps greatly exceeds the number of table searches or result rows, that would tend to indicate that the prepared statement is using a full table scan rather than an index."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-16 string, then sqlite3_column_bytes_APIName converts the string to UTF-8 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-8 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is NULL, then sqlite3_column_bytes_APIName returns zero."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_column_type_APIName routine returns the datatype code for the initial data type of the result column.sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value.The value returned by sqlite3_column_type_APIName is only meaningful if no automatic type conversions have occurred for the value in question.After a type conversion, the result of calling sqlite3_column_type_APIName is undefined, though harmless.Future versions of SQLite may change the behavior of sqlite3_column_type_APIName following a type conversion.", "key": "sqlite3_column_type", "sent": "The return value of sqlite3_column_type_APIName can be used to decide which of the first six interface should be used to extract the column value."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-16 string, then sqlite3_column_bytes_APIName converts the string to UTF-8 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-8 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a UTF-16 string, then sqlite3_column_bytes_APIName converts the string to UTF-8 and then returns the number of bytes."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-8 string, then sqlite3_column_bytes16_APIName converts the string to UTF-16 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes16_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-16 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes16_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is NULL, then sqlite3_column_bytes16_APIName returns zero."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName interfaces can be used to determine the size of that BLOB or string.", "key": "sqlite3_column_bytes", "sent": "If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName interfaces can be used to determine the size of that BLOB or string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-16 string, then sqlite3_column_bytes_APIName converts the string to UTF-8 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-8 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes_APIName routine returns the number of bytes in that BLOB or string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-8 string, then sqlite3_column_bytes16_APIName converts the string to UTF-16 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes16_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-16 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes16_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a UTF-8 string, then sqlite3_column_bytes16_APIName converts the string to UTF-16 and then returns the number of bytes."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const unsigned char *"}, "paraph": "Strings returned by sqlite3_column_text_APIName and sqlite3_column_text16_APIName, even empty strings, are always zero-terminated.The return value from sqlite3_column_blob_APIName for a zero-length BLOB is a NULL pointer.", "key": "sqlite3_column_text", "sent": "Strings returned by sqlite3_column_text_APIName and sqlite3_column_text16_APIName, even empty strings, are always zero-terminated."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Strings returned by sqlite3_column_text_APIName and sqlite3_column_text16_APIName, even empty strings, are always zero-terminated.The return value from sqlite3_column_blob_APIName for a zero-length BLOB is a NULL pointer.", "key": "sqlite3_column_blob", "sent": "The return value from sqlite3_column_blob_APIName for a zero-length BLOB is a NULL pointer."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_value *"}, "paraph": "Warning: The object returned by sqlite3_column_value_APIName is an unprotected sqlite3_value object.In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName.If the unprotected sqlite3_value object returned by sqlite3_column_value_APIName is used in any other way, including calls to routines like sqlite3_value_int_APIName, sqlite3_value_text_APIName, or sqlite3_value_bytes_APIName, the behavior is not threadsafe.Hence, the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables, not within top-level application code.", "key": "sqlite3_column_value", "sent": "Warning: The object returned by sqlite3_column_value_APIName is an unprotected sqlite3_value object."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName do not include the zero terminators at the end of the string.For clarity: the values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName are the number of bytes in the string, not the number of characters.", "key": "sqlite3_column_bytes", "sent": "The values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName do not include the zero terminators at the end of the string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_value *"}, "paraph": "The these routines may attempt to convert the datatype of the result.For example, if the internal representation is FLOAT and a text result is requested, sqlite3_snprintf_APIName is used internally to perform the conversion automatically.The following table details the conversions that are applied:", "key": "sqlite3_column_value", "sent": "The following table details the conversions that are applied:"}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The these routines may attempt to convert the datatype of the result.For example, if the internal representation is FLOAT and a text result is requested, sqlite3_snprintf_APIName is used internally to perform the conversion automatically.The following table details the conversions that are applied:", "key": "sqlite3_column_blob", "sent": "The these routines may attempt to convert the datatype of the result."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "The values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName do not include the zero terminators at the end of the string.For clarity: the values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName are the number of bytes in the string, not the number of characters.", "key": "sqlite3_column_bytes", "sent": "For clarity: the values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName are the number of bytes in the string, not the number of characters."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-8 string, then sqlite3_column_bytes16_APIName converts the string to UTF-16 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes16_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-16 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes16_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16_APIName routine returns the number of bytes in that BLOB or string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-16 string, then sqlite3_column_bytes_APIName converts the string to UTF-8 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-8 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a numeric value then sqlite3_column_bytes_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-8 string and returns the number of bytes in that string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob_APIName, sqlite3_column_text_APIName, and/or sqlite3_column_text16_APIName may be invalidated.Type conversions and pointer invalidations might occur in the following cases:", "key": "sqlite3_column_blob", "sent": "Type conversions and pointer invalidations might occur in the following cases:"}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_value *"}, "paraph": "Warning: The object returned by sqlite3_column_value_APIName is an unprotected sqlite3_value object.In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName.If the unprotected sqlite3_value object returned by sqlite3_column_value_APIName is used in any other way, including calls to routines like sqlite3_value_int_APIName, sqlite3_value_text_APIName, or sqlite3_value_bytes_APIName, the behavior is not threadsafe.Hence, the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables, not within top-level application code.", "key": "sqlite3_column_value", "sent": "In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob_APIName, sqlite3_column_text_APIName, and/or sqlite3_column_text16_APIName may be invalidated.Type conversions and pointer invalidations might occur in the following cases:", "key": "sqlite3_column_blob", "sent": "Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob_APIName, sqlite3_column_text_APIName, and/or sqlite3_column_text16_APIName may be invalidated."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The safest policy is to invoke these routines in one of the following ways:", "key": "sqlite3_column_blob", "sent": "The safest policy is to invoke these routines in one of the following ways:"}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_int64"}, "paraph": "The these routines may attempt to convert the datatype of the result.For example, if the internal representation is FLOAT and a text result is requested, sqlite3_snprintf_APIName is used internally to perform the conversion automatically.The following table details the conversions that are applied:", "key": "sqlite3_column_int64", "sent": "For example, if the internal representation is FLOAT and a text result is requested, sqlite3_snprintf_APIName is used internally to perform the conversion automatically."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "int"}, "paraph": "If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16_APIName routine returns the number of bytes in that BLOB or string.If the result is a UTF-8 string, then sqlite3_column_bytes16_APIName converts the string to UTF-16 and then returns the number of bytes.If the result is a numeric value then sqlite3_column_bytes16_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-16 string and returns the number of bytes in that string.If the result is NULL, then sqlite3_column_bytes16_APIName returns zero.", "key": "sqlite3_column_bytes", "sent": "If the result is a numeric value then sqlite3_column_bytes16_APIName uses sqlite3_snprintf_APIName to convert that value to a UTF-16 string and returns the number of bytes in that string."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called.The memory space used to hold strings and BLOBs is freed automatically.Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc.into sqlite3_free_APIName.", "key": "sqlite3_column_blob", "sent": "into sqlite3_free_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_value *"}, "paraph": "Warning: The object returned by sqlite3_column_value_APIName is an unprotected sqlite3_value object.In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName.If the unprotected sqlite3_value object returned by sqlite3_column_value_APIName is used in any other way, including calls to routines like sqlite3_value_int_APIName, sqlite3_value_text_APIName, or sqlite3_value_bytes_APIName, the behavior is not threadsafe.Hence, the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables, not within top-level application code.", "key": "sqlite3_column_value", "sent": "If the unprotected sqlite3_value object returned by sqlite3_column_value_APIName is used in any other way, including calls to routines like sqlite3_value_int_APIName, sqlite3_value_text_APIName, or sqlite3_value_bytes_APIName, the behavior is not threadsafe."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called.The memory space used to hold strings and BLOBs is freed automatically.Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc.into sqlite3_free_APIName.", "key": "sqlite3_column_blob", "sent": "Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called.The memory space used to hold strings and BLOBs is freed automatically.Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc.into sqlite3_free_APIName.", "key": "sqlite3_column_blob", "sent": "The memory space used to hold strings and BLOBs is freed automatically."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "sqlite3_value *"}, "paraph": "Warning: The object returned by sqlite3_column_value_APIName is an unprotected sqlite3_value object.In a multithreaded environment, an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName.If the unprotected sqlite3_value object returned by sqlite3_column_value_APIName is used in any other way, including calls to routines like sqlite3_value_int_APIName, sqlite3_value_text_APIName, or sqlite3_value_bytes_APIName, the behavior is not threadsafe.Hence, the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables, not within top-level application code.", "key": "sqlite3_column_value", "sent": "Hence, the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables, not within top-level application code."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "In other words, you should call sqlite3_column_text_APIName, sqlite3_column_blob_APIName, or sqlite3_column_text16_APIName first to force the result into the desired format, then invoke sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName to find the size of the result.Do not mix calls to sqlite3_column_text_APIName or sqlite3_column_blob_APIName with calls to sqlite3_column_bytes16_APIName, and do not mix calls to sqlite3_column_text16_APIName with calls to sqlite3_column_bytes_APIName.", "key": "sqlite3_column_blob", "sent": "Do not mix calls to sqlite3_column_text_APIName or sqlite3_column_blob_APIName with calls to sqlite3_column_bytes16_APIName, and do not mix calls to sqlite3_column_text16_APIName with calls to sqlite3_column_bytes_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called.The memory space used to hold strings and BLOBs is freed automatically.Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc.into sqlite3_free_APIName.", "key": "sqlite3_column_blob", "sent": "The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified.Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.", "key": "sqlite3_column_text16", "sent": "Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion.Only the following subset of interfaces are subject to out-of-memory errors:", "key": "sqlite3_column_text16", "sent": "Only the following subset of interfaces are subject to out-of-memory errors:"}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion.Only the following subset of interfaces are subject to out-of-memory errors:", "key": "sqlite3_column_blob", "sent": "As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "In other words, you should call sqlite3_column_text_APIName, sqlite3_column_blob_APIName, or sqlite3_column_text16_APIName first to force the result into the desired format, then invoke sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName to find the size of the result.Do not mix calls to sqlite3_column_text_APIName or sqlite3_column_blob_APIName with calls to sqlite3_column_bytes16_APIName, and do not mix calls to sqlite3_column_text16_APIName with calls to sqlite3_column_bytes_APIName.", "key": "sqlite3_column_blob", "sent": "In other words, you should call sqlite3_column_text_APIName, sqlite3_column_blob_APIName, or sqlite3_column_text16_APIName first to force the result into the desired format, then invoke sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName to find the size of the result."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value.Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection.", "key": "sqlite3_column_blob", "sent": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified.Other kinds of conversion are done in place when it is possible, but sometimes they are not possible and in those cases prior pointers are invalidated.", "key": "sqlite3_column_blob", "sent": "Conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer references will have been modified."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.The use of the new \"vX\" interface is recommended for new applications but the legacy interface will continue to be supported.", "key": "sqlite3_step", "sent": "The use of the new \"vX\" interface is recommended for new applications but the legacy interface will continue to be supported."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "In the legacy interface, the return value will be either SQLITE_BUSY_API_constant, SQLITE_DONE_API_constant, SQLITE_ROW_API_constant, SQLITE_ERROR_API_constant, or SQLITE_MISUSE_API_constant.With the \"v2\" interface, any of the other result codes or extended result codes might be returned as well.", "key": "sqlite3_step", "sent": "In the legacy interface, the return value will be either SQLITE_BUSY_API_constant, SQLITE_DONE_API_constant, SQLITE_ROW_API_constant, SQLITE_ERROR_API_constant, or SQLITE_MISUSE_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_DONE_API_constant means that the statement has finished executing successfully.sqlite3_step_APIName should not be called again on this virtual machine without first calling sqlite3_reset_APIName to reset the virtual machine back to its initial state.", "key": "sqlite3_step", "sent": "SQLITE_DONE_API_constant means that the statement has finished executing successfully."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "In the legacy interface, the return value will be either SQLITE_BUSY_API_constant, SQLITE_DONE_API_constant, SQLITE_ROW_API_constant, SQLITE_ERROR_API_constant, or SQLITE_MISUSE_API_constant.With the \"v2\" interface, any of the other result codes or extended result codes might be returned as well.", "key": "sqlite3_step", "sent": "With the \"v2\" interface, any of the other result codes or extended result codes might be returned as well."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_BUSY_API_constant means that the database engine was unable to acquire the database locks it needs to do its job.If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement.If the statement is not a COMMIT and occurs within an explicit transaction then you should rollback the transaction before continuing.", "key": "sqlite3_step", "sent": "If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "If the SQL statement being executed returns any data, then SQLITE_ROW_API_constant be returned by sqlite3_step_APIName each time a new row of data is ready for processing by the caller.The values may be accessed using the column access functions.sqlite3_step_APIName is called again to retrieve the next row of data.", "key": "sqlite3_step", "sent": "The values may be accessed using the column access functions."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred.sqlite3_step_APIName should not be called again on the VM.More information may be found by calling sqlite3_errmsg_APIName.With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement.In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.", "key": "sqlite3_step", "sent": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "If the SQL statement being executed returns any data, then SQLITE_ROW_API_constant be returned by sqlite3_step_APIName each time a new row of data is ready for processing by the caller.The values may be accessed using the column access functions.sqlite3_step_APIName is called again to retrieve the next row of data.", "key": "sqlite3_step", "sent": "sqlite3_step_APIName is called again to retrieve the next row of data."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred.sqlite3_step_APIName should not be called again on the VM.More information may be found by calling sqlite3_errmsg_APIName.With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement.In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.", "key": "sqlite3_step", "sent": "sqlite3_step_APIName should not be called again on the VM."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_BUSY_API_constant means that the database engine was unable to acquire the database locks it needs to do its job.If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement.If the statement is not a COMMIT and occurs within an explicit transaction then you should rollback the transaction before continuing.", "key": "sqlite3_step", "sent": "SQLITE_BUSY_API_constant means that the database engine was unable to acquire the database locks it needs to do its job."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred.sqlite3_step_APIName should not be called again on the VM.More information may be found by calling sqlite3_errmsg_APIName.With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement.In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.", "key": "sqlite3_step", "sent": "More information may be found by calling sqlite3_errmsg_APIName."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_DONE_API_constant means that the statement has finished executing successfully.sqlite3_step_APIName should not be called again on this virtual machine without first calling sqlite3_reset_APIName to reset the virtual machine back to its initial state.", "key": "sqlite3_step", "sent": "sqlite3_step_APIName should not be called again on this virtual machine without first calling sqlite3_reset_APIName to reset the virtual machine back to its initial state."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_BUSY_API_constant means that the database engine was unable to acquire the database locks it needs to do its job.If the statement is a COMMIT or occurs outside of an explicit transaction, then you can retry the statement.If the statement is not a COMMIT and occurs within an explicit transaction then you should rollback the transaction before continuing.", "key": "sqlite3_step", "sent": "If the statement is not a COMMIT and occurs within an explicit transaction then you should rollback the transaction before continuing."}, {"API_info": {"var": ["sqlite3_stmt*", "iCol"], "API_desc": "In every case the first argument is a pointer to the prepared statement that is being evaluated (the sqlite3_stmt* that was returned from sqlite3_prepare_v2_APIName or one of its variants) and the second argument is the index of the column for which information should be returned.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value.Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection.", "key": "sqlite3_column_text16", "sent": "Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_MISUSE_API_constant means that the this routine was called inappropriately.Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR_API_constant or SQLITE_DONE_API_constant.Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.", "key": "sqlite3_step", "sent": "SQLITE_MISUSE_API_constant means that the this routine was called inappropriately."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred.sqlite3_step_APIName should not be called again on the VM.More information may be found by calling sqlite3_errmsg_APIName.With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement.In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.", "key": "sqlite3_step", "sent": "With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_ERROR_API_constant means that a run-time error (such as a constraint violation) has occurred.sqlite3_step_APIName should not be called again on the VM.More information may be found by calling sqlite3_errmsg_APIName.With the legacy interface, a more specific error code (for example, SQLITE_INTERRUPT_API_constant, SQLITE_SCHEMA_API_constant, SQLITE_CORRUPT_API_constant, and so forth) can be obtained by calling sqlite3_reset_APIName on the prepared statement.In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.", "key": "sqlite3_step", "sent": "In the \"v2\" interface, the more specific error code be returned by sqlite3_step_APIName directly by sqlite3_step_APIName."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName.Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName.But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant.This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition.The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.", "key": "sqlite3_step", "sent": "Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName.Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName.But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant.This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition.The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.", "key": "sqlite3_step", "sent": "The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName.Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName.But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant.This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition.The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.", "key": "sqlite3_step", "sent": "But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.The use of the new \"vX\" interface is recommended for new applications but the legacy interface will continue to be supported.", "key": "sqlite3_step", "sent": "The details of the behavior of the sqlite3_step_APIName interface depend on  ."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_MISUSE_API_constant means that the this routine was called inappropriately.Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR_API_constant or SQLITE_DONE_API_constant.Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.", "key": "sqlite3_step", "sent": "Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR_API_constant or SQLITE_DONE_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "We admit that this is a goofy design."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.", "key": "sqlite3_step", "sent": "After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "If the SQL statement being executed returns any data, then SQLITE_ROW_API_constant be returned by sqlite3_step_APIName each time a new row of data is ready for processing by the caller.The values may be accessed using the column access functions.sqlite3_step_APIName is called again to retrieve the next row of data.", "key": "sqlite3_step", "sent": "If the SQL statement being executed returns any data, then SQLITE_ROW_API_constant be returned by sqlite3_step_APIName each time a new row of data is ready for processing by the caller."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "The problem has been fixed with the \"v2\" interface."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "SQLITE_MISUSE_API_constant means that the this routine was called inappropriately.Perhaps it was called on a prepared statement that has already been finalized or on one that had previously returned SQLITE_ERROR_API_constant or SQLITE_DONE_API_constant.Or it could be the case that the same database connection is being used by two or more threads at the same moment in time.", "key": "sqlite3_step", "sent": "Or it could be the case that the same database connection is being used by two or more threads at the same moment in time."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName.Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName.But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant.This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition.The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.", "key": "sqlite3_step", "sent": "This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "The use of the \"vX\" interfaces is recommended."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "You must call sqlite3_reset_APIName or sqlite3_finalize_APIName  ."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName.Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName.But after version 3.6.23.1 (2010-03-26, sqlite3_step_APIName began calling sqlite3_reset_APIName automatically in this circumstance rather than returning SQLITE_MISUSE_API_constant.This is not considered a compatibility break because any application that ever receives an SQLITE_MISUSE_API_constant error is broken by definition.The SQLITE_OMIT_AUTORESET compile-time option can be used to restore the legacy behavior.", "key": "sqlite3_step", "sent": "For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName, sqlite3_step_APIName must be called one or more times to evaluate the statement.The details of the behavior of the sqlite3_step_APIName interface depend on whether the statement was prepared using the newer \"vX\" interfaces sqlite3_prepare_v3_APIName, sqlite3_prepare_v2_APIName, sqlite3_prepare16_v3_APIName, sqlite3_prepare16_v2_APIName or the older legacy interfaces sqlite3_prepare_APIName and sqlite3_prepare16_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Goofy Interface Alert: In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant.You must call sqlite3_reset_APIName or sqlite3_finalize_APIName in order to find one of the specific error codes that better describes the error.We admit that this is a goofy design.The problem has been fixed with the \"v2\" interface.If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName.The use of the \"vX\" interfaces is recommended.", "key": "sqlite3_step", "sent": "If you prepare all of your SQL statements using sqlite3_prepare_v3_APIName or sqlite3_prepare_v2_APIName or sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName instead of the legacy sqlite3_prepare_APIName and sqlite3_prepare16_APIName interfaces, then the more specific error codes be returned by sqlite3_step_APIName directly by sqlite3_step_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The first parameter is a prepared statement.If this statement is a SELECT statement and the Nth column of sqlite3_column_decltype_APIParam_0 set of that SELECT is a table column (not an expression or subquery) then the declared type of the table column be returned by sqlite3_column_decltype_APIName.If the Nth column of the result set is an expression or subquery, then a NULL pointer be returned by sqlite3_column_decltype16_APIName.sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded.", "key": "sqlite3_column_decltype", "sent": "The first parameter is a prepared statement."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The first parameter is a prepared statement.If this statement is a SELECT statement and the Nth column of sqlite3_column_decltype_APIParam_0 set of that SELECT is a table column (not an expression or subquery) then the declared type of the table column be returned by sqlite3_column_decltype_APIName.If the Nth column of the result set is an expression or subquery, then a NULL pointer be returned by sqlite3_column_decltype16_APIName.sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded.", "key": "sqlite3_column_decltype16", "sent": "sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "CREATE TABLE t1(c1 VARIANT);", "key": "sqlite3_column_decltype", "sent": "CREATE TABLE t1(c1 VARIANT);"}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "For example, given the database schema:", "key": "sqlite3_column_decltype", "sent": "For example, given the database schema:"}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "and the following statement to be compiled:", "key": "sqlite3_column_decltype", "sent": "and the following statement to be compiled:"}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "SELECT c1 + 1, c1 FROM t1;", "key": "sqlite3_column_decltype", "sent": "SELECT c1 + 1, c1 FROM t1;"}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "SQLite uses dynamic run-time typing.So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type.SQLite is strongly typed, but the typing is dynamic not static.Type is associated with individual values, not with the containers used to hold those values.", "key": "sqlite3_column_decltype", "sent": "SQLite uses dynamic run-time typing."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The first parameter is a prepared statement.If this statement is a SELECT statement and the Nth column of sqlite3_column_decltype_APIParam_0 set of that SELECT is a table column (not an expression or subquery) then the declared type of the table column be returned by sqlite3_column_decltype_APIName.If the Nth column of the result set is an expression or subquery, then a NULL pointer be returned by sqlite3_column_decltype16_APIName.sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded.", "key": "sqlite3_column_decltype16", "sent": "If the Nth column of the result set is an expression or subquery, then a NULL pointer be returned by sqlite3_column_decltype16_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "SQLite uses dynamic run-time typing.So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type.SQLite is strongly typed, but the typing is dynamic not static.Type is associated with individual values, not with the containers used to hold those values.", "key": "sqlite3_column_decltype16", "sent": "SQLite is strongly typed, but the typing is dynamic not static."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "SQLite uses dynamic run-time typing.So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type.SQLite is strongly typed, but the typing is dynamic not static.Type is associated with individual values, not with the containers used to hold those values.", "key": "sqlite3_column_decltype16", "sent": "Type is associated with individual values, not with the containers used to hold those values."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The first parameter is a prepared statement.If this statement is a SELECT statement and the Nth column of sqlite3_column_decltype_APIParam_0 set of that SELECT is a table column (not an expression or subquery) then the declared type of the table column be returned by sqlite3_column_decltype_APIName.If the Nth column of the result set is an expression or subquery, then a NULL pointer be returned by sqlite3_column_decltype16_APIName.sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded.", "key": "sqlite3_column_decltype", "sent": "If this statement is a SELECT statement and the Nth column of sqlite3_column_decltype_APIParam_0 set of that SELECT is a table column (not an expression or subquery) then the declared type of the table column be returned by sqlite3_column_decltype_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "SQLite uses dynamic run-time typing.So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type.SQLite is strongly typed, but the typing is dynamic not static.Type is associated with individual values, not with the containers used to hold those values.", "key": "sqlite3_column_decltype", "sent": "So just  a particular type does not mean that the data stored in that column is of the declared type ."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_DESERIALIZE option.", "key": "sqlite3_deserialize", "sent": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_DESERIALIZE option."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.Any SQL statement variables that had values bound to them using the sqlite3_bind_*_APIName API retain their values.Use sqlite3_clear_bindings_APIName to reset the bindings.", "key": "sqlite3_reset", "sent": "Use sqlite3_clear_bindings_APIName to reset the bindings."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " The first parameter is a prepared statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "this routine would return the string \"VARIANT\" for the second result column (i==1), and a NULL pointer for the first result column (i==0).", "key": "sqlite3_column_decltype", "sent": "this routine would return the string \"VARIANT\" for the second result column (i==1), and a NULL pointer for the first result column (i==0)."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.Any SQL statement variables that had values bound to them using the sqlite3_bind_*_APIName API retain their values.Use sqlite3_clear_bindings_APIName to reset the bindings.", "key": "sqlite3_reset", "sent": "Any SQL statement variables that had values bound to them using the sqlite3_bind_*_APIName API retain their values."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "If the SQLITE_DESERIALIZE_FREEONCLOSE_API_constant bit is set in F, then SQLite will invoke sqlite3_free_APIName on the serialization buffer when the database connection closes.If the SQLITE_DESERIALIZE_RESIZEABLE_API_constant bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64_APIName if writes on the database cause it to grow larger than M bytes.", "key": "sqlite3_deserialize", "sent": "If the SQLITE_DESERIALIZE_FREEONCLOSE_API_constant bit is set in F, then SQLite will invoke sqlite3_free_APIName on the serialization buffer when the database connection closes."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "The sqlite3_deserialize_APIName interface will fail with SQLITE_BUSY_API_constant if the database is currently in a read transaction or is involved in a backup operation.", "key": "sqlite3_deserialize", "sent": "The sqlite3_deserialize_APIName interface will fail with SQLITE_BUSY_API_constant if the database is currently in a read transaction or is involved in a backup operation."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.Any SQL statement variables that had values bound to them using the sqlite3_bind_*_APIName API retain their values.Use sqlite3_clear_bindings_APIName to reset the bindings.", "key": "sqlite3_reset", "sent": "The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_reset_APIName interface resets the prepared statement S back to the beginning of its program.", "key": "sqlite3_reset", "sent": "The sqlite3_reset_APIName interface resets the prepared statement S back to the beginning of its program."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "If sqlite3_deserialize_APIName fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE_API_constant bit is set in argument F, then sqlite3_free_APIName is invoked on argument sqlite3_deserialize_APIParam_3 prior to returning.", "key": "sqlite3_deserialize", "sent": "If sqlite3_deserialize_APIName fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE_API_constant bit is set in argument F, then sqlite3_free_APIName is invoked on argument sqlite3_deserialize_APIParam_3 prior to returning."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "The sqlite3_deserialize_APIName interface causes the database connection sqlite3_deserialize_APIParam_1 to disconnect from database sqlite3_deserialize_APIParam_2 and then reopen sqlite3_deserialize_APIParam_2 as an in-memory database based on the serialization contained in sqlite3_deserialize_APIParam_3.  The serialized database sqlite3_deserialize_APIParam_3 is sqlite3_deserialize_APIParam_4 bytes in size.M is the size of the buffer P, which might be larger than N.  If sqlite3_deserialize_APIParam_5 is larger than N, and the SQLITE_DESERIALIZE_READONLY_API_constant bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed sqlite3_deserialize_APIParam_5 bytes.", "key": "sqlite3_deserialize", "sent": "The sqlite3_deserialize_APIName interface causes the database connection sqlite3_deserialize_APIParam_1 to disconnect from database sqlite3_deserialize_APIParam_2 and then reopen sqlite3_deserialize_APIParam_2 as an in-memory database based on the serialization contained in sqlite3_deserialize_APIParam_3.  The serialized database sqlite3_deserialize_APIParam_3 is sqlite3_deserialize_APIParam_4 bytes in size."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "On success, sqlite3_blob_write_APIName returns SQLITE_OK_API_constant.Otherwise, an  error code or an extended error code be returned by sqlite3_blob_write_APIName.Unless SQLITE_MISUSE_API_constant be returned by sqlite3_blob_write_APIName, sqlite3_blob_write_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions.", "key": "sqlite3_blob_write", "sent": "On success, sqlite3_blob_write_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_reset_APIName interface does not change the values of any bindings on the prepared statement S.", "key": "sqlite3_reset", "sent": "The sqlite3_reset_APIName interface does not change the values of any bindings on the prepared statement S."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.N bytes of data are copied from the buffer Z into the open BLOB, starting at offset sqlite3_blob_write_APIParam_4.", "key": "sqlite3_blob_write", "sent": "sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "If the SQLITE_DESERIALIZE_FREEONCLOSE_API_constant bit is set in F, then SQLite will invoke sqlite3_free_APIName on the serialization buffer when the database connection closes.If the SQLITE_DESERIALIZE_RESIZEABLE_API_constant bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64_APIName if writes on the database cause it to grow larger than M bytes.", "key": "sqlite3_deserialize", "sent": "If the SQLITE_DESERIALIZE_RESIZEABLE_API_constant bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64_APIName if writes on the database cause it to grow larger than M bytes."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "If the most recent call to sqlite3_step_APIName for the prepared statement sqlite3_reset_APIParam_1 indicated an error, then sqlite3_reset_APIName returns an appropriate error code.", "key": "sqlite3_reset", "sent": "If the most recent call to sqlite3_step_APIName for the prepared statement sqlite3_reset_APIParam_1 indicated an error, then sqlite3_reset_APIName returns an appropriate error code."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.N bytes of data are copied from the buffer Z into the open BLOB, starting at offset sqlite3_blob_write_APIParam_4.", "key": "sqlite3_blob_write", "sent": "N bytes of data are copied from the buffer Z into the open BLOB, starting at offset sqlite3_blob_write_APIParam_4."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "On success, sqlite3_blob_write_APIName returns SQLITE_OK_API_constant.Otherwise, an  error code or an extended error code be returned by sqlite3_blob_write_APIName.Unless SQLITE_MISUSE_API_constant be returned by sqlite3_blob_write_APIName, sqlite3_blob_write_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions.", "key": "sqlite3_blob_write", "sent": "Otherwise, an  error code or an extended error code be returned by sqlite3_blob_write_APIName."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "If the BLOB handle passed as sqlite3_blob_write_APIParam_1 was not opened for writing (the flags parameter to sqlite3_blob_open_APIName was zero), sqlite3_blob_write_APIName returns SQLITE_READ_API_constantONLY.", "key": "sqlite3_blob_write", "sent": "If the BLOB handle passed as sqlite3_blob_write_APIParam_1 was not opened for writing (the flags parameter to sqlite3_blob_open_APIName was zero), sqlite3_blob_write_APIName returns SQLITE_READ_API_constantONLY."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API.If offset sqlite3_blob_write_APIParam_4 is less than N bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.If N or sqlite3_blob_write_APIParam_4 are less than zero SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.", "key": "sqlite3_blob_write", "sent": "The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API.If offset sqlite3_blob_write_APIParam_4 is less than N bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.If N or sqlite3_blob_write_APIParam_4 are less than zero SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.", "key": "sqlite3_blob_write", "sent": "sqlite3_blob_write_APIName may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "On success, sqlite3_blob_write_APIName returns SQLITE_OK_API_constant.Otherwise, an  error code or an extended error code be returned by sqlite3_blob_write_APIName.Unless SQLITE_MISUSE_API_constant be returned by sqlite3_blob_write_APIName, sqlite3_blob_write_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions.", "key": "sqlite3_blob_write", "sent": "Unless SQLITE_MISUSE_API_constant be returned by sqlite3_blob_write_APIName, sqlite3_blob_write_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "An attempt to write to an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant.Writes to the BLOB that occurred before the BLOB handle expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.", "key": "sqlite3_blob_write", "sent": "An attempt to write to an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_reset_APIName function is called to reset a prepared statement object back to its initial state, ready to be re-executed.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "If the most recent call to sqlite3_step_APIName for the prepared statement sqlite3_reset_APIParam_1 returned SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if sqlite3_step_APIName has never before been called on sqlite3_reset_APIParam_1, then sqlite3_reset_APIName returns SQLITE_OK_API_constant.", "key": "sqlite3_reset", "sent": "If the most recent call to sqlite3_step_APIName for the prepared statement sqlite3_reset_APIParam_1 returned SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if sqlite3_step_APIName has never before been called on sqlite3_reset_APIParam_1, then sqlite3_reset_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["db", "zSchema", "pData", "szDb", "szBuf", "mFlags"], "API_desc": " The sqlite3_deserialize_APIName interface causes the database connection D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P.  The serialized database P is N bytes in size.", "var_type": ["sqlite3 *", "const char *", "unsigned char *", "sqlite3_int64", "sqlite3_int64", "unsigned"], "ret_type": "int"}, "paraph": "The sqlite3_deserialize_APIName interface causes the database connection sqlite3_deserialize_APIParam_1 to disconnect from database sqlite3_deserialize_APIParam_2 and then reopen sqlite3_deserialize_APIParam_2 as an in-memory database based on the serialization contained in sqlite3_deserialize_APIParam_3.  The serialized database sqlite3_deserialize_APIParam_3 is sqlite3_deserialize_APIParam_4 bytes in size.M is the size of the buffer P, which might be larger than N.  If sqlite3_deserialize_APIParam_5 is larger than N, and the SQLITE_DESERIALIZE_READONLY_API_constant bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed sqlite3_deserialize_APIParam_5 bytes.", "key": "sqlite3_deserialize", "sent": "M is the size of the buffer P, which might be larger than N.  If sqlite3_deserialize_APIParam_5 is larger than N, and the SQLITE_DESERIALIZE_READONLY_API_constant bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed sqlite3_deserialize_APIParam_5 bytes."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "See also: sqlite3_blob_read_APIName.", "key": "sqlite3_blob_write", "sent": "See also: sqlite3_blob_read_APIName."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API.If offset sqlite3_blob_write_APIParam_4 is less than N bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.If N or sqlite3_blob_write_APIParam_4 are less than zero SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.", "key": "sqlite3_blob_write", "sent": "If N or sqlite3_blob_write_APIParam_4 are less than zero SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_write", "sent": "Passing any other pointer in to this routine results in undefined and probably undesirable behavior."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_write_APIName may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API.If offset sqlite3_blob_write_APIParam_4 is less than N bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.If N or sqlite3_blob_write_APIParam_4 are less than zero SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written.", "key": "sqlite3_blob_write", "sent": "If offset sqlite3_blob_write_APIParam_4 is less than N bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_write_APIName and no data is written."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.", "key": "sqlite3_sleep", "sent": "The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.", "var_type": ["int"], "ret_type": "int"}, "paraph": "If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.The number of milliseconds of sleep actually requested from the operating system be returned by sqlite3_sleep_APIName.", "key": "sqlite3_sleep", "sent": "The number of milliseconds of sleep actually requested from the operating system be returned by sqlite3_sleep_APIName."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.", "var_type": ["int"], "ret_type": "int"}, "paraph": "SQLite implements this interface by calling the xSleep_APIName method of the default sqlite3_vfs object.If the xSleep_APIName method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep_APIName may deviate from the description in the previous paragraphs.", "key": "sqlite3_sleep", "sent": "SQLite implements this interface by calling the xSleep_APIName method of the default sqlite3_vfs object."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs.", "var_type": ["sqlite3_stmt*"], "ret_type": "sqlite3 *"}, "paraph": "The sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs.The database connection returned by sqlite3_db_handle is the same database connection that was sqlite3_db_handle_APIParam_1 to the sqlite3_prepare_v2_APIName call (or its variants) that was used to create the statement in the first place.", "key": "sqlite3_db_handle", "sent": "The sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_write", "sent": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": " The sqlite3_value_subtype_APIName function returns the subtype for an application-defined SQL function argument V.  The subtype information can be used to pass a limited amount of context from one SQL function to another.", "var_type": ["sqlite3_value*"], "ret_type": "unsigned int"}, "paraph": "The sqlite3_value_subtype_APIName function returns the subtype for an application-defined SQL function argument V.  The subtype information can be used to pass a limited amount of context from one SQL function to another.Use the sqlite3_result_subtype_APIName routine to set the subtype for the return value of an SQL function.", "key": "sqlite3_value_subtype", "sent": "Use the sqlite3_result_subtype_APIName routine to set the subtype for the return value of an SQL function."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.", "var_type": ["int"], "ret_type": "int"}, "paraph": "If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.The number of milliseconds of sleep actually requested from the operating system be returned by sqlite3_sleep_APIName.", "key": "sqlite3_sleep", "sent": "If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": " The sqlite3_value_subtype_APIName function returns the subtype for an application-defined SQL function argument V.  The subtype information can be used to pass a limited amount of context from one SQL function to another.", "var_type": ["sqlite3_value*"], "ret_type": "unsigned int"}, "paraph": "The sqlite3_value_subtype_APIName function returns the subtype for an application-defined SQL function argument V.  The subtype information can be used to pass a limited amount of context from one SQL function to another.Use the sqlite3_result_subtype_APIName routine to set the subtype for the return value of an SQL function.", "key": "sqlite3_value_subtype", "sent": "The sqlite3_value_subtype_APIName function returns the subtype for an application-defined SQL function argument V.  The subtype information can be used to pass a limited amount of context from one SQL function to another."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "If the function is registered using the sqlite3_collation_needed_APIName API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8.If sqlite3_collation_needed16_APIName is used, the names are passed as UTF-16 in machine native byte order.A call to either function replaces the existing collation-needed callback.", "key": "sqlite3_collation_needed", "sent": "A call to either function replaces the existing collation-needed callback."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "If the function is registered using the sqlite3_collation_needed_APIName API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8.If sqlite3_collation_needed16_APIName is used, the names are passed as UTF-16 in machine native byte order.A call to either function replaces the existing collation-needed callback.", "key": "sqlite3_collation_needed", "sent": "If sqlite3_collation_needed16_APIName is used, the names are passed as UTF-16 in machine native byte order."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed_APIName or sqlite3_collation_needed16_APIName.The second argument is the database connection.The third argument is one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE, indicating the most desirable form of the collation sequence function required.The fourth parameter is the name of the required collation sequence.", "key": "sqlite3_collation_needed", "sent": "The second argument is the database connection."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "If the function is registered using the sqlite3_collation_needed_APIName API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8.If sqlite3_collation_needed16_APIName is used, the names are passed as UTF-16 in machine native byte order.A call to either function replaces the existing collation-needed callback.", "key": "sqlite3_collation_needed", "sent": "If the function is registered using the sqlite3_collation_needed_APIName API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed_APIName or sqlite3_collation_needed16_APIName.The second argument is the database connection.The third argument is one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE, indicating the most desirable form of the collation sequence function required.The fourth parameter is the name of the required collation sequence.", "key": "sqlite3_collation_needed", "sent": "The fourth parameter is the name of the required collation sequence."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs.", "var_type": ["sqlite3_stmt*"], "ret_type": "sqlite3 *"}, "paraph": "The sqlite3_db_handle interface returns the database connection handle to which a prepared statement belongs.The database connection returned by sqlite3_db_handle is the same database connection that was sqlite3_db_handle_APIParam_1 to the sqlite3_prepare_v2_APIName call (or its variants) that was used to create the statement in the first place.", "key": "sqlite3_db_handle", "sent": "The database connection returned by sqlite3_db_handle is the same database connection that was sqlite3_db_handle_APIParam_1 to the sqlite3_prepare_v2_APIName call (or its variants) that was used to create the statement in the first place."}, {"API_info": "sqlite3_collation_needed not exist in API_info", "paraph": "The callback function should register the desired collation using sqlite3_create_collation_APIName, sqlite3_create_collation16_APIName, or sqlite3_create_collation_v2_APIName.", "key": "sqlite3_collation_needed", "sent": "The callback function should register the desired collation using sqlite3_create_collation_APIName, sqlite3_create_collation16_APIName, or sqlite3_create_collation_v2_APIName."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed_APIName or sqlite3_collation_needed16_APIName.The second argument is the database connection.The third argument is one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE, indicating the most desirable form of the collation sequence function required.The fourth parameter is the name of the required collation sequence.", "key": "sqlite3_collation_needed", "sent": "When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed_APIName or sqlite3_collation_needed16_APIName."}, {"API_info": {"var": ["sqlite3_blob *", "z", "n", "iOffset"], "API_desc": " sqlite3_blob_write_APIName is used to write data into an open BLOB handle from a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "const void *", "int", "int"], "ret_type": "int"}, "paraph": "An attempt to write to an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant.Writes to the BLOB that occurred before the BLOB handle expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.", "key": "sqlite3_blob_write", "sent": "Writes to the BLOB that occurred before the BLOB handle expired are not rolled back by the expiration of the handle ,  ."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.The PRNG is also used for the build-in random_APIName and randomblob_APIName SQL functions.This interface allows applications to access the same PRNG for other purposes.", "key": "sqlite3_randomness", "sent": "The PRNG is also used for the build-in random_APIName and randomblob_APIName SQL functions."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.The PRNG is also used for the build-in random_APIName and randomblob_APIName SQL functions.This interface allows applications to access the same PRNG for other purposes.", "key": "sqlite3_randomness", "sent": "This interface allows applications to access the same PRNG for other purposes."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint", "sent": "The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2_APIName."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "A call to this routine stores sqlite3_randomness_APIParam_1 bytes of randomness into buffer sqlite3_randomness_APIParam_2. The sqlite3_randomness_APIParam_2 parameter can be a NULL pointer.", "key": "sqlite3_randomness", "sent": "A call to this routine stores sqlite3_randomness_APIParam_1 bytes of randomness into buffer sqlite3_randomness_APIParam_2. The sqlite3_randomness_APIParam_2 parameter can be a NULL pointer."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database sqlite3_wal_checkpoint_APIParam_2 on database connection sqlite3_wal_checkpoint_APIParam_1 to be transferred into the database file and for the write-ahead log to be reset.See the checkpointing documentation for addition information.", "key": "sqlite3_wal_checkpoint", "sent": "See the checkpointing documentation for addition information."}, {"API_info": "sqlite3_collation_needednot exist in API_info", "paraph": "When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed_APIName or sqlite3_collation_needed16_APIName.The second argument is the database connection.The third argument is one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE, indicating the most desirable form of the collation sequence function required.The fourth parameter is the name of the required collation sequence.", "key": "sqlite3_collation_needed", "sent": "The third argument is one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE, indicating the most desirable form of the collation sequence function required."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.The PRNG is also used for the build-in random_APIName and randomblob_APIName SQL functions.This interface allows applications to access the same PRNG for other purposes.", "key": "sqlite3_randomness", "sent": "SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "This interface used to be the only way to cause a checkpoint to occur.But then the newer and more powerful sqlite3_wal_checkpoint_v2_APIName interface was added.This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint", "sent": "This interface used to be the only way to cause a checkpoint to occur."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "This interface used to be the only way to cause a checkpoint to occur.But then the newer and more powerful sqlite3_wal_checkpoint_v2_APIName interface was added.This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint", "sent": "But then the newer and more powerful sqlite3_wal_checkpoint_v2_APIName interface was added."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_sleep_APIName function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second.", "var_type": ["int"], "ret_type": "int"}, "paraph": "SQLite implements this interface by calling the xSleep_APIName method of the default sqlite3_vfs object.If the xSleep_APIName method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep_APIName may deviate from the description in the previous paragraphs.", "key": "sqlite3_sleep", "sent": "If the xSleep_APIName method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep_APIName may deviate from the description in the previous paragraphs."}, {"API_info": "sqlite3_collation_needed not exist in API_info", "paraph": "To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the database connection to be invoked whenever an undefined collation sequence is required.", "key": "sqlite3_collation_needed", "sent": "To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the database connection to be invoked whenever an undefined collation sequence is required."}, {"API_info": "sqlite3_cancel_auto_extensionnot exist in API_info", "paraph": "The sqlite3_cancel_auto_extension_APIName interface unregisters the initialization routine X that was registered using a prior call to sqlite3_auto_extension_APIName.The sqlite3_cancel_auto_extension_APIName routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.", "key": "sqlite3_cancel_auto_extension", "sent": "The sqlite3_cancel_auto_extension_APIName interface unregisters the initialization routine X that was registered using a prior call to sqlite3_auto_extension_APIName."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.These routines understand most of the common formatting options from the standard library printf_APIName plus some additional non-standard formats (%q, %Q, %w, and %z).See the built-in printf_APIName documentation for details.", "key": "sqlite3_snprintf", "sent": "See the built-in printf_APIName documentation for details."}, {"API_info": {"var": ["const char*", "..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", "..."], "ret_type": "char *"}, "paraph": "These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.These routines understand most of the common formatting options from the standard library printf_APIName plus some additional non-standard formats (%q, %Q, %w, and %z).See the built-in printf_APIName documentation for details.", "key": "sqlite3_mprintf", "sent": "These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library."}, {"API_info": {"var": ["const char*", "..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", "..."], "ret_type": "char *"}, "paraph": "The sqlite3_mprintf_APIName and sqlite3_vmprintf_APIName routines write their results into memory obtained from sqlite3_malloc64_APIName.The strings returned by these two routines should be released by sqlite3_free_APIName.Both routines return a NULL pointer if sqlite3_malloc64_APIName is unable to allocate enough memory to hold the resulting string.", "key": "sqlite3_mprintf", "sent": "The sqlite3_mprintf_APIName and sqlite3_vmprintf_APIName routines write their results into memory obtained from sqlite3_malloc64_APIName."}, {"API_info": {"var": ["const char*", "..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", "..."], "ret_type": "char *"}, "paraph": "The sqlite3_mprintf_APIName and sqlite3_vmprintf_APIName routines write their results into memory obtained from sqlite3_malloc64_APIName.The strings returned by these two routines should be released by sqlite3_free_APIName.Both routines return a NULL pointer if sqlite3_malloc64_APIName is unable to allocate enough memory to hold the resulting string.", "key": "sqlite3_mprintf", "sent": "The strings returned by these two routines should be released by sqlite3_free_APIName."}, {"API_info": {"var": ["const char*", " va_list"], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", " va_list"], "ret_type": "char *"}, "paraph": "These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.These routines understand most of the common formatting options from the standard library printf_APIName plus some additional non-standard formats (%q, %Q, %w, and %z).See the built-in printf_APIName documentation for details.", "key": "sqlite3_vmprintf", "sent": "These routines understand most of the common formatting options from the standard library printf_APIName plus some additional non-standard formats (%q, %Q, %w, and %z)."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database sqlite3_wal_checkpoint_APIParam_2 on database connection sqlite3_wal_checkpoint_APIParam_1 to be transferred into the database file and for the write-ahead log to be reset.See the checkpointing documentation for addition information.", "key": "sqlite3_wal_checkpoint", "sent": "In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database sqlite3_wal_checkpoint_APIParam_2 on database connection sqlite3_wal_checkpoint_APIParam_1 to be transferred into the database file and for the write-ahead log to be reset."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "If this routine has not been previously called or if the previous call had sqlite3_randomness_APIParam_1 less than one or a NULL pointer for sqlite3_randomness_APIParam_2, then the PRNG is seeded using randomness obtained from the xRandomness method of the default sqlite3_vfs object.If the previous call to this routine had an sqlite3_randomness_APIParam_1 of 1 or more and a non-NULL sqlite3_randomness_APIParam_2 then the pseudo-randomness is generated internally and without recourse to the sqlite3_vfs xRandomness method.", "key": "sqlite3_randomness", "sent": "If the previous call to this routine had an sqlite3_randomness_APIParam_1 of 1 or more and a non-NULL sqlite3_randomness_APIParam_2 then the pseudo-randomness is generated internally and without recourse to the sqlite3_vfs xRandomness method."}, {"API_info": {"var": ["const char*", "..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", "..."], "ret_type": "char *"}, "paraph": "The sqlite3_mprintf_APIName and sqlite3_vmprintf_APIName routines write their results into memory obtained from sqlite3_malloc64_APIName.The strings returned by these two routines should be released by sqlite3_free_APIName.Both routines return a NULL pointer if sqlite3_malloc64_APIName is unable to allocate enough memory to hold the resulting string.", "key": "sqlite3_mprintf", "sent": "Both routines return a NULL pointer if sqlite3_malloc64_APIName is unable to allocate enough memory to hold the resulting string."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "This is an historical accident that cannot be fixed without breaking backwards compatibility."}, {"API_info": "sqlite3_cancel_auto_extensionnot exist in API_info", "paraph": "The sqlite3_cancel_auto_extension_APIName interface unregisters the initialization routine X that was registered using a prior call to sqlite3_auto_extension_APIName.The sqlite3_cancel_auto_extension_APIName routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines.", "key": "sqlite3_cancel_auto_extension", "sent": "The sqlite3_cancel_auto_extension_APIName routine returns 1 if initialization routine X was successfully unregistered and it returns 0 if X was not on the list of initialization routines."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "Note that the order of the first two parameters is reversed from snprintf_APIName."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " The sqlite3_wal_checkpoint_APIName is equivalent to sqlite3_wal_checkpoint_v2(D,X,SQLITE_CHECKPOINT_PASSIVE,0,0).In brief, sqlite3_wal_checkpoint_APIName causes the content in the write-ahead log for database X on database connection D to be transferred into the database file and for the write-ahead log to be reset.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "This interface used to be the only way to cause a checkpoint to occur.But then the newer and more powerful sqlite3_wal_checkpoint_v2_APIName interface was added.This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint", "sent": "This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of sqlite3_wal_checkpoint_v2_APIName."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "As long as the buffer size is greater than zero, sqlite3_snprintf_APIName guarantees that the buffer is always zero-terminated.The first parameter \"n\" is the total size of the buffer, including space for the zero terminator.So the longest string that can be completely written will be n-1 characters.", "key": "sqlite3_snprintf", "sent": "So the longest string that can be completely written will be n-1 characters."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_vsnprintf_APIName routine is a varargs version of sqlite3_snprintf_APIName.", "key": "sqlite3_snprintf", "sent": "The sqlite3_vsnprintf_APIName routine is a varargs version of sqlite3_snprintf_APIName."}, {"API_info": {"var": ["const char*", "..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["const char*", "..."], "ret_type": "char *"}, "paraph": "See also:  built-in printf_APIName, printf_APIName SQL function", "key": "sqlite3_mprintf", "sent": "See also:  built-in printf_APIName, printf_APIName SQL function"}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "As long as the buffer size is greater than zero, sqlite3_snprintf_APIName guarantees that the buffer is always zero-terminated.The first parameter \"n\" is the total size of the buffer, including space for the zero terminator.So the longest string that can be completely written will be n-1 characters.", "key": "sqlite3_snprintf", "sent": "As long as the buffer size is greater than zero, sqlite3_snprintf_APIName guarantees that the buffer is always zero-terminated."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "As long as the buffer size is greater than zero, sqlite3_snprintf_APIName guarantees that the buffer is always zero-terminated.The first parameter \"n\" is the total size of the buffer, including space for the zero terminator.So the longest string that can be completely written will be n-1 characters.", "key": "sqlite3_snprintf", "sent": "The first parameter \"n\" is the total size of the buffer, including space for the zero terminator."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status", "sent": "Recognized integer codes are of the form SQLITE_STATUS_...."}, {"API_info": {"var": ["int", "char*", "const char*", " ..."], "API_desc": " These routines are work-alikes of the \"printf_APIName\" family of functions from the standard C library.", "var_type": ["int", "char*", "const char*", " ..."], "ret_type": "char *"}, "paraph": "The sqlite3_snprintf_APIName routine is similar to \"snprintf_APIName\" from the standard C library.The result is written into the buffer supplied as sqlite3_snprintf_APIParam_2 whose size is given by sqlite3_snprintf_APIParam_1.Note that the order of the first two parameters is reversed from snprintf_APIName.This is an historical accident that cannot be fixed without breaking backwards compatibility.Note also that sqlite3_snprintf_APIName returns a pointer to its buffer instead of the number of characters actually written into the buffer.We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility.", "key": "sqlite3_snprintf", "sent": "We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf_APIName now without breaking compatibility."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status", "sent": "The first argument is an integer code for the specific parameter to measure."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status", "sent": "The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent."}, {"API_info": {"var": ["N", "P"], "API_desc": " SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random ROWIDs when inserting new records into a table that already uses the largest possible ROWID.", "var_type": ["int", "void *"], "ret_type": "void"}, "paraph": "If this routine has not been previously called or if the previous call had sqlite3_randomness_APIParam_1 less than one or a NULL pointer for sqlite3_randomness_APIParam_2, then the PRNG is seeded using randomness obtained from the xRandomness method of the default sqlite3_vfs object.If the previous call to this routine had an sqlite3_randomness_APIParam_1 of 1 or more and a non-NULL sqlite3_randomness_APIParam_2 then the pseudo-randomness is generated internally and without recourse to the sqlite3_vfs xRandomness method.", "key": "sqlite3_randomness", "sent": "If this routine has not been previously called or if the previous call had sqlite3_randomness_APIParam_1 less than one or a NULL pointer for sqlite3_randomness_APIParam_2, then the PRNG is seeded using randomness obtained from the xRandomness method of the default sqlite3_vfs object."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status", "sent": "The highest recorded value be returned by sqlite3_status_APIName in *pHighwater."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status", "sent": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "sqlite3_int64 *", "sqlite3_int64 *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status64", "sent": "Some parameters do not record the highest value."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "sqlite3_int64 *", "sqlite3_int64 *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status64", "sent": "For these latter parameters nothing is written into *pCurrent."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "sqlite3_int64 *", "sqlite3_int64 *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status64", "sent": "Other parameters record only the highwater mark and not the current value."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "sqlite3_int64 *", "sqlite3_int64 *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status64", "sent": "For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "sqlite3_int64 *", "sqlite3_int64 *", "int"], "ret_type": "int"}, "paraph": "These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.The first argument is an integer code for the specific parameter to measure.Recognized integer codes are of the form SQLITE_STATUS_....The current value of the parameter be returned by sqlite3_status_APIName into *pCurrent.The highest recorded value be returned by sqlite3_status_APIName in *pHighwater.If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written.Some parameters do not record the highest value.For those parameters nothing is written into *pHighwater and the sqlite3_status64_APIParam_4 is ignored.Other parameters record only the highwater mark and not the current value.For these latter parameters nothing is written into *pCurrent.", "key": "sqlite3_status64", "sent": "If the sqlite3_status64_APIParam_4 is true, then the highest record value is reset after *pHighwater is written."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "See also: sqlite3_db_status_APIName", "key": "sqlite3_status", "sent": "See also: sqlite3_db_status_APIName"}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The following must be true for sqlite3_snapshot_get_APIName to succeed.If any of the following statements are false when sqlite3_snapshot_get_APIName is called, SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_get_APIName.The final value of *P is undefined in this case.", "key": "sqlite3_snapshot_get", "sent": "The following must be true for sqlite3_snapshot_get_APIName to succeed."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_status_APIName and sqlite3_status64_APIName routines return SQLITE_OK_API_constant on success and a non-zero error code on failure.", "key": "sqlite3_status", "sent": "The sqlite3_status_APIName and sqlite3_status64_APIName routines return SQLITE_OK_API_constant on success and a non-zero error code on failure."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The following must be true for sqlite3_snapshot_get_APIName to succeed.If any of the following statements are false when sqlite3_snapshot_get_APIName is called, SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_get_APIName.The final value of *P is undefined in this case.", "key": "sqlite3_snapshot_get", "sent": "The final value of *P is undefined in this case."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "sqlite3_snapshot_get_APIName may also return SQLITE_NOMEM_API_constant.If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.", "key": "sqlite3_snapshot_get", "sent": "sqlite3_snapshot_get_APIName may also return SQLITE_NOMEM_API_constant."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The following must be true for sqlite3_snapshot_get_APIName to succeed.If any of the following statements are false when sqlite3_snapshot_get_APIName is called, SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_get_APIName.The final value of *P is undefined in this case.", "key": "sqlite3_snapshot_get", "sent": "If any of the following statements are false when sqlite3_snapshot_get_APIName is called, SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_get_APIName."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema sqlite3_snapshot_get_APIParam_2 in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK_API_constant.If there is not already a read-transaction open on schema sqlite3_snapshot_get_APIParam_2 when sqlite3_snapshot_get_APIName is called, one is opened automatically.", "key": "sqlite3_snapshot_get", "sent": "If there is not already a read-transaction open on schema sqlite3_snapshot_get_APIParam_2 when sqlite3_snapshot_get_APIName is called, one is opened automatically."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_get_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.", "key": "sqlite3_snapshot_get", "sent": "The sqlite3_snapshot_get_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "void"}, "paraph": "The SQLite core uses these three routines for all of its own internal memory allocation needs.\"Core\" in the previous sentence does not include operating-system specific VFS implementation.The Windows VFS uses native malloc_APIName and free_APIName for some operations.", "key": "sqlite3_free", "sent": "The Windows VFS uses native malloc_APIName and free_APIName for some operations."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot object returned from a successful call to sqlite3_snapshot_get_APIName must be freed using sqlite3_snapshot_free_APIName to avoid a memory leak.", "key": "sqlite3_snapshot_get", "sent": "The sqlite3_snapshot object returned from a successful call to sqlite3_snapshot_get_APIName must be freed using sqlite3_snapshot_free_APIName to avoid a memory leak."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The SQLite core uses these three routines for all of its own internal memory allocation needs.\"Core\" in the previous sentence does not include operating-system specific VFS implementation.The Windows VFS uses native malloc_APIName and free_APIName for some operations.", "key": "sqlite3_realloc", "sent": "\"Core\" in the previous sentence does not include operating-system specific VFS implementation."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The SQLite core uses these three routines for all of its own internal memory allocation needs.\"Core\" in the previous sentence does not include operating-system specific VFS implementation.The Windows VFS uses native malloc_APIName and free_APIName for some operations.", "key": "sqlite3_malloc", "sent": "The SQLite core uses these three routines for all of its own internal memory allocation needs."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The sqlite3_malloc_APIName routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter.If sqlite3_malloc_APIName is unable to obtain sufficient free memory, sqlite3_malloc_APIName returns a NULL pointer.If the parameter N to sqlite3_malloc_APIName is zero or negative then sqlite3_malloc_APIName returns a NULL pointer.", "key": "sqlite3_malloc", "sent": "If sqlite3_malloc_APIName is unable to obtain sufficient free memory, sqlite3_malloc_APIName returns a NULL pointer."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The sqlite3_malloc_APIName routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter.If sqlite3_malloc_APIName is unable to obtain sufficient free memory, sqlite3_malloc_APIName returns a NULL pointer.If the parameter N to sqlite3_malloc_APIName is zero or negative then sqlite3_malloc_APIName returns a NULL pointer.", "key": "sqlite3_malloc", "sent": "If the parameter N to sqlite3_malloc_APIName is zero or negative then sqlite3_malloc_APIName returns a NULL pointer."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "void"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_free", "sent": "Passing a NULL pointer to sqlite3_free_APIName is harmless."}, {"API_info": {"var": ["op", "pCurrent", "pHighwater", "resetFlag"], "API_desc": " These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks.", "var_type": ["int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status_APIName are undefined.", "key": "sqlite3_status", "sent": "If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status_APIName are undefined."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "void"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_free", "sent": "The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_malloc", "sent": "After being freed, memory should neither be read nor written."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The sqlite3_malloc_APIName routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter.If sqlite3_malloc_APIName is unable to obtain sufficient free memory, sqlite3_malloc_APIName returns a NULL pointer.If the parameter N to sqlite3_malloc_APIName is zero or negative then sqlite3_malloc_APIName returns a NULL pointer.", "key": "sqlite3_malloc", "sent": "The sqlite3_malloc_APIName routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The sqlite3_malloc64_APIName routine works just like sqlite3_malloc_APIName except that sqlite3_malloc_APIParam_1 is an unsigned 64-bit integer instead of a signed 32-bit integer.", "key": "sqlite3_malloc", "sent": "The sqlite3_malloc64_APIName routine works just like sqlite3_malloc_APIName except that sqlite3_malloc_APIParam_1 is an unsigned 64-bit integer instead of a signed 32-bit integer."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "sqlite3_snapshot_get_APIName may also return SQLITE_NOMEM_API_constant.If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.", "key": "sqlite3_snapshot_get", "sent": "If it is called with the database handle in autocommit mode but fails for some other reason ,  is undefined ."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_malloc", "sent": "Even reading previously freed memory might result in a segmentation fault or other severe error."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_malloc", "sent": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_realloc", "sent": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_malloc", "sent": "If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_realloc", "sent": "If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_realloc", "sent": "If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "sqlite3_uint64"}, "paraph": "If sqlite3_msize_APIParam_1 is a memory allocation previously obtained from sqlite3_malloc_APIName, sqlite3_malloc64_APIName, sqlite3_realloc_APIName, or sqlite3_realloc64_APIName, then sqlite3_msize_APIName returns the size of that memory allocation in bytes.The value returned by sqlite3_msize_APIName might be larger than the number of bytes requested when sqlite3_msize_APIParam_1 was allocated.If sqlite3_msize_APIParam_1 is a NULL pointer then sqlite3_msize_APIName returns zero.If sqlite3_msize_APIParam_1 points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize_APIName is undefined and possibly harmful.", "key": "sqlite3_msize", "sent": "If sqlite3_msize_APIParam_1 is a NULL pointer then sqlite3_msize_APIName returns zero."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "sqlite3_uint64"}, "paraph": "If sqlite3_msize_APIParam_1 is a memory allocation previously obtained from sqlite3_malloc_APIName, sqlite3_malloc64_APIName, sqlite3_realloc_APIName, or sqlite3_realloc64_APIName, then sqlite3_msize_APIName returns the size of that memory allocation in bytes.The value returned by sqlite3_msize_APIName might be larger than the number of bytes requested when sqlite3_msize_APIParam_1 was allocated.If sqlite3_msize_APIParam_1 is a NULL pointer then sqlite3_msize_APIName returns zero.If sqlite3_msize_APIParam_1 points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize_APIName is undefined and possibly harmful.", "key": "sqlite3_msize", "sent": "The value returned by sqlite3_msize_APIName might be larger than the number of bytes requested when sqlite3_msize_APIParam_1 was allocated."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted.That capability is no longer provided.Only built-in memory allocators can be used.", "key": "sqlite3_realloc", "sent": "That capability is no longer provided."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "void"}, "paraph": "In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted.That capability is no longer provided.Only built-in memory allocators can be used.", "key": "sqlite3_free", "sent": "Only built-in memory allocators can be used."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_realloc", "sent": "sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available."}, {"API_info": {"var": ["db", "zSchema", "ppSnapshot"], "API_desc": " The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema S in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot **"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema sqlite3_snapshot_get_APIParam_2 in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK_API_constant.If there is not already a read-transaction open on schema sqlite3_snapshot_get_APIParam_2 when sqlite3_snapshot_get_APIName is called, one is opened automatically.", "key": "sqlite3_snapshot_get", "sent": "The sqlite3_snapshot_get_APIName interface attempts to make a new sqlite3_snapshot object that records the current state of schema sqlite3_snapshot_get_APIParam_2 in database connection D.  On success, the sqlite3_snapshot_get_APIName interface writes a pointer to the newly created sqlite3_snapshot object into *P and returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc64_APIName interfaces works the same as sqlite3_realloc_APIName except that sqlite3_realloc_APIParam_2 is a 64-bit unsigned integer instead of a 32-bit signed integer.", "key": "sqlite3_realloc", "sent": "The sqlite3_realloc64_APIName interfaces works the same as sqlite3_realloc_APIName except that sqlite3_realloc_APIParam_2 is a 64-bit unsigned integer instead of a 32-bit signed integer."}, {"API_info": {"var": ["void*", " sqlite3_uint64"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " sqlite3_uint64"], "ret_type": "void *"}, "paraph": "Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc_APIName and free_APIName directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation.Memory allocation errors were detected, but they were reported back as SQLITE_CANTOPEN_API_constant or SQLITE_IOERR_API_constant rather than SQLITE_NOMEM_API_constant.", "key": "sqlite3_realloc64", "sent": "Memory allocation errors were detected, but they were reported back as SQLITE_CANTOPEN_API_constant or SQLITE_IOERR_API_constant rather than SQLITE_NOMEM_API_constant."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "Calling sqlite3_free_APIName with a pointer previously returned by sqlite3_malloc_APIName or sqlite3_realloc_APIName releases that memory so that it might be reused.The sqlite3_free_APIName routine is a no-op if is called with a NULL pointer.Passing a NULL pointer to sqlite3_free_APIName is harmless.After being freed, memory should neither be read nor written.Even reading previously freed memory might result in a segmentation fault or other severe error.Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_malloc", "sent": "Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free_APIName is called with a non-NULL pointer that was not obtained from sqlite3_malloc_APIName or sqlite3_realloc_APIName."}, {"API_info": {"var": ["void"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["void"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).The sqlite3_memory_highwater_APIName routine returns the maximum value of sqlite3_memory_used_APIName since the high-water mark was last reset.The values returned by sqlite3_memory_used_APIName and sqlite3_memory_highwater_APIName include any overhead added by SQLite in its implementation of sqlite3_malloc_APIName, but not overhead added by the any underlying system library routines that sqlite3_malloc_APIName may call.", "key": "sqlite3_memory_used", "sent": "The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed)."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted.That capability is no longer provided.Only built-in memory allocators can be used.", "key": "sqlite3_malloc", "sent": "In SQLite version 3.5.0 and 3.5.1, it was possible to define the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in implementation of these routines to be omitted."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "If sqlite3_msize_APIParam_1 is a memory allocation previously obtained from sqlite3_malloc_APIName, sqlite3_malloc64_APIName, sqlite3_realloc_APIName, or sqlite3_realloc64_APIName, then sqlite3_msize_APIName returns the size of that memory allocation in bytes.The value returned by sqlite3_msize_APIName might be larger than the number of bytes requested when sqlite3_msize_APIParam_1 was allocated.If sqlite3_msize_APIParam_1 is a NULL pointer then sqlite3_msize_APIName returns zero.If sqlite3_msize_APIParam_1 points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize_APIName is undefined and possibly harmful.", "key": "sqlite3_malloc", "sent": "If sqlite3_msize_APIParam_1 is a memory allocation previously obtained from sqlite3_malloc_APIName, sqlite3_malloc64_APIName, sqlite3_realloc_APIName, or sqlite3_realloc64_APIName, then sqlite3_msize_APIName returns the size of that memory allocation in bytes."}, {"API_info": {"var": ["resetFlag"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["int"], "ret_type": "sqlite3_int64"}, "paraph": "The memory high-water mark is reset to the current value of sqlite3_memory_used_APIName if and only if the parameter to sqlite3_memory_highwater_APIName is true.The value returned by sqlite3_memory_highwater_APIName is the high-water mark prior to the reset.", "key": "sqlite3_memory_highwater", "sent": "The value returned by sqlite3_memory_highwater_APIName is the high-water mark prior to the reset."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The application must not read or write any part of a block of memory after it has been released using sqlite3_free_APIName or sqlite3_realloc_APIName.", "key": "sqlite3_realloc", "sent": "The application must not read or write any part of a block of memory after it has been released using sqlite3_free_APIName or sqlite3_realloc_APIName."}, {"API_info": {"var": ["void"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["void"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).The sqlite3_memory_highwater_APIName routine returns the maximum value of sqlite3_memory_used_APIName since the high-water mark was last reset.The values returned by sqlite3_memory_used_APIName and sqlite3_memory_highwater_APIName include any overhead added by SQLite in its implementation of sqlite3_malloc_APIName, but not overhead added by the any underlying system library routines that sqlite3_malloc_APIName may call.", "key": "sqlite3_memory_used", "sent": "The sqlite3_memory_highwater_APIName routine returns the maximum value of sqlite3_memory_used_APIName since the high-water mark was last reset."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The pointer arguments to sqlite3_free_APIName and sqlite3_realloc_APIName must be either NULL or else pointers obtained from a prior invocation of sqlite3_malloc_APIName or sqlite3_realloc_APIName that have not yet been released.", "key": "sqlite3_malloc", "sent": "The pointer arguments to sqlite3_free_APIName and sqlite3_realloc_APIName must be either NULL or else pointers obtained from a prior invocation of sqlite3_malloc_APIName or sqlite3_realloc_APIName that have not yet been released."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "These functions (collectively known as \"function creation routines\") are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates.The only differences between the three \"sqlite3_create_function*\" routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer.Function sqlite3_create_window_function_APIName is similar, but allows the user to supply the extra callback functions needed by aggregate window functions.", "key": "sqlite3_create_function", "sent": "These functions (collectively known as \"function creation routines\") are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates."}, {"API_info": {"var": ["void"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["void"], "ret_type": "sqlite3_int64"}, "paraph": "SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.", "key": "sqlite3_memory_used", "sent": "SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The first parameter is the database connection to which the SQL function is to be added.If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.", "key": "sqlite3_create_function", "sent": "The first parameter is the database connection to which the SQL function is to be added."}, {"API_info": {"var": ["void*", " int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*", " int"], "ret_type": "void *"}, "paraph": "The sqlite3_realloc_APIName interface attempts to resize a prior memory allocation sqlite3_realloc_APIParam_1 to be at least sqlite3_realloc_APIParam_2 bytes.If the sqlite3_realloc_APIParam_1 parameter to sqlite3_realloc_APIName is a NULL pointer then its behavior is identical to calling sqlite3_malloc_APIName.If the sqlite3_realloc_APIParam_2 parameter to sqlite3_realloc_APIName is zero or negative then the behavior is exactly the same as calling sqlite3_free_APIName.sqlite3_realloc_APIName returns a pointer to a memory allocation of at least sqlite3_realloc_APIParam_2 bytes in size or NULL if insufficient memory is available.If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed.If sqlite3_realloc_APIName returns NULL and sqlite3_realloc_APIParam_2 is positive, then the prior allocation is not freed.", "key": "sqlite3_realloc", "sent": "If min_APIParam_2 is the size of the prior allocation, then min_APIName bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc_APIName and the prior allocation is freed."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The second parameter is the name of the SQL function to be created or redefined.The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator.Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned.", "key": "sqlite3_create_function", "sent": "The second parameter is the name of the SQL function to be created or redefined."}, {"API_info": "sqlite3_create_window_functionnot exist in API_info", "paraph": "These functions (collectively known as \"function creation routines\") are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates.The only differences between the three \"sqlite3_create_function*\" routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer.Function sqlite3_create_window_function_APIName is similar, but allows the user to supply the extra callback functions needed by aggregate window functions.", "key": "sqlite3_create_window_function", "sent": "Function sqlite3_create_window_function_APIName is similar, but allows the user to supply the extra callback functions needed by aggregate window functions."}, {"API_info": {"var": ["void"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["void"], "ret_type": "sqlite3_int64"}, "paraph": "The memory high-water mark is reset to the current value of sqlite3_memory_used_APIName if and only if the parameter to sqlite3_memory_highwater_APIName is true.The value returned by sqlite3_memory_highwater_APIName is the high-water mark prior to the reset.", "key": "sqlite3_memory_used", "sent": "The memory high-water mark is reset to the current value of sqlite3_memory_used_APIName if and only if the parameter to sqlite3_memory_highwater_APIName is true."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "The memory returned by sqlite3_malloc_APIName, sqlite3_realloc_APIName, sqlite3_malloc64_APIName, and sqlite3_realloc64_APIName is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the SQLITE_4_BYTE_ALIGNED_MALLOC compile-time option is used.", "key": "sqlite3_malloc", "sent": "The memory returned by sqlite3_malloc_APIName, sqlite3_realloc_APIName, sqlite3_malloc64_APIName, and sqlite3_realloc64_APIName is always aligned to at least an 8 byte boundary, or to a 4 byte boundary if the SQLITE_4_BYTE_ALIGNED_MALLOC compile-time option is used."}, {"API_info": "sqlite3_create_function16 not exist in API_info", "paraph": "The second parameter is the name of the SQL function to be created or redefined.The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator.Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned.", "key": "sqlite3_create_function16", "sent": "The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The first parameter is the database connection to which the SQL function is to be added.If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately.", "key": "sqlite3_create_function_v2", "sent": "If an application uses more than one database connection then application-defined SQL functions must be added to each database connection separately."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The second parameter is the name of the SQL function to be created or redefined.The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator.Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned.", "key": "sqlite3_create_function_v2", "sent": "Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes."}, {"API_info": {"var": ["void*"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["void*"], "ret_type": "sqlite3_uint64"}, "paraph": "If sqlite3_msize_APIParam_1 is a memory allocation previously obtained from sqlite3_malloc_APIName, sqlite3_malloc64_APIName, sqlite3_realloc_APIName, or sqlite3_realloc64_APIName, then sqlite3_msize_APIName returns the size of that memory allocation in bytes.The value returned by sqlite3_msize_APIName might be larger than the number of bytes requested when sqlite3_msize_APIParam_1 was allocated.If sqlite3_msize_APIParam_1 is a NULL pointer then sqlite3_msize_APIName returns zero.If sqlite3_msize_APIParam_1 points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize_APIName is undefined and possibly harmful.", "key": "sqlite3_msize", "sent": "If sqlite3_msize_APIParam_1 points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize_APIName is undefined and possibly harmful."}, {"API_info": "sqlite3_create_window_function not exist in API_info", "paraph": "The second parameter is the name of the SQL function to be created or redefined.The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator.Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned.", "key": "sqlite3_create_window_function", "sent": "Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes.If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by sqlite3_limit_APIName.If the third parameter is less than -1 or greater than 127 then the behavior is undefined.", "key": "sqlite3_create_function", "sent": "The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "These functions (collectively known as \"function creation routines\") are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates.The only differences between the three \"sqlite3_create_function*\" routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer.Function sqlite3_create_window_function_APIName is similar, but allows the user to supply the extra callback functions needed by aggregate window functions.", "key": "sqlite3_create_function", "sent": "The only differences between the three \"sqlite3_create_function*\" routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes.If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by sqlite3_limit_APIName.If the third parameter is less than -1 or greater than 127 then the behavior is undefined.", "key": "sqlite3_create_function_v2", "sent": "If the third parameter is less than -1 or greater than 127 then the behavior is undefined."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these three routines for all of its own internal memory allocation needs.", "var_type": ["int"], "ret_type": "void *"}, "paraph": "Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc_APIName and free_APIName directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation.Memory allocation errors were detected, but they were reported back as SQLITE_CANTOPEN_API_constant or SQLITE_IOERR_API_constant rather than SQLITE_NOMEM_API_constant.", "key": "sqlite3_malloc", "sent": "Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc_APIName and free_APIName directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation."}, {"API_info": "sqlite3_create_function16 not exist in API_info", "paraph": "The fourth parameter may optionally be ORed with SQLITE_DETERMINISTIC_API_constant to signal that the function will always return the same result given the same inputs within a single SQL statement.Most SQL functions are deterministic.The built-in random_APIName SQL function is an example of a function that is not deterministic.The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible.", "key": "sqlite3_create_function16", "sent": "Most SQL functions are deterministic."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The fourth parameter, eTextRep, specifies what text encoding this SQL function prefers for its parameters.The application should set this parameter to SQLITE_UTF16_API_constantLE if the function implementation invokes sqlite3_value_text16le_APIName on an input, or SQLITE_UTF16_API_constantBE if the implementation invokes sqlite3_value_text16be_APIName on an input, or SQLITE_UTF16_API_constant if sqlite3_value_text16_APIName is used, or SQLITE_UTF8_API_constant otherwise.The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding.When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.", "key": "sqlite3_create_function", "sent": "The fourth parameter, eTextRep, specifies what text encoding this SQL function prefers for its parameters."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The fourth parameter, eTextRep, specifies what text encoding this SQL function prefers for its parameters.The application should set this parameter to SQLITE_UTF16_API_constantLE if the function implementation invokes sqlite3_value_text16le_APIName on an input, or SQLITE_UTF16_API_constantBE if the implementation invokes sqlite3_value_text16be_APIName on an input, or SQLITE_UTF16_API_constant if sqlite3_value_text16_APIName is used, or SQLITE_UTF8_API_constant otherwise.The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding.When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.", "key": "sqlite3_create_function_v2", "sent": "The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding."}, {"API_info": "sqlite3_create_function16 not exist in API_info", "paraph": "The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes.If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by sqlite3_limit_APIName.If the third parameter is less than -1 or greater than 127 then the behavior is undefined.", "key": "sqlite3_create_function16", "sent": "If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by sqlite3_limit_APIName."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The fourth parameter may optionally be ORed with SQLITE_DETERMINISTIC_API_constant to signal that the function will always return the same result given the same inputs within a single SQL statement.Most SQL functions are deterministic.The built-in random_APIName SQL function is an example of a function that is not deterministic.The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible.", "key": "sqlite3_create_function_v2", "sent": "The built-in random_APIName SQL function is an example of a function that is not deterministic."}, {"API_info": {"var": ["void"], "API_desc": " SQLite provides these two interfaces for reporting on the status of the sqlite3_malloc_APIName, sqlite3_free_APIName, and sqlite3_realloc_APIName routines, which form the built-in memory allocation subsystem.The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).", "var_type": ["void"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_memory_used_APIName routine returns the number of bytes of memory currently outstanding (malloced but not freed).The sqlite3_memory_highwater_APIName routine returns the maximum value of sqlite3_memory_used_APIName since the high-water mark was last reset.The values returned by sqlite3_memory_used_APIName and sqlite3_memory_highwater_APIName include any overhead added by SQLite in its implementation of sqlite3_malloc_APIName, but not overhead added by the any underlying system library routines that sqlite3_malloc_APIName may call.", "key": "sqlite3_memory_used", "sent": "The values returned by sqlite3_memory_used_APIName and sqlite3_memory_highwater_APIName include any overhead added by SQLite in its implementation of sqlite3_malloc_APIName, but not overhead added by the any underlying system library routines that sqlite3_malloc_APIName may call."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The fifth parameter is an arbitrary pointer.The implementation of the function can gain access to this pointer using sqlite3_user_data_APIName.", "key": "sqlite3_create_function", "sent": "The fifth parameter is an arbitrary pointer."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The fourth parameter may also optionally include the SQLITE_DIRECTONLY_API_constant flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs.For security reasons, the SQLITE_DIRECTONLY_API_constant flag is recommended for any application-defined SQL function that has side-effects.", "key": "sqlite3_create_function_v2", "sent": "For security reasons, the SQLITE_DIRECTONLY_API_constant flag is recommended for any application-defined SQL function that has side-effects."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "The fifth parameter is an arbitrary pointer.The implementation of the function can gain access to this pointer using sqlite3_user_data_APIName.", "key": "sqlite3_create_function_v2", "sent": "The implementation of the function can gain access to this pointer using sqlite3_user_data_APIName."}, {"API_info": "sqlite3_create_window_function not exist in API_info", "paraph": "The fourth parameter, eTextRep, specifies what text encoding this SQL function prefers for its parameters.The application should set this parameter to SQLITE_UTF16_API_constantLE if the function implementation invokes sqlite3_value_text16le_APIName on an input, or SQLITE_UTF16_API_constantBE if the implementation invokes sqlite3_value_text16be_APIName on an input, or SQLITE_UTF16_API_constant if sqlite3_value_text16_APIName is used, or SQLITE_UTF8_API_constant otherwise.The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding.When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.", "key": "sqlite3_create_window_function", "sent": "When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The fourth parameter may also optionally include the SQLITE_DIRECTONLY_API_constant flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs.For security reasons, the SQLITE_DIRECTONLY_API_constant flag is recommended for any application-defined SQL function that has side-effects.", "key": "sqlite3_create_function", "sent": "The fourth parameter may also optionally include the SQLITE_DIRECTONLY_API_constant flag, which if present prevents the function from being invoked from within VIEWs or TRIGGERs."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "The fourth parameter may optionally be ORed with SQLITE_DETERMINISTIC_API_constant to signal that the function will always return the same result given the same inputs within a single SQL statement.Most SQL functions are deterministic.The built-in random_APIName SQL function is an example of a function that is not deterministic.The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible.", "key": "sqlite3_create_function", "sent": "The fourth parameter may optionally be ORed with SQLITE_DETERMINISTIC_API_constant to signal that the function will always return the same result given the same inputs within a single SQL statement."}, {"API_info": "sqlite3_create_window_function not exist in API_info", "paraph": "The fourth parameter may optionally be ORed with SQLITE_DETERMINISTIC_API_constant to signal that the function will always return the same result given the same inputs within a single SQL statement.Most SQL functions are deterministic.The built-in random_APIName SQL function is an example of a function that is not deterministic.The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible.", "key": "sqlite3_create_window_function", "sent": "The SQLite query planner is able to perform additional optimizations on deterministic functions, so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible."}, {"API_info": "sqlite3_create_window_functionnot exist in API_info", "paraph": "The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function.xStep and xFinal must both be non-NULL.xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function.More details regarding the implementation of aggregate window functions are available here.", "key": "sqlite3_create_window_function", "sent": "xStep and xFinal must both be non-NULL."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "The sixth, seventh and eighth parameters passed to the three \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate.A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters.An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc.To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.", "key": "sqlite3_create_function", "sent": "An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "The sixth, seventh and eighth parameters passed to the three \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate.A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters.An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc.To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.", "key": "sqlite3_create_function", "sent": "To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "The sixth, seventh and eighth parameters passed to the three \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate.A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters.An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc.To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.", "key": "sqlite3_create_function", "sent": "A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters."}, {"API_info": "sqlite3_create_window_functionnot exist in API_info", "paraph": "The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function.xStep and xFinal must both be non-NULL.xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function.More details regarding the implementation of aggregate window functions are available here.", "key": "sqlite3_create_window_function", "sent": "More details regarding the implementation of aggregate window functions are available here."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "If the final parameter to sqlite3_create_function_v2_APIName or sqlite3_create_window_function_APIName is not NULL, then it is destructor for the application data pointer.The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes.The destructor is also invoked if the call to sqlite3_create_function_v2_APIName fails.When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2_APIName.", "key": "sqlite3_create_function", "sent": "The destructor is also invoked if the call to sqlite3_create_function_v2_APIName fails."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "The sixth, seventh and eighth parameters passed to the three \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate.A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters.An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc.To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.", "key": "sqlite3_create_function", "sent": "The sixth, seventh and eighth parameters passed to the three \"sqlite3_create_function*\" functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "If the final parameter to sqlite3_create_function_v2_APIName or sqlite3_create_window_function_APIName is not NULL, then it is destructor for the application data pointer.The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes.The destructor is also invoked if the call to sqlite3_create_function_v2_APIName fails.When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2_APIName.", "key": "sqlite3_create_function", "sent": "If the final parameter to sqlite3_create_function_v2_APIName or sqlite3_create_window_function_APIName is not NULL, then it is destructor for the application data pointer."}, {"API_info": "sqlite3_create_window_functionnot exist in API_info", "paraph": "The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function.xStep and xFinal must both be non-NULL.xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function.More details regarding the implementation of aggregate window functions are available here.", "key": "sqlite3_create_window_function", "sent": "The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "If the final parameter to sqlite3_create_function_v2_APIName or sqlite3_create_window_function_APIName is not NULL, then it is destructor for the application data pointer.The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes.The destructor is also invoked if the call to sqlite3_create_function_v2_APIName fails.When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2_APIName.", "key": "sqlite3_create_function", "sent": "The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "Built-in functions may be overloaded by new application-defined functions.", "key": "sqlite3_create_function", "sent": "Built-in functions may be overloaded by new application-defined functions."}, {"API_info": "sqlite3_create_function16 not exist in API_info", "paraph": "The fourth parameter, eTextRep, specifies what text encoding this SQL function prefers for its parameters.The application should set this parameter to SQLITE_UTF16_API_constantLE if the function implementation invokes sqlite3_value_text16le_APIName on an input, or SQLITE_UTF16_API_constantBE if the implementation invokes sqlite3_value_text16be_APIName on an input, or SQLITE_UTF16_API_constant if sqlite3_value_text16_APIName is used, or SQLITE_UTF8_API_constant otherwise.The same SQL function may be registered multiple times using different preferred text encodings, with different implementations for each encoding.When multiple implementations of the same function are available, SQLite will pick the one that involves the least amount of data conversion.", "key": "sqlite3_create_function16", "sent": "The application should set this parameter to SQLITE_UTF16_API_constantLE if the function implementation invokes sqlite3_value_text16le_APIName on an input, or SQLITE_UTF16_API_constantBE if the implementation invokes sqlite3_value_text16be_APIName on an input, or SQLITE_UTF16_API_constant if sqlite3_value_text16_APIName is used, or SQLITE_UTF8_API_constant otherwise."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings.SQLite will use the implementation that most closely matches the way in which the SQL function is used.A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg.A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different.A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.", "key": "sqlite3_create_function", "sent": "SQLite will use the implementation that most closely matches the way in which the SQL function is used."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings.SQLite will use the implementation that most closely matches the way in which the SQL function is used.A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg.A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different.A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.", "key": "sqlite3_create_function_v2", "sent": "A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "An application-defined function is permitted to call other SQLite interfaces.However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.", "key": "sqlite3_create_function", "sent": "An application-defined function is permitted to call other SQLite interfaces."}, {"API_info": "sqlite3_create_functionnot exist in API_info", "paraph": "If the final parameter to sqlite3_create_function_v2_APIName or sqlite3_create_window_function_APIName is not NULL, then it is destructor for the application data pointer.The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes.The destructor is also invoked if the call to sqlite3_create_function_v2_APIName fails.When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2_APIName.", "key": "sqlite3_create_function", "sent": "When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2_APIName."}, {"API_info": "sqlite3_create_function16 not exist in API_info", "paraph": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings.SQLite will use the implementation that most closely matches the way in which the SQL function is used.A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg.A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different.A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.", "key": "sqlite3_create_function16", "sent": "A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg."}, {"API_info": "sqlite3_create_function not exist in API_info", "paraph": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings.SQLite will use the implementation that most closely matches the way in which the SQL function is used.A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg.A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different.A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.", "key": "sqlite3_create_function", "sent": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved.An example of where this might be useful is in a regular-expression matching function.The compiled version of the regular expression can be stored as metadata associated with the pattern string.Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.", "key": "sqlite3_get_auxdata", "sent": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved.An example of where this might be useful is in a regular-expression matching function.The compiled version of the regular expression can be stored as metadata associated with the pattern string.Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.", "key": "sqlite3_get_auxdata", "sent": "An example of where this might be useful is in a regular-expression matching function."}, {"API_info": "sqlite3_create_window_function not exist in API_info", "paraph": "It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings.SQLite will use the implementation that most closely matches the way in which the SQL function is used.A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg.A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different.A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.", "key": "sqlite3_create_window_function", "sent": "A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_get_auxdata_APIName interface returns a pointer to the metadata associated by the sqlite3_set_auxdata_APIName function with the Nth argument value to the application-defined function.N is zero for the left-most function argument.If there is no metadata associated with the function argument, the sqlite3_get_auxdata_APIName interface returns a NULL pointer.", "key": "sqlite3_get_auxdata", "sent": "N is zero for the left-most function argument."}, {"API_info": "sqlite3_set_auxdata not exist in API_info", "paraph": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved.An example of where this might be useful is in a regular-expression matching function.The compiled version of the regular expression can be stored as metadata associated with the pattern string.Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.", "key": "sqlite3_set_auxdata", "sent": "The compiled version of the regular expression can be stored as metadata associated with the pattern string."}, {"API_info": "sqlite3_create_function_v2 not exist in API_info", "paraph": "An application-defined function is permitted to call other SQLite interfaces.However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.", "key": "sqlite3_create_function_v2", "sent": "However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_get_auxdata_APIName interface returns a pointer to the metadata associated by the sqlite3_set_auxdata_APIName function with the Nth argument value to the application-defined function.N is zero for the left-most function argument.If there is no metadata associated with the function argument, the sqlite3_get_auxdata_APIName interface returns a NULL pointer.", "key": "sqlite3_get_auxdata", "sent": "The sqlite3_get_auxdata_APIName interface returns a pointer to the metadata associated by the sqlite3_set_auxdata_APIName function with the Nth argument value to the application-defined function."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved.An example of where this might be useful is in a regular-expression matching function.The compiled version of the regular expression can be stored as metadata associated with the pattern string.Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.", "key": "sqlite3_get_auxdata", "sent": "If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved."}, {"API_info": "sqlite3_create_window_functionnot exist in API_info", "paraph": "The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function.xStep and xFinal must both be non-NULL.xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function.More details regarding the implementation of aggregate window functions are available here.", "key": "sqlite3_create_window_function", "sent": "xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function."}, {"API_info": "sqlite3_set_auxdata not exist in API_info", "paraph": "These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved.An example of where this might be useful is in a regular-expression matching function.The compiled version of the regular expression can be stored as metadata associated with the pattern string.Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.", "key": "sqlite3_set_auxdata", "sent": "Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_get_auxdata_APIName interface returns a pointer to the metadata associated by the sqlite3_set_auxdata_APIName function with the Nth argument value to the application-defined function.N is zero for the left-most function argument.If there is no metadata associated with the function argument, the sqlite3_get_auxdata_APIName interface returns a NULL pointer.", "key": "sqlite3_get_auxdata", "sent": "If there is no metadata associated with the function argument, the sqlite3_get_auxdata_APIName interface returns a NULL pointer."}, {"API_info": "sqlite3_set_auxdatanot exist in API_info", "paraph": "Note the last bullet in particular.The destructor X in sqlite3_set_auxdata_APIName might be called immediately, before the sqlite3_set_auxdata_APIName interface even returns.Hence sqlite3_set_auxdata_APIName should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata_APIName has been called.", "key": "sqlite3_set_auxdata", "sent": "Note the last bullet in particular."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_set_auxdata_APIName interface saves P as metadata for the N-th argument of the application-defined function.Subsequent calls to sqlite3_get_auxdata_APIName return sqlite3_set_auxdata_APIParam_3 from the most recent sqlite3_set_auxdata_APIName call if the metadata is still valid or NULL if the metadata has been discarded.After each call to sqlite3_set_auxdata_APIName where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded.SQLite is free to discard the metadata at any time, including:", "key": "sqlite3_get_auxdata", "sent": "SQLite is free to discard the metadata at any time, including:"}, {"API_info": "sqlite3_set_auxdatanot exist in API_info", "paraph": "The sqlite3_set_auxdata_APIName interface saves P as metadata for the N-th argument of the application-defined function.Subsequent calls to sqlite3_get_auxdata_APIName return sqlite3_set_auxdata_APIParam_3 from the most recent sqlite3_set_auxdata_APIName call if the metadata is still valid or NULL if the metadata has been discarded.After each call to sqlite3_set_auxdata_APIName where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded.SQLite is free to discard the metadata at any time, including:", "key": "sqlite3_set_auxdata", "sent": "The sqlite3_set_auxdata_APIName interface saves P as metadata for the N-th argument of the application-defined function."}, {"API_info": "sqlite3_set_auxdatanot exist in API_info", "paraph": "Note the last bullet in particular.The destructor X in sqlite3_set_auxdata_APIName might be called immediately, before the sqlite3_set_auxdata_APIName interface even returns.Hence sqlite3_set_auxdata_APIName should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata_APIName has been called.", "key": "sqlite3_set_auxdata", "sent": "The destructor X in sqlite3_set_auxdata_APIName might be called immediately, before the sqlite3_set_auxdata_APIName interface even returns."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The value of the sqlite3_get_auxdata_APIParam_2 parameter to these interfaces should be non-negative.Future enhancements may make use of negative N values to define new kinds of function caching behavior.", "key": "sqlite3_get_auxdata", "sent": "The value of the sqlite3_get_auxdata_APIParam_2 parameter to these interfaces should be non-negative."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "These routines are deprecated.Use the sqlite3_trace_v2_APIName interface instead of the routines described here.", "key": "sqlite3_trace", "sent": "These routines are deprecated."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "These routines must be called from the same thread in which the SQL function is running.", "key": "sqlite3_get_auxdata", "sent": "These routines must be called from the same thread in which the SQL function is running."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_set_auxdata_APIName interface saves P as metadata for the N-th argument of the application-defined function.Subsequent calls to sqlite3_get_auxdata_APIName return sqlite3_set_auxdata_APIParam_3 from the most recent sqlite3_set_auxdata_APIName call if the metadata is still valid or NULL if the metadata has been discarded.After each call to sqlite3_set_auxdata_APIName where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded.SQLite is free to discard the metadata at any time, including:", "key": "sqlite3_get_auxdata", "sent": "Subsequent calls to sqlite3_get_auxdata_APIName return sqlite3_set_auxdata_APIParam_3 from the most recent sqlite3_set_auxdata_APIName call if the metadata is still valid or NULL if the metadata has been discarded."}, {"API_info": "sqlite3_set_auxdata not exist in API_info", "paraph": "The value of the sqlite3_get_auxdata_APIParam_2 parameter to these interfaces should be non-negative.Future enhancements may make use of negative N values to define new kinds of function caching behavior.", "key": "sqlite3_set_auxdata", "sent": "Future enhancements may make use of negative N values to define new kinds of function caching behavior."}, {"API_info": {"var": ["sqlite3_context*", "int"], "API_desc": " The sqlite3_result_subtype_APIName function causes the subtype of the result from the application-defined SQL function with sqlite3_context C to be the value T.  Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded.", "var_type": ["sqlite3_context*", "unsigned"], "ret_type": "void"}, "paraph": "The sqlite3_result_subtype_APIName function causes the subtype of the result from the application-defined SQL function with sqlite3_context sqlite3_result_subtype_APIParam_1 to be the value sqlite3_result_subtype_APIParam_2.  Only the lower 8 bits of the subtype sqlite3_result_subtype_APIParam_2 are preserved in current versions of SQLite; higher order bits are discarded.The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.", "key": "sqlite3_result_subtype", "sent": "The number of subtype bytes preserved by SQLite might increase in future releases of SQLite."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "These routines are deprecated.Use the sqlite3_trace_v2_APIName interface instead of the routines described here.", "key": "sqlite3_trace", "sent": "Use the sqlite3_trace_v2_APIName interface instead of the routines described here."}, {"API_info": "sqlite3_set_auxdatanot exist in API_info", "paraph": "The sqlite3_set_auxdata_APIName interface saves P as metadata for the N-th argument of the application-defined function.Subsequent calls to sqlite3_get_auxdata_APIName return sqlite3_set_auxdata_APIParam_3 from the most recent sqlite3_set_auxdata_APIName call if the metadata is still valid or NULL if the metadata has been discarded.After each call to sqlite3_set_auxdata_APIName where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded.SQLite is free to discard the metadata at any time, including:", "key": "sqlite3_set_auxdata", "sent": "After each call to sqlite3_set_auxdata_APIName where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_trace_APIName is invoked at various times when an SQL statement is being run by sqlite3_step_APIName.The sqlite3_trace_APIName callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing.Additional sqlite3_trace_APIName callbacks might occur as each triggered subprogram is entered.The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.", "key": "sqlite3_trace", "sent": "Additional sqlite3_trace_APIName callbacks might occur as each triggered subprogram is entered."}, {"API_info": "sqlite3_set_auxdatanot exist in API_info", "paraph": "Note the last bullet in particular.The destructor X in sqlite3_set_auxdata_APIName might be called immediately, before the sqlite3_set_auxdata_APIName interface even returns.Hence sqlite3_set_auxdata_APIName should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata_APIName has been called.", "key": "sqlite3_set_auxdata", "sent": "Hence sqlite3_set_auxdata_APIName should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata_APIName has been called."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_trace_APIName is invoked at various times when an SQL statement is being run by sqlite3_step_APIName.The sqlite3_trace_APIName callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing.Additional sqlite3_trace_APIName callbacks might occur as each triggered subprogram is entered.The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.", "key": "sqlite3_trace", "sent": "The callback function registered by sqlite3_trace_APIName is invoked at various times when an SQL statement is being run by sqlite3_step_APIName."}, {"API_info": "sqlite3_trace not exist in API_info", "paraph": "These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.", "key": "sqlite3_trace", "sent": "These routines register callback functions that can be used for tracing and profiling the execution of SQL statements."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_trace_APIName is invoked at various times when an SQL statement is being run by sqlite3_step_APIName.The sqlite3_trace_APIName callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing.Additional sqlite3_trace_APIName callbacks might occur as each triggered subprogram is entered.The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.", "key": "sqlite3_trace", "sent": "The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger."}, {"API_info": "sqlite3_profilenot exist in API_info", "paraph": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes.The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run.The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless.Future versions of SQLite might provide greater resolution on the profiler callback.Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback.", "key": "sqlite3_profile", "sent": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes.The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run.The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless.Future versions of SQLite might provide greater resolution on the profiler callback.Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback.", "key": "sqlite3_trace", "sent": "Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes.The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run.The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless.Future versions of SQLite might provide greater resolution on the profiler callback.Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback.", "key": "sqlite3_trace", "sent": "Future versions of SQLite might provide greater resolution on the profiler callback."}, {"API_info": {"var": ["sqlite3_context*", "N"], "API_desc": " These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and parameters and expressions composed from the same.", "key": "sqlite3_get_auxdata", "sent": "In practice, metadata is preserved between function calls for function parameters that are compile-time constants, including literal values and parameters and expressions composed from the same."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The SQLITE_TRACE_API_constant_SIZE_LIMIT compile-time option can be used to limit the length of bound parameter expansion in the output of sqlite3_trace_APIName.", "key": "sqlite3_trace", "sent": "The SQLITE_TRACE_API_constant_SIZE_LIMIT compile-time option can be used to limit the length of bound parameter expansion in the output of sqlite3_trace_APIName."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_trace_APIName is invoked at various times when an SQL statement is being run by sqlite3_step_APIName.The sqlite3_trace_APIName callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing.Additional sqlite3_trace_APIName callbacks might occur as each triggered subprogram is entered.The callbacks for triggers contain a UTF-8 SQL comment that identifies the trigger.", "key": "sqlite3_trace", "sent": "The sqlite3_trace_APIName callback is invoked with a UTF-8 rendering of the SQL statement text as the statement first begins executing."}, {"API_info": {"var": ["sqlite3_context*", "int"], "API_desc": " The sqlite3_result_subtype_APIName function causes the subtype of the result from the application-defined SQL function with sqlite3_context C to be the value T.  Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded.", "var_type": ["sqlite3_context*", "unsigned"], "ret_type": "void"}, "paraph": "The sqlite3_result_subtype_APIName function causes the subtype of the result from the application-defined SQL function with sqlite3_context sqlite3_result_subtype_APIParam_1 to be the value sqlite3_result_subtype_APIParam_2.  Only the lower 8 bits of the subtype sqlite3_result_subtype_APIParam_2 are preserved in current versions of SQLite; higher order bits are discarded.The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.", "key": "sqlite3_result_subtype", "sent": "The sqlite3_result_subtype_APIName function causes the subtype of the result from the application-defined SQL function with sqlite3_context sqlite3_result_subtype_APIParam_1 to be the value sqlite3_result_subtype_APIParam_2.  Only the lower 8 bits of the subtype sqlite3_result_subtype_APIParam_2 are preserved in current versions of SQLite; higher order bits are discarded."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The values returned by sqlite3_errcode_APIName and/or sqlite3_extended_errcode_APIName might change with each API call.Except, there are some interfaces that are guaranteed to never change the value of the error code.The error-code preserving interfaces are:", "key": "sqlite3_errcode", "sent": "The error-code preserving interfaces are:"}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The values returned by sqlite3_errcode_APIName and/or sqlite3_extended_errcode_APIName might change with each API call.Except, there are some interfaces that are guaranteed to never change the value of the error code.The error-code preserving interfaces are:", "key": "sqlite3_errcode", "sent": "The values returned by sqlite3_errcode_APIName and/or sqlite3_extended_errcode_APIName might change with each API call."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes.The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run.The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless.Future versions of SQLite might provide greater resolution on the profiler callback.Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback.", "key": "sqlite3_trace", "sent": "The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The values returned by sqlite3_errcode_APIName and/or sqlite3_extended_errcode_APIName might change with each API call.Except, there are some interfaces that are guaranteed to never change the value of the error code.The error-code preserving interfaces are:", "key": "sqlite3_errcode", "sent": "Except, there are some interfaces that are guaranteed to never change the value of the error code."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const char *"}, "paraph": "The sqlite3_errmsg_APIName and sqlite3_errmsg16_APIName return English-language text that describes the error, as either UTF-8 or UTF-16 respectively.Memory to hold the error message string is managed internally.The application does not need to worry about freeing the result.However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.", "key": "sqlite3_errmsg", "sent": "Memory to hold the error message string is managed internally."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const char *"}, "paraph": "The sqlite3_errmsg_APIName and sqlite3_errmsg16_APIName return English-language text that describes the error, as either UTF-8 or UTF-16 respectively.Memory to hold the error message string is managed internally.The application does not need to worry about freeing the result.However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.", "key": "sqlite3_errmsg", "sent": "The application does not need to worry about freeing the result."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const char *"}, "paraph": "The sqlite3_errmsg_APIName and sqlite3_errmsg16_APIName return English-language text that describes the error, as either UTF-8 or UTF-16 respectively.Memory to hold the error message string is managed internally.The application does not need to worry about freeing the result.However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.", "key": "sqlite3_errmsg", "sent": "The sqlite3_errmsg_APIName and sqlite3_errmsg16_APIName return English-language text that describes the error, as either UTF-8 or UTF-16 respectively."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "If the most recent sqlite3_* API call associated with database connection sqlite3_errcode_APIParam_1 failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.The sqlite3_extended_errcode_APIName interface is the same except that it always returns the extended result code even when extended result codes are disabled.", "key": "sqlite3_extended_errcode", "sent": "The sqlite3_extended_errcode_APIName interface is the same except that it always returns the extended result code even when extended result codes are disabled."}, {"API_info": {"var": ["int"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["int"], "ret_type": "const char *"}, "paraph": "The sqlite3_errstr_APIName interface returns the English-language text that describes the result code, as UTF-8.Memory to hold the error message string is managed internally and must not be freed by the application.", "key": "sqlite3_errstr", "sent": "The sqlite3_errstr_APIName interface returns the English-language text that describes the result code, as UTF-8."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const char *"}, "paraph": "The sqlite3_errmsg_APIName and sqlite3_errmsg16_APIName return English-language text that describes the error, as either UTF-8 or UTF-16 respectively.Memory to hold the error message string is managed internally.The application does not need to worry about freeing the result.However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.", "key": "sqlite3_errmsg", "sent": "However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "When the serialized threading mode is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces.When that happens, the second error will be reported since these interfaces always report the most recent result.To avoid this, each thread can obtain exclusive use of the database connection sqlite3_db_mutex_APIParam_1 by invoking sqlite3_mutex_enter(sqlite3_db_mutex_APIName) before beginning to use sqlite3_db_mutex_APIParam_1 and invoking sqlite3_mutex_leave(sqlite3_db_mutex_APIName) after all calls to the interfaces listed here are completed.", "key": "sqlite3_extended_errcode", "sent": "When that happens , the second error will be reported  ."}, {"API_info": {"var": ["int"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["int"], "ret_type": "const char *"}, "paraph": "The sqlite3_errstr_APIName interface returns the English-language text that describes the result code, as UTF-8.Memory to hold the error message string is managed internally and must not be freed by the application.", "key": "sqlite3_errstr", "sent": "Memory to hold the error message string is managed internally and must not be freed by the application."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const char *"}, "paraph": "If an interface fails with SQLITE_MISUSE_API_constant, that means the interface was invoked incorrectly by the application.In that case, the error code and message may or may not be set.", "key": "sqlite3_errmsg", "sent": "In that case, the error code and message may or may not be set."}, {"API_info": "sqlite3_tracenot exist in API_info", "paraph": "The callback function registered by sqlite3_profile_APIName is invoked as each SQL statement finishes.The profile callback contains the original statement text and an estimate of wall-clock time of how long that statement took to run.The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless.Future versions of SQLite might provide greater resolution on the profiler callback.Invoking either sqlite3_trace_APIName or sqlite3_trace_v2_APIName will cancel the profile callback.", "key": "sqlite3_trace", "sent": "The profile callback time is in units of nanoseconds, however the current implementation is only capable of millisecond resolution so the six least significant digits in the time are meaningless."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "If an interface fails with SQLITE_MISUSE_API_constant, that means the interface was invoked incorrectly by the application.In that case, the error code and message may or may not be set.", "key": "sqlite3_errcode", "sent": "If an interface fails with SQLITE_MISUSE_API_constant, that means the interface was invoked incorrectly by the application."}, {"API_info": {"var": ["void"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["void"], "ret_type": "int"}, "paraph": "These routines provide access to the set of SQL language keywords recognized by SQLite.Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.", "key": "sqlite3_keyword_count", "sent": "These routines provide access to the set of SQL language keywords recognized by SQLite."}, {"API_info": {"var": ["void"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_keyword_count_APIName interface returns the number of distinct keywords understood by SQLite.", "key": "sqlite3_keyword_count", "sent": "The sqlite3_keyword_count_APIName interface returns the number of distinct keywords understood by SQLite."}, {"API_info": {"var": ["void"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The parser used by SQLite is forgiving.It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity.For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\".Nevertheless, best practice is to avoid using keywords as identifiers.Common techniques used to avoid keyword name collisions include:", "key": "sqlite3_keyword_count", "sent": "The parser used by SQLite is forgiving."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "The sqlite3_keyword_name_APIName interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L.  The string that *Z points to is not zero-terminated.The sqlite3_keyword_name_APIName routine returns SQLITE_OK_API_constant if sqlite3_keyword_name_APIParam_1 is within bounds and SQLITE_ERROR_API_constant if not.If either Z or sqlite3_keyword_name_APIParam_3 are NULL or invalid pointers then calls to sqlite3_keyword_name_APIName result in undefined behavior.", "key": "sqlite3_keyword_name", "sent": "The sqlite3_keyword_name_APIName routine returns SQLITE_OK_API_constant if sqlite3_keyword_name_APIParam_1 is within bounds and SQLITE_ERROR_API_constant if not."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "The sqlite3_keyword_name_APIName interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L.  The string that *Z points to is not zero-terminated.The sqlite3_keyword_name_APIName routine returns SQLITE_OK_API_constant if sqlite3_keyword_name_APIParam_1 is within bounds and SQLITE_ERROR_API_constant if not.If either Z or sqlite3_keyword_name_APIParam_3 are NULL or invalid pointers then calls to sqlite3_keyword_name_APIName result in undefined behavior.", "key": "sqlite3_keyword_name", "sent": "If either Z or sqlite3_keyword_name_APIParam_3 are NULL or invalid pointers then calls to sqlite3_keyword_name_APIName result in undefined behavior."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "These routines provide access to the set of SQL language keywords recognized by SQLite.Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.", "key": "sqlite3_keyword_name", "sent": "Applications can uses these routines to determine  ."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "If the most recent sqlite3_* API call associated with database connection sqlite3_errcode_APIParam_1 failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.The sqlite3_extended_errcode_APIName interface is the same except that it always returns the extended result code even when extended result codes are disabled.", "key": "sqlite3_errcode", "sent": "If the most recent sqlite3_* API call associated with database connection sqlite3_errcode_APIParam_1 failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "The parser used by SQLite is forgiving.It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity.For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\".Nevertheless, best practice is to avoid using keywords as identifiers.Common techniques used to avoid keyword name collisions include:", "key": "sqlite3_keyword_name", "sent": "Nevertheless, best practice is to avoid using keywords as identifiers."}, {"API_info": {"var": ["const char*", "int"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["const char*", "int"], "ret_type": "int"}, "paraph": "The parser used by SQLite is forgiving.It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity.For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\".Nevertheless, best practice is to avoid using keywords as identifiers.Common techniques used to avoid keyword name collisions include:", "key": "sqlite3_keyword_check", "sent": "Common techniques used to avoid keyword name collisions include:"}, {"API_info": {"var": ["void"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Note that the number of keywords understood by SQLite can depend on compile-time options.For example, \"VACUUM\" is not a keyword if SQLite is compiled with the -DSQLITE_OMIT_VACUUM option.Also, new keywords may be added to future releases of SQLite.", "key": "sqlite3_keyword_count", "sent": "Note that the number of keywords understood by SQLite can depend on compile-time options."}, {"API_info": {"var": ["const char*", "int"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["const char*", "int"], "ret_type": "int"}, "paraph": "Note that the number of keywords understood by SQLite can depend on compile-time options.For example, \"VACUUM\" is not a keyword if SQLite is compiled with the -DSQLITE_OMIT_VACUUM option.Also, new keywords may be added to future releases of SQLite.", "key": "sqlite3_keyword_check", "sent": "Also, new keywords may be added to future releases of SQLite."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3*"], "ret_type": "const void *"}, "paraph": "When the serialized threading mode is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces.When that happens, the second error will be reported since these interfaces always report the most recent result.To avoid this, each thread can obtain exclusive use of the database connection sqlite3_db_mutex_APIParam_1 by invoking sqlite3_mutex_enter(sqlite3_db_mutex_APIName) before beginning to use sqlite3_db_mutex_APIParam_1 and invoking sqlite3_mutex_leave(sqlite3_db_mutex_APIName) after all calls to the interfaces listed here are completed.", "key": "sqlite3_errmsg16", "sent": "To avoid this, each thread can obtain exclusive use of the database connection sqlite3_db_mutex_APIParam_1 by invoking sqlite3_mutex_enter(sqlite3_db_mutex_APIName) before beginning to use sqlite3_db_mutex_APIParam_1 and invoking sqlite3_mutex_leave(sqlite3_db_mutex_APIName) after all calls to the interfaces listed here are completed."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "Note that the number of keywords understood by SQLite can depend on compile-time options.For example, \"VACUUM\" is not a keyword if SQLite is compiled with the -DSQLITE_OMIT_VACUUM option.Also, new keywords may be added to future releases of SQLite.", "key": "sqlite3_keyword_name", "sent": "For example, \"VACUUM\" is not a keyword if SQLite is compiled with the -DSQLITE_OMIT_VACUUM option."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.", "key": "sqlite3_snapshot_cmp", "sent": "The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles."}, {"API_info": {"var": ["void"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The parser used by SQLite is forgiving.It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity.For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\".Nevertheless, best practice is to avoid using keywords as identifiers.Common techniques used to avoid keyword name collisions include:", "key": "sqlite3_keyword_count", "sent": "It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "The sqlite3_keyword_name_APIName interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L.  The string that *Z points to is not zero-terminated.The sqlite3_keyword_name_APIName routine returns SQLITE_OK_API_constant if sqlite3_keyword_name_APIParam_1 is within bounds and SQLITE_ERROR_API_constant if not.If either Z or sqlite3_keyword_name_APIParam_3 are NULL or invalid pointers then calls to sqlite3_keyword_name_APIName result in undefined behavior.", "key": "sqlite3_keyword_name", "sent": "The sqlite3_keyword_name_APIName interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L.  The string that *Z points to is not zero-terminated."}, {"API_info": {"var": ["db"], "API_desc": " If the most recent sqlite3_* API call associated with database connection D failed, then the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "When the serialized threading mode is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces.When that happens, the second error will be reported since these interfaces always report the most recent result.To avoid this, each thread can obtain exclusive use of the database connection sqlite3_db_mutex_APIParam_1 by invoking sqlite3_mutex_enter(sqlite3_db_mutex_APIName) before beginning to use sqlite3_db_mutex_APIParam_1 and invoking sqlite3_mutex_leave(sqlite3_db_mutex_APIName) after all calls to the interfaces listed here are completed.", "key": "sqlite3_errcode", "sent": "When the serialized threading mode is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.", "key": "sqlite3_snapshot_cmp", "sent": "If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined."}, {"API_info": {"var": ["int", "const char**", "int*"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["int", "const char**", "int*"], "ret_type": "int"}, "paraph": "The parser used by SQLite is forgiving.It is often possible to use a keyword as an identifier as long as such use does not result in a parsing ambiguity.For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\".Nevertheless, best practice is to avoid using keywords as identifiers.Common techniques used to avoid keyword name collisions include:", "key": "sqlite3_keyword_name", "sent": "For example, the statement \"CREATE TABLE BEGIN_APIName;\" is accepted by SQLite, and creates a new table named \"BEGIN\" with three columns named \"REPLACE\", \"PRAGMA\", and \"END\"."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option.", "key": "sqlite3_snapshot_cmp", "sent": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "This is a legacy interface that is preserved for backwards compatibility.Use of this interface is not recommended.", "key": "sqlite3_free_table", "sent": "Use of this interface is not recommended."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "This is a legacy interface that is preserved for backwards compatibility.Use of this interface is not recommended.", "key": "sqlite3_get_table", "sent": "This is a legacy interface that is preserved for backwards compatibility."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero.If either snapshot handle was obtained before the wal file was last deleted, the value returned by sqlite3_snapshot_cmp_APIName is undefined.", "key": "sqlite3_snapshot_cmp", "sent": "If either snapshot handle was obtained before the wal file was last deleted, the value returned by sqlite3_snapshot_cmp_APIName is undefined."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "Definition: A result table is memory data structure created by the sqlite3_get_table_APIName interface.A result table records the complete query results from one or more queries.", "key": "sqlite3_get_table", "sent": "Definition: A result table is memory data structure created by the sqlite3_get_table_APIName interface."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero.If either snapshot handle was obtained before the wal file was last deleted, the value returned by sqlite3_snapshot_cmp_APIName is undefined.", "key": "sqlite3_snapshot_cmp", "sent": "The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero."}, {"API_info": {"var": ["const char*", "int"], "API_desc": " These routines provide access to the set of SQL language keywords recognized by SQLite.", "var_type": ["const char*", "int"], "ret_type": "int"}, "paraph": "The sqlite3_keyword_check_APIName interface checks to see whether or not the L-byte UTF8 identifier that sqlite3_keyword_check_APIParam_1 points to is a keyword, returning non-zero if it is and zero if not.", "key": "sqlite3_keyword_check", "sent": "The sqlite3_keyword_check_APIName interface checks to see  ."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The table conceptually has a number of rows and columns.But these numbers are not part of the result table itself.These numbers are obtained separately.Let N be the number of rows and M be the number of columns.", "key": "sqlite3_get_table", "sent": "The table conceptually has a number of rows and columns."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "Definition: A result table is memory data structure created by the sqlite3_get_table_APIName interface.A result table records the complete query results from one or more queries.", "key": "sqlite3_get_table", "sent": "A result table records the complete query results from one or more queries."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The table conceptually has a number of rows and columns.But these numbers are not part of the result table itself.These numbers are obtained separately.Let N be the number of rows and M be the number of columns.", "key": "sqlite3_get_table", "sent": "But these numbers are not part of the result table itself."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "The table conceptually has a number of rows and columns.But these numbers are not part of the result table itself.These numbers are obtained separately.Let N be the number of rows and M be the number of columns.", "key": "sqlite3_free_table", "sent": "These numbers are obtained separately."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero.If either snapshot handle was obtained before the wal file was last deleted, the value returned by sqlite3_snapshot_cmp_APIName is undefined.", "key": "sqlite3_snapshot_cmp", "sent": "Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_get_table", "sent": "A result table is an array of pointers to zero-terminated UTF-8 strings."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_get_table", "sent": "There are (N+1)*M elements in the array."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_free_table", "sent": "The remaining entries all point to query results."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "The table conceptually has a number of rows and columns.But these numbers are not part of the result table itself.These numbers are obtained separately.Let N be the number of rows and M be the number of columns.", "key": "sqlite3_free_table", "sent": "Let N be the number of rows and M be the number of columns."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_free_table", "sent": "NULL values sqlite3_free_table_APIParam_1 in NULL pointers."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_get_table", "sent": "The first M pointers point to zero-terminated strings that  contain the names of the columns."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A result table is an array of pointers to zero-terminated UTF-8 strings.There are (N+1)*M elements in the array.The first M pointers point to zero-terminated strings that  contain the names of the columns.The remaining entries all point to query results.NULL values sqlite3_free_table_APIParam_1 in NULL pointers.All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName.", "key": "sqlite3_free_table", "sent": "All other values are in their UTF-8 zero-terminated string representation as returned by sqlite3_column_text_APIName."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A sqlite3_free_table_APIParam_1 table might consist of one or more memory allocations.It is not safe to pass a sqlite3_free_table_APIParam_1 table directly to sqlite3_free_APIName.A sqlite3_free_table_APIParam_1 table should be deallocated using sqlite3_free_table_APIName.", "key": "sqlite3_free_table", "sent": "It is not safe to pass a sqlite3_free_table_APIParam_1 table directly to sqlite3_free_APIName."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A sqlite3_free_table_APIParam_1 table might consist of one or more memory allocations.It is not safe to pass a sqlite3_free_table_APIParam_1 table directly to sqlite3_free_APIName.A sqlite3_free_table_APIParam_1 table should be deallocated using sqlite3_free_table_APIName.", "key": "sqlite3_free_table", "sent": "A sqlite3_free_table_APIParam_1 table might consist of one or more memory allocations."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "A sqlite3_free_table_APIParam_1 table might consist of one or more memory allocations.It is not safe to pass a sqlite3_free_table_APIParam_1 table directly to sqlite3_free_APIName.A sqlite3_free_table_APIParam_1 table should be deallocated using sqlite3_free_table_APIName.", "key": "sqlite3_free_table", "sent": "A sqlite3_free_table_APIParam_1 table should be deallocated using sqlite3_free_table_APIName."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "There are two column (M==2) and three rows (N==3).Thus the result table has 8 entries.Suppose the sqlite3_free_table_APIParam_1 table is stored in an array names azResult.Then azResult holds this content:", "key": "sqlite3_get_table", "sent": "There are two column (M==2) and three rows (N==3)."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "There are two column (M==2) and three rows (N==3).Thus the result table has 8 entries.Suppose the sqlite3_free_table_APIParam_1 table is stored in an array names azResult.Then azResult holds this content:", "key": "sqlite3_free_table", "sent": "Then azResult holds this content:"}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "There are two column (M==2) and three rows (N==3).Thus the result table has 8 entries.Suppose the sqlite3_free_table_APIParam_1 table is stored in an array names azResult.Then azResult holds this content:", "key": "sqlite3_get_table", "sent": "Thus the result table has 8 entries."}, {"API_info": {"var": ["db", "zDbName"], "API_desc": " The sqlite3_db_readonly_APIName interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "The sqlite3_db_readonly_APIName interface returns 1 if the database sqlite3_db_readonly_APIParam_2 of connection sqlite3_db_readonly_APIParam_1 is read-only, 0 if it is read/write, or -1 if sqlite3_db_readonly_APIParam_2 is not the name of a database on connection sqlite3_db_readonly_APIParam_1.", "key": "sqlite3_db_readonly", "sent": "The sqlite3_db_readonly_APIName interface returns 1 if the database sqlite3_db_readonly_APIParam_2 of connection sqlite3_db_readonly_APIParam_1 is read-only, 0 if it is read/write, or -1 if sqlite3_db_readonly_APIParam_2 is not the name of a database on connection sqlite3_db_readonly_APIParam_1."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "As an example of the result table format, suppose a query result is as follows:", "key": "sqlite3_get_table", "sent": "As an example of the result table format, suppose a query result is as follows:"}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "There are two column (M==2) and three rows (N==3).Thus the result table has 8 entries.Suppose the sqlite3_free_table_APIParam_1 table is stored in an array names azResult.Then azResult holds this content:", "key": "sqlite3_free_table", "sent": "Suppose the sqlite3_free_table_APIParam_1 table is stored in an array names azResult."}, {"API_info": {"var": ["result"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["char **"], "ret_type": "void"}, "paraph": "After the application has finished with the result from sqlite3_get_table_APIName, it must pass the result table pointer to sqlite3_free_table_APIName in order to release the memory that was malloced.Because of the way the sqlite3_malloc_APIName happens within sqlite3_get_table_APIName, the calling function must not try to call sqlite3_free_APIName directly.Only sqlite3_free_table_APIName is able to release the memory properly and safely.", "key": "sqlite3_free_table", "sent": "Only sqlite3_free_table_APIName is able to release the memory properly and safely."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_get_table_APIName interface is implemented as a wrapper around sqlite3_exec_APIName.The sqlite3_get_table_APIName routine does not have access to any internal data structures of SQLite.It uses only the public interface defined here.As a consequence, errors that occur in the wrapper layer outside of the internal sqlite3_exec_APIName call are not reflected in subsequent calls to sqlite3_errcode_APIName or sqlite3_errmsg_APIName.", "key": "sqlite3_get_table", "sent": "The sqlite3_get_table_APIName interface is implemented as a wrapper around sqlite3_exec_APIName."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_get_table_APIName interface is implemented as a wrapper around sqlite3_exec_APIName.The sqlite3_get_table_APIName routine does not have access to any internal data structures of SQLite.It uses only the public interface defined here.As a consequence, errors that occur in the wrapper layer outside of the internal sqlite3_exec_APIName call are not reflected in subsequent calls to sqlite3_errcode_APIName or sqlite3_errmsg_APIName.", "key": "sqlite3_get_table", "sent": "It uses only the public interface defined here."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "After the application has finished with the result from sqlite3_get_table_APIName, it must pass the result table pointer to sqlite3_free_table_APIName in order to release the memory that was malloced.Because of the way the sqlite3_malloc_APIName happens within sqlite3_get_table_APIName, the calling function must not try to call sqlite3_free_APIName directly.Only sqlite3_free_table_APIName is able to release the memory properly and safely.", "key": "sqlite3_get_table", "sent": " , the calling function must not try to call sqlite3_free_APIName directly ."}, {"API_info": {"var": ["p1", "p2"], "API_desc": " The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get_APIName since the last time the wal file was deleted.", "var_type": ["sqlite3_snapshot *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.", "key": "sqlite3_snapshot_cmp", "sent": "Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_get_table_APIName interface is implemented as a wrapper around sqlite3_exec_APIName.The sqlite3_get_table_APIName routine does not have access to any internal data structures of SQLite.It uses only the public interface defined here.As a consequence, errors that occur in the wrapper layer outside of the internal sqlite3_exec_APIName call are not reflected in subsequent calls to sqlite3_errcode_APIName or sqlite3_errmsg_APIName.", "key": "sqlite3_get_table", "sent": "The sqlite3_get_table_APIName routine does not have access to any internal data structures of SQLite."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines return the name assigned to a particular column in the result set of a SELECT statement.The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string.The first parameter is the prepared statement that implements the SELECT statement.The second parameter is the column number.The leftmost column is number 0.", "key": "sqlite3_column_name", "sent": "The first parameter is the prepared statement that implements the SELECT statement."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines return the name assigned to a particular column in the result set of a SELECT statement.The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string.The first parameter is the prepared statement that implements the SELECT statement.The second parameter is the column number.The leftmost column is number 0.", "key": "sqlite3_column_name", "sent": "The second parameter is the column number."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines return the name assigned to a particular column in the result set of a SELECT statement.The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string.The first parameter is the prepared statement that implements the SELECT statement.The second parameter is the column number.The leftmost column is number 0.", "key": "sqlite3_column_name", "sent": "The leftmost column is number 0."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines return the name assigned to a particular column in the result set of a SELECT statement.The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string.The first parameter is the prepared statement that implements the SELECT statement.The second parameter is the column number.The leftmost column is number 0.", "key": "sqlite3_column_name", "sent": "These routines return the name assigned to a particular column in the result set of a SELECT statement."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "After the application has finished with the result from sqlite3_get_table_APIName, it must pass the result table pointer to sqlite3_free_table_APIName in order to release the memory that was malloced.Because of the way the sqlite3_malloc_APIName happens within sqlite3_get_table_APIName, the calling function must not try to call sqlite3_free_APIName directly.Only sqlite3_free_table_APIName is able to release the memory properly and safely.", "key": "sqlite3_get_table", "sent": "After the application has finished with the result from sqlite3_get_table_APIName , it must pass the result table pointer to sqlite3_free_table_APIName  ."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_get_table_APIName interface is implemented as a wrapper around sqlite3_exec_APIName.The sqlite3_get_table_APIName routine does not have access to any internal data structures of SQLite.It uses only the public interface defined here.As a consequence, errors that occur in the wrapper layer outside of the internal sqlite3_exec_APIName call are not reflected in subsequent calls to sqlite3_errcode_APIName or sqlite3_errmsg_APIName.", "key": "sqlite3_get_table", "sent": "As a consequence, errors that occur in the wrapper layer outside of the internal sqlite3_exec_APIName call are not reflected in subsequent calls to sqlite3_errcode_APIName or sqlite3_errmsg_APIName."}, {"API_info": {"var": ["db", "zSql", "pazResult", "pnRow", "pnColumn", "pzErrmsg"], "API_desc": " This is a legacy interface that is preserved for backwards compatibility.", "var_type": ["sqlite3 *", "const char *", "char ***", "int *", "int *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_get_table_APIName function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2_APIConstant parameter and returns a result table to the pointer given in its 3_APIConstant parameter.", "key": "sqlite3_get_table", "sent": "The sqlite3_get_table_APIName function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2_APIConstant parameter and returns a result table to the pointer given in its 3_APIConstant parameter."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines return the name assigned to a particular column in the result set of a SELECT statement.The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string.The first parameter is the prepared statement that implements the SELECT statement.The second parameter is the column number.The leftmost column is number 0.", "key": "sqlite3_column_name", "sent": "The sqlite3_column_name_APIName interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16_APIName returns a pointer to a zero-terminated UTF-16 string."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If sqlite3_malloc_APIName fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer be returned by sqlite3_column_name_APIName.", "key": "sqlite3_column_name", "sent": "If sqlite3_malloc_APIName fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer be returned by sqlite3_column_name_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If a write-transaction is open on database connection sqlite3_db_cacheflush_APIParam_1 when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always \"in use\").The sqlite3_db_cacheflush_APIName interface flushes caches for all schemas - \"main\", \"temp\", and any attached databases.", "key": "sqlite3_db_cacheflush", "sent": "The sqlite3_db_cacheflush_APIName interface flushes caches for all schemas - \"main\", \"temp\", and any attached databases."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If sqlite3_db_cacheflush_APIName needs to obtain extra database locks before dirty pages can be flushed to disk, it does so.If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner.If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database.If any databases are skipped because locks cannot be obtained, but no other error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_BUSY_API_constant.", "key": "sqlite3_db_cacheflush", "sent": "If sqlite3_db_cacheflush_APIName needs to obtain extra database locks before dirty pages can be flushed to disk, it does so."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Otherwise, if no error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_OK_API_constant.", "key": "sqlite3_db_cacheflush", "sent": "Otherwise, if no error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If sqlite3_db_cacheflush_APIName needs to obtain extra database locks before dirty pages can be flushed to disk, it does so.If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner.If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database.If any databases are skipped because locks cannot be obtained, but no other error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_BUSY_API_constant.", "key": "sqlite3_db_cacheflush", "sent": "If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The name of a result column is the value of the \"AS\" clause for that column, if there is an AS clause.If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.", "key": "sqlite3_column_name", "sent": "The name of a result column is the value of the \"AS\" clause for that column, if there is an AS clause."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_db_release_memory_APIName interface attempts to free as much heap memory as possible from database connection D. Unlike the sqlite3_release_memory_APIName interface, this interface is in effect even when the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is omitted.See also: sqlite3_release_memory_APIName", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "See also: sqlite3_release_memory_APIName", "key": "sqlite3_db_release_memory", "sent": "See also: sqlite3_release_memory_APIName"}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " Contrary to the intuition of many, sqlite3_reset_APIName does not reset the bindings on a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Contrary to the intuition of many, sqlite3_reset_APIName does not reset the bindings on a prepared statement.Use this routine to reset all host parameters to NULL.", "key": "sqlite3_clear_bindings", "sent": "Use this routine to reset all host parameters to NULL."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "sqlite3_db_cacheflush_APIName does not set the database handle error code or message returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions.", "key": "sqlite3_db_cacheflush", "sent": "sqlite3_db_cacheflush_APIName does not set the database handle error code or message returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If sqlite3_db_cacheflush_APIName needs to obtain extra database locks before dirty pages can be flushed to disk, it does so.If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner.If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database.If any databases are skipped because locks cannot be obtained, but no other error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_BUSY_API_constant.", "key": "sqlite3_db_cacheflush", "sent": "If any databases are skipped because locks cannot be obtained, but no other error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_BUSY_API_constant."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " Contrary to the intuition of many, sqlite3_reset_APIName does not reset the bindings on a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "Contrary to the intuition of many, sqlite3_reset_APIName does not reset the bindings on a prepared statement.Use this routine to reset all host parameters to NULL.", "key": "sqlite3_clear_bindings", "sent": "Contrary to the intuition of many, sqlite3_reset_APIName does not reset the bindings on a prepared statement."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " Zero all sqlite3_stmt_scanstatus_APIName related event counters.This API is only available if the library is built with pre-processor symbol SQLITE_ENABLE_STMT_SCANSTATUS defined.", "var_type": ["sqlite3_stmt*"], "ret_type": "void"}, "paraph": "Zero all sqlite3_stmt_scanstatus_APIName related event counters.", "key": "sqlite3_stmt_scanstatus_reset", "sent": "Zero all sqlite3_stmt_scanstatus_APIName related event counters."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "The name of a result column is the value of the \"AS\" clause for that column, if there is an AS clause.If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next.", "key": "sqlite3_column_name16", "sent": "If there is no AS clause then the name of the column is unspecified and may change from one release of SQLite to the next."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "This interface loads an SQLite extension library from the named file.", "key": "sqlite3_load_extension", "sent": "This interface loads an SQLite extension library from the named file."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If a write-transaction is open on database connection sqlite3_db_cacheflush_APIParam_1 when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always \"in use\").The sqlite3_db_cacheflush_APIName interface flushes caches for all schemas - \"main\", \"temp\", and any attached databases.", "key": "sqlite3_db_cacheflush", "sent": "If a write-transaction is open on database connection sqlite3_db_cacheflush_APIParam_1 when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If sqlite3_db_cacheflush_APIName needs to obtain extra database locks before dirty pages can be flushed to disk, it does so.If those locks cannot be obtained immediately and there is a busy-handler callback configured, it is invoked in the usual manner.If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database.If any databases are skipped because locks cannot be obtained, but no other error occurs, sqlite3_db_cacheflush_APIName returns SQLITE_BUSY_API_constant.", "key": "sqlite3_db_cacheflush", "sent": "If the required lock still cannot be obtained, then the database is skipped and an attempt made to flush any dirty pages belonging to the next (if any) database."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " Zero all sqlite3_stmt_scanstatus_APIName related event counters.This API is only available if the library is built with pre-processor symbol SQLITE_ENABLE_STMT_SCANSTATUS defined.", "var_type": ["sqlite3_stmt*"], "ret_type": "void"}, "paraph": "This API is only available if the library is built with pre-processor symbol SQLITE_ENABLE_STMT_SCANSTATUS defined.", "key": "sqlite3_stmt_scanstatus_reset", "sent": "This API is only available if the library is built with pre-processor symbol SQLITE_ENABLE_STMT_SCANSTATUS defined."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "The entry point is sqlite3_load_extension_APIParam_3."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added.So for example, if \"samplelib\" cannot be loaded, then names like \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might be tried also.", "key": "sqlite3_load_extension", "sent": "The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "It first tries \"sqlite3_extension_init\"."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "and omitting any initial \"lib\"."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added.So for example, if \"samplelib\" cannot be loaded, then names like \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might be tried also.", "key": "sqlite3_load_extension", "sent": "If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite error code be returned by sqlite3_db_cacheflush_APIName to the caller immediately.", "key": "sqlite3_db_cacheflush", "sent": "If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite error code be returned by sqlite3_db_cacheflush_APIName to the caller immediately."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " If a write-transaction is open on database connection D when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If a write-transaction is open on database connection sqlite3_db_cacheflush_APIParam_1 when the sqlite3_db_cacheflush_APIName interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk.A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always \"in use\").The sqlite3_db_cacheflush_APIName interface flushes caches for all schemas - \"main\", \"temp\", and any attached databases.", "key": "sqlite3_db_cacheflush", "sent": "A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always \"in use\")."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "The calling function should free this memory by calling sqlite3_free_APIName."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added.So for example, if \"samplelib\" cannot be loaded, then names like \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might be tried also.", "key": "sqlite3_load_extension", "sent": "So for example, if \"samplelib\" cannot be loaded, then names like \"samplelib.so\" or \"samplelib.dylib\" or \"samplelib.dll\" might be tried also."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "Security warning: It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method be used to enable only this interface.The use of the sqlite3_enable_load_extension_APIName interface should be avoided.This will keep the SQL function load_extension_APIName disabled and prevent SQL injections from giving attackers access to extension loading capabilities.", "key": "sqlite3_load_extension", "sent": "The use of the sqlite3_enable_load_extension_APIName interface should be avoided."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "See also the load_extension_APIName SQL function.", "key": "sqlite3_load_extension", "sent": "See also the load_extension_APIName SQL function."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "Summary:", "key": "sqlite3_value_blob", "sent": "Summary:"}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "zProc may be 0, in which case SQLite will try to come up with an entry point name on its own."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "Details:", "key": "sqlite3_value_blob", "sent": "Details:"}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "Security warning: It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method be used to enable only this interface.The use of the sqlite3_enable_load_extension_APIName interface should be avoided.This will keep the SQL function load_extension_APIName disabled and prevent SQL injections from giving attackers access to extension loading capabilities.", "key": "sqlite3_load_extension", "sent": "Security warning: It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method be used to enable only this interface."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "Extension loading must be enabled using sqlite3_enable_load_extension_APIName or sqlite3_db_config_APIName prior to calling this API, otherwise an error will be returned.", "key": "sqlite3_load_extension", "sent": "Extension loading must be enabled using sqlite3_enable_load_extension_APIName or sqlite3_db_config_APIName prior to calling this API, otherwise an error will be returned."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines work only with protected sqlite3_value objects.Any attempt to use these routines on an unprotected sqlite3_value is not threadsafe.", "key": "sqlite3_value_blob", "sent": "These routines work only with protected sqlite3_value objects."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "Security warning: It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method be used to enable only this interface.The use of the sqlite3_enable_load_extension_APIName interface should be avoided.This will keep the SQL function load_extension_APIName disabled and prevent SQL injections from giving attackers access to extension loading capabilities.", "key": "sqlite3_load_extension", "sent": "This will keep the SQL function load_extension_APIName disabled and prevent SQL injections from giving attackers access to extension loading capabilities."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_db_release_memory_APIName interface attempts to free as much heap memory as possible from database connection D. Unlike the sqlite3_release_memory_APIName interface, this interface is in effect even when the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is omitted.See also: sqlite3_release_memory_APIName", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_db_release_memory_APIName interface attempts to free as much heap memory as possible from database connection D. Unlike the sqlite3_release_memory_APIName interface, this interface is in effect even when the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is omitted.", "key": "sqlite3_db_release_memory", "sent": "The sqlite3_db_release_memory_APIName interface attempts to free as much heap memory as possible from database connection D. Unlike the sqlite3_release_memory_APIName interface, this interface is in effect even when the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is omitted."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines extract type, size, and content information from protected sqlite3_value objects.Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.", "key": "sqlite3_value_blob", "sent": "These routines extract type, size, and content information from protected sqlite3_value objects."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines work only with protected sqlite3_value objects.Any attempt to use these routines on an unprotected sqlite3_value is not threadsafe.", "key": "sqlite3_value_text16le", "sent": "Any attempt to use these routines on an unprotected sqlite3_value is not threadsafe."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines extract type, size, and content information from protected sqlite3_value objects.Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.", "key": "sqlite3_value_text16le", "sent": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const unsigned char *"}, "paraph": "The sqlite3_value_type_APIName interface returns the datatype code for the initial datatype of the sqlite3_value object V. sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.Other interfaces might change the datatype for an sqlite3_value object.For example, if the datatype is initially SQLITE_INTEGER_API_constant and sqlite3_value_text_APIName is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant.Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.", "key": "sqlite3_value_text", "sent": "Other interfaces might change the datatype for an sqlite3_value object."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const unsigned char *"}, "paraph": "The sqlite3_value_text16_APIName interface extracts a UTF-16 string in the native byte-order of the host machine.The sqlite3_value_text16be_APIName and sqlite3_value_text16le_APIName interfaces extract UTF-16 strings as big-endian and little-endian respectively.", "key": "sqlite3_value_text", "sent": "The sqlite3_value_text16be_APIName and sqlite3_value_text16le_APIName interfaces extract UTF-16 strings as big-endian and little-endian respectively."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const unsigned char *"}, "paraph": "The sqlite3_value_text16_APIName interface extracts a UTF-16 string in the native byte-order of the host machine.The sqlite3_value_text16be_APIName and sqlite3_value_text16le_APIName interfaces extract UTF-16 strings as big-endian and little-endian respectively.", "key": "sqlite3_value_text", "sent": "The sqlite3_value_text16_APIName interface extracts a UTF-16 string in the native byte-order of the host machine."}, {"API_info": {"var": ["db", "zFile", "zProc", "pzErrMsg"], "API_desc": " This interface loads an SQLite extension library from the named file.The sqlite3_load_extension_APIName interface attempts to load an SQLite extension library contained in the file sqlite3_load_extension_APIParam_2.", "var_type": ["sqlite3 *", "const char *", "const char *", "char **"], "ret_type": "int"}, "paraph": "The entry point is sqlite3_load_extension_APIParam_3.zProc may be 0, in which case SQLite will try to come up with an entry point name on its own.It first tries \"sqlite3_extension_init\".If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\"and omitting any initial \"lib\".The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong.If an error occurs and sqlite3_load_extension_APIParam_4 is not 0, then the sqlite3_load_extension_APIName interface shall attempt to fill *pzErrMsg with error message text stored in memory obtained from sqlite3_malloc_APIName.The calling function should free this memory by calling sqlite3_free_APIName.", "key": "sqlite3_load_extension", "sent": "If that does not work, it constructs a name \"sqlite3_X_init\" where the X is consists of the lower-case equivalent of all ASCII alphabetic characters in the filename from the last \"/\" to the first following \".\""}, {"API_info": {"var": ["sqlite3_value*", " const char*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*", " const char*"], "ret_type": "void *"}, "paraph": "If sqlite3_value object sqlite3_value_pointer_APIParam_1 was initialized using sqlite3_bind_pointer_APIName or sqlite3_result_pointer_APIName and if strcmp_APIParam_1 and sqlite3_value_pointer_APIParam_2 are strings that compare equal according to strcmp_APIName, then sqlite3_value_pointer_APIName will return the pointer P.  Otherwise, sqlite3_value_pointer_APIName returns a NULL.The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_value_pointer", "sent": "The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value.This means that an attempt is made to convert the value to an integer or floating point.If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed.Otherwise no conversion occurs.The datatype after conversion be returned by sqlite3_value_numeric_type_APIName.", "key": "sqlite3_value_numeric_type", "sent": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value.This means that an attempt is made to convert the value to an integer or floating point.If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed.Otherwise no conversion occurs.The datatype after conversion be returned by sqlite3_value_numeric_type_APIName.", "key": "sqlite3_value_numeric_type", "sent": "Otherwise no conversion occurs."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value.This means that an attempt is made to convert the value to an integer or floating point.If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed.Otherwise no conversion occurs.The datatype after conversion be returned by sqlite3_value_numeric_type_APIName.", "key": "sqlite3_value_numeric_type", "sent": "This means that an attempt is made to convert the value to an integer or floating point."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value.This means that an attempt is made to convert the value to an integer or floating point.If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed.Otherwise no conversion occurs.The datatype after conversion be returned by sqlite3_value_numeric_type_APIName.", "key": "sqlite3_value_numeric_type", "sent": "The datatype after conversion be returned by sqlite3_value_numeric_type_APIName."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_numeric_type_APIName interface attempts to apply numeric affinity to the value.This means that an attempt is made to convert the value to an integer or floating point.If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed.Otherwise no conversion occurs.The datatype after conversion be returned by sqlite3_value_numeric_type_APIName.", "key": "sqlite3_value_numeric_type", "sent": "If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed."}, {"API_info": {"var": ["sqlite3_stmt*", "N"], "API_desc": " These routines return the name assigned to a particular column in the result set of a SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "sqlite3_column_name_APIParam_0 pointer is valid until either the prepared statement is destroyed by sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the next call to sqlite3_column_name_APIName or sqlite3_column_name16_APIName on the same column.", "key": "sqlite3_column_name", "sent": "sqlite3_column_name_APIParam_0 pointer is valid until either the prepared statement is destroyed by sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the next call to sqlite3_column_name_APIName or sqlite3_column_name16_APIName on the same column."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const unsigned char *"}, "paraph": "The sqlite3_value_type_APIName interface returns the datatype code for the initial datatype of the sqlite3_value object V. sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.Other interfaces might change the datatype for an sqlite3_value object.For example, if the datatype is initially SQLITE_INTEGER_API_constant and sqlite3_value_text_APIName is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant.Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.", "key": "sqlite3_value_text", "sent": " is undefined and may change from one release of SQLite to the next ."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_type_APIName interface returns the datatype code for the initial datatype of the sqlite3_value object V. sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.Other interfaces might change the datatype for an sqlite3_value object.For example, if the datatype is initially SQLITE_INTEGER_API_constant and sqlite3_value_text_APIName is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant.Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.", "key": "sqlite3_value_type", "sent": "The sqlite3_value_type_APIName interface returns the datatype code for the initial datatype of the sqlite3_value object V. sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_frombind_APIName interface returns non-zero if the value sqlite3_value_frombind_APIParam_1 originated from one of the sqlite3_bind_APIName interfaces.If sqlite3_value_frombind_APIParam_1 comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind_APIName returns zero.", "key": "sqlite3_value_frombind", "sent": "The sqlite3_value_frombind_APIName interface returns non-zero if the value sqlite3_value_frombind_APIParam_1 originated from one of the sqlite3_bind_APIName interfaces."}, {"API_info": {"var": ["sqlite3_value*", " const char*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*", " const char*"], "ret_type": "void *"}, "paraph": "If sqlite3_value object sqlite3_value_pointer_APIParam_1 was initialized using sqlite3_bind_pointer_APIName or sqlite3_result_pointer_APIName and if strcmp_APIParam_1 and sqlite3_value_pointer_APIParam_2 are strings that compare equal according to strcmp_APIName, then sqlite3_value_pointer_APIName will return the pointer P.  Otherwise, sqlite3_value_pointer_APIName returns a NULL.The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_value_pointer", "sent": "If sqlite3_value object sqlite3_value_pointer_APIParam_1 was initialized using sqlite3_bind_pointer_APIName or sqlite3_result_pointer_APIName and if strcmp_APIParam_1 and sqlite3_value_pointer_APIParam_2 are strings that compare equal according to strcmp_APIName, then sqlite3_value_pointer_APIName will return the pointer P.  Otherwise, sqlite3_value_pointer_APIName returns a NULL."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines must be called from the same thread as the SQL function that supplied the sqlite3_value* parameters.", "key": "sqlite3_value_blob", "sent": "These routines must be called from the same thread as the SQL function that supplied the sqlite3_value* parameters."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion.Only the following subset of interfaces are subject to out-of-memory errors:", "key": "sqlite3_value_text16le", "sent": "Only the following subset of interfaces are subject to out-of-memory errors:"}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "These routines work just like the corresponding column access functions except that these routines take a single protected sqlite3_value object pointer instead of a sqlite3_stmt* pointer and an integer column number.", "key": "sqlite3_value_blob", "sent": "These routines work just like the corresponding column access functions except that these routines take a single protected sqlite3_value object pointer instead of a sqlite3_stmt* pointer and an integer column number."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "Within the xUpdate method of a virtual table, the sqlite3_value_nochange_APIName interface returns true if and only if the column corresponding to sqlite3_value_nochange_APIParam_1 is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior xColumn method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried sqlite3_vtab_nochange_APIName and found that the column was unchanging).Within an xUpdate method, any value for which sqlite3_value_nochange_APIName is true will in all other respects appear to be a NULL value.If sqlite3_value_nochange_APIName is invoked anywhere other than within an xUpdate method call for an UPDATE statement, then the return value is arbitrary and meaningless.", "key": "sqlite3_value_nochange", "sent": "Within an xUpdate method , any value  appear to be a NULL value ."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_value_frombind_APIName interface returns non-zero if the value sqlite3_value_frombind_APIParam_1 originated from one of the sqlite3_bind_APIName interfaces.If sqlite3_value_frombind_APIParam_1 comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind_APIName returns zero.", "key": "sqlite3_value_frombind", "sent": "If sqlite3_value_frombind_APIParam_1 comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind_APIName returns zero."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "Within the xUpdate method of a virtual table, the sqlite3_value_nochange_APIName interface returns true if and only if the column corresponding to sqlite3_value_nochange_APIParam_1 is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior xColumn method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried sqlite3_vtab_nochange_APIName and found that the column was unchanging).Within an xUpdate method, any value for which sqlite3_value_nochange_APIName is true will in all other respects appear to be a NULL value.If sqlite3_value_nochange_APIName is invoked anywhere other than within an xUpdate method call for an UPDATE statement, then the return value is arbitrary and meaningless.", "key": "sqlite3_value_nochange", "sent": "If sqlite3_value_nochange_APIName is invoked anywhere other than within an xUpdate method call for an UPDATE statement, then the return value is arbitrary and meaningless."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const unsigned char *"}, "paraph": "The sqlite3_value_type_APIName interface returns the datatype code for the initial datatype of the sqlite3_value object V. sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant.Other interfaces might change the datatype for an sqlite3_value object.For example, if the datatype is initially SQLITE_INTEGER_API_constant and sqlite3_value_text_APIName is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant.Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.", "key": "sqlite3_value_text", "sent": "For example, if the datatype is initially SQLITE_INTEGER_API_constant and sqlite3_value_text_APIName is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The SQLite core uses these routines for thread synchronization.Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.", "key": "sqlite3_mutex_alloc", "sent": "The SQLite core uses these routines for thread synchronization."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.The calling application should pass sqlite3_str_finish_APIParam_0 value to sqlite3_free_APIName to avoid a memory leak.The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string.The sqlite3_str_finish_APIName interface will also return a NULL pointer if the string in sqlite3_str object sqlite3_str_finish_APIParam_1 is zero bytes long.", "key": "sqlite3_str_finish", "sent": "The calling application should pass sqlite3_str_finish_APIParam_0 value to sqlite3_free_APIName to avoid a memory leak."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The SQLite source code contains multiple implementations of these mutex routines.An appropriate implementation is selected automatically at compile-time.The following implementations are available in the SQLite core:", "key": "sqlite3_mutex_free", "sent": "An appropriate implementation is selected automatically at compile-time."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion.Only the following subset of interfaces are subject to out-of-memory errors:", "key": "sqlite3_value_blob", "sent": "As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The SQLite source code contains multiple implementations of these mutex routines.An appropriate implementation is selected automatically at compile-time.The following implementations are available in the SQLite core:", "key": "sqlite3_mutex_alloc", "sent": "The SQLite source code contains multiple implementations of these mutex routines."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.The calling application should pass sqlite3_str_finish_APIParam_0 value to sqlite3_free_APIName to avoid a memory leak.The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string.The sqlite3_str_finish_APIName interface will also return a NULL pointer if the string in sqlite3_str object sqlite3_str_finish_APIParam_1 is zero bytes long.", "key": "sqlite3_str_finish", "sent": "The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value.Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection.", "key": "sqlite3_value_blob", "sent": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "The SQLite source code contains multiple implementations of these mutex routines.An appropriate implementation is selected automatically at compile-time.The following implementations are available in the SQLite core:", "key": "sqlite3_mutex_try", "sent": "The following implementations are available in the SQLite core:"}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.The calling application should pass sqlite3_str_finish_APIParam_0 value to sqlite3_free_APIName to avoid a memory leak.The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string.The sqlite3_str_finish_APIName interface will also return a NULL pointer if the string in sqlite3_str object sqlite3_str_finish_APIParam_1 is zero bytes long.", "key": "sqlite3_str_finish", "sent": "The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_finish_APIName interface destroys the sqlite3_str object X and returns a pointer to a memory buffer obtained from sqlite3_malloc64_APIName that contains the constructed string.The calling application should pass sqlite3_str_finish_APIParam_0 value to sqlite3_free_APIName to avoid a memory leak.The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string.The sqlite3_str_finish_APIName interface will also return a NULL pointer if the string in sqlite3_str object sqlite3_str_finish_APIParam_1 is zero bytes long.", "key": "sqlite3_str_finish", "sent": "The sqlite3_str_finish_APIName interface will also return a NULL pointer if the string in sqlite3_str object sqlite3_str_finish_APIParam_1 is zero bytes long."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application.The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.", "key": "sqlite3_mutex_enter", "sent": "The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The SQLite core uses these routines for thread synchronization.Though they are intended for internal use by SQLite, code that links against SQLite is permitted to use any of these routines.", "key": "sqlite3_mutex_enter", "sent": " , code that links against SQLite is permitted to use any of these routines ."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The sqlite3_mutex_alloc_APIName routine allocates a new mutex and returns a pointer to it.The sqlite3_mutex_alloc_APIName routine returns NULL if it is unable to allocate the requested mutex.The argument to sqlite3_mutex_alloc_APIName must one of these integer constants:", "key": "sqlite3_mutex_alloc", "sent": "The argument to sqlite3_mutex_alloc_APIName must one of these integer constants:"}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The sqlite3_mutex_alloc_APIName routine allocates a new mutex and returns a pointer to it.The sqlite3_mutex_alloc_APIName routine returns NULL if it is unable to allocate the requested mutex.The argument to sqlite3_mutex_alloc_APIName must one of these integer constants:", "key": "sqlite3_mutex_alloc", "sent": "The sqlite3_mutex_alloc_APIName routine allocates a new mutex and returns a pointer to it."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex.The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used.The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to.SQLite will only request a recursive mutex in cases where it really needs one.If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The sqlite3_mutex_alloc_APIName routine allocates a new mutex and returns a pointer to it.The sqlite3_mutex_alloc_APIName routine returns NULL if it is unable to allocate the requested mutex.The argument to sqlite3_mutex_alloc_APIName must one of these integer constants:", "key": "sqlite3_mutex_alloc", "sent": "The sqlite3_mutex_alloc_APIName routine returns NULL if it is unable to allocate the requested mutex."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "Please pay particular attention to the fact that the pointer returned from sqlite3_value_blob_APIName, sqlite3_value_text_APIName, or sqlite3_value_text16_APIName can be invalidated by a subsequent call to sqlite3_value_bytes_APIName, sqlite3_value_bytes16_APIName, sqlite3_value_text_APIName, or sqlite3_value_text16_APIName.", "key": "sqlite3_value_blob", "sent": "Please pay particular attention to the fact that the pointer returned from sqlite3_value_blob_APIName, sqlite3_value_text_APIName, or sqlite3_value_text16_APIName can be invalidated by a subsequent call to sqlite3_value_bytes_APIName, sqlite3_value_bytes16_APIName, sqlite3_value_text_APIName, or sqlite3_value_text16_APIName."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application.The SQLITE_MUTEX_PTHREADS and SQLITE_MUTEX_W32 implementations are appropriate for use on Unix and Windows.", "key": "sqlite3_mutex_alloc", "sent": "The SQLITE_MUTEX_NOOP implementation is a set of routines that does no real locking and is appropriate for use in a single-threaded application."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with \"-DSQLITE_MUTEX_APPDEF=1\"), then no mutex implementation is included with the library.In this case the application must supply a custom mutex implementation using the SQLITE_CONFIG_MUTEX_API_constant option of the sqlite3_config_APIName function before calling sqlite3_initialize_APIName or any other public sqlite3_ function that calls sqlite3_initialize_APIName.", "key": "sqlite3_mutex_alloc", "sent": "If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with \"-DSQLITE_MUTEX_APPDEF=1\"), then no mutex implementation is included with the library."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex.The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used.The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to.SQLite will only request a recursive mutex in cases where it really needs one.If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex.The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used.The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to.SQLite will only request a recursive mutex in cases where it really needs one.If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "SQLite will only request a recursive mutex in cases where it really needs one."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "const void *"}, "paraph": "If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value.Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection.", "key": "sqlite3_value_text16le", "sent": "Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex.The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used.The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to.SQLite will only request a recursive mutex in cases where it really needs one.If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex.Nine static mutexes are used by the current version of SQLite.Future versions of SQLite may add additional static mutexes.Static mutexes are for internal use by SQLite only.Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex.Nine static mutexes are used by the current version of SQLite.Future versions of SQLite may add additional static mutexes.Static mutexes are for internal use by SQLite only.Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "Future versions of SQLite may add additional static mutexes."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex.Nine static mutexes are used by the current version of SQLite.Future versions of SQLite may add additional static mutexes.Static mutexes are for internal use by SQLite only.Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "Nine static mutexes are used by the current version of SQLite."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex.Nine static mutexes are used by the current version of SQLite.Future versions of SQLite may add additional static mutexes.Static mutexes are for internal use by SQLite only.Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "Static mutexes are for internal use by SQLite only."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with \"-DSQLITE_MUTEX_APPDEF=1\"), then no mutex implementation is included with the library.In this case the application must supply a custom mutex implementation using the SQLITE_CONFIG_MUTEX_API_constant option of the sqlite3_config_APIName function before calling sqlite3_initialize_APIName or any other public sqlite3_ function that calls sqlite3_initialize_APIName.", "key": "sqlite3_mutex_enter", "sent": "In this case the application must supply a custom mutex implementation using the SQLITE_CONFIG_MUTEX_API_constant option of the sqlite3_config_APIName function before calling sqlite3_initialize_APIName or any other public sqlite3_ function that calls sqlite3_initialize_APIName."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The first two constants (SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) cause sqlite3_mutex_alloc_APIName to create a new mutex.The new mutex is recursive when SQLITE_MUTEX_RECURSIVE_API_constant is used but not necessarily so when SQLITE_MUTEX_FAST_API_constant is used.The mutex implementation does not need to make a distinction between SQLITE_MUTEX_RECURSIVE_API_constant and SQLITE_MUTEX_FAST_API_constant if it does not want to.SQLite will only request a recursive mutex in cases where it really needs one.If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "If a faster non-recursive mutex implementation is available on the host platform, the mutex subsystem might return such a mutex in response to SQLITE_MUTEX_FAST_API_constant."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "The other allowed parameters to sqlite3_mutex_alloc_APIName (anything other than SQLITE_MUTEX_FAST_API_constant and SQLITE_MUTEX_RECURSIVE_API_constant) each return a pointer to a static preexisting mutex.Nine static mutexes are used by the current version of SQLite.Future versions of SQLite may add additional static mutexes.Static mutexes are for internal use by SQLite only.Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant.", "key": "sqlite3_mutex_alloc", "sent": "Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_free_APIName routine deallocates a previously allocated dynamic mutex.Attempting to deallocate a static mutex results in undefined behavior.", "key": "sqlite3_mutex_free", "sent": "The sqlite3_mutex_free_APIName routine deallocates a previously allocated dynamic mutex."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_enter", "sent": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_free_APIName routine deallocates a previously allocated dynamic mutex.Attempting to deallocate a static mutex results in undefined behavior.", "key": "sqlite3_mutex_free", "sent": "Attempting to deallocate a static mutex results in undefined behavior."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_try", "sent": "The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant) is used then sqlite3_mutex_alloc_APIName returns a different mutex on every call.For the static mutex types, the same mutex be returned by sqlite3_mutex_alloc_APIName on every call that has the same type number.", "key": "sqlite3_mutex_alloc", "sent": "For the static mutex types, the same mutex be returned by sqlite3_mutex_alloc_APIName on every call that has the same type number."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_enter", "sent": "If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant) is used then sqlite3_mutex_alloc_APIName returns a different mutex on every call.For the static mutex types, the same mutex be returned by sqlite3_mutex_alloc_APIName on every call that has the same type number.", "key": "sqlite3_mutex_alloc", "sent": "Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant) is used then sqlite3_mutex_alloc_APIName returns a different mutex on every call."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": "Protected sqlite3_value objects are used to pass parameter information into implementation of application-defined SQL functions and virtual tables.These routines work only with protected sqlite3_value objects.", "var_type": ["sqlite3_value*"], "ret_type": "int"}, "paraph": "Within the xUpdate method of a virtual table, the sqlite3_value_nochange_APIName interface returns true if and only if the column corresponding to sqlite3_value_nochange_APIParam_1 is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior xColumn method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried sqlite3_vtab_nochange_APIName and found that the column was unchanging).Within an xUpdate method, any value for which sqlite3_value_nochange_APIName is true will in all other respects appear to be a NULL value.If sqlite3_value_nochange_APIName is invoked anywhere other than within an xUpdate method call for an UPDATE statement, then the return value is arbitrary and meaningless.", "key": "sqlite3_value_nochange", "sent": "Within the xUpdate method of a virtual table, the sqlite3_value_nochange_APIName interface returns true if and only if the column corresponding to sqlite3_value_nochange_APIParam_1 is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior xColumn method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried sqlite3_vtab_nochange_APIName and found that the column was unchanging)."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_enter", "sent": "Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try_APIName.On those systems, sqlite3_mutex_try_APIName will always return SQLITE_BUSY_API_constant.The SQLite core only ever uses sqlite3_mutex_try_APIName as an optimization so this is acceptable behavior.", "key": "sqlite3_mutex_try", "sent": "Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try_APIName."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try_APIName.On those systems, sqlite3_mutex_try_APIName will always return SQLITE_BUSY_API_constant.The SQLite core only ever uses sqlite3_mutex_try_APIName as an optimization so this is acceptable behavior.", "key": "sqlite3_mutex_try", "sent": "On those systems, sqlite3_mutex_try_APIName will always return SQLITE_BUSY_API_constant."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_enter", "sent": "In such cases, the mutex must be exited an equal number of times before another thread can enter."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try_APIName.On those systems, sqlite3_mutex_try_APIName will always return SQLITE_BUSY_API_constant.The SQLite core only ever uses sqlite3_mutex_try_APIName as an optimization so this is acceptable behavior.", "key": "sqlite3_mutex_try", "sent": "The SQLite core only ever uses sqlite3_mutex_try_APIName as an optimization so this is acceptable behavior."}, {"API_info": {"var": ["int"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["int"], "ret_type": "sqlite3_mutex *"}, "paraph": "See also: sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName.", "key": "sqlite3_mutex_alloc", "sent": "See also: sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_leave_APIName routine exits a mutex that was previously entered by the same thread.The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.", "key": "sqlite3_mutex_leave", "sent": "The sqlite3_mutex_leave_APIName routine exits a mutex that was previously entered by the same thread."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_enter_APIName and sqlite3_mutex_try_APIName routines attempt to enter a mutex.If another thread is already within the mutex, sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant.The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry.Mutexes created using SQLITE_MUTEX_RECURSIVE_API_constant can be entered multiple times by the same thread.In such cases, the mutex must be exited an equal number of times before another thread can enter.If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined.", "key": "sqlite3_mutex_enter", "sent": "If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE_API_constant more than once, the behavior is undefined."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The sqlite3_exec_APIName interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the database connection passed in as its 1st argument.If the callback function of the 3rd argument to sqlite3_exec_APIName is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements.The 4th argument to sqlite3_exec_APIName is relayed through to the 1st argument of each callback invocation.If the callback pointer to sqlite3_exec_APIName is NULL, then no callback is ever invoked and result rows are ignored.", "key": "sqlite3_exec", "sent": "The 4_APIConstant argument to sqlite3_exec_APIName is relayed through to the 1_APIConstant argument of each callback invocation."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "The sqlite3_mutex_leave_APIName routine exits a mutex that was previously entered by the same thread.The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.", "key": "sqlite3_mutex_leave", "sent": "The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The sqlite3_exec_APIName interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the database connection passed in as its 1st argument.If the callback function of the 3rd argument to sqlite3_exec_APIName is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements.The 4th argument to sqlite3_exec_APIName is relayed through to the 1st argument of each callback invocation.If the callback pointer to sqlite3_exec_APIName is NULL, then no callback is ever invoked and result rows are ignored.", "key": "sqlite3_exec", "sent": "If the callback pointer to sqlite3_exec_APIName is NULL, then no callback is ever invoked and result rows are ignored."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The SQLite core uses these routines for thread synchronization.", "var_type": ["sqlite3_mutex*"], "ret_type": "void"}, "paraph": "If the argument to sqlite3_mutex_enter_APIName, sqlite3_mutex_try_APIName, or sqlite3_mutex_leave_APIName is a NULL pointer, then all three routines behave as no-ops.", "key": "sqlite3_mutex_enter", "sent": "If the argument to sqlite3_mutex_enter_APIName, sqlite3_mutex_try_APIName, or sqlite3_mutex_leave_APIName is a NULL pointer, then all three routines behave as no-ops."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "Restrictions:", "key": "sqlite3_exec", "sent": "Restrictions:"}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The 2nd argument to the sqlite3_exec_APIName callback function is the number of columns in the result.The 3rd argument to the sqlite3_exec_APIName callback is an array of pointers to strings obtained as if from sqlite3_column_text_APIName, one for each column.If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec_APIName callback is a NULL pointer.The 4th argument to the sqlite3_exec_APIName callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name_APIName.", "key": "sqlite3_exec", "sent": "The 2_APIConstant argument to the sqlite3_exec_APIName callback function is the number of columns in the result."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If an error occurs while evaluating the SQL statements passed into sqlite3_exec_APIName, then execution of the current statement stops and subsequent statements are skipped.If the 5th parameter to sqlite3_exec_APIName is not NULL then any error message is written into memory obtained from sqlite3_malloc_APIName and passed back through the 5th parameter.To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5th parameter of sqlite3_exec_APIName after the error message string is no longer needed.If the 5th parameter to sqlite3_exec_APIName is not NULL and no errors occur, then sqlite3_exec_APIName sets the pointer in its 5th parameter to NULL before returning.", "key": "sqlite3_exec", "sent": "If an error occurs while evaluating the SQL statements passed into sqlite3_exec_APIName, then execution of the current statement stops and subsequent statements are skipped."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2.Only the row can be changed.The database, table and column on which the blob handle is open remain the same.Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.", "key": "sqlite3_blob_reopen", "sent": "Only the row can be changed."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If an error occurs while evaluating the SQL statements passed into sqlite3_exec_APIName, then execution of the current statement stops and subsequent statements are skipped.If the 5th parameter to sqlite3_exec_APIName is not NULL then any error message is written into memory obtained from sqlite3_malloc_APIName and passed back through the 5th parameter.To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5th parameter of sqlite3_exec_APIName after the error message string is no longer needed.If the 5th parameter to sqlite3_exec_APIName is not NULL and no errors occur, then sqlite3_exec_APIName sets the pointer in its 5th parameter to NULL before returning.", "key": "sqlite3_exec", "sent": "If the 5_APIConstant parameter to sqlite3_exec_APIName is not NULL then any error message is written into memory obtained from sqlite3_malloc_APIName and passed back through the 5_APIConstant parameter."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2.Only the row can be changed.The database, table and column on which the blob handle is open remain the same.Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.", "key": "sqlite3_blob_reopen", "sent": "The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The 2nd argument to the sqlite3_exec_APIName callback function is the number of columns in the result.The 3rd argument to the sqlite3_exec_APIName callback is an array of pointers to strings obtained as if from sqlite3_column_text_APIName, one for each column.If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec_APIName callback is a NULL pointer.The 4th argument to the sqlite3_exec_APIName callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name_APIName.", "key": "sqlite3_exec", "sent": "The 3_APIConstant argument to the sqlite3_exec_APIName callback is an array of pointers to strings obtained as if from sqlite3_column_text_APIName, one for each column."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The sqlite3_exec_APIName interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the database connection passed in as its 1st argument.If the callback function of the 3rd argument to sqlite3_exec_APIName is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements.The 4th argument to sqlite3_exec_APIName is relayed through to the 1st argument of each callback invocation.If the callback pointer to sqlite3_exec_APIName is NULL, then no callback is ever invoked and result rows are ignored.", "key": "sqlite3_exec", "sent": "The sqlite3_exec_APIName interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2_APIConstant argument, in the context of the database connection passed in as its 1_APIConstant argument."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If an sqlite3_exec_APIName callback returns non-zero, the sqlite3_exec_APIName routine returns SQLITE_ABORT_API_constant without invoking the callback again and without running any subsequent SQL statements.", "key": "sqlite3_exec", "sent": "If an sqlite3_exec_APIName callback returns non-zero, the sqlite3_exec_APIName routine returns SQLITE_ABORT_API_constant without invoking the callback again and without running any subsequent SQL statements."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The 2nd argument to the sqlite3_exec_APIName callback function is the number of columns in the result.The 3rd argument to the sqlite3_exec_APIName callback is an array of pointers to strings obtained as if from sqlite3_column_text_APIName, one for each column.If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec_APIName callback is a NULL pointer.The 4th argument to the sqlite3_exec_APIName callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name_APIName.", "key": "sqlite3_exec", "sent": "If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec_APIName callback is a NULL pointer."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2.Only the row can be changed.The database, table and column on which the blob handle is open remain the same.Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.", "key": "sqlite3_blob_reopen", "sent": "The database, table and column on which the blob handle is open remain the same."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If an error occurs while evaluating the SQL statements passed into sqlite3_exec_APIName, then execution of the current statement stops and subsequent statements are skipped.If the 5th parameter to sqlite3_exec_APIName is not NULL then any error message is written into memory obtained from sqlite3_malloc_APIName and passed back through the 5th parameter.To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5th parameter of sqlite3_exec_APIName after the error message string is no longer needed.If the 5th parameter to sqlite3_exec_APIName is not NULL and no errors occur, then sqlite3_exec_APIName sets the pointer in its 5th parameter to NULL before returning.", "key": "sqlite3_exec", "sent": "If the 5_APIConstant parameter to sqlite3_exec_APIName is not NULL and no errors occur, then sqlite3_exec_APIName sets the pointer in its 5_APIConstant parameter to NULL before returning."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The sqlite3_exec_APIName interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the database connection passed in as its 1st argument.If the callback function of the 3rd argument to sqlite3_exec_APIName is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements.The 4th argument to sqlite3_exec_APIName is relayed through to the 1st argument of each callback invocation.If the callback pointer to sqlite3_exec_APIName is NULL, then no callback is ever invoked and result rows are ignored.", "key": "sqlite3_exec", "sent": "If the callback function of the 3_APIConstant argument to sqlite3_exec_APIName is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If an error occurs while evaluating the SQL statements passed into sqlite3_exec_APIName, then execution of the current statement stops and subsequent statements are skipped.If the 5th parameter to sqlite3_exec_APIName is not NULL then any error message is written into memory obtained from sqlite3_malloc_APIName and passed back through the 5th parameter.To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5th parameter of sqlite3_exec_APIName after the error message string is no longer needed.If the 5th parameter to sqlite3_exec_APIName is not NULL and no errors occur, then sqlite3_exec_APIName sets the pointer in its 5th parameter to NULL before returning.", "key": "sqlite3_exec", "sent": "To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5_APIConstant parameter of sqlite3_exec_APIName after the error message string is no longer needed."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column.If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code be returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted.All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant.Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero.", "key": "sqlite3_blob_reopen", "sent": "Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName sets the database handle error code and message.", "key": "sqlite3_blob_reopen", "sent": "sqlite3_blob_reopen_APIName sets the database handle error code and message."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2.Only the row can be changed.The database, table and column on which the blob handle is open remain the same.Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.", "key": "sqlite3_blob_reopen", "sent": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column.If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code be returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted.All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant.Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero.", "key": "sqlite3_blob_reopen", "sent": "All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The sqlite3_exec_APIName interface is a convenience wrapper around sqlite3_prepare_v2_APIName, sqlite3_step_APIName, and sqlite3_finalize_APIName, that allows an application to run multiple statements of SQL without having to use a lot of C code.", "key": "sqlite3_exec", "sent": "The sqlite3_exec_APIName interface is a convenience wrapper around sqlite3_prepare_v2_APIName, sqlite3_step_APIName, and sqlite3_finalize_APIName, that allows an application to run multiple statements of SQL without having to use a lot of C code."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "The 2nd argument to the sqlite3_exec_APIName callback function is the number of columns in the result.The 3rd argument to the sqlite3_exec_APIName callback is an array of pointers to strings obtained as if from sqlite3_column_text_APIName, one for each column.If an element of a result row is NULL then the corresponding string pointer for the sqlite3_exec_APIName callback is a NULL pointer.The 4th argument to the sqlite3_exec_APIName callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name_APIName.", "key": "sqlite3_exec", "sent": "The 4_APIConstant argument to the sqlite3_exec_APIName callback is an array of pointers to strings where each entry represents the name of corresponding result column as obtained from sqlite3_column_name_APIName."}, {"API_info": {"var": ["sqlite3_vfs*"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*"], "ret_type": "int"}, "paraph": "A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.Most SQLite builds come with a single default VFS that is appropriate for the host computer.New VFSes can be registered and existing VFSes can be unregistered.The following interfaces are provided.", "key": "sqlite3_vfs_unregister", "sent": "The following interfaces are provided."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.Most SQLite builds come with a single default VFS that is appropriate for the host computer.New VFSes can be registered and existing VFSes can be unregistered.The following interfaces are provided.", "key": "sqlite3_vfs_find", "sent": "A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.The new row is identified by the rowid value passed as sqlite3_blob_reopen_APIParam_2.Only the row can be changed.The database, table and column on which the blob handle is open remain the same.Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one.", "key": "sqlite3_blob_reopen", "sent": "Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.Most SQLite builds come with a single default VFS that is appropriate for the host computer.New VFSes can be registered and existing VFSes can be unregistered.The following interfaces are provided.", "key": "sqlite3_vfs_register", "sent": "New VFSes can be registered and existing VFSes can be unregistered."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name.Names are case sensitive.Names are zero-terminated UTF-8 strings.If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName.If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName.", "key": "sqlite3_vfs_find", "sent": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name.Names are case sensitive.Names are zero-terminated UTF-8 strings.If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName.If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName.", "key": "sqlite3_vfs_find", "sent": "Names are case sensitive."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.Most SQLite builds come with a single default VFS that is appropriate for the host computer.New VFSes can be registered and existing VFSes can be unregistered.The following interfaces are provided.", "key": "sqlite3_vfs_find", "sent": "Most SQLite builds come with a single default VFS that is appropriate for the host computer."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name.Names are case sensitive.Names are zero-terminated UTF-8 strings.If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName.If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName.", "key": "sqlite3_vfs_find", "sent": "Names are zero-terminated UTF-8 strings."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "New VFSes are registered with sqlite3_vfs_register_APIName."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name.Names are case sensitive.Names are zero-terminated UTF-8 strings.If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName.If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName.", "key": "sqlite3_vfs_find", "sent": "If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName."}, {"API_info": {"var": ["zVfsName"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["const char *"], "ret_type": "sqlite3_vfs *"}, "paraph": "The sqlite3_vfs_find_APIName interface returns a pointer to a VFS given its name.Names are case sensitive.Names are zero-terminated UTF-8 strings.If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName.If sqlite3_vfs_find_APIParam_1 is NULL then the default VFS be returned by sqlite3_vfs_find_APIName.", "key": "sqlite3_vfs_find", "sent": "If there is no match, a NULL pointer be returned by sqlite3_vfs_find_APIName."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "The same VFS can be registered multiple times without injury."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set."}, {"API_info": {"var": ["sqlite3_vfs*"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*"], "ret_type": "int"}, "paraph": "Unregister a VFS with the sqlite3_vfs_unregister_APIName interface.If the default VFS is unregistered, another VFS is chosen as the default.The choice for the new VFS is arbitrary.", "key": "sqlite3_vfs_unregister", "sent": "Unregister a VFS with the sqlite3_vfs_unregister_APIName interface."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column.If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code be returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted.All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant.Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero.", "key": "sqlite3_blob_reopen", "sent": "The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "If two different VFSes with the same name are registered, the behavior is undefined."}, {"API_info": {"var": ["sqlite3_vfs*"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*"], "ret_type": "int"}, "paraph": "Unregister a VFS with the sqlite3_vfs_unregister_APIName interface.If the default VFS is unregistered, another VFS is chosen as the default.The choice for the new VFS is arbitrary.", "key": "sqlite3_vfs_unregister", "sent": "The choice for the new VFS is arbitrary."}, {"API_info": {"var": ["sqlite3_vfs*"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*"], "ret_type": "int"}, "paraph": "Unregister a VFS with the sqlite3_vfs_unregister_APIName interface.If the default VFS is unregistered, another VFS is chosen as the default.The choice for the new VFS is arbitrary.", "key": "sqlite3_vfs_unregister", "sent": "If the default VFS is unregistered, another VFS is chosen as the default."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve runtime status information about a single database connection.The first argument is the database connection object to be interrogated.The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate.The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite.", "key": "sqlite3_db_status", "sent": "This interface is used to retrieve runtime status information about a single database connection."}, {"API_info": {"var": ["sqlite3_vfs*", "makeDflt"], "API_desc": " A virtual filesystem (VFS) is an sqlite3_vfs object that SQLite uses to interact with the underlying operating system.", "var_type": ["sqlite3_vfs*", "int"], "ret_type": "int"}, "paraph": "New VFSes are registered with sqlite3_vfs_register_APIName.Each new VFS becomes the default VFS if the sqlite3_vfs_register_APIParam_2 flag is set.The same VFS can be registered multiple times without injury.To make an existing VFS into the default VFS, register it again with the sqlite3_vfs_register_APIParam_2 flag set.If two different VFSes with the same name are registered, the behavior is undefined.If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.", "key": "sqlite3_vfs_register", "sent": "If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve runtime status information about a single database connection.The first argument is the database connection object to be interrogated.The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate.The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite.", "key": "sqlite3_db_status", "sent": "The first argument is the database connection object to be interrogated."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "See also: sqlite3_status_APIName and sqlite3_stmt_status_APIName.", "key": "sqlite3_db_status", "sent": "See also: sqlite3_status_APIName and sqlite3_stmt_status_APIName."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve runtime status information about a single database connection.The first argument is the database connection object to be interrogated.The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate.The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite.", "key": "sqlite3_db_status", "sent": "The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_db_status_APIName routine returns SQLITE_OK_API_constant on success and a non-zero error code on failure.", "key": "sqlite3_db_status", "sent": "The sqlite3_db_status_APIName routine returns SQLITE_OK_API_constant on success and a non-zero error code on failure."}, {"API_info": {"var": ["sqlite3_str*", "zFormat", " ..."], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", " ..."], "ret_type": "void"}, "paraph": "These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.", "key": "sqlite3_str_appendf", "sent": "These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr.If the sqlite3_db_status_APIParam_5 is true, then the highest instantaneous value is reset back down to the current value.", "key": "sqlite3_db_status", "sent": "The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "The current value of the requested parameter is written into *pCur and the highest instantaneous value is written into *pHiwtr.If the sqlite3_db_status_APIParam_5 is true, then the highest instantaneous value is reset back down to the current value.", "key": "sqlite3_db_status", "sent": "If the sqlite3_db_status_APIParam_5 is true, then the highest instantaneous value is reset back down to the current value."}, {"API_info": {"var": ["sqlite3*", "op", "pCur", "pHiwtr", "resetFlg"], "API_desc": " This interface is used to retrieve runtime status information about a single database connection.", "var_type": ["sqlite3*", "int", "int *", "int *", "int"], "ret_type": "int"}, "paraph": "This interface is used to retrieve runtime status information about a single database connection.The first argument is the database connection object to be interrogated.The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate.The set of SQLITE_DBSTATUS options is likely to grow in future releases of SQLite.", "key": "sqlite3_db_status", "sent": "The second argument is an integer constant, taken from the set of SQLITE_DBSTATUS options, that determines the parameter to interrogate."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_append_APIName method appends exactly sqlite3_str_append_APIParam_3 bytes from string S onto the end of the sqlite3_str object X.  sqlite3_str_append_APIParam_3 must be non-negative.S must contain at least sqlite3_str_append_APIParam_3 non-zero bytes of content.To append a zero-terminated string in its entirety, use the sqlite3_str_appendall_APIName method instead.", "key": "sqlite3_str_append", "sent": "S must contain at least sqlite3_str_append_APIParam_3 non-zero bytes of content."}, {"API_info": {"var": ["sqlite3_str*", "zFormat", " ..."], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.", "key": "sqlite3_str_appendf", "sent": "The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_appendchar_APIName method appends sqlite3_str_append_APIParam_3 copies of the single-byte character sqlite3_str_appendchar_APIParam_3 onto the end of sqlite3_str object X.This method can be used, for example, to add whitespace indentation.", "key": "sqlite3_str_append", "sent": "This method can be used, for example, to add whitespace indentation."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_append_APIName method appends exactly sqlite3_str_append_APIParam_3 bytes from string S onto the end of the sqlite3_str object X.  sqlite3_str_append_APIParam_3 must be non-negative.S must contain at least sqlite3_str_append_APIParam_3 non-zero bytes of content.To append a zero-terminated string in its entirety, use the sqlite3_str_appendall_APIName method instead.", "key": "sqlite3_str_append", "sent": "To append a zero-terminated string in its entirety, use the sqlite3_str_appendall_APIName method instead."}, {"API_info": {"var": ["sqlite3_str*", "zFormat", " ..."], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", " ..."], "ret_type": "void"}, "paraph": "These methods do not return a result code.If an error occurs, that fact is recorded in the sqlite3_str object and can be recovered by a subsequent call to sqlite3_str_errcode_APIName.", "key": "sqlite3_str_appendf", "sent": "These methods do not return a result code."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_appendchar_APIName method appends sqlite3_str_append_APIParam_3 copies of the single-byte character sqlite3_str_appendchar_APIParam_3 onto the end of sqlite3_str object X.This method can be used, for example, to add whitespace indentation.", "key": "sqlite3_str_append", "sent": "The sqlite3_str_appendchar_APIName method appends sqlite3_str_append_APIParam_3 copies of the single-byte character sqlite3_str_appendchar_APIParam_3 onto the end of sqlite3_str object X."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_append_APIName method appends exactly sqlite3_str_append_APIParam_3 bytes from string S onto the end of the sqlite3_str object X.  sqlite3_str_append_APIParam_3 must be non-negative.S must contain at least sqlite3_str_append_APIParam_3 non-zero bytes of content.To append a zero-terminated string in its entirety, use the sqlite3_str_appendall_APIName method instead.", "key": "sqlite3_str_append", "sent": "The sqlite3_str_append_APIName method appends exactly sqlite3_str_append_APIParam_3 bytes from string S onto the end of the sqlite3_str object X.  sqlite3_str_append_APIParam_3 must be non-negative."}, {"API_info": {"var": ["sqlite3_str*", "zIn", "N"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *", "int"], "ret_type": "void"}, "paraph": "The sqlite3_str_appendall_APIName method appends the complete content of zero-terminated string sqlite3_str_appendall_APIParam_2 onto the end of sqlite3_str object X.", "key": "sqlite3_str_append", "sent": "The sqlite3_str_appendall_APIName method appends the complete content of zero-terminated string sqlite3_str_appendall_APIParam_2 onto the end of sqlite3_str object X."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine can be used to find the number of SQL parameters in a prepared statement.SQL parameters are tokens of the form \"?\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as placeholders for values that are bound to the parameters at a later time.", "key": "sqlite3_bind_parameter_count", "sent": "SQL parameters are tokens of the form \"?"}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine can be used to find the number of SQL parameters in a prepared statement.SQL parameters are tokens of the form \"?\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as placeholders for values that are bound to the parameters at a later time.", "key": "sqlite3_bind_parameter_count", "sent": "This routine can be used to find the number of SQL parameters in a prepared statement."}, {"API_info": {"var": ["sqlite3_blob *", " sqlite3_int64"], "API_desc": " sqlite3_blob_reopen_APIName is used to move an existing BLOB handle so that it points to a different row of the same database table.", "var_type": ["sqlite3_blob *", " sqlite3_int64"], "ret_type": "int"}, "paraph": "The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column.If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code be returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted.All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant.Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero.", "key": "sqlite3_blob_reopen", "sent": "If the new row is not present in the table, or if it does not contain a blob or text value, or if another error occurs, an SQLite error code be returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine actually returns the index of the largest (rightmost) parameter.For all forms except ?NNN, this will correspond to the number of unique parameters.If parameters of the ?NNN form are used, there may be gaps in the list.", "key": "sqlite3_bind_parameter_count", "sent": "This routine actually returns the index of the largest (rightmost) parameter."}, {"API_info": "sqlite3_execnot exist in API_info", "paraph": "If the 2nd parameter to sqlite3_exec_APIName is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.", "key": "sqlite3_exec", "sent": "If the 2_APIConstant parameter to sqlite3_exec_APIName is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*"], "ret_type": "void"}, "paraph": "The sqlite3_str_reset_APIName method resets the string under construction inside sqlite3_str object sqlite3_str_reset_APIParam_1 back to zero bytes in length.", "key": "sqlite3_str_reset", "sent": "The sqlite3_str_reset_APIName method resets the string under construction inside sqlite3_str object sqlite3_str_reset_APIParam_1 back to zero bytes in length."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine actually returns the index of the largest (rightmost) parameter.For all forms except ?NNN, this will correspond to the number of unique parameters.If parameters of the ?NNN form are used, there may be gaps in the list.", "key": "sqlite3_bind_parameter_count", "sent": "For all forms except ?NNN, this will correspond to the number of unique parameters."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine actually returns the index of the largest (rightmost) parameter.For all forms except ?NNN, this will correspond to the number of unique parameters.If parameters of the ?NNN form are used, there may be gaps in the list.", "key": "sqlite3_bind_parameter_count", "sent": "If parameters of the ?NNN form are used, there may be gaps in the list."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_name_APIName, and sqlite3_bind_parameter_index_APIName.", "key": "sqlite3_bind_parameter_count", "sent": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_name_APIName, and sqlite3_bind_parameter_index_APIName."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "Each call to either sqlite3_trace_APIName or sqlite3_trace_v2_APIName overrides (cancels) any prior calls to sqlite3_trace_APIName or sqlite3_trace_v2_APIName.", "key": "sqlite3_trace_v2", "sent": "Each call to either sqlite3_trace_APIName or sqlite3_trace_v2_APIName overrides (cancels) any prior calls to sqlite3_trace_APIName or sqlite3_trace_v2_APIName."}, {"API_info": {"var": ["sqlite3_str*", "zIn"], "API_desc": " These interfaces add content to an sqlite3_str object previously obtained from sqlite3_str_new_APIName.The sqlite3_str_appendf(X,F,...) and sqlite3_str_vappendf_APIName interfaces uses the built-in printf functionality of SQLite to append formatted text onto the end of sqlite3_str object X.The sqlite3_str_append_APIName method appends exactly N bytes from string S onto the end of the sqlite3_str object X.  N must be non-negative.", "var_type": ["sqlite3_str*", "const char *"], "ret_type": "void"}, "paraph": "These methods do not return a result code.If an error occurs, that fact is recorded in the sqlite3_str object and can be recovered by a subsequent call to sqlite3_str_errcode_APIName.", "key": "sqlite3_str_appendall", "sent": "If an error occurs, that fact is recorded in the sqlite3_str object and can be recovered by a subsequent call to sqlite3_str_errcode_APIName."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The X callback is invoked whenever any of the events identified by mask M occur.The integer return value from the callback is currently ignored, though this may change in future releases.Callback implementations should return zero to ensure future compatibility.", "key": "sqlite3_trace_v2", "sent": "The X callback is invoked whenever any of the events identified by mask M occur."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The X callback is invoked whenever any of the events identified by mask M occur.The integer return value from the callback is currently ignored, though this may change in future releases.Callback implementations should return zero to ensure future compatibility.", "key": "sqlite3_trace_v2", "sent": "Callback implementations should return zero to ensure future compatibility."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "A trace callback is invoked with four arguments: callback_APIName.The T argument is one of the SQLITE_TRACE_API_constant constants to indicate why the callback was invoked.The C argument is a copy of the context pointer.The P and X arguments are pointers whose meanings depend on T.", "key": "sqlite3_trace_v2", "sent": "A trace callback is invoked with four arguments: callback_APIName."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The sqlite3_trace_v2_APIName interface registers a trace callback function X against database connection D, using property mask M and context pointer P.  If the X callback is NULL or if the M mask is zero, then tracing is disabled.The M argument should be the bitwise OR-ed combination of zero or more SQLITE_TRACE_API_constant constants.", "key": "sqlite3_trace_v2", "sent": "The M argument should be the bitwise OR-ed combination of zero or more SQLITE_TRACE_API_constant constants."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "A trace callback is invoked with four arguments: callback_APIName.The T argument is one of the SQLITE_TRACE_API_constant constants to indicate why the callback was invoked.The C argument is a copy of the context pointer.The P and X arguments are pointers whose meanings depend on T.", "key": "sqlite3_trace_v2", "sent": "The C argument is a copy of the context pointer."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The X callback is invoked whenever any of the events identified by mask M occur.The integer return value from the callback is currently ignored, though this may change in future releases.Callback implementations should return zero to ensure future compatibility.", "key": "sqlite3_trace_v2", "sent": "The integer return value from the callback is currently ignored ,  ."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "A trace callback is invoked with four arguments: callback_APIName.The T argument is one of the SQLITE_TRACE_API_constant constants to indicate why the callback was invoked.The C argument is a copy of the context pointer.The P and X arguments are pointers whose meanings depend on T.", "key": "sqlite3_trace_v2", "sent": "The P and X arguments are pointers whose meanings depend on T."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "A trace callback is invoked with four arguments: callback_APIName.The T argument is one of the SQLITE_TRACE_API_constant constants to indicate why the callback was invoked.The C argument is a copy of the context pointer.The P and X arguments are pointers whose meanings depend on T.", "key": "sqlite3_trace_v2", "sent": "The T argument is one of the SQLITE_TRACE_API_constant constants to indicate why the callback was invoked."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.The return value is OS-dependent.For example, on unix systems, after sqlite3_open_v2_APIName returns SQLITE_CANTOPEN_API_constant, this interface could be called to get back the underlying \"errno\" that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.", "key": "sqlite3_system_errno", "sent": "The return value is OS-dependent."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The sqlite3_trace_v2_APIName interface is intended to replace the legacy interfaces sqlite3_trace_APIName and sqlite3_profile_APIName, both of which are deprecated.", "key": "sqlite3_trace_v2", "sent": "The sqlite3_trace_v2_APIName interface is intended to replace the legacy interfaces sqlite3_trace_APIName and sqlite3_profile_APIName, both of which are deprecated."}, {"API_info": "sqlite3_trace_v2not exist in API_info", "paraph": "The sqlite3_trace_v2_APIName interface registers a trace callback function X against database connection D, using property mask M and context pointer P.  If the X callback is NULL or if the M mask is zero, then tracing is disabled.The M argument should be the bitwise OR-ed combination of zero or more SQLITE_TRACE_API_constant constants.", "key": "sqlite3_trace_v2", "sent": "The sqlite3_trace_v2_APIName interface registers a trace callback function X against database connection D, using property mask M and context pointer P.  If the X callback is NULL or if the M mask is zero, then tracing is disabled."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command.A NULL pointer can be used in place of \"main\" to refer to the main database file.The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method.The return value of the xFileControl method becomes the return value of this routine.", "key": "sqlite3_file_control", "sent": "The return value of the xFileControl method becomes the return value of this routine."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command.A NULL pointer can be used in place of \"main\" to refer to the main database file.The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method.The return value of the xFileControl method becomes the return value of this routine.", "key": "sqlite3_file_control", "sent": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command.A NULL pointer can be used in place of \"main\" to refer to the main database file.The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method.The return value of the xFileControl method becomes the return value of this routine.", "key": "sqlite3_file_control", "sent": "A NULL pointer can be used in place of \"main\" to refer to the main database file."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method.The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter.The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database.The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file.The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager.", "key": "sqlite3_file_control", "sent": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command.A NULL pointer can be used in place of \"main\" to refer to the main database file.The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method.The return value of the xFileControl method becomes the return value of this routine.", "key": "sqlite3_file_control", "sent": "The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.The return value is OS-dependent.For example, on unix systems, after sqlite3_open_v2_APIName returns SQLITE_CANTOPEN_API_constant, this interface could be called to get back the underlying \"errno\" that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.", "key": "sqlite3_system_errno", "sent": "Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method.The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter.The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database.The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file.The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager.", "key": "sqlite3_file_control", "sent": "The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command.A NULL pointer can be used in place of \"main\" to refer to the main database file.The third and fourth parameters to this routine are passed directly through to the second and third parameters of the xFileControl method.The return value of the xFileControl method becomes the return value of this routine.", "key": "sqlite3_file_control", "sent": "The name of the database is \"main\" for the main database or \"temp\" for the TEMP database, or the name that appears after the AS keyword for databases that are added using the ATTACH SQL command."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file.The return value is OS-dependent.For example, on unix systems, after sqlite3_open_v2_APIName returns SQLITE_CANTOPEN_API_constant, this interface could be called to get back the underlying \"errno\" that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.", "key": "sqlite3_system_errno", "sent": "For example, on unix systems, after sqlite3_open_v2_APIName returns SQLITE_CANTOPEN_API_constant, this interface could be called to get back the underlying \"errno\" that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " This routine can be used to find the number of SQL parameters in a prepared statement.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This routine can be used to find the number of SQL parameters in a prepared statement.SQL parameters are tokens of the form \"?\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as placeholders for values that are bound to the parameters at a later time.", "key": "sqlite3_bind_parameter_count", "sent": "\", \"?NNN\", \":AAA\", \"$AAA\", or \"@AAA\" that serve as placeholders for values that are bound to the parameters at a later time."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method.The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter.The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database.The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file.The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager.", "key": "sqlite3_file_control", "sent": "The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method.The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter.The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database.The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file.The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager.", "key": "sqlite3_file_control", "sent": "The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "A few opcodes for sqlite3_file_control_APIName are handled directly by the SQLite core and never invoke the sqlite3_io_methods.xFileControl method.The SQLITE_FCNTL_FILE_POINTER_API_constant value for the sqlite3_file_control_APIParam_3 parameter causes a pointer to the underlying sqlite3_file object to be written into the space pointed to by the 4_APIConstant parameter.The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database.The SQLITE_FCNTL_VFS_POINTER_API_constant opcode returns a pointer to the underlying sqlite3_vfs object for the file.The SQLITE_FCNTL_DATA_VERSION_API_constant returns the data version counter from the pager.", "key": "sqlite3_file_control", "sent": "The SQLITE_FCNTL_JOURNAL_POINTER_API_constant works similarly except that sqlite3_file_control_APIName returns the sqlite3_file object associated with the journal file instead of the main database."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "If sqlite3_file_control_APIParam_2 (zDbName) does not match the name of any open database file, then SQLITE_ERROR_API_constant be returned by sqlite3_file_control_APIName.This error code is not remembered and will not be recalled by sqlite3_errcode_APIName or sqlite3_errmsg_APIName.The underlying xFileControl method might also return SQLITE_ERROR_API_constant.There is no way to distinguish between an incorrect sqlite3_file_control_APIParam_2 and an SQLITE_ERROR_API_constant return from the underlying xFileControl method.", "key": "sqlite3_file_control", "sent": "The underlying xFileControl method might also return SQLITE_ERROR_API_constant."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "See also: file control opcodes", "key": "sqlite3_file_control", "sent": "See also: file control opcodes"}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "If sqlite3_file_control_APIParam_2 (zDbName) does not match the name of any open database file, then SQLITE_ERROR_API_constant be returned by sqlite3_file_control_APIName.This error code is not remembered and will not be recalled by sqlite3_errcode_APIName or sqlite3_errmsg_APIName.The underlying xFileControl method might also return SQLITE_ERROR_API_constant.There is no way to distinguish between an incorrect sqlite3_file_control_APIParam_2 and an SQLITE_ERROR_API_constant return from the underlying xFileControl method.", "key": "sqlite3_file_control", "sent": "If sqlite3_file_control_APIParam_2 (zDbName) does not match the name of any open database file, then SQLITE_ERROR_API_constant be returned by sqlite3_file_control_APIName."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "If sqlite3_file_control_APIParam_2 (zDbName) does not match the name of any open database file, then SQLITE_ERROR_API_constant be returned by sqlite3_file_control_APIName.This error code is not remembered and will not be recalled by sqlite3_errcode_APIName or sqlite3_errmsg_APIName.The underlying xFileControl method might also return SQLITE_ERROR_API_constant.There is no way to distinguish between an incorrect sqlite3_file_control_APIParam_2 and an SQLITE_ERROR_API_constant return from the underlying xFileControl method.", "key": "sqlite3_file_control", "sent": "This error code is not remembered and will not be recalled by sqlite3_errcode_APIName or sqlite3_errmsg_APIName."}, {"API_info": {"var": ["sqlite3*", "zDbName", "op", " void*"], "API_desc": " The sqlite3_file_control_APIName interface makes a direct call to the xFileControl method for the sqlite3_io_methods object associated with a particular database identified by sqlite3_file_control_APIParam_2.", "var_type": ["sqlite3*", "const char *", "int", " void*"], "ret_type": "int"}, "paraph": "If sqlite3_file_control_APIParam_2 (zDbName) does not match the name of any open database file, then SQLITE_ERROR_API_constant be returned by sqlite3_file_control_APIName.This error code is not remembered and will not be recalled by sqlite3_errcode_APIName or sqlite3_errmsg_APIName.The underlying xFileControl method might also return SQLITE_ERROR_API_constant.There is no way to distinguish between an incorrect sqlite3_file_control_APIParam_2 and an SQLITE_ERROR_API_constant return from the underlying xFileControl method.", "key": "sqlite3_file_control", "sent": "There is no way to distinguish between an incorrect sqlite3_file_control_APIParam_2 and an SQLITE_ERROR_API_constant return from the underlying xFileControl method."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema sqlite3_snapshot_open_APIParam_2 of database connection sqlite3_snapshot_open_APIParam_1 such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.The sqlite3_snapshot_open_APIName interface returns SQLITE_OK_API_constant on success or an appropriate error code if it fails.", "key": "sqlite3_snapshot_open", "sent": "The sqlite3_snapshot_open_APIName interface returns SQLITE_OK_API_constant on success or an appropriate error code if it fails."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "A call to sqlite3_snapshot_open_APIName will fail to open if the specified snapshot has been overwritten by a checkpoint.In this case SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName.", "key": "sqlite3_snapshot_open", "sent": "In this case SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "In order to succeed, the database connection must not be in autocommit mode when sqlite3_snapshot_open_APIName is called.If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step_APIName but not sqlite3_reset_APIName or sqlite3_finalize_APIName).SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_open_APIName if either of these conditions is violated, or if schema sqlite3_snapshot_open_APIParam_2 does not exist, or if the snapshot object is invalid.", "key": "sqlite3_snapshot_open", "sent": " , the database connection must not be in autocommit mode when sqlite3_snapshot_open_APIName is called ."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "In order to succeed, the database connection must not be in autocommit mode when sqlite3_snapshot_open_APIName is called.If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step_APIName but not sqlite3_reset_APIName or sqlite3_finalize_APIName).SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_open_APIName if either of these conditions is violated, or if schema sqlite3_snapshot_open_APIParam_2 does not exist, or if the snapshot object is invalid.", "key": "sqlite3_snapshot_open", "sent": "If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step_APIName but not sqlite3_reset_APIName or sqlite3_finalize_APIName)."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "A call to sqlite3_snapshot_open_APIName will fail to open if the specified snapshot has been overwritten by a checkpoint.In this case SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName.", "key": "sqlite3_snapshot_open", "sent": "A call to sqlite3_snapshot_open_APIName will fail to open if the specified snapshot has been overwritten by a checkpoint."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "A call to sqlite3_snapshot_open_APIName will fail if the database connection sqlite3_snapshot_open_APIParam_1 does not know that the database file for schema sqlite3_snapshot_open_APIParam_2 is in WAL mode.A database connection might not know that the database file is in WAL mode if there has been no prior I/O on that database connection, or if the database entered WAL mode after the most recent I/O on the database connection.(Hint: Run \"PRAGMA application_id\" against a newly opened database connection in order to make it ready to use snapshots.)", "key": "sqlite3_snapshot_open", "sent": "(Hint: Run \"PRAGMA application_id\" against a newly opened database connection in order to make it ready to use snapshots.)"}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "If there is already a read transaction open when sqlite3_snapshot_open_APIName is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR_API_constant, SQLITE_BUSY_API_constant or SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName.If another error code - for example SQLITE_PROTOCOL_API_constant or an SQLITE_IOERR_API_constant error code - be returned by sqlite3_snapshot_open_APIName, then the final state of the read transaction is undefined.If SQLITE_OK_API_constant be returned by sqlite3_snapshot_open_APIName, then the read transaction is now open on database snapshot P.", "key": "sqlite3_snapshot_open", "sent": "If SQLITE_OK_API_constant be returned by sqlite3_snapshot_open_APIName, then the read transaction is now open on database snapshot P."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "sqlite3_blob_close_APIName closes an open BLOB handle.The BLOB handle is closed unconditionally.Even if this routine returns an error code, the handle is still closed.", "key": "sqlite3_blob_close", "sent": "sqlite3_blob_close_APIName closes an open BLOB handle."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "sqlite3_blob_close_APIName closes an open BLOB handle.The BLOB handle is closed unconditionally.Even if this routine returns an error code, the handle is still closed.", "key": "sqlite3_blob_close", "sent": "The BLOB handle is closed unconditionally."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_open_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.", "key": "sqlite3_snapshot_open", "sent": "The sqlite3_snapshot_open_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "sqlite3_blob_close_APIName closes an open BLOB handle.The BLOB handle is closed unconditionally.Even if this routine returns an error code, the handle is still closed.", "key": "sqlite3_blob_close", "sent": " is still closed ."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "Calling sqlite3_blob_close_APIName with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour.Calling this routine with a null pointer (such as would be returned by a failed call to sqlite3_blob_open_APIName) is a harmless no-op.Otherwise, if sqlite3_blob_close_APIName is passed a valid open blob handle, the values returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions are set before returning.", "key": "sqlite3_blob_close", "sent": "Calling this routine with a null pointer (such as would be returned by a failed call to sqlite3_blob_open_APIName) is a harmless no-op."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed.If an error occurs while committing the transaction, an error code be returned by sqlite3_blob_close_APIName and the transaction rolled back.", "key": "sqlite3_blob_close", "sent": "If an error occurs while committing the transaction, an error code be returned by sqlite3_blob_close_APIName and the transaction rolled back."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "A call to sqlite3_snapshot_open_APIName will fail if the database connection sqlite3_snapshot_open_APIParam_1 does not know that the database file for schema sqlite3_snapshot_open_APIParam_2 is in WAL mode.A database connection might not know that the database file is in WAL mode if there has been no prior I/O on that database connection, or if the database entered WAL mode after the most recent I/O on the database connection.(Hint: Run \"PRAGMA application_id\" against a newly opened database connection in order to make it ready to use snapshots.)", "key": "sqlite3_snapshot_open", "sent": "A call to sqlite3_snapshot_open_APIName will fail if the database connection sqlite3_snapshot_open_APIParam_1 does not know that the database file for schema sqlite3_snapshot_open_APIParam_2 is in WAL mode."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "If there is already a read transaction open when sqlite3_snapshot_open_APIName is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR_API_constant, SQLITE_BUSY_API_constant or SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName.If another error code - for example SQLITE_PROTOCOL_API_constant or an SQLITE_IOERR_API_constant error code - be returned by sqlite3_snapshot_open_APIName, then the final state of the read transaction is undefined.If SQLITE_OK_API_constant be returned by sqlite3_snapshot_open_APIName, then the read transaction is now open on database snapshot P.", "key": "sqlite3_snapshot_open", "sent": "If there is already a read transaction open when sqlite3_snapshot_open_APIName is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR_API_constant, SQLITE_BUSY_API_constant or SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "If there is already a read transaction open when sqlite3_snapshot_open_APIName is invoked, then the same read transaction remains open (on the same database snapshot) if SQLITE_ERROR_API_constant, SQLITE_BUSY_API_constant or SQLITE_ERROR_API_constant_SNAPSHOT be returned by sqlite3_snapshot_open_APIName.If another error code - for example SQLITE_PROTOCOL_API_constant or an SQLITE_IOERR_API_constant error code - be returned by sqlite3_snapshot_open_APIName, then the final state of the read transaction is undefined.If SQLITE_OK_API_constant be returned by sqlite3_snapshot_open_APIName, then the read transaction is now open on database snapshot P.", "key": "sqlite3_snapshot_open", "sent": "If another error code - for example SQLITE_PROTOCOL_API_constant or an SQLITE_IOERR_API_constant error code - be returned by sqlite3_snapshot_open_APIName, then the final state of the read transaction is undefined."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "In order to succeed, the database connection must not be in autocommit mode when sqlite3_snapshot_open_APIName is called.If there is already a read transaction open on schema S, then the database handle must have no active statements (SELECT statements that have been passed to sqlite3_step_APIName but not sqlite3_reset_APIName or sqlite3_finalize_APIName).SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_open_APIName if either of these conditions is violated, or if schema sqlite3_snapshot_open_APIParam_2 does not exist, or if the snapshot object is invalid.", "key": "sqlite3_snapshot_open", "sent": "SQLITE_ERROR_API_constant be returned by sqlite3_snapshot_open_APIName if either of these conditions is violated, or if schema sqlite3_snapshot_open_APIParam_2 does not exist, or if the snapshot object is invalid."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName function is called to delete a prepared statement.If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize_APIName returns SQLITE_OK_API_constant.If the most recent evaluation of statement sqlite3_finalize_APIParam_1 failed, then sqlite3_finalize_APIName returns the appropriate error code or extended error code.", "key": "sqlite3_finalize", "sent": "The sqlite3_finalize_APIName function is called to delete a prepared statement."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.", "var_type": ["sqlite3_context*"], "ret_type": "int"}, "paraph": "If the xColumn method calls sqlite3_vtab_nochange_APIName and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the sqlite3_result_xxxxx_APIName interfaces.In that case, sqlite3_value_nochange_APIName will return true for the same column in the xUpdate method.", "key": "sqlite3_vtab_nochange", "sent": "In that case, sqlite3_value_nochange_APIName will return true for the same column in the xUpdate method."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "Calling sqlite3_blob_close_APIName with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour.Calling this routine with a null pointer (such as would be returned by a failed call to sqlite3_blob_open_APIName) is a harmless no-op.Otherwise, if sqlite3_blob_close_APIName is passed a valid open blob handle, the values returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions are set before returning.", "key": "sqlite3_blob_close", "sent": "Calling sqlite3_blob_close_APIName with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "Calling sqlite3_blob_close_APIName with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour.Calling this routine with a null pointer (such as would be returned by a failed call to sqlite3_blob_open_APIName) is a harmless no-op.Otherwise, if sqlite3_blob_close_APIName is passed a valid open blob handle, the values returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions are set before returning.", "key": "sqlite3_blob_close", "sent": "Otherwise, if sqlite3_blob_close_APIName is passed a valid open blob handle, the values returned by the sqlite3_errcode_APIName and sqlite3_errmsg_APIName functions are set before returning."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName routine can be called at any point during the life cycle of prepared statement S: before statement sqlite3_finalize_APIParam_1 is ever evaluated, after one or more calls to sqlite3_reset_APIName, or after any call to sqlite3_step_APIName regardless of whether or not the statement has completed execution.", "key": "sqlite3_finalize", "sent": "The sqlite3_finalize_APIName routine can be called before statement sqlite3_finalize_APIParam_1 is ever evaluated"}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.", "var_type": ["sqlite3_context*"], "ret_type": "int"}, "paraph": "If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then sqlite3_vtab_nochange_APIName returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.Applications might use this to substitute a return value that is less expensive to compute and that the corresponding xUpdate method understands as a \"no-change\" value.", "key": "sqlite3_vtab_nochange", "sent": "Applications might use this to substitute a return value that is less expensive to compute and that the corresponding xUpdate method understands as a \"no-change\" value."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName routine can be called at any point during the life cycle of prepared statement S: before statement sqlite3_finalize_APIParam_1 is ever evaluated, after one or more calls to sqlite3_reset_APIName, or after any call to sqlite3_step_APIName regardless of whether or not the statement has completed execution.", "key": "sqlite3_finalize", "sent": "The sqlite3_finalize_APIName routine can be called after one or more calls to sqlite3_reset_APIName"}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Invoking sqlite3_finalize_APIName on a NULL pointer is a harmless no-op.", "key": "sqlite3_finalize", "sent": "Invoking sqlite3_finalize_APIName on a NULL pointer is a harmless no-op."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName function is called to delete a prepared statement.If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize_APIName returns SQLITE_OK_API_constant.If the most recent evaluation of statement sqlite3_finalize_APIParam_1 failed, then sqlite3_finalize_APIName returns the appropriate error code or extended error code.", "key": "sqlite3_finalize", "sent": "If the most recent evaluation of statement sqlite3_finalize_APIParam_1 failed, then sqlite3_finalize_APIName returns the appropriate error code or extended error code."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The application must finalize every prepared statement in order to avoid resource leaks.It is a grievous error for the application to try to use a prepared statement after it has been finalized.Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.", "key": "sqlite3_finalize", "sent": "The application must finalize every prepared statement  ."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName function is called to delete a prepared statement.If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize_APIName returns SQLITE_OK_API_constant.If the most recent evaluation of statement sqlite3_finalize_APIParam_1 failed, then sqlite3_finalize_APIName returns the appropriate error code or extended error code.", "key": "sqlite3_finalize", "sent": "If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_finalize_APIName routine can be called at any point during the life cycle of prepared statement S: before statement sqlite3_finalize_APIParam_1 is ever evaluated, after one or more calls to sqlite3_reset_APIName, or after any call to sqlite3_step_APIName regardless of whether or not the statement has completed execution.", "key": "sqlite3_finalize", "sent": "The sqlite3_finalize_APIName routine can be called after any call to sqlite3_step_APIName regardless of  ."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The parameter P is passed through as the only parameter to the callback function X.The parameter N is the approximate number of virtual machine instructions that are evaluated between successive invocations of the callback X.If N is less than one then the progress handler is disabled.", "key": "sqlite3_progress_handler", "sent": "The parameter P is passed through as the only parameter to the callback function X."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema sqlite3_snapshot_open_APIParam_2 of database connection sqlite3_snapshot_open_APIParam_1 such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.The sqlite3_snapshot_open_APIName interface returns SQLITE_OK_API_constant on success or an appropriate error code if it fails.", "key": "sqlite3_snapshot_open", "sent": "The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema sqlite3_snapshot_open_APIParam_2 of database connection sqlite3_snapshot_open_APIParam_1 such that the read transaction refers to historical snapshot P, rather than the most recent change to the database."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The parameter P is passed through as the only parameter to the callback function X.The parameter N is the approximate number of virtual machine instructions that are evaluated between successive invocations of the callback X.If N is less than one then the progress handler is disabled.", "key": "sqlite3_progress_handler", "sent": "If N is less than one then the progress handler is disabled."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " sqlite3_blob_close_APIName closes an open BLOB handle.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed.If an error occurs while committing the transaction, an error code be returned by sqlite3_blob_close_APIName and the transaction rolled back.", "key": "sqlite3_blob_close", "sent": "If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The application must finalize every prepared statement in order to avoid resource leaks.It is a grievous error for the application to try to use a prepared statement after it has been finalized.Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.", "key": "sqlite3_finalize", "sent": "It is a grievous error for the application to try to use a prepared statement after it has been finalized."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "Only a single progress handler may be defined at one time per database connection; setting a new progress handler cancels the old one.Setting parameter X to NULL disables the progress handler.The progress handler is also disabled by setting N to a value less than 1.", "key": "sqlite3_progress_handler", "sent": "Setting parameter X to NULL disables the progress handler."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_finalize_APIName function is called to delete a prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The application must finalize every prepared statement in order to avoid resource leaks.It is a grievous error for the application to try to use a prepared statement after it has been finalized.Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption.", "key": "sqlite3_finalize", "sent": "Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The parameter P is passed through as the only parameter to the callback function X.The parameter N is the approximate number of virtual machine instructions that are evaluated between successive invocations of the callback X.If N is less than one then the progress handler is disabled.", "key": "sqlite3_progress_handler", "sent": "The parameter N is the approximate number of virtual machine instructions that are evaluated between successive invocations of the callback X."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "Only a single progress handler may be defined at one time per database connection; setting a new progress handler cancels the old one.Setting parameter X to NULL disables the progress handler.The progress handler is also disabled by setting N to a value less than 1.", "key": "sqlite3_progress_handler", "sent": "The progress handler is also disabled by setting N to a value less than 1."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.", "var_type": ["sqlite3_context*"], "ret_type": "int"}, "paraph": "If the xColumn method calls sqlite3_vtab_nochange_APIName and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the sqlite3_result_xxxxx_APIName interfaces.In that case, sqlite3_value_nochange_APIName will return true for the same column in the xUpdate method.", "key": "sqlite3_vtab_nochange", "sent": "If the xColumn method calls sqlite3_vtab_nochange_APIName and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the sqlite3_result_xxxxx_APIName interfaces."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "If the progress callback returns non-zero, the operation is interrupted.This feature can be used to implement a \"Cancel\" button on a GUI progress dialog box.", "key": "sqlite3_progress_handler", "sent": "If the progress callback returns non-zero, the operation is interrupted."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "If the progress callback returns non-zero, the operation is interrupted.This feature can be used to implement a \"Cancel\" button on a GUI progress dialog box.", "key": "sqlite3_progress_handler", "sent": "This feature can be used to implement a \"Cancel\" button on a GUI progress dialog box."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The sqlite3_progress_handler_APIName interface causes the callback function X to be invoked periodically during long running calls to sqlite3_exec_APIName, sqlite3_step_APIName and sqlite3_get_table_APIName for database connection D.  An example use for this interface is to keep a GUI updated during a large query.", "key": "sqlite3_progress_handler", "sent": "The sqlite3_progress_handler_APIName interface causes the callback function X to be invoked periodically during long running calls to sqlite3_exec_APIName, sqlite3_step_APIName and sqlite3_get_table_APIName for database connection D.  An example use for this interface is to keep a GUI updated during a large query."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The progress handler callback must not do anything that will modify the database connection that invoked the progress handler.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_progress_handler", "sent": "The progress handler callback must not do anything that will modify the database connection that invoked the progress handler."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "Only a single progress handler may be defined at one time per database connection; setting a new progress handler cancels the old one.Setting parameter X to NULL disables the progress handler.The progress handler is also disabled by setting N to a value less than 1.", "key": "sqlite3_progress_handler", "sent": "Only a single progress handler may be defined at one time per database connection; setting a new progress handler cancels the old one."}, {"API_info": "sqlite3_progress_handlernot exist in API_info", "paraph": "The progress handler callback must not do anything that will modify the database connection that invoked the progress handler.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_progress_handler", "sent": "Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "const char *"}, "paraph": "The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement sqlite3_normalized_sql_APIParam_1 if sqlite3_normalized_sql_APIParam_1 was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.The sqlite3_expanded_sql_APIName interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement sqlite3_normalized_sql_APIParam_1 with bound parameters expanded.The sqlite3_normalized_sql_APIName interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P.  The semantics used to normalize a SQL statement are unspecified and subject to change.At a minimum, literal values will be replaced with suitable placeholders.", "key": "sqlite3_sql", "sent": "At a minimum, literal values will be replaced with suitable placeholders."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "char *"}, "paraph": "The SQLITE_TRACE_API_constant_SIZE_LIMIT compile-time option limits the size of bound parameter expansions.The SQLITE_OMIT_TRACE compile-time option causes sqlite3_expanded_sql_APIName to always return NULL.", "key": "sqlite3_expanded_sql", "sent": "The SQLITE_TRACE_API_constant_SIZE_LIMIT compile-time option limits the size of bound parameter expansions."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "char *"}, "paraph": "The SQLITE_TRACE_API_constant_SIZE_LIMIT compile-time option limits the size of bound parameter expansions.The SQLITE_OMIT_TRACE compile-time option causes sqlite3_expanded_sql_APIName to always return NULL.", "key": "sqlite3_expanded_sql", "sent": "The SQLITE_OMIT_TRACE compile-time option causes sqlite3_expanded_sql_APIName to always return NULL."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "const char *"}, "paraph": "The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement sqlite3_normalized_sql_APIParam_1 if sqlite3_normalized_sql_APIParam_1 was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.The sqlite3_expanded_sql_APIName interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement sqlite3_normalized_sql_APIParam_1 with bound parameters expanded.The sqlite3_normalized_sql_APIName interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P.  The semantics used to normalize a SQL statement are unspecified and subject to change.At a minimum, literal values will be replaced with suitable placeholders.", "key": "sqlite3_normalized_sql", "sent": "The sqlite3_normalized_sql_APIName interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P.  The semantics used to normalize a SQL statement are unspecified and subject to change."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "char *"}, "paraph": "The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement sqlite3_normalized_sql_APIParam_1 if sqlite3_normalized_sql_APIParam_1 was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.The sqlite3_expanded_sql_APIName interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement sqlite3_normalized_sql_APIParam_1 with bound parameters expanded.The sqlite3_normalized_sql_APIName interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P.  The semantics used to normalize a SQL statement are unspecified and subject to change.At a minimum, literal values will be replaced with suitable placeholders.", "key": "sqlite3_expanded_sql", "sent": "The sqlite3_expanded_sql_APIName interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement sqlite3_normalized_sql_APIParam_1 with bound parameters expanded."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The third argument (eTextRep) must be one of the constants:", "key": "sqlite3_create_collation", "sent": "The third argument (eTextRep) must be one of the constants:"}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "const char *"}, "paraph": "The strings returned by sqlite3_sql_APIName and sqlite3_normalized_sql_APIName are managed by SQLite and are automatically freed when the prepared statement is finalized.The string returned by sqlite3_expanded_sql_APIName, on the other hand, is obtained from sqlite3_malloc_APIName and must be free by the application by passing it to sqlite3_free_APIName.", "key": "sqlite3_sql", "sent": "The strings returned by sqlite3_sql_APIName and sqlite3_normalized_sql_APIName are managed by SQLite and are automatically freed when the prepared statement is finalized."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "These functions add, remove, or modify a collation associated with the database connection specified as the first argument.", "key": "sqlite3_create_collation", "sent": "These functions add, remove, or modify a collation associated with the database connection specified as the first argument."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The name of the collation is a UTF-8 string for sqlite3_create_collation_APIName and sqlite3_create_collation_v2_APIName and a UTF-16 string in native byte order for sqlite3_create_collation16_APIName.Collation names that compare equal according to sqlite3_strnicmp_APIName are considered to be the same name.", "key": "sqlite3_create_collation", "sent": "Collation names that compare equal according to sqlite3_strnicmp_APIName are considered to be the same name."}, {"API_info": {"var": ["db", "zSchema", "pSnapshot"], "API_desc": " The sqlite3_snapshot_open_APIName interface either starts a new read transaction or upgrades an existing one for schema S of database connection D such that the read transaction refers to historical snapshot P, rather than the most recent change to the database.", "var_type": ["sqlite3 *", "const char *", "sqlite3_snapshot *"], "ret_type": "int"}, "paraph": "A call to sqlite3_snapshot_open_APIName will fail if the database connection sqlite3_snapshot_open_APIParam_1 does not know that the database file for schema sqlite3_snapshot_open_APIParam_2 is in WAL mode.A database connection might not know that the database file is in WAL mode if there has been no prior I/O on that database connection, or if the database entered WAL mode after the most recent I/O on the database connection.(Hint: Run \"PRAGMA application_id\" against a newly opened database connection in order to make it ready to use snapshots.)", "key": "sqlite3_snapshot_open", "sent": "A database connection might not know that the database file is in WAL mode if there has been no prior I/O on that database connection, or if the database entered WAL mode after the most recent I/O on the database connection."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "const char *"}, "paraph": "The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement sqlite3_normalized_sql_APIParam_1 if sqlite3_normalized_sql_APIParam_1 was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.The sqlite3_expanded_sql_APIName interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement sqlite3_normalized_sql_APIParam_1 with bound parameters expanded.The sqlite3_normalized_sql_APIName interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P.  The semantics used to normalize a SQL statement are unspecified and subject to change.At a minimum, literal values will be replaced with suitable placeholders.", "key": "sqlite3_sql", "sent": "The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement sqlite3_normalized_sql_APIParam_1 if sqlite3_normalized_sql_APIParam_1 was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The fifth argument, xCallback, is a pointer to the collating function.Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation.If the xCallback argument is NULL then the collating function is deleted.When all collating functions having the same name are deleted, that collation is no longer usable.", "key": "sqlite3_create_collation", "sent": "The fifth argument, xCallback, is a pointer to the collating function."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The name of the collation is a UTF-8 string for sqlite3_create_collation_APIName and sqlite3_create_collation_v2_APIName and a UTF-16 string in native byte order for sqlite3_create_collation16_APIName.Collation names that compare equal according to sqlite3_strnicmp_APIName are considered to be the same name.", "key": "sqlite3_create_collation", "sent": "The name of the collation is a UTF-8 string for sqlite3_create_collation_APIName and sqlite3_create_collation_v2_APIName and a UTF-16 string in native byte order for sqlite3_create_collation16_APIName."}, {"API_info": "sqlite3_create_collation_v2 not exist in API_info", "paraph": "The fifth argument, xCallback, is a pointer to the collating function.Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation.If the xCallback argument is NULL then the collating function is deleted.When all collating functions having the same name are deleted, that collation is no longer usable.", "key": "sqlite3_create_collation_v2", "sent": "If the xCallback argument is NULL then the collating function is deleted."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "char *"}, "paraph": "The sqlite3_expanded_sql_APIName interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the SQLITE_LIMIT_LENGTH_API_constant.", "key": "sqlite3_expanded_sql", "sent": "The sqlite3_expanded_sql_APIName interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the SQLITE_LIMIT_LENGTH_API_constant."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "char *"}, "paraph": "The strings returned by sqlite3_sql_APIName and sqlite3_normalized_sql_APIName are managed by SQLite and are automatically freed when the prepared statement is finalized.The string returned by sqlite3_expanded_sql_APIName, on the other hand, is obtained from sqlite3_malloc_APIName and must be free by the application by passing it to sqlite3_free_APIName.", "key": "sqlite3_expanded_sql", "sent": "The string returned by sqlite3_expanded_sql_APIName, on the other hand, is obtained from sqlite3_malloc_APIName and must be free by the application by passing it to sqlite3_free_APIName."}, {"API_info": "sqlite3_create_collation_v2 not exist in API_info", "paraph": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument.The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively.A collating function must always return the same answer given the same inputs.If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings.The collating function must obey the following properties for all strings A, B, and C:", "key": "sqlite3_create_collation_v2", "sent": "A collating function must always return the same answer given the same inputs."}, {"API_info": "sqlite3_create_collation16 not exist in API_info", "paraph": "The fifth argument, xCallback, is a pointer to the collating function.Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation.If the xCallback argument is NULL then the collating function is deleted.When all collating functions having the same name are deleted, that collation is no longer usable.", "key": "sqlite3_create_collation16", "sent": "When all collating functions having the same name are deleted, that collation is no longer usable."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback.", "key": "sqlite3_create_collation", "sent": "The fourth argument, pArg, is an application data pointer that is passed through as the first argument to the collating function callback."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.", "var_type": ["sqlite3_context*"], "ret_type": "int"}, "paraph": "If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then sqlite3_vtab_nochange_APIName returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change.Applications might use this to substitute a return value that is less expensive to compute and that the corresponding xUpdate method understands as a \"no-change\" value.", "key": "sqlite3_vtab_nochange", "sent": "If the sqlite3_vtab_nochange_APIName routine is called within the xColumn method of a virtual table, then sqlite3_vtab_nochange_APIName returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The fifth argument, xCallback, is a pointer to the collating function.Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation.If the xCallback argument is NULL then the collating function is deleted.When all collating functions having the same name are deleted, that collation is no longer usable.", "key": "sqlite3_create_collation", "sent": "Multiple collating functions can be registered using the same name but with different eTextRep parameters and SQLite will use whichever function requires the least amount of data transformation."}, {"API_info": "sqlite3_create_collation16 not exist in API_info", "paraph": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument.The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively.A collating function must always return the same answer given the same inputs.If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings.The collating function must obey the following properties for all strings A, B, and C:", "key": "sqlite3_create_collation16", "sent": "The collating function must obey the following properties for all strings A, B, and C:"}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The xDestroy callback is not called if the sqlite3_create_collation_v2_APIName function fails.Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them.This is different from every other SQLite interface.The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.", "key": "sqlite3_create_collation", "sent": "The xDestroy callback is not called if the sqlite3_create_collation_v2_APIName function fails."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The xDestroy callback is not called if the sqlite3_create_collation_v2_APIName function fails.Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them.This is different from every other SQLite interface.The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.", "key": "sqlite3_create_collation", "sent": "This is different from every other SQLite interface."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument.The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively.A collating function must always return the same answer given the same inputs.If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings.The collating function must obey the following properties for all strings A, B, and C:", "key": "sqlite3_create_collation", "sent": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument."}, {"API_info": "sqlite3_create_collation_v2 not exist in API_info", "paraph": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument.The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively.A collating function must always return the same answer given the same inputs.If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings.The collating function must obey the following properties for all strings A, B, and C:", "key": "sqlite3_create_collation_v2", "sent": "If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "See also:  sqlite3_collation_needed_APIName and sqlite3_collation_needed16_APIName.", "key": "sqlite3_create_collation", "sent": "See also:  sqlite3_collation_needed_APIName and sqlite3_collation_needed16_APIName."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The xDestroy callback is not called if the sqlite3_create_collation_v2_APIName function fails.Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them.This is different from every other SQLite interface.The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.", "key": "sqlite3_create_collation", "sent": "The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The sqlite3_create_collation_v2_APIName works like sqlite3_create_collation_APIName with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted.Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the database connection is closed using sqlite3_close_APIName.", "key": "sqlite3_create_collation", "sent": "The sqlite3_create_collation_v2_APIName works like sqlite3_create_collation_APIName with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The sqlite3_create_collation_v2_APIName works like sqlite3_create_collation_APIName with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted.Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the database connection is closed using sqlite3_close_APIName.", "key": "sqlite3_create_collation", "sent": "Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the database connection is closed using sqlite3_close_APIName."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core.The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag.External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.", "key": "sqlite3_mutex_held", "sent": "The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "The collating function callback is invoked with a copy of the pArg application data pointer and with two strings in the encoding specified by the eTextRep argument.The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively.A collating function must always return the same answer given the same inputs.If two or more collating functions are registered to the same collation name (using different eTextRep values) then all must give an equivalent answer when invoked with equivalent strings.The collating function must obey the following properties for all strings A, B, and C:", "key": "sqlite3_create_collation", "sent": "The collating function must return an integer that is negative, zero, or positive if the first string is less than, equal to, or greater than the second, respectively."}, {"API_info": "sqlite3_create_collation not exist in API_info", "paraph": "If a collating function fails any of the above constraints and that collating function is  registered and used, then the behavior of SQLite is undefined.", "key": "sqlite3_create_collation", "sent": "If a collating function fails any of the above constraints and that collating function is  registered and used, then the behavior of SQLite is undefined."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core.The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag.External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.", "key": "sqlite3_mutex_held", "sent": "The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "The implementation is not required to provide versions of these routines that actually work.If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.", "key": "sqlite3_mutex_held", "sent": "The implementation is not required to provide versions of these routines that actually work."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core.The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag.External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.", "key": "sqlite3_mutex_held", "sent": "External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core.The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag.External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.", "key": "sqlite3_mutex_held", "sent": "The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag."}, {"API_info": "sqlite3_create_collationnot exist in API_info", "paraph": "The xDestroy callback is not called if the sqlite3_create_collation_v2_APIName function fails.Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them.This is different from every other SQLite interface.The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.", "key": "sqlite3_create_collation", "sent": "Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1.This seems counter-intuitive since clearly the mutex cannot be held if it does not exist.But the reason the mutex does not exist is because the build is not using mutexes.And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do.The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer.", "key": "sqlite3_mutex_held", "sent": "But the reason the mutex does not exist is  ."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1.This seems counter-intuitive since clearly the mutex cannot be held if it does not exist.But the reason the mutex does not exist is because the build is not using mutexes.And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do.The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer.", "key": "sqlite3_mutex_held", "sent": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1.This seems counter-intuitive since clearly the mutex cannot be held if it does not exist.But the reason the mutex does not exist is because the build is not using mutexes.And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do.The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer.", "key": "sqlite3_mutex_notheld", "sent": "The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1.This seems counter-intuitive since clearly the mutex cannot be held if it does not exist.But the reason the mutex does not exist is because the build is not using mutexes.And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do.The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer.", "key": "sqlite3_mutex_held", "sent": "This seems counter-intuitive  ."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.", "key": "sqlite3_mutex_held", "sent": "These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "#ifndef NDEBUGint"}, "paraph": "If the argument to sqlite3_mutex_held_APIName is a NULL pointer then the routine should return 1.This seems counter-intuitive since clearly the mutex cannot be held if it does not exist.But the reason the mutex does not exist is because the build is not using mutexes.And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do.The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer.", "key": "sqlite3_mutex_held", "sent": "And we do not want the assert_APIName containing the call to sqlite3_mutex_held_APIName to fail, so a non-zero return is the appropriate thing to do."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The sqlite3_wal_hook_APIName function is used to register a callback that is invoked each time data is committed to a database in wal mode.", "key": "sqlite3_wal_hook", "sent": "The sqlite3_wal_hook_APIName function is used to register a callback that is invoked each time data is committed to a database in wal mode."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or checkpoint the database as required.", "key": "sqlite3_wal_hook", "sent": "The callback is invoked by SQLite after the commit has taken place and the associated write-lock on the database released, so the implementation may read, write or checkpoint the database as required."}, {"API_info": {"var": ["sqlite3_mutex*"], "API_desc": " The sqlite3_mutex_held_APIName and sqlite3_mutex_notheld_APIName routines are intended for use inside assert_APIName statements.", "var_type": ["sqlite3_mutex*"], "ret_type": "int"}, "paraph": "The implementation is not required to provide versions of these routines that actually work.If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures.", "key": "sqlite3_mutex_notheld", "sent": "If the implementation does not provide working versions of these routines, it should at least provide stubs that always return true so that one does not get spurious assertion failures."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_sql_APIName interface returns a pointer to a copy of the UTF-8 SQL text used to create prepared statement P if P was created by sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "var_type": ["sqlite3_stmt *"], "ret_type": "const char *"}, "paraph": "For example, if a prepared statement is created using the SQL text \"SELECT $abc,:xyz\" and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql_APIName will return the original string, \"SELECT $abc,:xyz\" but sqlite3_expanded_sql_APIName will return \"SELECT 2345,NULL\".", "key": "sqlite3_sql", "sent": "For example, if a prepared statement is created using the SQL text \"SELECT $abc,:xyz\" and if parameter $abc is bound to integer 2345 and parameter :xyz is unbound, then sqlite3_sql_APIName will return the original string, \"SELECT $abc,:xyz\" but sqlite3_expanded_sql_APIName will return \"SELECT 2345,NULL\"."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook_APIName when registering the callback.The second is a copy of the database handle.The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database.The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.", "key": "sqlite3_wal_hook", "sent": "The second is a copy of the database handle."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The callback function should normally return SQLITE_OK_API_constant.If an error code is returned by sqlite3_wal_hook_APIName, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred.If the callback returns SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.", "key": "sqlite3_wal_hook", "sent": "The callback function should normally return SQLITE_OK_API_constant."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "A single database handle may have at most a single write-ahead log callback registered at one time.Calling sqlite3_wal_hook_APIName replaces any previously registered write-ahead log callback.Note that the sqlite3_wal_autocheckpoint_APIName interface and the wal_autocheckpoint pragma both invoke sqlite3_wal_hook_APIName and will overwrite any prior sqlite3_wal_hook_APIName settings.", "key": "sqlite3_wal_hook", "sent": "Calling sqlite3_wal_hook_APIName replaces any previously registered write-ahead log callback."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook_APIName when registering the callback.The second is a copy of the database handle.The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database.The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.", "key": "sqlite3_wal_hook", "sent": "The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "A single database handle may have at most a single write-ahead log callback registered at one time.Calling sqlite3_wal_hook_APIName replaces any previously registered write-ahead log callback.Note that the sqlite3_wal_autocheckpoint_APIName interface and the wal_autocheckpoint pragma both invoke sqlite3_wal_hook_APIName and will overwrite any prior sqlite3_wal_hook_APIName settings.", "key": "sqlite3_wal_hook", "sent": "A single database handle may have at most a single write-ahead log callback registered at one time."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook_APIName when registering the callback.The second is a copy of the database handle.The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database.The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.", "key": "sqlite3_wal_hook", "sent": "The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook_APIName when registering the callback."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "A single database handle may have at most a single write-ahead log callback registered at one time.Calling sqlite3_wal_hook_APIName replaces any previously registered write-ahead log callback.Note that the sqlite3_wal_autocheckpoint_APIName interface and the wal_autocheckpoint pragma both invoke sqlite3_wal_hook_APIName and will overwrite any prior sqlite3_wal_hook_APIName settings.", "key": "sqlite3_wal_hook", "sent": "Note that the sqlite3_wal_autocheckpoint_APIName interface and the wal_autocheckpoint pragma both invoke sqlite3_wal_hook_APIName and will overwrite any prior sqlite3_wal_hook_APIName settings."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The first parameter passed to the callback function when it is invoked is a copy of the third parameter passed to sqlite3_wal_hook_APIName when registering the callback.The second is a copy of the database handle.The third parameter is the name of the database that was written to - either \"main\" or the name of an ATTACH-ed database.The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed.", "key": "sqlite3_wal_hook", "sent": "The fourth parameter is the number of pages currently in the write-ahead log file, including those that were just committed."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string.The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name.sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding.", "key": "sqlite3_column_database_name16", "sent": "The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The first argument to these interfaces is a prepared statement.These functions return information about the Nth result column returned by the statement, where N is the second function argument.The left-most column is column 0 for these routines.", "key": "sqlite3_column_database_name", "sent": "The first argument to these interfaces is a prepared statement."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The first argument to these interfaces is a prepared statement.These functions return information about the Nth result column returned by the statement, where N is the second function argument.The left-most column is column 0 for these routines.", "key": "sqlite3_column_origin_name", "sent": "The left-most column is column 0 for these routines."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The names returned are the original un-aliased names of the database, table, and column.", "key": "sqlite3_column_database_name", "sent": "The names returned are the original un-aliased names of the database, table, and column."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The callback function should normally return SQLITE_OK_API_constant.If an error code is returned by sqlite3_wal_hook_APIName, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred.If the callback returns SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.", "key": "sqlite3_wal_hook", "sent": "If the callback returns SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL.These routine might also return NULL if a memory allocation error occurs.Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.", "key": "sqlite3_column_table_name", "sent": "These routine might also return NULL if a memory allocation error occurs."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string.The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name.sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding.", "key": "sqlite3_column_database_name", "sent": "These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const void *"}, "paraph": "These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string.The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name.sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding.", "key": "sqlite3_column_table_name16", "sent": "The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These APIs are only available if the library was compiled with the SQLITE_ENABLE_COLUMN_METADATA C-preprocessor symbol.", "key": "sqlite3_column_database_name", "sent": "These APIs are only available if the library was compiled with the SQLITE_ENABLE_COLUMN_METADATA C-preprocessor symbol."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "The first argument to these interfaces is a prepared statement.These functions return information about the Nth result column returned by the statement, where N is the second function argument.The left-most column is column 0 for these routines.", "key": "sqlite3_column_table_name", "sent": "These functions return information about the Nth result column returned by the statement, where N is the second function argument."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "As with all other SQLite APIs, those whose names end with \"16\" return UTF-16 encoded strings and the other functions return UTF-8.", "key": "sqlite3_column_database_name", "sent": "As with all other SQLite APIs, those whose names end with \"16\" return UTF-16 encoded strings and the other functions return UTF-8."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL.These routine might also return NULL if a memory allocation error occurs.Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.", "key": "sqlite3_column_database_name", "sent": "If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL.These routine might also return NULL if a memory allocation error occurs.Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.", "key": "sqlite3_column_origin_name", "sent": "Otherwise, they return the name of the attached database, table, or column that query result column was extracted from."}, {"API_info": {"var": ["const sqlite3_value*"], "API_desc": " The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.", "var_type": ["const sqlite3_value*"], "ret_type": "sqlite3_value *"}, "paraph": "The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.The sqlite3_value returned is a protected sqlite3_value object even if the input is not.The sqlite3_value_dup_APIName interface returns NULL if sqlite3_value_dup_APIParam_1 is NULL or if a memory allocation fails.", "key": "sqlite3_value_dup", "sent": "The sqlite3_value returned is a protected sqlite3_value object  ."}, {"API_info": {"var": ["const sqlite3_value*"], "API_desc": " The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.", "var_type": ["const sqlite3_value*"], "ret_type": "sqlite3_value *"}, "paraph": "The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.The sqlite3_value returned is a protected sqlite3_value object even if the input is not.The sqlite3_value_dup_APIName interface returns NULL if sqlite3_value_dup_APIParam_1 is NULL or if a memory allocation fails.", "key": "sqlite3_value_dup", "sent": "The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy."}, {"API_info": {"var": ["const sqlite3_value*"], "API_desc": " The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.", "var_type": ["const sqlite3_value*"], "ret_type": "sqlite3_value *"}, "paraph": "The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.The sqlite3_value returned is a protected sqlite3_value object even if the input is not.The sqlite3_value_dup_APIName interface returns NULL if sqlite3_value_dup_APIParam_1 is NULL or if a memory allocation fails.", "key": "sqlite3_value_dup", "sent": "The sqlite3_value_dup_APIName interface returns NULL if sqlite3_value_dup_APIParam_1 is NULL or if a memory allocation fails."}, {"API_info": {"var": ["const sqlite3_value*"], "API_desc": " The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.", "var_type": ["const sqlite3_value*"], "ret_type": "sqlite3_value *"}, "paraph": "The sqlite3_value_free_APIName interface frees an sqlite3_value object previously obtained from sqlite3_value_dup_APIName.If sqlite3_value_free_APIParam_1 is a NULL pointer then sqlite3_value_free_APIName is a harmless no-op.", "key": "sqlite3_value_dup", "sent": "The sqlite3_value_free_APIName interface frees an sqlite3_value object previously obtained from sqlite3_value_dup_APIName."}, {"API_info": "sqlite3_wal_hooknot exist in API_info", "paraph": "The callback function should normally return SQLITE_OK_API_constant.If an error code is returned by sqlite3_wal_hook_APIName, that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error, though the commit will have still occurred.If the callback returns SQLITE_ROW_API_constant or SQLITE_DONE_API_constant, or if it returns a value that does not correspond to any valid SQLite error code, the results are undefined.", "key": "sqlite3_wal_hook", "sent": "If an error code is returned by sqlite3_wal_hook_APIName , that error will propagate back up through the SQLite code base to cause the statement that provoked the callback to report an error ,  will have still occurred ."}, {"API_info": {"var": ["sqlite3_value*"], "API_desc": " The sqlite3_value_dup_APIName interface makes a copy of the sqlite3_value object D and returns a pointer to that copy.", "var_type": ["sqlite3_value*"], "ret_type": "void"}, "paraph": "The sqlite3_value_free_APIName interface frees an sqlite3_value object previously obtained from sqlite3_value_dup_APIName.If sqlite3_value_free_APIParam_1 is a NULL pointer then sqlite3_value_free_APIName is a harmless no-op.", "key": "sqlite3_value_free", "sent": "If sqlite3_value_free_APIParam_1 is a NULL pointer then sqlite3_value_free_APIName is a harmless no-op."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " sqlite3_vtab_on_conflict_APIName may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "sqlite3_vtab_on_conflict_APIName may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation.The value returned is one of SQLITE_ROLLBACK_API_constant, SQLITE_IGNORE_API_constant, SQLITE_FAIL_API_constant, SQLITE_ABORT_API_constant, or SQLITE_REPLACE_API_constant, according to the ON CONFLICT mode of the SQL statement that triggered the call to the xUpdate method of the virtual table.", "key": "sqlite3_vtab_on_conflict", "sent": "sqlite3_vtab_on_conflict_APIName may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "This interface is not for use by applications.It exists solely for verifying the correct operation of the SQLite library.Depending on how the SQLite library is compiled, this interface might not exist.", "key": "sqlite3_test_control", "sent": "This interface is not for use by applications."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined.", "key": "sqlite3_column_database_name", "sent": "If two or more threads call one or more of these routines against the same prepared statement and column at the same time then the results are undefined."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "This interface is not for use by applications.It exists solely for verifying the correct operation of the SQLite library.Depending on how the SQLite library is compiled, this interface might not exist.", "key": "sqlite3_test_control", "sent": "It exists solely for verifying the correct operation of the SQLite library."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "This interface is not for use by applications.It exists solely for verifying the correct operation of the SQLite library.Depending on how the SQLite library is compiled, this interface might not exist.", "key": "sqlite3_test_control", "sent": "Depending on how the SQLite library is compiled, this interface might not exist."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "If two or more threads call one or more column metadata interfaces for the same prepared statement and result column at the same time then the results are undefined.", "key": "sqlite3_column_database_name", "sent": "If two or more threads call one or more column metadata interfaces for the same prepared statement and result column at the same time then the results are undefined."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "These routines are used to register a new virtual table module name.Module names must be registered before creating a new virtual table using the module and before using a preexisting virtual table for the module.", "key": "sqlite3_create_module", "sent": "These routines are used to register a new virtual table module name."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.", "key": "sqlite3_test_control", "sent": "The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.", "key": "sqlite3_test_control", "sent": "The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The module name is registered on the database connection specified by sqlite3_create_module_APIParam_1.The name of the module is given by the second parameter.The third parameter is a pointer to the implementation of the virtual table module.The fourth parameter is an arbitrary client data pointer that is passed through into the xCreate and xConnect methods of the virtual table module when a new virtual table is be being created or reinitialized.", "key": "sqlite3_create_module", "sent": "The module name is registered on the database connection specified by sqlite3_create_module_APIParam_1."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice.Unlike most of the SQLite API, sqlite3_test_control_APIName is not guaranteed to operate consistently from one release to the next.", "key": "sqlite3_test_control", "sent": "Unlike most of the SQLite API, sqlite3_test_control_APIName is not guaranteed to operate consistently from one release to the next."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The module name is registered on the database connection specified by sqlite3_create_module_APIParam_1.The name of the module is given by the second parameter.The third parameter is a pointer to the implementation of the virtual table module.The fourth parameter is an arbitrary client data pointer that is passed through into the xCreate and xConnect methods of the virtual table module when a new virtual table is be being created or reinitialized.", "key": "sqlite3_create_module", "sent": "The name of the module is given by the second parameter."}, {"API_info": {"var": ["sqlite3_stmt*", "int"], "API_desc": " These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.", "var_type": ["sqlite3_stmt*", "int"], "ret_type": "const char *"}, "paraph": "These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in SELECT statement.The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string.The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name.sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding.", "key": "sqlite3_column_origin_name", "sent": "sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding."}, {"API_info": "sqlite3_create_module_v2 not exist in API_info", "paraph": "The module name is registered on the database connection specified by sqlite3_create_module_APIParam_1.The name of the module is given by the second parameter.The third parameter is a pointer to the implementation of the virtual table module.The fourth parameter is an arbitrary client data pointer that is passed through into the xCreate and xConnect methods of the virtual table module when a new virtual table is be being created or reinitialized.", "key": "sqlite3_create_module_v2", "sent": "The third parameter is a pointer to the implementation of the virtual table module."}, {"API_info": "sqlite3_create_module_v2 not exist in API_info", "paraph": "These routines are used to register a new virtual table module name.Module names must be registered before creating a new virtual table using the module and before using a preexisting virtual table for the module.", "key": "sqlite3_create_module_v2", "sent": "Module names must be registered before creating a new virtual table using the module and before using a preexisting virtual table for the module."}, {"API_info": {"var": ["op", " ..."], "API_desc": " The sqlite3_test_control_APIName interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice.Unlike most of the SQLite API, sqlite3_test_control_APIName is not guaranteed to operate consistently from one release to the next.", "key": "sqlite3_test_control", "sent": "The details of the operation codes, their meanings, the parameters they take, and what they do are all subject to change without notice."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " sqlite3_vtab_on_conflict_APIName may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "sqlite3_vtab_on_conflict_APIName may only be called from within a call to the xUpdate method of a virtual table implementation for an INSERT or UPDATE operation.The value returned is one of SQLITE_ROLLBACK_API_constant, SQLITE_IGNORE_API_constant, SQLITE_FAIL_API_constant, SQLITE_ABORT_API_constant, or SQLITE_REPLACE_API_constant, according to the ON CONFLICT mode of the SQL statement that triggered the call to the xUpdate method of the virtual table.", "key": "sqlite3_vtab_on_conflict", "sent": "The value returned is one of SQLITE_ROLLBACK_API_constant, SQLITE_IGNORE_API_constant, SQLITE_FAIL_API_constant, SQLITE_ABORT_API_constant, or SQLITE_REPLACE_API_constant, according to the ON CONFLICT mode of the SQL statement that triggered the call to the xUpdate method of the virtual table."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The sqlite3_create_module_v2_APIName interface has a fifth parameter which is a pointer to a destructor for the sqlite3_create_module_APIParam_4.SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the sqlite3_create_module_APIParam_4 pointer.The destructor will also be invoked if the call to sqlite3_create_module_v2_APIName fails.The sqlite3_create_module_APIName interface is equivalent to sqlite3_create_module_v2_APIName with a NULL destructor.", "key": "sqlite3_create_module", "sent": "SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the sqlite3_create_module_APIParam_4 pointer."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The sqlite3_create_module_v2_APIName interface has a fifth parameter which is a pointer to a destructor for the sqlite3_create_module_APIParam_4.SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the sqlite3_create_module_APIParam_4 pointer.The destructor will also be invoked if the call to sqlite3_create_module_v2_APIName fails.The sqlite3_create_module_APIName interface is equivalent to sqlite3_create_module_v2_APIName with a NULL destructor.", "key": "sqlite3_create_module", "sent": "The destructor will also be invoked if the call to sqlite3_create_module_v2_APIName fails."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The sqlite3_create_module_v2_APIName interface has a fifth parameter which is a pointer to a destructor for the sqlite3_create_module_APIParam_4.SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the sqlite3_create_module_APIParam_4 pointer.The destructor will also be invoked if the call to sqlite3_create_module_v2_APIName fails.The sqlite3_create_module_APIName interface is equivalent to sqlite3_create_module_v2_APIName with a NULL destructor.", "key": "sqlite3_create_module", "sent": "The sqlite3_create_module_v2_APIName interface has a fifth parameter which is a pointer to a destructor for the sqlite3_create_module_APIParam_4."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "See also: sqlite3_drop_modules_APIName", "key": "sqlite3_create_module", "sent": "See also: sqlite3_drop_modules_APIName"}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "The sqlite3_create_module_v2_APIName interface has a fifth parameter which is a pointer to a destructor for the sqlite3_create_module_APIParam_4.SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the sqlite3_create_module_APIParam_4 pointer.The destructor will also be invoked if the call to sqlite3_create_module_v2_APIName fails.The sqlite3_create_module_APIName interface is equivalent to sqlite3_create_module_v2_APIName with a NULL destructor.", "key": "sqlite3_create_module", "sent": "The sqlite3_create_module_APIName interface is equivalent to sqlite3_create_module_v2_APIName with a NULL destructor."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit.The soft heap limit is \"soft\" because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an SQLITE_NOMEM_API_constant error.In other words, the soft heap limit is advisory only.", "key": "sqlite3_soft_heap_limit64", "sent": "In other words, the soft heap limit is advisory only."}, {"API_info": {"var": ["db", "zName", "p", "pClientData"], "API_desc": " These routines are used to register a new virtual table module name.", "var_type": ["sqlite3 *", "const char *", "const sqlite3_module *", "void *"], "ret_type": "int"}, "paraph": "If sqlite3_create_module_APIParam_3 (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.", "key": "sqlite3_create_module", "sent": "If sqlite3_create_module_APIParam_3 (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit.The soft heap limit is \"soft\" because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an SQLITE_NOMEM_API_constant error.In other words, the soft heap limit is advisory only.", "key": "sqlite3_soft_heap_limit64", "sent": "The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The return value from sqlite3_soft_heap_limit64_APIName is the size of the soft heap limit prior to the call, or negative in the case of an error.If the argument sqlite3_soft_heap_limit64_APIParam_1 is negative then no change is made to the soft heap limit.Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64_APIName with a negative argument.", "key": "sqlite3_soft_heap_limit64", "sent": "If the argument sqlite3_soft_heap_limit64_APIParam_1 is negative then no change is made to the soft heap limit."}, {"API_info": "sqlite3_create_module_v2 not exist in API_info", "paraph": "The module name is registered on the database connection specified by sqlite3_create_module_APIParam_1.The name of the module is given by the second parameter.The third parameter is a pointer to the implementation of the virtual table module.The fourth parameter is an arbitrary client data pointer that is passed through into the xCreate and xConnect methods of the virtual table module when a new virtual table is be being created or reinitialized.", "key": "sqlite3_create_module_v2", "sent": "The fourth parameter is an arbitrary client data pointer that is passed through into the xCreate and xConnect methods of the virtual table module when a new virtual table is be being created or reinitialized."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "If the argument sqlite3_soft_heap_limit64_APIParam_1 is zero then the soft heap limit is disabled.", "key": "sqlite3_soft_heap_limit64", "sent": "If the argument sqlite3_soft_heap_limit64_APIParam_1 is zero then the soft heap limit is disabled."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "Beginning with SQLite version 3.7.3 (2010-10-08), the soft heap limit is enforced regardless of whether or not the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is invoked.With SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is enforced on every memory allocation.Without SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is only enforced when memory is allocated by the page cache.Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_soft_heap_limit64", "sent": "With SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is enforced on every memory allocation."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit.The soft heap limit is \"soft\" because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an SQLITE_NOMEM_API_constant error.In other words, the soft heap limit is advisory only.", "key": "sqlite3_soft_heap_limit64", "sent": "The soft heap limit is \"soft\" because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an SQLITE_NOMEM_API_constant error."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The return value from sqlite3_soft_heap_limit64_APIName is the size of the soft heap limit prior to the call, or negative in the case of an error.If the argument sqlite3_soft_heap_limit64_APIParam_1 is negative then no change is made to the soft heap limit.Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64_APIName with a negative argument.", "key": "sqlite3_soft_heap_limit64", "sent": "Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64_APIName with a negative argument."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "Beginning with SQLite version 3.7.3 (2010-10-08), the soft heap limit is enforced regardless of whether or not the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is invoked.With SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is enforced on every memory allocation.Without SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is only enforced when memory is allocated by the page cache.Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_soft_heap_limit64", "sent": "Without SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is only enforced when memory is allocated by the page cache."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:", "key": "sqlite3_soft_heap_limit64", "sent": "The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:"}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The return value from sqlite3_soft_heap_limit64_APIName is the size of the soft heap limit prior to the call, or negative in the case of an error.If the argument sqlite3_soft_heap_limit64_APIParam_1 is negative then no change is made to the soft heap limit.Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64_APIName with a negative argument.", "key": "sqlite3_soft_heap_limit64", "sent": "The return value from sqlite3_soft_heap_limit64_APIName is the size of the soft heap limit prior to the call, or negative in the case of an error."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite.", "key": "sqlite3_soft_heap_limit64", "sent": "The circumstances under which SQLite will enforce the soft heap limit may changes in future releases of SQLite."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const void *"], "ret_type": "int"}, "paraph": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.These routines return 1 if the input string appears to be a complete SQL statement.A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement.Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator.Whitespace and comments that follow the final semicolon are ignored.", "key": "sqlite3_complete16", "sent": "Whitespace and comments that follow the final semicolon are ignored."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "These routines return 0 if the statement is incomplete.If a memory allocation fails, then SQLITE_NOMEM_API_constant be returned by sqlite3_complete16_APIName.", "key": "sqlite3_complete", "sent": "These routines return 0 if the statement is incomplete."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "Beginning with SQLite version 3.7.3 (2010-10-08), the soft heap limit is enforced regardless of whether or not the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is invoked.With SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is enforced on every memory allocation.Without SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is only enforced when memory is allocated by the page cache.Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_soft_heap_limit64", "sent": "Beginning with SQLite version 3.7.3 , the soft heap limit is enforced regardless of  ."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.These routines return 1 if the input string appears to be a complete SQL statement.A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement.Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator.Whitespace and comments that follow the final semicolon are ignored.", "key": "sqlite3_complete", "sent": "These routines return 1 if the input string appears to be a complete SQL statement."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit.The soft heap limit is \"soft\" because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an SQLITE_NOMEM_API_constant error.In other words, the soft heap limit is advisory only.", "key": "sqlite3_soft_heap_limit64", "sent": "SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const void *"], "ret_type": "int"}, "paraph": "These routines return 0 if the statement is incomplete.If a memory allocation fails, then SQLITE_NOMEM_API_constant be returned by sqlite3_complete16_APIName.", "key": "sqlite3_complete16", "sent": "If a memory allocation fails, then SQLITE_NOMEM_API_constant be returned by sqlite3_complete16_APIName."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.", "key": "sqlite3_complete", "sent": "These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.These routines return 1 if the input string appears to be a complete SQL statement.A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement.Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator.Whitespace and comments that follow the final semicolon are ignored.", "key": "sqlite3_complete", "sent": "A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_soft_heap_limit64_APIName interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite.", "var_type": ["sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "Beginning with SQLite version 3.7.3 (2010-10-08), the soft heap limit is enforced regardless of whether or not the SQLITE_ENABLE_MEMORY_MANAGEMENT compile-time option is invoked.With SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is enforced on every memory allocation.Without SQLITE_ENABLE_MEMORY_MANAGEMENT, the soft heap limit is only enforced when memory is allocated by the page cache.Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_soft_heap_limit64", "sent": "Testing suggests that  , most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT ."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const void *"], "ret_type": "int"}, "paraph": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.These routines return 1 if the input string appears to be a complete SQL statement.A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement.Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator.Whitespace and comments that follow the final semicolon are ignored.", "key": "sqlite3_complete16", "sent": "Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "The input to sqlite3_complete_APIName must be a zero-terminated UTF-8 string.", "key": "sqlite3_complete", "sent": "The input to sqlite3_complete_APIName must be a zero-terminated UTF-8 string."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "If SQLite has not been initialized using sqlite3_initialize_APIName prior to invoking sqlite3_complete16_APIName then sqlite3_initialize_APIName is invoked automatically by sqlite3_complete16_APIName.If that initialization fails, then the return value from sqlite3_complete16_APIName will be non-zero regardless of whether or not the input SQL is complete.", "key": "sqlite3_complete", "sent": "If SQLite has not been initialized using sqlite3_initialize_APIName prior to invoking sqlite3_complete16_APIName then sqlite3_initialize_APIName is invoked automatically by sqlite3_complete16_APIName."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "The input to sqlite3_complete16_APIName must be a zero-terminated UTF-16 string in native byte order.", "key": "sqlite3_complete", "sent": "The input to sqlite3_complete16_APIName must be a zero-terminated UTF-16 string in native byte order."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "If SQLite has not been initialized using sqlite3_initialize_APIName prior to invoking sqlite3_complete16_APIName then sqlite3_initialize_APIName is invoked automatically by sqlite3_complete16_APIName.If that initialization fails, then the return value from sqlite3_complete16_APIName will be non-zero regardless of whether or not the input SQL is complete.", "key": "sqlite3_complete", "sent": "If that initialization fails , then the return value from sqlite3_complete16_APIName will be non-zero regardless of  ."}, {"API_info": {"var": ["const char*", " const char*", " sqlite3_int64"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char*", " const char*", " sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_uri_int64_APIName routine converts the value of sqlite3_uri_int64_APIParam_2 into a 64-bit signed integer and returns that integer, or sqlite3_uri_int64_APIParam_3 if sqlite3_uri_int64_APIParam_2 does not exist.If the value of sqlite3_uri_int64_APIParam_2 is something other than an integer, then zero be returned by sqlite3_uri_int64_APIName.", "key": "sqlite3_uri_int64", "sent": "If the value of sqlite3_uri_int64_APIParam_2 is something other than an integer, then zero be returned by sqlite3_uri_int64_APIName."}, {"API_info": {"var": ["zFilename", "zParam"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *"], "ret_type": "const char *"}, "paraph": "If sqlite3_uri_boolean_APIParam_1 is a NULL pointer, then sqlite3_uri_parameter_APIName returns NULL and sqlite3_uri_boolean_APIName returns B.If sqlite3_uri_boolean_APIParam_1 is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.", "key": "sqlite3_uri_parameter", "sent": "If sqlite3_uri_boolean_APIParam_1 is a NULL pointer, then sqlite3_uri_parameter_APIName returns NULL and sqlite3_uri_boolean_APIName returns B."}, {"API_info": {"var": ["zFilename", "zParam"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *"], "ret_type": "const char *"}, "paraph": "See the URI filename documentation for additional information.", "key": "sqlite3_uri_parameter", "sent": "See the URI filename documentation for additional information."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.", "key": "sqlite3_aggregate_context", "sent": "Implementations of aggregate SQL functions use this routine to allocate memory for storing their state."}, {"API_info": {"var": ["const char*", " const char*", " sqlite3_int64"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char*", " const char*", " sqlite3_int64"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_uri_int64_APIName routine converts the value of sqlite3_uri_int64_APIParam_2 into a 64-bit signed integer and returns that integer, or sqlite3_uri_int64_APIParam_3 if sqlite3_uri_int64_APIParam_2 does not exist.If the value of sqlite3_uri_int64_APIParam_2 is something other than an integer, then zero be returned by sqlite3_uri_int64_APIName.", "key": "sqlite3_uri_int64", "sent": "The sqlite3_uri_int64_APIName routine converts the value of sqlite3_uri_int64_APIParam_2 into a 64-bit signed integer and returns that integer, or sqlite3_uri_int64_APIParam_3 if sqlite3_uri_int64_APIParam_2 does not exist."}, {"API_info": {"var": ["sql"], "API_desc": " These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.", "var_type": ["const char *"], "ret_type": "int"}, "paraph": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing.These routines return 1 if the input string appears to be a complete SQL statement.A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement.Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator.Whitespace and comments that follow the final semicolon are ignored.", "key": "sqlite3_complete", "sent": "These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory.On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName.Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked.When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once.In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName.", "key": "sqlite3_aggregate_context", "sent": "In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName."}, {"API_info": {"var": ["zFile", "zParam", "bDefault"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_uri_boolean_APIName routine assumes that sqlite3_uri_boolean_APIParam_2 is a boolean parameter and returns true (1) or false (0) according to the value of sqlite3_uri_boolean_APIParam_2.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.The sqlite3_uri_boolean_APIName routines returns false (0) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"no\", \"false\", or \"off\" in any case or if the value begins with a numeric zero.If sqlite3_uri_boolean_APIParam_2 is not a query parameter on sqlite3_uri_boolean_APIParam_1 or if the value of sqlite3_uri_boolean_APIParam_2 is does not match any of the above, then sqlite3_uri_boolean_APIName returns (B!=0).", "key": "sqlite3_uri_boolean", "sent": "If sqlite3_uri_boolean_APIParam_2 is not a query parameter on sqlite3_uri_boolean_APIParam_1 or if the value of sqlite3_uri_boolean_APIParam_2 is does not match any of the above, then sqlite3_uri_boolean_APIName returns (B!=0)."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory.On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName.Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked.When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once.In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName.", "key": "sqlite3_aggregate_context", "sent": "On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory.On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName.Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked.When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once.In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName.", "key": "sqlite3_aggregate_context", "sent": "Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked."}, {"API_info": {"var": ["zFilename", "zParam"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *"], "ret_type": "const char *"}, "paraph": "These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.", "key": "sqlite3_uri_parameter", "sent": "These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The amount of space allocated by sqlite3_aggregate_context_APIName is determined by the sqlite3_aggregate_context_APIParam_2 parameter on first successful call.Changing the value of sqlite3_aggregate_context_APIParam_2 in subsequent call to sqlite3_aggregate_context_APIName within the same aggregate function instance will not resize the memory allocation.Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context_APIName so that no pointless memory allocations occur.", "key": "sqlite3_aggregate_context", "sent": "The amount of space allocated by sqlite3_aggregate_context_APIName is determined by the sqlite3_aggregate_context_APIParam_2 parameter on first successful call."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "SQLite automatically frees the memory allocated by sqlite3_aggregate_context_APIName when the aggregate query concludes.", "key": "sqlite3_aggregate_context", "sent": "SQLite automatically frees the memory allocated by sqlite3_aggregate_context_APIName when the aggregate query concludes."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory.On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName.Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked.When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once.In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName.", "key": "sqlite3_aggregate_context", "sent": "When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "This routine must be called from the same thread in which the aggregate SQL function is running.", "key": "sqlite3_aggregate_context", "sent": "This routine must be called from the same thread in which the aggregate SQL function is running."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The sqlite3_aggregate_context_APIName routine returns a NULL pointer when first called if sqlite3_aggregate_context_APIParam_2 is less than or equal to zero or if a memory allocate error occurs.", "key": "sqlite3_aggregate_context", "sent": "The sqlite3_aggregate_context_APIName routine returns a NULL pointer when first called if sqlite3_aggregate_context_APIParam_2 is less than or equal to zero or if a memory allocate error occurs."}, {"API_info": {"var": ["zFile", "zParam", "bDefault"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_uri_boolean_APIName routine assumes that sqlite3_uri_boolean_APIParam_2 is a boolean parameter and returns true (1) or false (0) according to the value of sqlite3_uri_boolean_APIParam_2.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.The sqlite3_uri_boolean_APIName routines returns false (0) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"no\", \"false\", or \"off\" in any case or if the value begins with a numeric zero.If sqlite3_uri_boolean_APIParam_2 is not a query parameter on sqlite3_uri_boolean_APIParam_1 or if the value of sqlite3_uri_boolean_APIParam_2 is does not match any of the above, then sqlite3_uri_boolean_APIName returns (B!=0).", "key": "sqlite3_uri_boolean", "sent": "The sqlite3_uri_boolean_APIName routines returns false (0) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"no\", \"false\", or \"off\" in any case or if the value begins with a numeric zero."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The amount of space allocated by sqlite3_aggregate_context_APIName is determined by the sqlite3_aggregate_context_APIParam_2 parameter on first successful call.Changing the value of sqlite3_aggregate_context_APIParam_2 in subsequent call to sqlite3_aggregate_context_APIName within the same aggregate function instance will not resize the memory allocation.Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context_APIName so that no pointless memory allocations occur.", "key": "sqlite3_aggregate_context", "sent": "Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context_APIName so that no pointless memory allocations occur."}, {"API_info": {"var": ["zFilename", "zParam"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *"], "ret_type": "const char *"}, "paraph": "If sqlite3_uri_boolean_APIParam_1 is a NULL pointer, then sqlite3_uri_parameter_APIName returns NULL and sqlite3_uri_boolean_APIName returns B.If sqlite3_uri_boolean_APIParam_1 is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.", "key": "sqlite3_uri_parameter", "sent": "If sqlite3_uri_boolean_APIParam_1 is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The amount of space allocated by sqlite3_aggregate_context_APIName is determined by the sqlite3_aggregate_context_APIParam_2 parameter on first successful call.Changing the value of sqlite3_aggregate_context_APIParam_2 in subsequent call to sqlite3_aggregate_context_APIName within the same aggregate function instance will not resize the memory allocation.Within the xFinal callback, it is customary to set N=0 in calls to sqlite3_aggregate_context_APIName so that no pointless memory allocations occur.", "key": "sqlite3_aggregate_context", "sent": "Changing the value of sqlite3_aggregate_context_APIParam_2 in subsequent call to sqlite3_aggregate_context_APIName within the same aggregate function instance will not resize the memory allocation."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory.On second and subsequent calls to sqlite3_aggregate_context_APIName for the same aggregate function instance, the same buffer be returned by sqlite3_aggregate_context_APIName.Sqlite3_aggregate_context_APIName is normally called once for each invocation of the xStep callback and then one last time when the xFinal callback is invoked.When no rows match an aggregate query, the xStep_APIName callback of the aggregate function implementation is never called and xFinal_APIName is called exactly once.In those cases, sqlite3_aggregate_context_APIName might be called for the first time from within xFinal_APIName.", "key": "sqlite3_aggregate_context", "sent": "The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates sqlite3_aggregate_context_APIParam_2 of memory, zeroes out that memory, and returns a pointer to the new memory."}, {"API_info": {"var": ["zFile", "zParam", "bDefault"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_uri_boolean_APIName routine assumes that sqlite3_uri_boolean_APIParam_2 is a boolean parameter and returns true (1) or false (0) according to the value of sqlite3_uri_boolean_APIParam_2.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.The sqlite3_uri_boolean_APIName routines returns false (0) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"no\", \"false\", or \"off\" in any case or if the value begins with a numeric zero.If sqlite3_uri_boolean_APIParam_2 is not a query parameter on sqlite3_uri_boolean_APIParam_1 or if the value of sqlite3_uri_boolean_APIParam_2 is does not match any of the above, then sqlite3_uri_boolean_APIName returns (B!=0).", "key": "sqlite3_uri_boolean", "sent": "The sqlite3_uri_boolean_APIName routine assumes that sqlite3_uri_boolean_APIParam_2 is a boolean parameter and returns true (1) or false (0) according to the value of sqlite3_uri_boolean_APIParam_2.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number."}, {"API_info": {"var": ["sqlite3_context*", "nBytes"], "API_desc": " Implementations of aggregate SQL functions use this routine to allocate memory for storing their state.The first time the sqlite3_aggregate_context_APIName routine is called for a particular aggregate function, SQLite allocates N of memory, zeroes out that memory, and returns a pointer to the new memory.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void *"}, "paraph": "The first parameter must be a copy of the SQL function context that is sqlite3_aggregate_context_APIParam_1 to the xStep or xFinal callback routine that implements the aggregate function.", "key": "sqlite3_aggregate_context", "sent": "The first parameter must be a copy of the SQL function context that is sqlite3_aggregate_context_APIParam_1 to the xStep or xFinal callback routine that implements the aggregate function."}, {"API_info": {"var": ["const char *", " const char *"], "API_desc": " The sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of \"case independence\" that SQLite uses internally when comparing identifiers.", "var_type": ["const char *", " const char *"], "ret_type": "int"}, "paraph": "The sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of \"case independence\" that SQLite uses internally when comparing identifiers.", "key": "sqlite3_stricmp", "sent": "The sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName APIs allow applications and extensions to compare the contents of two buffers containing UTF-8 strings in a case-independent fashion, using the same definition of \"case independence\" that SQLite uses internally when comparing identifiers."}, {"API_info": {"var": ["zFilename", "zParam"], "API_desc": " These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.If F is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI or SQLITE_OPEN_MAIN_DB bits set and P is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F.  If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.The sqlite3_uri_boolean_APIName routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P.  The sqlite3_uri_boolean_APIName routine returns true (1) if the value of query parameter P is one of \"yes\", \"true\", or \"on\" in any case or if the value begins with a non-zero number.", "var_type": ["const char *", "const char *"], "ret_type": "const char *"}, "paraph": "If sqlite3_uri_parameter_APIParam_1 is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI_API_constant or SQLITE_OPEN_MAIN_DB_API_constant bits set and sqlite3_uri_parameter_APIParam_2 is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the sqlite3_uri_parameter_APIParam_2 parameter if it exists or a NULL pointer if sqlite3_uri_parameter_APIParam_2 does not appear as a query parameter on sqlite3_uri_parameter_APIParam_1.  If sqlite3_uri_parameter_APIParam_2 is a query parameter of sqlite3_uri_parameter_APIParam_1 has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string.", "key": "sqlite3_uri_parameter", "sent": "If sqlite3_uri_parameter_APIParam_1 is the database filename pointer passed into the xOpen_APIName method of a VFS implementation when the flags parameter to xOpen_APIName has one or more of the SQLITE_OPEN_URI_API_constant or SQLITE_OPEN_MAIN_DB_API_constant bits set and sqlite3_uri_parameter_APIParam_2 is the name of the query parameter, then sqlite3_uri_parameter_APIName returns the value of the sqlite3_uri_parameter_APIParam_2 parameter if it exists or a NULL pointer if sqlite3_uri_parameter_APIParam_2 does not appear as a query parameter on sqlite3_uri_parameter_APIParam_1.  If sqlite3_uri_parameter_APIParam_2 is a query parameter of sqlite3_uri_parameter_APIParam_1 has no explicit value, then sqlite3_uri_parameter_APIName returns a pointer to an empty string."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Extension loading is off by default.Call the sqlite3_enable_load_extension_APIName routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.", "key": "sqlite3_enable_load_extension", "sent": "Extension loading is off by default."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "This interface enables or disables both the C-API sqlite3_load_extension_APIName and the SQL function load_extension_APIName.Use sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant,..) to enable or disable only the C-API.", "key": "sqlite3_enable_load_extension", "sent": "Use sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant,..) to enable or disable only the C-API."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "This interface enables or disables both the C-API sqlite3_load_extension_APIName and the SQL function load_extension_APIName.Use sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant,..) to enable or disable only the C-API.", "key": "sqlite3_enable_load_extension", "sent": "This interface enables or disables both the C-API sqlite3_load_extension_APIName and the SQL function load_extension_APIName."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Security warning: It is recommended that extension loading be disabled using the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method rather than this interface, so the load_extension_APIName SQL function remains disabled.This will prevent SQL injections from giving attackers access to extension loading capabilities.", "key": "sqlite3_enable_load_extension", "sent": "This will prevent SQL injections from giving attackers access to extension loading capabilities."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_isexplain_APIName interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_isexplain_APIName interface returns 1 if the prepared statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN statement, or 2 if the statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN QUERY PLAN.The sqlite3_stmt_isexplain_APIName interface returns 0 if sqlite3_stmt_isexplain_APIParam_1 is an ordinary statement or a NULL pointer.", "key": "sqlite3_stmt_isexplain", "sent": "The sqlite3_stmt_isexplain_APIName interface returns 0 if sqlite3_stmt_isexplain_APIParam_1 is an ordinary statement or a NULL pointer."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Extension loading is off by default.Call the sqlite3_enable_load_extension_APIName routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again.", "key": "sqlite3_enable_load_extension", "sent": "Call the sqlite3_enable_load_extension_APIName routine with onoff==1 to turn extension loading on and call it with onoff==0 to turn it back off again."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_libversion", "sent": "The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Security warning: It is recommended that extension loading be disabled using the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method rather than this interface, so the load_extension_APIName SQL function remains disabled.This will prevent SQL injections from giving attackers access to extension loading capabilities.", "key": "sqlite3_enable_load_extension", "sent": "Security warning: It is recommended that extension loading be disabled using the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method rather than this interface, so the load_extension_APIName SQL function remains disabled."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "See also: sqlite_version_APIName and sqlite_source_id_APIName.", "key": "sqlite3_libversion", "sent": "See also: sqlite_version_APIName and sqlite_source_id_APIName."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_isexplain_APIName interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_isexplain_APIName interface returns 1 if the prepared statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN statement, or 2 if the statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN QUERY PLAN.The sqlite3_stmt_isexplain_APIName interface returns 0 if sqlite3_stmt_isexplain_APIParam_1 is an ordinary statement or a NULL pointer.", "key": "sqlite3_stmt_isexplain", "sent": "The sqlite3_stmt_isexplain_APIName interface returns 1 if the prepared statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN statement, or 2 if the statement sqlite3_stmt_isexplain_APIParam_1 is an EXPLAIN QUERY PLAN."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.This routine is typically called in response to a user action such as pressing \"Cancel\" or Ctrl-C where the user wants a long query operation to halt immediately.", "key": "sqlite3_interrupt", "sent": "sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_libversion", "sent": "The sqlite3_libversion_APIName function is provided for use in DLLs  ."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_sourceid", "sent": "The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "An SQL operation that is interrupted will return SQLITE_INTERRUPT_API_constant.If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.", "key": "sqlite3_interrupt", "sent": "An SQL operation that is interrupted will return SQLITE_INTERRUPT_API_constant."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "It is safe to call this routine from a thread different from the thread that is currently running the database operation.But it is not safe to call this routine with a database connection that is closed or might close before sqlite3_interrupt_APIName returns.", "key": "sqlite3_interrupt", "sent": "It is safe to call this routine from a thread different from the thread that is currently running the database operation."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "These interfaces provide the same information as the SQLITE_VERSION_API_constant, SQLITE_VERSION_API_constant_NUMBER, and SQLITE_SOURCE_ID_API_constant C preprocessor macros but are associated with the library instead of the header file.Cautious programmers might include assert_APIName statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.", "key": "sqlite3_libversion", "sent": "These interfaces provide the same information as the SQLITE_VERSION_API_constant, SQLITE_VERSION_API_constant_NUMBER, and SQLITE_SOURCE_ID_API_constant C preprocessor macros but are associated with the library instead of the header file."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "It is safe to call this routine from a thread different from the thread that is currently running the database operation.But it is not safe to call this routine with a database connection that is closed or might close before sqlite3_interrupt_APIName returns.", "key": "sqlite3_interrupt", "sent": "But it is not safe to call this routine with a database connection that is closed or might close before sqlite3_interrupt_APIName returns."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_libversion", "sent": "Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "The sqlite3_interrupt_APIName call is in effect until all currently running SQL statements on database connection sqlite3_interrupt_APIParam_1 complete.Any new SQL statements that are started after the sqlite3_interrupt_APIName call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt_APIName call.New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt_APIName.A call to sqlite3_interrupt_APIName that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt_APIName call returns.", "key": "sqlite3_interrupt", "sent": "The sqlite3_interrupt_APIName call is in effect until all currently running SQL statements on database connection sqlite3_interrupt_APIParam_1 complete."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_libversion", "sent": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "These interfaces provide the same information as the SQLITE_VERSION_API_constant, SQLITE_VERSION_API_constant_NUMBER, and SQLITE_SOURCE_ID_API_constant C preprocessor macros but are associated with the library instead of the header file.Cautious programmers might include assert_APIName statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.", "key": "sqlite3_sourceid", "sent": "Cautious programmers might include assert_APIName statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "The sqlite3_interrupt_APIName call is in effect until all currently running SQL statements on database connection sqlite3_interrupt_APIParam_1 complete.Any new SQL statements that are started after the sqlite3_interrupt_APIName call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt_APIName call.New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt_APIName.A call to sqlite3_interrupt_APIName that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt_APIName call returns.", "key": "sqlite3_interrupt", "sent": "New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "If an SQL operation is very nearly finished at the time when sqlite3_interrupt_APIName is called, then it might not have an opportunity to be interrupted and might continue to completion.", "key": "sqlite3_interrupt", "sent": "If an SQL operation is very nearly finished at the time when sqlite3_interrupt_APIName is called, then it might not have an opportunity to be interrupted and might continue to completion."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "SQLITE_OK_API_constant be returned by sqlite3_snapshot_recover_APIName if successful, or an SQLite error code otherwise.", "key": "sqlite3_snapshot_recover", "sent": "SQLITE_OK_API_constant be returned by sqlite3_snapshot_recover_APIName if successful, or an SQLite error code otherwise."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option.", "key": "sqlite3_snapshot_recover", "sent": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_SNAPSHOT option."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.This routine is typically called in response to a user action such as pressing \"Cancel\" or Ctrl-C where the user wants a long query operation to halt immediately.", "key": "sqlite3_interrupt", "sent": "This routine is typically called in response to a user action such as pressing \"Cancel\" or Ctrl-C where the user wants a long query operation to halt immediately."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "An SQL operation that is interrupted will return SQLITE_INTERRUPT_API_constant.If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.", "key": "sqlite3_interrupt", "sent": "If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically."}, {"API_info": {"var": ["db", "onoff"], "API_desc": " So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.Extension loading is off by default.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off.", "key": "sqlite3_enable_load_extension", "sent": "So as not to open security holes in older applications that are unprepared to deal with extension loading, and as a means of disabling extension loading while evaluating user-entered SQL, the following API is provided to turn the sqlite3_load_extension_APIName mechanism on and off."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.", "key": "sqlite3_snapshot_recover", "sent": "sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists.The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist.If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not.If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.", "key": "sqlite3_table_column_metadata", "sent": "The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists.The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist.If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not.If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.", "key": "sqlite3_table_column_metadata", "sent": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "The sqlite3_interrupt_APIName call is in effect until all currently running SQL statements on database connection sqlite3_interrupt_APIParam_1 complete.Any new SQL statements that are started after the sqlite3_interrupt_APIName call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt_APIName call.New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt_APIName.A call to sqlite3_interrupt_APIName that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt_APIName call returns.", "key": "sqlite3_interrupt", "sent": "A call to sqlite3_interrupt_APIName that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt_APIName call returns."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.", "key": "sqlite3_snapshot_recover", "sent": "It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The column is identified by the second, third and fourth parameters to sqlite3_table_column_metadata_APIName.The second parameter is either the name of the database (i.e.\"main\", \"temp\", or an attached database) containing the specified table or NULL.If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.", "key": "sqlite3_table_column_metadata", "sent": "The column is identified by the second, third and fourth parameters to sqlite3_table_column_metadata_APIName."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The column is identified by the second, third and fourth parameters to sqlite3_table_column_metadata_APIName.The second parameter is either the name of the database (i.e.\"main\", \"temp\", or an attached database) containing the specified table or NULL.If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.", "key": "sqlite3_table_column_metadata", "sent": "\"main\", \"temp\", or an attached database) containing the specified table or NULL."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_interrupt_APIName causes any pending database operation to abort and return at its earliest opportunity.", "var_type": ["sqlite3*"], "ret_type": "void"}, "paraph": "The sqlite3_interrupt_APIName call is in effect until all currently running SQL statements on database connection sqlite3_interrupt_APIParam_1 complete.Any new SQL statements that are started after the sqlite3_interrupt_APIName call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt_APIName call.New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt_APIName.A call to sqlite3_interrupt_APIName that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt_APIName call returns.", "key": "sqlite3_interrupt", "sent": "Any new SQL statements that are started after the sqlite3_interrupt_APIName call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt_APIName call."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists.The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist.If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not.If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.", "key": "sqlite3_table_column_metadata", "sent": "The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists.The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist.If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not.If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.", "key": "sqlite3_table_column_metadata", "sent": "If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "Metadata is returned by sqlite3_table_column_metadata_APIName by writing to the memory locations passed as the 5th and subsequent parameters to sqlite3_table_column_metadata_APIName.Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.", "key": "sqlite3_table_column_metadata", "sent": "Metadata is returned by sqlite3_table_column_metadata_APIName by writing to the memory locations passed as the 5_APIConstant and subsequent parameters to sqlite3_table_column_metadata_APIName."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The third and fourth parameters to sqlite3_table_column_metadata_APIName are the table and column name of the desired column, respectively.", "key": "sqlite3_table_column_metadata", "sent": "The third and fourth parameters to sqlite3_table_column_metadata_APIName are the table and column name of the desired column, respectively."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "Metadata is returned by sqlite3_table_column_metadata_APIName by writing to the memory locations passed as the 5th and subsequent parameters to sqlite3_table_column_metadata_APIName.Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.", "key": "sqlite3_table_column_metadata", "sent": "Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "If the specified table is actually a view, an error code be returned by sqlite3_table_column_metadata_APIName.", "key": "sqlite3_table_column_metadata", "sent": "If the specified table is actually a view, an error code be returned by sqlite3_table_column_metadata_APIName."}, {"API_info": {"var": ["void"], "API_desc": " These interfaces provide the same information as the SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C preprocessor macros but are associated with the library instead of the header file.", "var_type": ["void"], "ret_type": "const char *"}, "paraph": "The sqlite3_version[] string constant contains the text of SQLITE_VERSION_API_constant macro.The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant.The sqlite3_libversion_APIName function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL.The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER.The sqlite3_sourceid_APIName function returns a pointer to a string constant whose value is the same as the SQLITE_SOURCE_ID_API_constant C preprocessor macro.Except if SQLite is built using an edited copy of the amalgamation, then the last four characters of the hash might be different from SQLITE_SOURCE_ID_API_constant.", "key": "sqlite3_libversion", "sent": "The sqlite3_libversion_APIName function returns a pointer to the to the sqlite3_version[] string constant."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The column is identified by the second, third and fourth parameters to sqlite3_table_column_metadata_APIName.The second parameter is either the name of the database (i.e.\"main\", \"temp\", or an attached database) containing the specified table or NULL.If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.", "key": "sqlite3_table_column_metadata", "sent": "If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references."}, {"API_info": {"var": ["sqlite3_stmt*", "zName"], "API_desc": " Return the index of an SQL parameter given its name.", "var_type": ["sqlite3_stmt*", "const char *"], "ret_type": "int"}, "paraph": "Return the index of an SQL parameter given its name.The index value returned is suitable for use as the second parameter to sqlite3_bind_APIName.A zero be returned by sqlite3_bind_parameter_index_APIName if no matching parameter is found.The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_index", "sent": "Return the index of an SQL parameter given its name."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "If the specified column is \"rowid\", \"oid\" or \"_rowid_\" and the table is not a WITHOUT ROWID table and an INTEGER PRIMARY KEY column has been explicitly declared, then the output parameters are set for the explicitly declared column.If there is no INTEGER PRIMARY KEY column, then the outputs for the rowid are set as follows:", "key": "sqlite3_table_column_metadata", "sent": "If there is no INTEGER PRIMARY KEY column, then the outputs for the rowid are set as follows:"}, {"API_info": {"var": ["sqlite3_stmt*", "zName"], "API_desc": " Return the index of an SQL parameter given its name.", "var_type": ["sqlite3_stmt*", "const char *"], "ret_type": "int"}, "paraph": "Return the index of an SQL parameter given its name.The index value returned is suitable for use as the second parameter to sqlite3_bind_APIName.A zero be returned by sqlite3_bind_parameter_index_APIName if no matching parameter is found.The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_index", "sent": "The index value returned is suitable for use as the second parameter to sqlite3_bind_APIName."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The column is identified by the second, third and fourth parameters to sqlite3_table_column_metadata_APIName.The second parameter is either the name of the database (i.e.\"main\", \"temp\", or an attached database) containing the specified table or NULL.If it is NULL, then all attached databases are searched for the table using the same algorithm used by the database engine to resolve unqualified table references.", "key": "sqlite3_table_column_metadata", "sent": "The second parameter is either the name of the database (i.e."}, {"API_info": {"var": ["sqlite3_stmt*", "zName"], "API_desc": " Return the index of an SQL parameter given its name.", "var_type": ["sqlite3_stmt*", "const char *"], "ret_type": "int"}, "paraph": "Return the index of an SQL parameter given its name.The index value returned is suitable for use as the second parameter to sqlite3_bind_APIName.A zero be returned by sqlite3_bind_parameter_index_APIName if no matching parameter is found.The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_index", "sent": "A zero be returned by sqlite3_bind_parameter_index_APIName if no matching parameter is found."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function.", "key": "sqlite3_table_column_metadata", "sent": "The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function."}, {"API_info": {"var": ["sqlite3_stmt*", "zName"], "API_desc": " Return the index of an SQL parameter given its name.", "var_type": ["sqlite3_stmt*", "const char *"], "ret_type": "int"}, "paraph": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_count_APIName, and sqlite3_bind_parameter_name_APIName.", "key": "sqlite3_bind_parameter_index", "sent": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_count_APIName, and sqlite3_bind_parameter_name_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", "zName"], "API_desc": " Return the index of an SQL parameter given its name.", "var_type": ["sqlite3_stmt*", "const char *"], "ret_type": "int"}, "paraph": "Return the index of an SQL parameter given its name.The index value returned is suitable for use as the second parameter to sqlite3_bind_APIName.A zero be returned by sqlite3_bind_parameter_index_APIName if no matching parameter is found.The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using sqlite3_prepare16_v2_APIName or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_index", "sent": "The parameter name must be given in UTF-8  ."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "The sqlite3_strlike_APIName function matches Unicode characters, though only ASCII characters are case folded.", "key": "sqlite3_strlike", "sent": "The sqlite3_strlike_APIName function matches Unicode characters ,  ."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "See also: sqlite3_strglob_APIName.", "key": "sqlite3_strlike", "sent": "See also: sqlite3_strglob_APIName."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists.The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist.If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not.If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.", "key": "sqlite3_table_column_metadata", "sent": "If the column-name parameter to sqlite3_table_column_metadata_APIName is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant if the table exists and SQLITE_ERROR_API_constant if it does not."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "The sqlite3_strlike_APIName interface returns zero if and only if string sqlite3_strlike_APIParam_2 matches the LIKE pattern sqlite3_strlike_APIParam_1 with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE sqlite3_strlike_APIParam_1 ESCAPE E\" operator in the SQL dialect understood by SQLite.For \"X LIKE P\" without the ESCAPE clause, set the sqlite3_strlike_APIParam_3 parameter of sqlite3_strlike_APIName to 0.As with the LIKE operator, the sqlite3_strlike_APIName function is case insensitive - equivalent upper and lower case ASCII characters match one another.", "key": "sqlite3_strlike", "sent": "For \"X LIKE P\" without the ESCAPE clause, set the sqlite3_strlike_APIParam_3 parameter of sqlite3_strlike_APIName to 0."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "The sqlite3_strlike_APIName interface returns zero if and only if string sqlite3_strlike_APIParam_2 matches the LIKE pattern sqlite3_strlike_APIParam_1 with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE sqlite3_strlike_APIParam_1 ESCAPE E\" operator in the SQL dialect understood by SQLite.For \"X LIKE P\" without the ESCAPE clause, set the sqlite3_strlike_APIParam_3 parameter of sqlite3_strlike_APIName to 0.As with the LIKE operator, the sqlite3_strlike_APIName function is case insensitive - equivalent upper and lower case ASCII characters match one another.", "key": "sqlite3_strlike", "sent": "As with the LIKE operator, the sqlite3_strlike_APIName function is case insensitive - equivalent upper and lower case ASCII characters match one another."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.Memory used to cache database pages to improve performance is an example of non-essential memory.sqlite3_release_memory_APIName returns the number of bytes actually freed, which might be more or less than the amount requested.The sqlite3_release_memory_APIName routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_release_memory", "sent": "Memory used to cache database pages to improve performance is an example of non-essential memory."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.", "var_type": ["int"], "ret_type": "int"}, "paraph": "See also: sqlite3_db_release_memory_APIName", "key": "sqlite3_release_memory", "sent": "See also: sqlite3_db_release_memory_APIName"}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.Memory used to cache database pages to improve performance is an example of non-essential memory.sqlite3_release_memory_APIName returns the number of bytes actually freed, which might be more or less than the amount requested.The sqlite3_release_memory_APIName routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_release_memory", "sent": "sqlite3_release_memory_APIName returns the number of bytes actually freed, which might be more or less than the amount requested."}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "sqlite3_table_column_metadata_APIName causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.", "key": "sqlite3_table_column_metadata", "sent": "sqlite3_table_column_metadata_APIName causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.Memory used to cache database pages to improve performance is an example of non-essential memory.sqlite3_release_memory_APIName returns the number of bytes actually freed, which might be more or less than the amount requested.The sqlite3_release_memory_APIName routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_release_memory", "sent": "The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "Note that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName.", "key": "sqlite3_strlike", "sent": "Note that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName."}, {"API_info": {"var": ["int"], "API_desc": " The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The sqlite3_release_memory_APIName interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library.Memory used to cache database pages to improve performance is an example of non-essential memory.sqlite3_release_memory_APIName returns the number of bytes actually freed, which might be more or less than the amount requested.The sqlite3_release_memory_APIName routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT.", "key": "sqlite3_release_memory", "sent": "The sqlite3_release_memory_APIName routine is a no-op returning zero if SQLite is not compiled with SQLITE_ENABLE_MEMORY_MANAGEMENT."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.Executing any other type of SQL statement does not modify the value returned by sqlite3_changes_APIName.", "key": "sqlite3_changes", "sent": "Executing any other type of SQL statement does not modify the value returned by sqlite3_changes_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Changes to a view that are intercepted by INSTEAD OF triggers are not counted.The value returned by sqlite3_changes_APIName immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.Only changes made to real tables are counted.", "key": "sqlite3_changes", "sent": "Changes to a view that are intercepted by INSTEAD OF triggers are not counted."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Changes to a view that are intercepted by INSTEAD OF triggers are not counted.The value returned by sqlite3_changes_APIName immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.Only changes made to real tables are counted.", "key": "sqlite3_changes", "sent": "Only changes made to real tables are counted."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Things are more complicated if the sqlite3_changes_APIName function is executed while a trigger program is running.This may happen if the program uses the changes_APIName SQL function, or if some other callback function invokes sqlite3_changes_APIName directly.Essentially:", "key": "sqlite3_changes", "sent": "Essentially:"}, {"API_info": {"var": ["db", "zDbName", "zTableName", "zColumnName", "pzDataType", "pzCollSeq", "pNotNull", "pPrimaryKey", "pAutoinc"], "API_desc": " The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on database connection X.", "var_type": ["sqlite3 *", "const char *", "const char *", "const char *", "char const **", "char const **", "int *", "int *", "int *"], "ret_type": "int"}, "paraph": "If the specified column is \"rowid\", \"oid\" or \"_rowid_\" and the table is not a WITHOUT ROWID table and an INTEGER PRIMARY KEY column has been explicitly declared, then the output parameters are set for the explicitly declared column.If there is no INTEGER PRIMARY KEY column, then the outputs for the rowid are set as follows:", "key": "sqlite3_table_column_metadata", "sent": "If the specified column is \"rowid\", \"oid\" or \"_rowid_\" and the table is not a WITHOUT ROWID table and an INTEGER PRIMARY KEY column has been explicitly declared, then the output parameters are set for the explicitly declared column."}, {"API_info": {"var": ["zGlob", "zStr", "cEsc"], "API_desc": "The sqlite3_strlike_APIName interface returns zero if and only if string X matches the LIKE pattern P with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE P ESCAPE E\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *", "unsigned int"], "ret_type": "int"}, "paraph": "The sqlite3_strlike_APIName interface returns zero if and only if string sqlite3_strlike_APIParam_2 matches the LIKE pattern sqlite3_strlike_APIParam_1 with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE sqlite3_strlike_APIParam_1 ESCAPE E\" operator in the SQL dialect understood by SQLite.For \"X LIKE P\" without the ESCAPE clause, set the sqlite3_strlike_APIParam_3 parameter of sqlite3_strlike_APIName to 0.As with the LIKE operator, the sqlite3_strlike_APIName function is case insensitive - equivalent upper and lower case ASCII characters match one another.", "key": "sqlite3_strlike", "sent": "The sqlite3_strlike_APIName interface returns zero if and only if string sqlite3_strlike_APIParam_2 matches the LIKE pattern sqlite3_strlike_APIParam_1 with escape character E. The definition of LIKE pattern matching used in sqlite3_strlike_APIName is the same as for the \"X LIKE sqlite3_strlike_APIParam_1 ESCAPE E\" operator in the SQL dialect understood by SQLite."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Things are more complicated if the sqlite3_changes_APIName function is executed while a trigger program is running.This may happen if the program uses the changes_APIName SQL function, or if some other callback function invokes sqlite3_changes_APIName directly.Essentially:", "key": "sqlite3_changes", "sent": "Things are more complicated if the sqlite3_changes_APIName function is executed while a trigger program is running."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "See also:", "key": "sqlite3_changes", "sent": "See also:"}, {"API_info": {"var": ["zGlob", "zStr"], "API_desc": "The sqlite3_strglob_APIName interface returns zero if and only if string X matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *"], "ret_type": "int"}, "paraph": "The sqlite3_strglob_APIName interface returns zero if and only if string sqlite3_strglob_APIParam_2 matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.The sqlite3_strglob_APIName function is case sensitive.", "key": "sqlite3_strglob", "sent": "The sqlite3_strglob_APIName function is case sensitive."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Changes to a view that are intercepted by INSTEAD OF triggers are not counted.The value returned by sqlite3_changes_APIName immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.Only changes made to real tables are counted.", "key": "sqlite3_changes", "sent": "The value returned by sqlite3_changes_APIName immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Things are more complicated if the sqlite3_changes_APIName function is executed while a trigger program is running.This may happen if the program uses the changes_APIName SQL function, or if some other callback function invokes sqlite3_changes_APIName directly.Essentially:", "key": "sqlite3_changes", "sent": "This may happen if the program uses the changes_APIName SQL function, or if some other callback function invokes sqlite3_changes_APIName directly."}, {"API_info": {"var": ["zGlob", "zStr"], "API_desc": "The sqlite3_strglob_APIName interface returns zero if and only if string X matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *"], "ret_type": "int"}, "paraph": "See also: sqlite3_strlike_APIName.", "key": "sqlite3_strglob", "sent": "See also: sqlite3_strlike_APIName."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "These interfaces are available only on Windows."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.Executing any other type of SQL statement does not modify the value returned by sqlite3_changes_APIName.", "key": "sqlite3_changes", "sent": "sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "WinRT and UWP."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If a separate thread makes changes on the same database connection while sqlite3_changes_APIName is running then the value returned is unpredictable and not meaningful.", "key": "sqlite3_changes", "sent": "If a separate thread makes changes on the same database connection while sqlite3_changes_APIName is running then the value returned is unpredictable and not meaningful."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by triggers, foreign key actions or REPLACE constraint resolution are not counted.", "key": "sqlite3_changes", "sent": "Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by triggers, foreign key actions or REPLACE constraint resolution are not counted."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.See sqlite3_create_function_APIName and sqlite3_create_function16_APIName for additional information.", "key": "sqlite3_result_null", "sent": "See sqlite3_create_function_APIName and sqlite3_create_function16_APIName for additional information."}, {"API_info": "sqlite3_result_blob not exist in API_info", "paraph": "These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.See sqlite3_create_function_APIName and sqlite3_create_function16_APIName for additional information.", "key": "sqlite3_result_blob", "sent": "These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates."}, {"API_info": {"var": ["zGlob", "zStr"], "API_desc": "The sqlite3_strglob_APIName interface returns zero if and only if string X matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *"], "ret_type": "int"}, "paraph": "Note that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName.", "key": "sqlite3_strglob", "sent": "Note that this routine returns zero on a match and non-zero if the strings do not match, the same as sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "These functions work very much like the parameter binding family of functions used to bind values to host parameters in prepared statements.Refer to the SQL parameter documentation for additional information.", "key": "sqlite3_result_null", "sent": "Refer to the SQL parameter documentation for additional information."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "This means that if the changes_APIName SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing.If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.", "key": "sqlite3_changes", "sent": "This means that if the changes_APIName SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing."}, {"API_info": {"var": ["zGlob", "zStr"], "API_desc": "The sqlite3_strglob_APIName interface returns zero if and only if string X matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.", "var_type": ["const char *", "const char *"], "ret_type": "int"}, "paraph": "The sqlite3_strglob_APIName interface returns zero if and only if string sqlite3_strglob_APIParam_2 matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite.The sqlite3_strglob_APIName function is case sensitive.", "key": "sqlite3_strglob", "sent": "The sqlite3_strglob_APIName interface returns zero if and only if string sqlite3_strglob_APIParam_2 matches the GLOB pattern P. The definition of GLOB pattern matching used in sqlite3_strglob_APIName is the same as for the \"X GLOB P\" operator in the SQL dialect understood by SQLite."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used."}, {"API_info": "sqlite3_result_blob not exist in API_info", "paraph": "These functions work very much like the parameter binding family of functions used to bind values to host parameters in prepared statements.Refer to the SQL parameter documentation for additional information.", "key": "sqlite3_result_blob", "sent": "These functions work very much like the parameter binding family of functions used to bind values to host parameters in prepared statements."}, {"API_info": {"var": ["type", "zValue"], "API_desc": " These interfaces are available only on Windows.", "var_type": ["unsigned long", "void *"], "ret_type": "int"}, "paraph": "These interfaces are available only on Windows.The sqlite3_win32_set_directory interface is used to set the value associated with the sqlite3_temp_directory or sqlite3_data_directory variable, to sqlite3_win32_set_directory_APIParam_2, depending on the value of the sqlite3_win32_set_directory_APIParam_1 parameter.The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free; a non-NULL value will be copied into memory obtained from sqlite3_malloc prior to being used.The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated.The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g.WinRT and UWP.The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.", "key": "sqlite3_win32_set_directory", "sent": "The value of the sqlite3_data_directory variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g."}, {"API_info": {"var": ["sqlite3_context*", " double"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " double"], "ret_type": "void"}, "paraph": "The sqlite3_result_double_APIName interface sets the result from an application-defined function to be a floating point value specified by its 2_APIConstant argument.", "key": "sqlite3_result_double", "sent": "The sqlite3_result_double_APIName interface sets the result from an application-defined function to be a floating point value specified by its 2_APIConstant argument."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_changes_APIName returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "This means that if the changes_APIName SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing.If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.", "key": "sqlite3_changes", "sent": "If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger."}, {"API_info": {"var": ["sqlite3_context*", "n"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", "int"], "ret_type": "void"}, "paraph": "The sqlite3_result_zeroblob_APIName and sqlite3_result_zeroblob64_APIName interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and sqlite3_result_zeroblob64_APIParam_2 bytes in size.", "key": "sqlite3_result_zeroblob", "sent": "The sqlite3_result_zeroblob_APIName and sqlite3_result_zeroblob64_APIName interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and sqlite3_result_zeroblob64_APIParam_2 bytes in size."}, {"API_info": {"var": ["db", "zDb"], "API_desc": " If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.sqlite3_snapshot_recover_APIName attempts to scan the WAL file associated with database sqlite3_snapshot_recover_APIParam_2 of database handle sqlite3_snapshot_recover_APIParam_1 and make all valid snapshots available to sqlite3_snapshot_open_APIName.", "var_type": ["sqlite3 *", "const char *"], "ret_type": "int"}, "paraph": "If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL_API_constant file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.", "key": "sqlite3_snapshot_recover", "sent": "If a WAL file remains on disk after all database connections close (either through the use of the SQLITE_FCNTL_PERSIST_WAL_API_constant file control or because the last process to have the database opened exited without calling sqlite3_close_APIName) and a new connection is subsequently opened on that database and WAL file, the sqlite3_snapshot_open_APIName interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "SQLite uses the string pointed to by the 2_APIConstant parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_blob_APIName interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.", "key": "sqlite3_result_blob", "sent": "The sqlite3_result_blob_APIName interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "Hence, the calling function can deallocate or modify the text after they return without harm."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "By default, the error code is SQLITE_ERROR_API_constant."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_nomem_APIName interface causes SQLite to throw an error indicating that a memory allocation failed.", "key": "sqlite3_result_error", "sent": "The sqlite3_result_error_nomem_APIName interface causes SQLite to throw an error indicating that a memory allocation failed."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_APIName and sqlite3_result_error16_APIName functions cause the implemented SQL function to throw an exception.SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error_APIName or sqlite3_result_error16_APIName as the text of an error message.SQLite interprets the error message string from sqlite3_result_error_APIName as UTF-8.SQLite interprets the string from sqlite3_result_error16_APIName as UTF-16 in native byte order.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character.If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is non-negative then SQLite takes that many bytes (not characters) from the 2_APIConstant parameter as the error message.The sqlite3_result_error_APIName and sqlite3_result_error16_APIName routines make a private copy of the error message text before they return.Hence, the calling function can deallocate or modify the text after they return without harm.The sqlite3_result_error_code_APIName function changes the error code returned by SQLite as a result of an error in a function.By default, the error code is SQLITE_ERROR_API_constant.A subsequent call to sqlite3_result_error_APIName or sqlite3_result_error16_APIName resets the error code to SQLITE_ERROR_API_constant.", "key": "sqlite3_result_error", "sent": "If sqlite3_result_error_APIParam_3 to sqlite3_result_error_APIName or sqlite3_result_error16_APIName is negative then SQLite takes as the error message all text up through the first zero character."}, {"API_info": {"var": ["sqlite3_context*", " const char*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " const char*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_error_toobig_APIName interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.", "key": "sqlite3_result_error", "sent": "The sqlite3_result_error_toobig_APIName interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "The sqlite3_result_null_APIName interface sets the return value of the application-defined function to be NULL.", "key": "sqlite3_result_null", "sent": "The sqlite3_result_null_APIName interface sets the return value of the application-defined function to be NULL."}, {"API_info": "sqlite3_result_textnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_text", "sent": "SQLite takes the text result from the application from the 2_APIConstant parameter of the sqlite3_result_text* interfaces."}, {"API_info": {"var": ["sqlite3_context*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_int_APIName interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2_APIConstant argument.The sqlite3_result_int64_APIName interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2_APIConstant argument.", "key": "sqlite3_result_int", "sent": "The sqlite3_result_int_APIName interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2_APIConstant argument."}, {"API_info": {"var": ["sqlite3_context*", " int"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " int"], "ret_type": "void"}, "paraph": "The sqlite3_result_int_APIName interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2_APIConstant argument.The sqlite3_result_int64_APIName interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2_APIConstant argument.", "key": "sqlite3_result_int", "sent": "The sqlite3_result_int64_APIName interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2_APIConstant argument."}, {"API_info": "sqlite3_result_textnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_text", "sent": "If the 3_APIConstant parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2_APIConstant parameter through the first zero character."}, {"API_info": {"var": ["sqlite3_context*", " sqlite3_value*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " sqlite3_value*"], "ret_type": "void"}, "paraph": "The sqlite3_result_value_APIName interface sets the result of the application-defined function to be a copy of the unprotected sqlite3_value object specified by the 2_APIConstant parameter.The sqlite3_result_value_APIName interface makes a copy of the sqlite3_value so that the sqlite3_value specified in the parameter may change or be deallocated after sqlite3_result_value_APIName returns without harm.A protected sqlite3_value object may always be used where an unprotected sqlite3_value object is required, so either kind of sqlite3_value object can be used with this interface.", "key": "sqlite3_result_value", "sent": "The sqlite3_result_value_APIName interface sets the result of the application-defined function to be a copy of the unprotected sqlite3_value object specified by the 2_APIConstant parameter."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_blob", "sent": "If the 3_APIConstant parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated."}, {"API_info": "sqlite3_result_pointernot exist in API_info", "paraph": "The sqlite3_result_pointer_APIName interface sets the result to an SQL NULL value, just like sqlite3_result_null_APIName, except that it also associates the host-language pointer sqlite3_result_pointer_APIParam_2 or type sqlite3_result_pointer_APIParam_3 with that NULL value such that the pointer can be retrieved within an application-defined SQL function using sqlite3_value_pointer_APIName.If the sqlite3_result_pointer_APIParam_4 parameter is not NULL, then it is a pointer to a destructor for the sqlite3_result_pointer_APIParam_2 parameter.SQLite invokes sqlite3_result_pointer_APIParam_4 with sqlite3_result_pointer_APIParam_2 as its only argument when SQLite is finished with sqlite3_result_pointer_APIParam_2.  The sqlite3_result_pointer_APIParam_3 parameter should be a static string and preferably a string literal.The sqlite3_result_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_result_pointer", "sent": "The sqlite3_result_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "The sqlite3_result_pointer_APIName interface sets the result to an SQL NULL value, just like sqlite3_result_null_APIName, except that it also associates the host-language pointer sqlite3_result_pointer_APIParam_2 or type sqlite3_result_pointer_APIParam_3 with that NULL value such that the pointer can be retrieved within an application-defined SQL function using sqlite3_value_pointer_APIName.If the sqlite3_result_pointer_APIParam_4 parameter is not NULL, then it is a pointer to a destructor for the sqlite3_result_pointer_APIParam_2 parameter.SQLite invokes sqlite3_result_pointer_APIParam_4 with sqlite3_result_pointer_APIParam_2 as its only argument when SQLite is finished with sqlite3_result_pointer_APIParam_2.  The sqlite3_result_pointer_APIParam_3 parameter should be a static string and preferably a string literal.The sqlite3_result_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_result_null", "sent": "If the sqlite3_result_pointer_APIParam_4 parameter is not NULL, then it is a pointer to a destructor for the sqlite3_result_pointer_APIParam_2 parameter."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "The sqlite3_result_pointer_APIName interface sets the result to an SQL NULL value, just like sqlite3_result_null_APIName, except that it also associates the host-language pointer sqlite3_result_pointer_APIParam_2 or type sqlite3_result_pointer_APIParam_3 with that NULL value such that the pointer can be retrieved within an application-defined SQL function using sqlite3_value_pointer_APIName.If the sqlite3_result_pointer_APIParam_4 parameter is not NULL, then it is a pointer to a destructor for the sqlite3_result_pointer_APIParam_2 parameter.SQLite invokes sqlite3_result_pointer_APIParam_4 with sqlite3_result_pointer_APIParam_2 as its only argument when SQLite is finished with sqlite3_result_pointer_APIParam_2.  The sqlite3_result_pointer_APIParam_3 parameter should be a static string and preferably a string literal.The sqlite3_result_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_result_null", "sent": "SQLite invokes sqlite3_result_pointer_APIParam_4 with sqlite3_result_pointer_APIParam_2 as its only argument when SQLite is finished with sqlite3_result_pointer_APIParam_2.  The sqlite3_result_pointer_APIParam_3 parameter should be a static string and preferably a string literal."}, {"API_info": {"var": ["sqlite3_snapshot*"], "API_desc": " The sqlite3_snapshot_free_APIName interface destroys sqlite3_snapshot P. The application must eventually free every sqlite3_snapshot object using this routine to avoid a memory leak.The sqlite3_snapshot_free_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.", "var_type": ["sqlite3_snapshot*"], "ret_type": "void"}, "paraph": "The sqlite3_snapshot_free_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.", "key": "sqlite3_snapshot_free", "sent": "The sqlite3_snapshot_free_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used."}, {"API_info": "sqlite3_result_textnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_text", "sent": "If the 3_APIConstant parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2_APIConstant parameter are taken as the application-defined function result."}, {"API_info": {"var": ["sqlite3_snapshot*"], "API_desc": " The sqlite3_snapshot_free_APIName interface destroys sqlite3_snapshot P. The application must eventually free every sqlite3_snapshot object using this routine to avoid a memory leak.The sqlite3_snapshot_free_APIName interface is only available when the SQLITE_ENABLE_SNAPSHOT compile-time option is used.", "var_type": ["sqlite3_snapshot*"], "ret_type": "void"}, "paraph": "The sqlite3_snapshot_free_APIName interface destroys sqlite3_snapshot P. The application must eventually free every sqlite3_snapshot object using this routine to avoid a memory leak.", "key": "sqlite3_snapshot_free", "sent": "The sqlite3_snapshot_free_APIName interface destroys sqlite3_snapshot P. The application must eventually free every sqlite3_snapshot object using this routine to avoid a memory leak."}, {"API_info": {"var": ["sqlite3_context*", " sqlite3_value*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " sqlite3_value*"], "ret_type": "void"}, "paraph": "The sqlite3_result_value_APIName interface sets the result of the application-defined function to be a copy of the unprotected sqlite3_value object specified by the 2_APIConstant parameter.The sqlite3_result_value_APIName interface makes a copy of the sqlite3_value so that the sqlite3_value specified in the parameter may change or be deallocated after sqlite3_result_value_APIName returns without harm.A protected sqlite3_value object may always be used where an unprotected sqlite3_value object is required, so either kind of sqlite3_value object can be used with this interface.", "key": "sqlite3_result_value", "sent": "The sqlite3_result_value_APIName interface makes a copy of the sqlite3_value so that the sqlite3_value specified in the parameter may change or be deallocated after sqlite3_result_value_APIName returns without harm."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED_API_constant error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained.See SQLite Shared-Cache Mode for a description of shared-cache locking.This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it.This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined.", "key": "sqlite3_unlock_notify", "sent": "See SQLite Shared-Cache Mode for a description of shared-cache locking."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "See Also: Using the SQLite Unlock Notification Feature.", "key": "sqlite3_unlock_notify", "sent": "See Also: Using the SQLite Unlock Notification Feature."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_blob", "sent": "If the 4_APIConstant parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED_API_constant error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained.See SQLite Shared-Cache Mode for a description of shared-cache locking.This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it.This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined.", "key": "sqlite3_unlock_notify", "sent": "This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED_API_constant error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained.See SQLite Shared-Cache Mode for a description of shared-cache locking.This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it.This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined.", "key": "sqlite3_unlock_notify", "sent": "This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it."}, {"API_info": {"var": ["sqlite3_context*", " sqlite3_value*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*", " sqlite3_value*"], "ret_type": "void"}, "paraph": "The sqlite3_result_value_APIName interface sets the result of the application-defined function to be a copy of the unprotected sqlite3_value object specified by the 2_APIConstant parameter.The sqlite3_result_value_APIName interface makes a copy of the sqlite3_value so that the sqlite3_value specified in the parameter may change or be deallocated after sqlite3_result_value_APIName returns without harm.A protected sqlite3_value object may always be used where an unprotected sqlite3_value object is required, so either kind of sqlite3_value object can be used with this interface.", "key": "sqlite3_result_value", "sent": "A protected sqlite3_value object may always be used where an unprotected sqlite3_value object is required, so either kind of sqlite3_value object can be used with this interface."}, {"API_info": "sqlite3_result_textnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_text", "sent": "The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE."}, {"API_info": "sqlite3_result_blob not exist in API_info", "paraph": "If these routines are called from within the different thread than the one containing the application-defined function that received the sqlite3_context pointer, the results are undefined.", "key": "sqlite3_result_blob", "sent": "If these routines are called from within the different thread than the one containing the application-defined function that received the sqlite3_context pointer, the results are undefined."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_blob", "sent": "If the 4_APIConstant parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally.After an application receives an SQLITE_LOCKED_API_constant error, it may call the sqlite3_unlock_notify_APIName method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded.The callback is invoked from within the sqlite3_step or sqlite3_close call that concludes the blocking connections transaction.", "key": "sqlite3_unlock_notify", "sent": "The callback is invoked from within the sqlite3_step or sqlite3_close call that concludes the blocking connections transaction."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "If sqlite3_unlock_notify_APIName is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify_APIName is invoked.If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify_APIName.", "key": "sqlite3_unlock_notify", "sent": "If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify_APIName."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "There may be at most one unlock-notify callback registered by a blocked connection.If sqlite3_unlock_notify_APIName is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old.If sqlite3_unlock_notify_APIName is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled.The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close_APIName.", "key": "sqlite3_unlock_notify", "sent": "There may be at most one unlock-notify callback registered by a blocked connection."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.", "key": "sqlite3_unlock_notify", "sent": "Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "The unlock-notify callback is not reentrant.If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.", "key": "sqlite3_unlock_notify", "sent": "The unlock-notify callback is not reentrant."}, {"API_info": "sqlite3_result_textnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_text", "sent": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "There may be at most one unlock-notify callback registered by a blocked connection.If sqlite3_unlock_notify_APIName is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old.If sqlite3_unlock_notify_APIName is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled.The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close_APIName.", "key": "sqlite3_unlock_notify", "sent": "The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close_APIName."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Unless deadlock is detected (see below), sqlite3_unlock_notify_APIName always returns SQLITE_OK_API_constant.", "key": "sqlite3_unlock_notify", "sent": "Unless deadlock is detected (see below), sqlite3_unlock_notify_APIName always returns SQLITE_OK_API_constant."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Callback Invocation Details", "key": "sqlite3_unlock_notify", "sent": "Callback Invocation Details"}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED_API_constant error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained.See SQLite Shared-Cache Mode for a description of shared-cache locking.This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it.This API is only available if the library was compiled with the SQLITE_ENABLE_UNLOCK_NOTIFY C-preprocessor symbol defined.", "key": "sqlite3_unlock_notify", "sent": "When running in shared-cache mode, a database operation may fail with an SQLITE_LOCKED_API_constant error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "There may be at most one unlock-notify callback registered by a blocked connection.If sqlite3_unlock_notify_APIName is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old.If sqlite3_unlock_notify_APIName is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled.The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close_APIName.", "key": "sqlite3_unlock_notify", "sent": "If sqlite3_unlock_notify_APIName is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "There may be at most one unlock-notify callback registered by a blocked connection.If sqlite3_unlock_notify_APIName is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old.If sqlite3_unlock_notify_APIName is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled.The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using sqlite3_close_APIName.", "key": "sqlite3_unlock_notify", "sent": "If sqlite3_unlock_notify_APIName is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "If sqlite3_unlock_notify_APIName is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify_APIName is invoked.If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify_APIName.", "key": "sqlite3_unlock_notify", "sent": "If sqlite3_unlock_notify_APIName is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify_APIName is invoked."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "The unlock-notify callback is not reentrant.If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.", "key": "sqlite3_unlock_notify", "sent": "If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked.However, the signature of the callback function allows SQLite to pass it an array of void* context pointers.The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.", "key": "sqlite3_unlock_notify", "sent": "However, the signature of the callback function allows SQLite to pass it an array of void* context pointers."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally.After an application receives an SQLITE_LOCKED_API_constant error, it may call the sqlite3_unlock_notify_APIName method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded.The callback is invoked from within the sqlite3_step or sqlite3_close call that concludes the blocking connections transaction.", "key": "sqlite3_unlock_notify", "sent": "When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Deadlock Detection", "key": "sqlite3_unlock_notify", "sent": "Deadlock Detection"}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked.However, the signature of the callback function allows SQLite to pass it an array of void* context pointers.The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.", "key": "sqlite3_unlock_notify", "sent": "When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection.If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered.The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded.Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A.Any number of levels of indirection are allowed.", "key": "sqlite3_unlock_notify", "sent": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback.If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array.This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.", "key": "sqlite3_unlock_notify", "sent": "This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback.If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array.This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.", "key": "sqlite3_unlock_notify", "sent": "When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_blob", "sent": "If any NUL characters occur in the string at a byte offset that is less than the value of the 3_APIConstant parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "The \"DROP TABLE\" Exception", "key": "sqlite3_unlock_notify", "sent": "The \"DROP TABLE\" Exception"}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection.If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered.The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded.Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A.Any number of levels of indirection are allowed.", "key": "sqlite3_unlock_notify", "sent": "Any number of levels of indirection are allowed."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "There is however, one exception."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked.However, the signature of the callback function allows SQLite to pass it an array of void* context pointers.The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.", "key": "sqlite3_unlock_notify", "sent": "The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally.After an application receives an SQLITE_LOCKED_API_constant error, it may call the sqlite3_unlock_notify_APIName method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded.The callback is invoked from within the sqlite3_step or sqlite3_close call that concludes the blocking connections transaction.", "key": "sqlite3_unlock_notify", "sent": "After an application receives an SQLITE_LOCKED_API_constant error, it may call the sqlite3_unlock_notify_APIName method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded."}, {"API_info": "sqlite3_result_blobnot exist in API_info", "paraph": "The sqlite3_result_text_APIName, sqlite3_result_text16_APIName, sqlite3_result_text16le_APIName, and sqlite3_result_text16be_APIName interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively.The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE.SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces.If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character.If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result.If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated.If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result.If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT_API_constant then SQLite makes a copy of the result into space obtained from sqlite3_malloc_APIName before it returns.", "key": "sqlite3_result_blob", "sent": "If the 4_APIConstant parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC_API_constant, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection.If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered.The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded.Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A.Any number of levels of indirection are allowed.", "key": "sqlite3_unlock_notify", "sent": "If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock.For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.", "key": "sqlite3_unlock_notify", "sent": "Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "One way around this problem is to check the extended error code returned by an sqlite3_step_APIName call.If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_API_constant_SHAREDCACHE.Otherwise, in the special \"DROP TABLE/INDEX\" case, the extended error code is just SQLITE_LOCKED_API_constant.", "key": "sqlite3_unlock_notify", "sent": "One way around this problem is to check the extended error code returned by an sqlite3_step_APIName call."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "One way around this problem is to check the extended error code returned by an sqlite3_step_APIName call.If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_API_constant_SHAREDCACHE.Otherwise, in the special \"DROP TABLE/INDEX\" case, the extended error code is just SQLITE_LOCKED_API_constant.", "key": "sqlite3_unlock_notify", "sent": "If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_API_constant_SHAREDCACHE."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "One way around this problem is to check the extended error code returned by an sqlite3_step_APIName call.If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_API_constant_SHAREDCACHE.Otherwise, in the special \"DROP TABLE/INDEX\" case, the extended error code is just SQLITE_LOCKED_API_constant.", "key": "sqlite3_unlock_notify", "sent": "Otherwise, in the special \"DROP TABLE/INDEX\" case, the extended error code is just SQLITE_LOCKED_API_constant."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a call to sqlite3_step_APIName returns SQLITE_LOCKED_API_constant, it is almost always appropriate to call sqlite3_unlock_notify_APIName.There is however, one exception.When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection.If there are, SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName.In this case there is no \"blocking connection\", so invoking sqlite3_unlock_notify_APIName results in the unlock-notify callback being invoked immediately.If the application then re-attempts the \"DROP TABLE\" or \"DROP INDEX\" query, an infinite loop might be the result.", "key": "sqlite3_unlock_notify", "sent": "When executing a \"DROP TABLE\" or \"DROP INDEX\" statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.For attached databases, this is the name that appears after the AS keyword in the ATTACH statement.For the main database file, the database name is \"main\".For TEMP tables, the database name is \"temp\".", "key": "sqlite3_blob_open", "sent": "For the main database file, the database name is \"main\"."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.For attached databases, this is the name that appears after the AS keyword in the ATTACH statement.For the main database file, the database name is \"main\".For TEMP tables, the database name is \"temp\".", "key": "sqlite3_blob_open", "sent": "For TEMP tables, the database name is \"temp\"."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.For attached databases, this is the name that appears after the AS keyword in the ATTACH statement.For the main database file, the database name is \"main\".For TEMP tables, the database name is \"temp\".", "key": "sqlite3_blob_open", "sent": "Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.For attached databases, this is the name that appears after the AS keyword in the ATTACH statement.For the main database file, the database name is \"main\".For TEMP tables, the database name is \"temp\".", "key": "sqlite3_blob_open", "sent": "For attached databases, this is the name that appears after the AS keyword in the ATTACH statement."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates.", "var_type": ["sqlite3_context*"], "ret_type": "void"}, "paraph": "The sqlite3_result_pointer_APIName interface sets the result to an SQL NULL value, just like sqlite3_result_null_APIName, except that it also associates the host-language pointer sqlite3_result_pointer_APIParam_2 or type sqlite3_result_pointer_APIParam_3 with that NULL value such that the pointer can be retrieved within an application-defined SQL function using sqlite3_value_pointer_APIName.If the sqlite3_result_pointer_APIParam_4 parameter is not NULL, then it is a pointer to a destructor for the sqlite3_result_pointer_APIParam_2 parameter.SQLite invokes sqlite3_result_pointer_APIParam_4 with sqlite3_result_pointer_APIParam_2 as its only argument when SQLite is finished with sqlite3_result_pointer_APIParam_2.  The sqlite3_result_pointer_APIParam_3 parameter should be a static string and preferably a string literal.The sqlite3_result_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_result_null", "sent": "The sqlite3_result_pointer_APIName interface sets the result to an SQL NULL value, just like sqlite3_result_null_APIName, except that it also associates the host-language pointer sqlite3_result_pointer_APIParam_2 or type sqlite3_result_pointer_APIParam_3 with that NULL value such that the pointer can be retrieved within an application-defined SQL function using sqlite3_value_pointer_APIName."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the sqlite3_blob_open_APIParam_6 parameter is non-zero, then the BLOB is opened for read and write access.If the sqlite3_blob_open_APIParam_6 parameter is zero, the BLOB is opened for read-only access.", "key": "sqlite3_blob_open", "sent": "If the sqlite3_blob_open_APIParam_6 parameter is zero, the BLOB is opened for read-only access."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the sqlite3_blob_open_APIParam_6 parameter is non-zero, then the BLOB is opened for read and write access.If the sqlite3_blob_open_APIParam_6 parameter is zero, the BLOB is opened for read-only access.", "key": "sqlite3_blob_open", "sent": "If the sqlite3_blob_open_APIParam_6 parameter is non-zero, then the BLOB is opened for read and write access."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.", "key": "sqlite3_unlock_notify", "sent": "If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "sqlite3_blob_open_APIName fails with SQLITE_ERROR_API_constant if any of the following are true:", "key": "sqlite3_blob_open", "sent": "sqlite3_blob_open_APIName fails with SQLITE_ERROR_API_constant if any of the following are true:"}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock.For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.", "key": "sqlite3_unlock_notify", "sent": "For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "On success, SQLITE_OK_API_constant be returned by sqlite3_blob_open_APIName and the new BLOB handle is stored in *ppBlob.Otherwise an error code be returned by sqlite3_blob_open_APIName and, unless the error code is SQLITE_MISUSE_API_constant, *ppBlob is set to NULL.This means that, provided the API is not misused, it is always safe to call sqlite3_blob_close_APIName on *ppBlob after sqlite3_blob_open_APIName sqlite3_blob_open_APIName returns.", "key": "sqlite3_blob_open", "sent": "On success, SQLITE_OK_API_constant be returned by sqlite3_blob_open_APIName and the new BLOB handle is stored in *ppBlob."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "A BLOB referenced by sqlite3_blob_open_APIName may be read using the sqlite3_blob_read_APIName interface and modified by using sqlite3_blob_write_APIName.The BLOB handle can be moved to a different row of the same table using the sqlite3_blob_reopen_APIName interface.However, the column, table, or database of a BLOB handle cannot be changed after the BLOB handle is opened.", "key": "sqlite3_blob_open", "sent": "A BLOB referenced by sqlite3_blob_open_APIName may be read using the sqlite3_blob_read_APIName interface and modified by using sqlite3_blob_write_APIName."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "A BLOB referenced by sqlite3_blob_open_APIName may be read using the sqlite3_blob_read_APIName interface and modified by using sqlite3_blob_write_APIName.The BLOB handle can be moved to a different row of the same table using the sqlite3_blob_reopen_APIName interface.However, the column, table, or database of a BLOB handle cannot be changed after the BLOB handle is opened.", "key": "sqlite3_blob_open", "sent": "The BLOB handle can be moved to a different row of the same table using the sqlite3_blob_reopen_APIName interface."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback.If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array.This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.", "key": "sqlite3_unlock_notify", "sent": "If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Unless sqlite3_blob_open_APIName returns SQLITE_MISUSE_API_constant, sqlite3_blob_open_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions.", "key": "sqlite3_blob_open", "sent": "Unless sqlite3_blob_open_APIName returns SQLITE_MISUSE_API_constant, sqlite3_blob_open_APIName sets the database connection error code and message accessible via sqlite3_errcode_APIName and sqlite3_errmsg_APIName and related functions."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\".This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on.Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant.Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB.Such changes will eventually commit if the transaction continues to completion.", "key": "sqlite3_blob_open", "sent": "Such changes will eventually commit if the transaction continues to completion."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "On success, SQLITE_OK_API_constant be returned by sqlite3_blob_open_APIName and the new BLOB handle is stored in *ppBlob.Otherwise an error code be returned by sqlite3_blob_open_APIName and, unless the error code is SQLITE_MISUSE_API_constant, *ppBlob is set to NULL.This means that, provided the API is not misused, it is always safe to call sqlite3_blob_close_APIName on *ppBlob after sqlite3_blob_open_APIName sqlite3_blob_open_APIName returns.", "key": "sqlite3_blob_open", "sent": "Otherwise an error code be returned by sqlite3_blob_open_APIName and, unless the error code is SQLITE_MISUSE_API_constant, *ppBlob is set to NULL."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "On success, SQLITE_OK_API_constant be returned by sqlite3_blob_open_APIName and the new BLOB handle is stored in *ppBlob.Otherwise an error code be returned by sqlite3_blob_open_APIName and, unless the error code is SQLITE_MISUSE_API_constant, *ppBlob is set to NULL.This means that, provided the API is not misused, it is always safe to call sqlite3_blob_close_APIName on *ppBlob after sqlite3_blob_open_APIName sqlite3_blob_open_APIName returns.", "key": "sqlite3_blob_open", "sent": "This means that, provided the API is not misused, it is always safe to call sqlite3_blob_close_APIName on *ppBlob after sqlite3_blob_open_APIName sqlite3_blob_open_APIName returns."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection.If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered.The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded.Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A.Any number of levels of indirection are allowed.", "key": "sqlite3_unlock_notify", "sent": "Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Use the sqlite3_blob_bytes_APIName interface to determine the size of the opened blob.The size of a blob may not be changed by this interface.Use the UPDATE SQL command to change the size of a blob.", "key": "sqlite3_blob_open", "sent": "Use the sqlite3_blob_bytes_APIName interface to determine the size of the opened blob."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Use the sqlite3_blob_bytes_APIName interface to determine the size of the opened blob.The size of a blob may not be changed by this interface.Use the UPDATE SQL command to change the size of a blob.", "key": "sqlite3_blob_open", "sent": "The size of a blob may not be changed by this interface."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\".This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on.Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant.Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB.Such changes will eventually commit if the transaction continues to completion.", "key": "sqlite3_blob_open", "sent": "Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\".This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on.Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant.Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB.Such changes will eventually commit if the transaction continues to completion.", "key": "sqlite3_blob_open", "sent": "Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "Use the sqlite3_blob_bytes_APIName interface to determine the size of the opened blob.The size of a blob may not be changed by this interface.Use the UPDATE SQL command to change the size of a blob.", "key": "sqlite3_blob_open", "sent": "Use the UPDATE SQL command to change the size of a blob."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:", "key": "sqlite3_blob_open", "sent": "This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:"}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "A BLOB referenced by sqlite3_blob_open_APIName may be read using the sqlite3_blob_read_APIName interface and modified by using sqlite3_blob_write_APIName.The BLOB handle can be moved to a different row of the same table using the sqlite3_blob_reopen_APIName interface.However, the column, table, or database of a BLOB handle cannot be changed after the BLOB handle is opened.", "key": "sqlite3_blob_open", "sent": "However, the column, table, or database of a BLOB handle cannot be changed after the BLOB handle is opened."}, {"API_info": "sqlite3_unlock_notifynot exist in API_info", "paraph": "To avoid this scenario, the sqlite3_unlock_notify_APIName performs deadlock detection.If a given call to sqlite3_unlock_notify_APIName would put the system in a deadlocked state, then SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered.The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded.Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A.Any number of levels of indirection are allowed.", "key": "sqlite3_unlock_notify", "sent": "The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\".This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on.Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant.Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB.Such changes will eventually commit if the transaction continues to completion.", "key": "sqlite3_blob_open", "sent": "This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\".This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on.Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant.Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB.Such changes will eventually commit if the transaction continues to completion.", "key": "sqlite3_blob_open", "sent": "If the row that a BLOB handle points to is modified by an UPDATE, DELETE, or by ON CONFLICT side-effects then the BLOB handle is marked as \"expired\"."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "The sqlite3_bind_zeroblob_APIName and sqlite3_result_zeroblob_APIName interfaces and the built-in zeroblob SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface.", "key": "sqlite3_blob_open", "sent": "The sqlite3_bind_zeroblob_APIName and sqlite3_result_zeroblob_APIName interfaces and the built-in zeroblob SQL function may be used to create a zero-filled blob to read or write using the incremental-blob interface."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "See also: sqlite3_blob_close_APIName, sqlite3_blob_reopen_APIName, sqlite3_blob_read_APIName, sqlite3_blob_bytes_APIName, sqlite3_blob_write_APIName.", "key": "sqlite3_blob_open", "sent": "See also: sqlite3_blob_close_APIName, sqlite3_blob_reopen_APIName, sqlite3_blob_read_APIName, sqlite3_blob_bytes_APIName, sqlite3_blob_write_APIName."}, {"API_info": {"var": ["  sqlite3*", "zDb", "zTable", "zColumn", "iRow", "flags", "ppBlob"], "API_desc": " This interfaces opens a handle to the BLOB located in row sqlite3_blob_open_APIParam_5, column sqlite3_blob_open_APIParam_4, table sqlite3_blob_open_APIParam_3 in database sqlite3_blob_open_APIParam_2; in other words, the same BLOB that would be selected by:Parameter sqlite3_blob_open_APIParam_2 is not the filename that contains the database, but rather the symbolic name of the database.", "var_type": ["  sqlite3*", "const char *", "const char *", "const char *", "sqlite3_int64", "int", "sqlite3_blob **"], "ret_type": "int"}, "paraph": "To avoid a resource leak, every open BLOB handle should eventually be released by a call to sqlite3_blob_close_APIName.", "key": "sqlite3_blob_open", "sent": "To avoid a resource leak, every open BLOB handle should eventually be released by a call to sqlite3_blob_close_APIName."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.The handler will sleep multiple times until at least \"ms\" milliseconds of sleeping have accumulated.After at least \"ms\" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step_APIName to return SQLITE_BUSY_API_constant.", "key": "sqlite3_busy_timeout", "sent": "The handler will sleep multiple times until at least \"ms\" milliseconds of sleeping have accumulated."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.The handler will sleep multiple times until at least \"ms\" milliseconds of sleeping have accumulated.After at least \"ms\" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step_APIName to return SQLITE_BUSY_API_constant.", "key": "sqlite3_busy_timeout", "sent": "This routine sets a busy handler that sleeps for a specified amount of time when a table is locked."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "See also:  PRAGMA busy_timeout", "key": "sqlite3_busy_timeout", "sent": "See also:  PRAGMA busy_timeout"}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "There can only be a single busy handler for a particular database connection at any given moment.If another busy handler was defined  (using sqlite3_busy_handler_APIName) prior to calling this routine, that other busy handler is cleared.", "key": "sqlite3_busy_timeout", "sent": "If another busy handler was defined  (using sqlite3_busy_handler_APIName) prior to calling this routine, that other busy handler is cleared."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.The handler will sleep multiple times until at least \"ms\" milliseconds of sleeping have accumulated.After at least \"ms\" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step_APIName to return SQLITE_BUSY_API_constant.", "key": "sqlite3_busy_timeout", "sent": "After at least \"ms\" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step_APIName to return SQLITE_BUSY_API_constant."}, {"API_info": {"var": ["pStmt"], "API_desc": " Return the number of columns in the result set returned by the prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Return the number of columns in the result set returned by the prepared statement.If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE).However, just because this routine returns a positive number does not mean that one or more rows of data will be returned.A SELECT statement will always have a positive sqlite3_column_count_APIName but depending on the WHERE clause constraints and the table content, it might return no rows.", "key": "sqlite3_column_count", "sent": "Return the number of columns in the result set returned by the prepared statement."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "Calling this routine with an argument less than or equal to zero turns off all busy handlers.", "key": "sqlite3_busy_timeout", "sent": "Calling this routine with an argument less than or equal to zero turns off all busy handlers."}, {"API_info": {"var": ["pStmt"], "API_desc": " Return the number of columns in the result set returned by the prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "See also: sqlite3_data_count_APIName", "key": "sqlite3_column_count", "sent": "See also: sqlite3_data_count_APIName"}, {"API_info": {"var": ["pStmt"], "API_desc": " Return the number of columns in the result set returned by the prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Return the number of columns in the result set returned by the prepared statement.If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE).However, just because this routine returns a positive number does not mean that one or more rows of data will be returned.A SELECT statement will always have a positive sqlite3_column_count_APIName but depending on the WHERE clause constraints and the table content, it might return no rows.", "key": "sqlite3_column_count", "sent": "If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE)."}, {"API_info": {"var": ["sqlite3*", "ms"], "API_desc": " This routine sets a busy handler that sleeps for a specified amount of time when a table is locked.", "var_type": ["sqlite3*", "int"], "ret_type": "int"}, "paraph": "There can only be a single busy handler for a particular database connection at any given moment.If another busy handler was defined  (using sqlite3_busy_handler_APIName) prior to calling this routine, that other busy handler is cleared.", "key": "sqlite3_busy_timeout", "sent": "There can only be a single busy handler for a particular database connection at any given moment."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The preferred routine to use is sqlite3_prepare_v2_APIName.The sqlite3_prepare_APIName interface is legacy and should be avoided.sqlite3_prepare_v3_APIName has an extra \"prepFlags\" option that is used for special purposes.", "key": "sqlite3_prepare", "sent": "The preferred routine to use is sqlite3_prepare_v2_APIName."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.Or, in other words, these routines are constructors for the prepared statement object.", "key": "sqlite3_prepare16", "sent": "Or, in other words, these routines are constructors for the prepared statement object."}, {"API_info": {"var": ["pStmt"], "API_desc": " Return the number of columns in the result set returned by the prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Return the number of columns in the result set returned by the prepared statement.If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE).However, just because this routine returns a positive number does not mean that one or more rows of data will be returned.A SELECT statement will always have a positive sqlite3_column_count_APIName but depending on the WHERE clause constraints and the table content, it might return no rows.", "key": "sqlite3_column_count", "sent": "However, just because this routine returns a positive number does not mean that one or more rows of data will be returned."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The preferred routine to use is sqlite3_prepare_v2_APIName.The sqlite3_prepare_APIName interface is legacy and should be avoided.sqlite3_prepare_v3_APIName has an extra \"prepFlags\" option that is used for special purposes.", "key": "sqlite3_prepare", "sent": "The sqlite3_prepare_APIName interface is legacy and should be avoided."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.Or, in other words, these routines are constructors for the prepared statement object.", "key": "sqlite3_prepare", "sent": "To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The preferred routine to use is sqlite3_prepare_v2_APIName.The sqlite3_prepare_APIName interface is legacy and should be avoided.sqlite3_prepare_v3_APIName has an extra \"prepFlags\" option that is used for special purposes.", "key": "sqlite3_prepare", "sent": "sqlite3_prepare_v3_APIName has an extra \"prepFlags\" option that is used for special purposes."}, {"API_info": {"var": ["db", "zSql", "nByte", "prepFlags", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "unsigned int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8.The UTF-16 interfaces are provided as a convenience.The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.", "key": "sqlite3_prepare_v3", "sent": "The UTF-16 interfaces are provided as a convenience."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "The first argument, \"db\", is a database connection obtained from a prior successful call to sqlite3_open_APIName, sqlite3_open_v2_APIName or sqlite3_open16_APIName.The database connection must not have been closed.", "key": "sqlite3_prepare16", "sent": "The database connection must not have been closed."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8.The UTF-16 interfaces are provided as a convenience.The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.", "key": "sqlite3_prepare", "sent": "The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8.The UTF-16 interfaces are provided as a convenience.The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.", "key": "sqlite3_prepare16_v2", "sent": "The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface."}, {"API_info": {"var": ["pStmt"], "API_desc": " Return the number of columns in the result set returned by the prepared statement.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Return the number of columns in the result set returned by the prepared statement.If this routine returns 0, that means the prepared statement returns no data (for example an UPDATE).However, just because this routine returns a positive number does not mean that one or more rows of data will be returned.A SELECT statement will always have a positive sqlite3_column_count_APIName but depending on the WHERE clause constraints and the table content, it might return no rows.", "key": "sqlite3_column_count", "sent": "A SELECT statement will always have a positive sqlite3_column_count_APIName but depending on the WHERE clause constraints and the table content, it might return no rows."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "If the sqlite3_prepare_APIParam_3 argument is negative, then sqlite3_prepare_APIParam_2 is read up to the first zero terminator.If sqlite3_prepare_v2_APIParam_3 is positive, then it is the number of bytes read from sqlite3_prepare_v2_APIParam_2.If sqlite3_prepare16_APIParam_3 is zero, then no prepared statement is generated.If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator.", "key": "sqlite3_prepare16", "sent": "If sqlite3_prepare16_APIParam_3 is zero, then no prepared statement is generated."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The first argument, \"db\", is a database connection obtained from a prior successful call to sqlite3_open_APIName, sqlite3_open_v2_APIName or sqlite3_open16_APIName.The database connection must not have been closed.", "key": "sqlite3_prepare", "sent": "The first argument, \"db\", is a database connection obtained from a prior successful call to sqlite3_open_APIName, sqlite3_open_v2_APIName or sqlite3_open16_APIName."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The second argument, \"zSql\", is the statement to be compiled, encoded as either UTF-8 or UTF-16.The sqlite3_prepare_APIName, sqlite3_prepare_v2_APIName, and sqlite3_prepare_v3_APIName interfaces use UTF-8, and sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName use UTF-16.", "key": "sqlite3_prepare", "sent": "The sqlite3_prepare_APIName, sqlite3_prepare_v2_APIName, and sqlite3_prepare_v3_APIName interfaces use UTF-8, and sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName use UTF-16."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The second argument, \"zSql\", is the statement to be compiled, encoded as either UTF-8 or UTF-16.The sqlite3_prepare_APIName, sqlite3_prepare_v2_APIName, and sqlite3_prepare_v3_APIName interfaces use UTF-8, and sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName use UTF-16.", "key": "sqlite3_prepare", "sent": "The second argument, \"zSql\", is the statement to be compiled, encoded as either UTF-8 or UTF-16."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "If the sqlite3_prepare_APIParam_3 argument is negative, then sqlite3_prepare_APIParam_2 is read up to the first zero terminator.If sqlite3_prepare_v2_APIParam_3 is positive, then it is the number of bytes read from sqlite3_prepare_v2_APIParam_2.If sqlite3_prepare16_APIParam_3 is zero, then no prepared statement is generated.If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator.", "key": "sqlite3_prepare_v2", "sent": "If sqlite3_prepare_v2_APIParam_3 is positive, then it is the number of bytes read from sqlite3_prepare_v2_APIParam_2."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "If the sqlite3_prepare_APIParam_3 argument is negative, then sqlite3_prepare_APIParam_2 is read up to the first zero terminator.If sqlite3_prepare_v2_APIParam_3 is positive, then it is the number of bytes read from sqlite3_prepare_v2_APIParam_2.If sqlite3_prepare16_APIParam_3 is zero, then no prepared statement is generated.If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator.", "key": "sqlite3_prepare", "sent": "If the sqlite3_prepare_APIParam_3 argument is negative, then sqlite3_prepare_APIParam_2 is read up to the first zero terminator."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName.If there is an error, *ppStmt is set to NULL.If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL.The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it.ppStmt may not be NULL.", "key": "sqlite3_prepare_v2", "sent": "If there is an error, *ppStmt is set to NULL."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName.If there is an error, *ppStmt is set to NULL.If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL.The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it.ppStmt may not be NULL.", "key": "sqlite3_prepare", "sent": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName."}, {"API_info": {"var": ["db", "zSql", "nByte", "prepFlags", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "unsigned int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName.If there is an error, *ppStmt is set to NULL.If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL.The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it.ppStmt may not be NULL.", "key": "sqlite3_prepare_v3", "sent": "If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "If sqlite3_prepare_APIParam_5 is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in sqlite3_prepare_APIParam_2.These routines only compile the first statement in sqlite3_prepare16_APIParam_2, so *pzTail is left pointing to what remains uncompiled.", "key": "sqlite3_prepare16", "sent": "These routines only compile the first statement in sqlite3_prepare16_APIParam_2, so *pzTail is left pointing to what remains uncompiled."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName.If there is an error, *ppStmt is set to NULL.If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL.The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it.ppStmt may not be NULL.", "key": "sqlite3_prepare16_v2", "sent": "ppStmt may not be NULL."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "If sqlite3_prepare_APIParam_5 is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in sqlite3_prepare_APIParam_2.These routines only compile the first statement in sqlite3_prepare16_APIParam_2, so *pzTail is left pointing to what remains uncompiled.", "key": "sqlite3_prepare", "sent": "If sqlite3_prepare_APIParam_5 is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in sqlite3_prepare_APIParam_2."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "*ppStmt is left pointing to a compiled prepared statement that can be executed using sqlite3_step_APIName.If there is an error, *ppStmt is set to NULL.If the input text contains no SQL (if the input is an empty string or a comment) then *ppStmt is set to NULL.The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it.ppStmt may not be NULL.", "key": "sqlite3_prepare_v2", "sent": "The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs.The older interfaces (sqlite3_prepare_APIName and sqlite3_prepare16_APIName) are retained for backwards compatibility, but their use is discouraged.In the \"vX\" interfaces, the prepared statement that be returned by sqlite3_prepare_APIName (the sqlite3_stmt object) contains a copy of the original SQL text.This causes the sqlite3_step_APIName interface to behave differently in three ways:", "key": "sqlite3_prepare", "sent": "The older interfaces (sqlite3_prepare_APIName and sqlite3_prepare16_APIName) are retained for backwards compatibility, but their use is discouraged."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs.The older interfaces (sqlite3_prepare_APIName and sqlite3_prepare16_APIName) are retained for backwards compatibility, but their use is discouraged.In the \"vX\" interfaces, the prepared statement that be returned by sqlite3_prepare_APIName (the sqlite3_stmt object) contains a copy of the original SQL text.This causes the sqlite3_step_APIName interface to behave differently in three ways:", "key": "sqlite3_prepare", "sent": "The sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "On success, the sqlite3_prepare_APIName family of routines return SQLITE_OK_API_constant; otherwise an error code be returned by sqlite3_prepare_APIName.", "key": "sqlite3_prepare", "sent": "On success, the sqlite3_prepare_APIName family of routines return SQLITE_OK_API_constant; otherwise an error code be returned by sqlite3_prepare_APIName."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs.The older interfaces (sqlite3_prepare_APIName and sqlite3_prepare16_APIName) are retained for backwards compatibility, but their use is discouraged.In the \"vX\" interfaces, the prepared statement that be returned by sqlite3_prepare_APIName (the sqlite3_stmt object) contains a copy of the original SQL text.This causes the sqlite3_step_APIName interface to behave differently in three ways:", "key": "sqlite3_prepare", "sent": "This causes the sqlite3_step_APIName interface to behave differently in three ways:"}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "sqlite3_prepare_v3_APIName differs from sqlite3_prepare_v2_APIName only in having the extra prepFlags parameter, which is a bit array consisting of zero or more of the SQLITE_PREPARE_* flags.The sqlite3_prepare_v2_APIName interface works exactly the same as sqlite3_prepare_v3_APIName with a zero prepFlags parameter.", "key": "sqlite3_prepare", "sent": "The sqlite3_prepare_v2_APIName interface works exactly the same as sqlite3_prepare_v3_APIName with a zero prepFlags parameter."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs.The older interfaces (sqlite3_prepare_APIName and sqlite3_prepare16_APIName) are retained for backwards compatibility, but their use is discouraged.In the \"vX\" interfaces, the prepared statement that be returned by sqlite3_prepare_APIName (the sqlite3_stmt object) contains a copy of the original SQL text.This causes the sqlite3_step_APIName interface to behave differently in three ways:", "key": "sqlite3_prepare", "sent": "In the \"vX\" interfaces, the prepared statement that be returned by sqlite3_prepare_APIName (the sqlite3_stmt object) contains a copy of the original SQL text."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob.", "key": "sqlite3_blob_bytes", "sent": "Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_bytes", "sent": "Passing any other pointer in to this routine results in undefined and probably undesirable behavior."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob.", "key": "sqlite3_blob_bytes", "sent": "The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const void *", "int", "sqlite3_stmt **", "const void **"], "ret_type": "int"}, "paraph": "If the sqlite3_prepare_APIParam_3 argument is negative, then sqlite3_prepare_APIParam_2 is read up to the first zero terminator.If sqlite3_prepare_v2_APIParam_3 is positive, then it is the number of bytes read from sqlite3_prepare_v2_APIParam_2.If sqlite3_prepare16_APIParam_3 is zero, then no prepared statement is generated.If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator.", "key": "sqlite3_prepare16_v2", "sent": "If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator."}, {"API_info": {"var": ["pDb", "pStmt"], "API_desc": " This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.", "var_type": ["sqlite3 *", "sqlite3_stmt *"], "ret_type": "sqlite3_stmt *"}, "paraph": "This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.If sqlite3_next_stmt_APIParam_2 is NULL then this interface returns a pointer to the first prepared statement associated with the database connection sqlite3_next_stmt_APIParam_1.If no prepared statement satisfies the conditions of this routine, sqlite3_next_stmt_APIName returns NULL.", "key": "sqlite3_next_stmt", "sent": "This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1."}, {"API_info": {"var": ["pDb", "pStmt"], "API_desc": " This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.", "var_type": ["sqlite3 *", "sqlite3_stmt *"], "ret_type": "sqlite3_stmt *"}, "paraph": "This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.If sqlite3_next_stmt_APIParam_2 is NULL then this interface returns a pointer to the first prepared statement associated with the database connection sqlite3_next_stmt_APIParam_1.If no prepared statement satisfies the conditions of this routine, sqlite3_next_stmt_APIName returns NULL.", "key": "sqlite3_next_stmt", "sent": "If no prepared statement satisfies the conditions of this routine, sqlite3_next_stmt_APIName returns NULL."}, {"API_info": {"var": ["pDb", "pStmt"], "API_desc": " This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.", "var_type": ["sqlite3 *", "sqlite3_stmt *"], "ret_type": "sqlite3_stmt *"}, "paraph": "This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.If sqlite3_next_stmt_APIParam_2 is NULL then this interface returns a pointer to the first prepared statement associated with the database connection sqlite3_next_stmt_APIParam_1.If no prepared statement satisfies the conditions of this routine, sqlite3_next_stmt_APIName returns NULL.", "key": "sqlite3_next_stmt", "sent": "If sqlite3_next_stmt_APIParam_2 is NULL then this interface returns a pointer to the first prepared statement associated with the database connection sqlite3_next_stmt_APIParam_1."}, {"API_info": {"var": ["sqlite3_blob *"], "API_desc": " Returns the size in bytes of the BLOB accessible via the successfully opened BLOB handle in its only argument.", "var_type": ["sqlite3_blob *"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_bytes", "sent": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.For example, if an application defines a function \"eval_APIName\" that calls sqlite3_exec_APIName, then the following SQL statement would change the database file through side-effects:", "key": "sqlite3_stmt_readonly", "sent": "Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "But because the SELECT statement does not change the database file directly, sqlite3_stmt_readonly_APIName would still return true.", "key": "sqlite3_stmt_readonly", "sent": "But  , sqlite3_stmt_readonly_APIName would still return true ."}, {"API_info": {"var": ["db", "zSql", "nByte", "ppStmt", "pzTail"], "API_desc": " To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines.", "var_type": ["sqlite3 *", "const char *", "int", "sqlite3_stmt **", "const char **"], "ret_type": "int"}, "paraph": "sqlite3_prepare_v3_APIName differs from sqlite3_prepare_v2_APIName only in having the extra prepFlags parameter, which is a bit array consisting of zero or more of the SQLITE_PREPARE_* flags.The sqlite3_prepare_v2_APIName interface works exactly the same as sqlite3_prepare_v3_APIName with a zero prepFlags parameter.", "key": "sqlite3_prepare", "sent": "sqlite3_prepare_v3_APIName differs from sqlite3_prepare_v2_APIName only in having the extra prepFlags parameter, which is a bit array consisting of zero or more of the SQLITE_PREPARE_* flags."}, {"API_info": {"var": ["pDb", "pStmt"], "API_desc": " This interface returns a pointer to the next prepared statement after sqlite3_next_stmt_APIParam_2 associated with the database connection sqlite3_next_stmt_APIParam_1.", "var_type": ["sqlite3 *", "sqlite3_stmt *"], "ret_type": "sqlite3_stmt *"}, "paraph": "The database connection pointer sqlite3_next_stmt_APIParam_1 in a call to sqlite3_next_stmt_APIName must refer to an open database connection and in particular must not be a NULL pointer.", "key": "sqlite3_next_stmt", "sent": "The database connection pointer sqlite3_next_stmt_APIParam_1 in a call to sqlite3_next_stmt_APIName must refer to an open database connection and in particular must not be a NULL pointer."}, {"API_info": {"var": ["sqlite3_index_info*", "int"], "API_desc": " sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table.The first argument must be the sqlite3_index_info object that is sqlite3_vtab_collation_APIParam_1 to the xBestIndex_APIName method.", "var_type": ["sqlite3_index_info*", "int"], "ret_type": "const char *"}, "paraph": "sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table.", "key": "sqlite3_vtab_collation", "sent": "sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement sqlite3_step_APIParam_1. If prepared statement sqlite3_step_APIParam_1 does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.The sqlite3_data_count_APIName routine also returns 0 if sqlite3_step_APIParam_1 is a NULL pointer.The sqlite3_data_count_APIName routine returns 0 if the previous call to sqlite3_step_APIName returned SQLITE_DONE_API_constant.The sqlite3_data_count_APIName will return non-zero if previous call to sqlite3_step_APIName returned SQLITE_ROW_API_constant, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data.", "key": "sqlite3_data_count", "sent": "The sqlite3_data_count_APIName routine also returns 0 if sqlite3_step_APIParam_1 is a NULL pointer."}, {"API_info": {"var": ["sqlite3_index_info*", "int"], "API_desc": " sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table.The first argument must be the sqlite3_index_info object that is sqlite3_vtab_collation_APIParam_1 to the xBestIndex_APIName method.", "var_type": ["sqlite3_index_info*", "int"], "ret_type": "const char *"}, "paraph": "The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex_APIName method.The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex.sqlite3_vtab_collation_APIName returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.", "key": "sqlite3_vtab_collation", "sent": "The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex_APIName method."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "See also: sqlite3_column_count_APIName", "key": "sqlite3_data_count", "sent": "See also: sqlite3_column_count_APIName"}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement sqlite3_step_APIParam_1. If prepared statement sqlite3_step_APIParam_1 does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.The sqlite3_data_count_APIName routine also returns 0 if sqlite3_step_APIParam_1 is a NULL pointer.The sqlite3_data_count_APIName routine returns 0 if the previous call to sqlite3_step_APIName returned SQLITE_DONE_API_constant.The sqlite3_data_count_APIName will return non-zero if previous call to sqlite3_step_APIName returned SQLITE_ROW_API_constant, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data.", "key": "sqlite3_data_count", "sent": "The sqlite3_data_count_APIName routine returns 0 if the previous call to sqlite3_step_APIName returned SQLITE_DONE_API_constant."}, {"API_info": {"var": ["sqlite3_index_info*", "int"], "API_desc": " sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table.The first argument must be the sqlite3_index_info object that is sqlite3_vtab_collation_APIParam_1 to the xBestIndex_APIName method.", "var_type": ["sqlite3_index_info*", "int"], "ret_type": "const char *"}, "paraph": "The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex_APIName method.The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex.sqlite3_vtab_collation_APIName returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.", "key": "sqlite3_vtab_collation", "sent": "sqlite3_vtab_collation_APIName returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement sqlite3_stmt_readonly_APIParam_1 makes no direct changes to the content of the database file.", "key": "sqlite3_stmt_readonly", "sent": "The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement sqlite3_stmt_readonly_APIParam_1 makes no direct changes to the content of the database file."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.For example, if an application defines a function \"eval_APIName\" that calls sqlite3_exec_APIName, then the following SQL statement would change the database file through side-effects:", "key": "sqlite3_stmt_readonly", "sent": "For example, if an application defines a function \"eval_APIName\" that calls sqlite3_exec_APIName, then the following SQL statement would change the database file through side-effects:"}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun ANALYZE if discrepancies are found.", "key": "sqlite3_stmt_scanstatus", "sent": "This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement sqlite3_step_APIParam_1. If prepared statement sqlite3_step_APIParam_1 does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.The sqlite3_data_count_APIName routine also returns 0 if sqlite3_step_APIParam_1 is a NULL pointer.The sqlite3_data_count_APIName routine returns 0 if the previous call to sqlite3_step_APIName returned SQLITE_DONE_API_constant.The sqlite3_data_count_APIName will return non-zero if previous call to sqlite3_step_APIName returned SQLITE_ROW_API_constant, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data.", "key": "sqlite3_data_count", "sent": "The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement sqlite3_step_APIParam_1. If prepared statement sqlite3_step_APIParam_1 does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "The \"iScanStatusOp\" parameter determines which status information to return."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "Loops are numbered starting from zero."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "Parameter \"idx\" identifies the specific loop to retrieve statistics for."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "The requested measurement is written into a variable pointed to by the \"pOut\" parameter."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the SQLITE_ENABLE_STMT_SCANSTATUS compile-time option.", "key": "sqlite3_stmt_scanstatus", "sent": " , it is only available if SQLite is compiled using the SQLITE_ENABLE_STMT_SCANSTATUS compile-time option ."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun ANALYZE if discrepancies are found.", "key": "sqlite3_stmt_scanstatus", "sent": "Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun ANALYZE if discrepancies are found."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "Statistics might not be available for all loops in all statements.In cases where there exist loops with no available statistics, sqlite3_stmt_scanstatus_APIName behaves as if the loop did not exist - sqlite3_stmt_scanstatus_APIName returns non-zero and leave the variable that sqlite3_stmt_scanstatus_APIParam_4 points to unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "Statistics might not be available for all loops in all statements."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "See also: sqlite3_stmt_scanstatus_reset_APIName", "key": "sqlite3_stmt_scanstatus", "sent": "See also: sqlite3_stmt_scanstatus_reset_APIName"}, {"API_info": "defined not exist in API_info", "paraph": "These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.", "key": "defined", "sent": "These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.At most one preupdate hook may be registered at a time on a single database connection; each call to sqlite3_preupdate_hook_APIName overrides the previous setting.The preupdate hook is disabled by invoking sqlite3_preupdate_hook_APIName with a NULL pointer as sqlite3_preupdate_count_APIParam_2.The third parameter to sqlite3_preupdate_hook_APIName is passed through as sqlite3_preupdate_depth_APIParam_1 to callbacks.", "key": "sqlite3_preupdate_count", "sent": "The preupdate hook is disabled by invoking sqlite3_preupdate_hook_APIName with a NULL pointer as sqlite3_preupdate_count_APIParam_2."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Transaction control statements such as BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and RELEASE cause sqlite3_stmt_readonly_APIName to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database.The ATTACH and DETACH statements also cause sqlite3_stmt_readonly_APIName to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk.The sqlite3_stmt_readonly_APIName interface returns true for BEGIN since BEGIN merely sets internal flags, but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly_APIName returns false for those commands.", "key": "sqlite3_stmt_readonly", "sent": "The ATTACH and DETACH statements also cause sqlite3_stmt_readonly_APIName to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.At most one preupdate hook may be registered at a time on a single database connection; each call to sqlite3_preupdate_hook_APIName overrides the previous setting.The preupdate hook is disabled by invoking sqlite3_preupdate_hook_APIName with a NULL pointer as sqlite3_preupdate_count_APIParam_2.The third parameter to sqlite3_preupdate_hook_APIName is passed through as sqlite3_preupdate_depth_APIParam_1 to callbacks.", "key": "sqlite3_preupdate_depth", "sent": "The third parameter to sqlite3_preupdate_hook_APIName is passed through as sqlite3_preupdate_depth_APIParam_1 to callbacks."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Transaction control statements such as BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and RELEASE cause sqlite3_stmt_readonly_APIName to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database.The ATTACH and DETACH statements also cause sqlite3_stmt_readonly_APIName to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk.The sqlite3_stmt_readonly_APIName interface returns true for BEGIN since BEGIN merely sets internal flags, but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly_APIName returns false for those commands.", "key": "sqlite3_stmt_readonly", "sent": "The sqlite3_stmt_readonly_APIName interface returns true for BEGIN  , but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly_APIName returns false for those commands ."}, {"API_info": "defined not exist in API_info", "paraph": "The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.At most one preupdate hook may be registered at a time on a single database connection; each call to sqlite3_preupdate_hook_APIName overrides the previous setting.The preupdate hook is disabled by invoking sqlite3_preupdate_hook_APIName with a NULL pointer as sqlite3_preupdate_count_APIParam_2.The third parameter to sqlite3_preupdate_hook_APIName is passed through as sqlite3_preupdate_depth_APIParam_1 to callbacks.", "key": "defined", "sent": "The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement P. If prepared statement P does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "The sqlite3_data_count_APIName interface returns the number of columns in the current row of the result set of prepared statement sqlite3_step_APIParam_1. If prepared statement sqlite3_step_APIParam_1 does not have results ready to return (via calls to the sqlite3_column_*_APIName of interfaces) then sqlite3_data_count_APIName returns 0.The sqlite3_data_count_APIName routine also returns 0 if sqlite3_step_APIParam_1 is a NULL pointer.The sqlite3_data_count_APIName routine returns 0 if the previous call to sqlite3_step_APIName returned SQLITE_DONE_API_constant.The sqlite3_data_count_APIName will return non-zero if previous call to sqlite3_step_APIName returned SQLITE_ROW_API_constant, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data.", "key": "sqlite3_data_count", "sent": "The sqlite3_data_count_APIName will return non-zero if previous call to sqlite3_step_APIName returned SQLITE_ROW_API_constant, except in the case of the PRAGMA incremental_vacuum where it always returns zero since each step of that multi-step pragma returns 0 columns of data."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.At most one preupdate hook may be registered at a time on a single database connection; each call to sqlite3_preupdate_hook_APIName overrides the previous setting.The preupdate hook is disabled by invoking sqlite3_preupdate_hook_APIName with a NULL pointer as sqlite3_preupdate_count_APIParam_2.The third parameter to sqlite3_preupdate_hook_APIName is passed through as sqlite3_preupdate_depth_APIParam_1 to callbacks.", "key": "sqlite3_preupdate_old", "sent": "At most one preupdate hook may be registered at a time on a single database connection; each call to sqlite3_preupdate_hook_APIName overrides the previous setting."}, {"API_info": {"var": ["pStmt"], "API_desc": " The sqlite3_stmt_readonly_APIName interface returns true (non-zero) if and only if the prepared statement X makes no direct changes to the content of the database file.Note that application-defined SQL functions or virtual tables might change the database indirectly as a side effect.", "var_type": ["sqlite3_stmt *"], "ret_type": "int"}, "paraph": "Transaction control statements such as BEGIN, COMMIT, ROLLBACK, SAVEPOINT, and RELEASE cause sqlite3_stmt_readonly_APIName to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database.The ATTACH and DETACH statements also cause sqlite3_stmt_readonly_APIName to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk.The sqlite3_stmt_readonly_APIName interface returns true for BEGIN since BEGIN merely sets internal flags, but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly_APIName returns false for those commands.", "key": "sqlite3_stmt_readonly", "sent": "Transaction control statements such as BEGIN , COMMIT , ROLLBACK , SAVEPOINT , and RELEASE cause sqlite3_stmt_readonly_APIName to return true ,  ."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "Statistics might not be available for all loops in all statements.In cases where there exist loops with no available statistics, sqlite3_stmt_scanstatus_APIName behaves as if the loop did not exist - sqlite3_stmt_scanstatus_APIName returns non-zero and leave the variable that sqlite3_stmt_scanstatus_APIParam_4 points to unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "In cases where there exist loops with no available statistics, sqlite3_stmt_scanstatus_APIName behaves as if the loop did not exist - sqlite3_stmt_scanstatus_APIName returns non-zero and leave the variable that sqlite3_stmt_scanstatus_APIParam_4 points to unchanged."}, {"API_info": "defined not exist in API_info", "paraph": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook.The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur.The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified.This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases.The fifth parameter to the preupdate callback is the name of the table that is being modified.", "key": "defined", "sent": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook.The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur.The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified.This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases.The fifth parameter to the preupdate callback is the name of the table that is being modified.", "key": "sqlite3_preupdate_new", "sent": "The fifth parameter to the preupdate callback is the name of the table that is being modified."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook.The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur.The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified.This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases.The fifth parameter to the preupdate callback is the name of the table that is being modified.", "key": "sqlite3_preupdate_count", "sent": "The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_old_APIName, sqlite3_preupdate_new_APIName, sqlite3_preupdate_count_APIName, and sqlite3_preupdate_depth_APIName interfaces provide additional information about a preupdate event.These routines may only be called from within a preupdate callback.Invoking any of these routines from outside of a preupdate callback or with a database connection pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.", "key": "defined", "sent": "These routines may only be called from within a preupdate callback."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_old_APIName, sqlite3_preupdate_new_APIName, sqlite3_preupdate_count_APIName, and sqlite3_preupdate_depth_APIName interfaces provide additional information about a preupdate event.These routines may only be called from within a preupdate callback.Invoking any of these routines from outside of a preupdate callback or with a database connection pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.", "key": "sqlite3_preupdate_old", "sent": "The sqlite3_preupdate_old_APIName, sqlite3_preupdate_new_APIName, sqlite3_preupdate_count_APIName, and sqlite3_preupdate_depth_APIName interfaces provide additional information about a preupdate event."}, {"API_info": "defined not exist in API_info", "paraph": "The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to virtual tables or to system tables like sqlite_master or sqlite_stat1.", "key": "defined", "sent": "The preupdate hook only fires for changes to real database tables; the preupdate hook is not invoked for changes to virtual tables or to system tables like sqlite_master or sqlite_stat1."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook.The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur.The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified.This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases.The fifth parameter to the preupdate callback is the name of the table that is being modified.", "key": "sqlite3_preupdate_old", "sent": "The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_count_APIName interface returns the number of columns in the row that is being inserted, updated, or deleted.", "key": "sqlite3_preupdate_count", "sent": "The sqlite3_preupdate_count_APIName interface returns the number of columns in the row that is being inserted, updated, or deleted."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The second parameter to the preupdate callback is a pointer to the database connection that registered the preupdate hook.The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur.The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified.This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases.The fifth parameter to the preupdate callback is the name of the table that is being modified.", "key": "sqlite3_preupdate_depth", "sent": "This will be \"main\" for the main database or \"temp\" for TEMP tables or the name given after the AS keyword in the ATTACH statement for attached databases."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_old_APIName interface writes into sqlite3_preupdate_old_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row before it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks; if it is used by an SQLITE_INSERT_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined."}, {"API_info": "definednot exist in API_info", "paraph": "For an UPDATE or DELETE operation on a rowid table, the sixth parameter passed to the preupdate callback is the initial rowid of the row being modified or deleted.For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined.For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated.The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.", "key": "defined", "sent": "For an UPDATE or DELETE operation on a rowid table, the sixth parameter passed to the preupdate callback is the initial rowid of the row being modified or deleted."}, {"API_info": "definednot exist in API_info", "paraph": "For an UPDATE or DELETE operation on a rowid table, the sixth parameter passed to the preupdate callback is the initial rowid of the row being modified or deleted.For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined.For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated.The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.", "key": "defined", "sent": "For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_old_APIName interface writes into sqlite3_preupdate_old_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row before it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks; if it is used by an SQLITE_INSERT_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "sqlite3_preupdate_old", "sent": "The sqlite3_preupdate_old_APIName interface writes into sqlite3_preupdate_old_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row before it is updated."}, {"API_info": "definednot exist in API_info", "paraph": "For an UPDATE or DELETE operation on a rowid table, the sixth parameter passed to the preupdate callback is the initial rowid of the row being modified or deleted.For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined.For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated.The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.", "key": "defined", "sent": "The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables."}, {"API_info": "definednot exist in API_info", "paraph": "For an UPDATE or DELETE operation on a rowid table, the sixth parameter passed to the preupdate callback is the initial rowid of the row being modified or deleted.For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined.For an INSERT or UPDATE on a rowid table the seventh parameter is the final rowid value of the row being inserted or updated.The value of the seventh parameter passed to the callback function is not defined for operations on WITHOUT ROWID tables, or for INSERT operations on rowid tables.", "key": "defined", "sent": "For an INSERT operation on a rowid table, or any operation on a WITHOUT ROWID table, the value of the sixth parameter is undefined."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_old_APIName, sqlite3_preupdate_new_APIName, sqlite3_preupdate_count_APIName, and sqlite3_preupdate_depth_APIName interfaces provide additional information about a preupdate event.These routines may only be called from within a preupdate callback.Invoking any of these routines from outside of a preupdate callback or with a database connection pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior.", "key": "defined", "sent": "Invoking any of these routines from outside of a preupdate callback or with a database connection pointer that is different from the one supplied to the preupdate callback results in undefined and probably undesirable behavior."}, {"API_info": {"var": ["pStmt", "idx", "iScanStatusOp", "pOut"], "API_desc": " This interface returns information about the predicted and measured performance for sqlite3_stmt_scanstatus_APIParam_1.", "var_type": ["sqlite3_stmt *", "int", "int", "void *"], "ret_type": "int"}, "paraph": "The \"iScanStatusOp\" parameter determines which status information to return.The \"iScanStatusOp\" must be one of the scanstatus options or the behavior of this interface is undefined.The requested measurement is written into a variable pointed to by the \"pOut\" parameter.Parameter \"idx\" identifies the specific loop to retrieve statistics for.Loops are numbered starting from zero.If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged.", "key": "sqlite3_stmt_scanstatus", "sent": "If sqlite3_stmt_scanstatus_APIParam_2 is out of range - less than zero or greater than or equal to the total number of loops used to implement the statement - a non-zero value be returned by sqlite3_stmt_scanstatus_APIName and the variable that sqlite3_stmt_scanstatus_APIParam_4 points to is unchanged."}, {"API_info": {"var": ["sqlite3_index_info*", "int"], "API_desc": " sqlite3_vtab_collation_APIName may only be called from within a call to the xBestIndex method of a virtual table.The first argument must be the sqlite3_index_info object that is sqlite3_vtab_collation_APIParam_1 to the xBestIndex_APIName method.", "var_type": ["sqlite3_index_info*", "int"], "ret_type": "const char *"}, "paraph": "The first argument must be the sqlite3_index_info object that is the first parameter to the xBestIndex_APIName method.The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex.sqlite3_vtab_collation_APIName returns a pointer to a buffer containing the name of the collation sequence for the corresponding constraint.", "key": "sqlite3_vtab_collation", "sent": "The second argument must be an index into the aConstraint[] array belonging to the sqlite3_index_info structure passed to xBestIndex."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_old_APIName interface writes into sqlite3_preupdate_old_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row before it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks; if it is used by an SQLITE_INSERT_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "The sqlite3_value that P points to will be destroyed when the preupdate callback returns."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_new_APIName interface writes into sqlite3_preupdate_new_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row after it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks; if it is used by an SQLITE_DELETE_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "The sqlite3_value that P points to will be destroyed when the preupdate callback returns."}, {"API_info": "defined not exist in API_info", "paraph": "See also:  sqlite3_update_hook_APIName", "key": "defined", "sent": "See also:  sqlite3_update_hook_APIName"}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_old_APIName interface writes into sqlite3_preupdate_old_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row before it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks; if it is used by an SQLITE_INSERT_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks; if it is used by an SQLITE_INSERT_API_constant callback then the behavior is undefined."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_new_APIName interface writes into sqlite3_preupdate_new_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row after it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks; if it is used by an SQLITE_DELETE_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks; if it is used by an SQLITE_DELETE_API_constant callback then the behavior is undefined."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.The values of these parameters (also called \"host parameter names\" or \"SQL parameters\") can be set using the sqlite3_bind_*_APIName routines defined here.", "key": "sqlite3_bind_blob", "sent": "In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier."}, {"API_info": {"var": ["sqlite3 *", " int", " sqlite3_value **"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *", " int", " sqlite3_value **"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_new_APIName interface writes into sqlite3_preupdate_new_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row after it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks; if it is used by an SQLITE_DELETE_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "sqlite3_preupdate_new", "sent": "The sqlite3_preupdate_new_APIName interface writes into sqlite3_preupdate_new_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row after it is updated."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.The values of these parameters (also called \"host parameter names\" or \"SQL parameters\") can be set using the sqlite3_bind_*_APIName routines defined here.", "key": "sqlite3_bind_text", "sent": "The values of these parameters (also called \"host parameter names\" or \"SQL parameters\") can be set using the sqlite3_bind_*_APIName routines defined here."}, {"API_info": "definednot exist in API_info", "paraph": "The sqlite3_preupdate_new_APIName interface writes into sqlite3_preupdate_new_APIParam_3 a pointer to a protected sqlite3_value that contains the value of the Nth column of the table row after it is updated.The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined.This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks; if it is used by an SQLITE_DELETE_API_constant callback then the behavior is undefined.The sqlite3_value that P points to will be destroyed when the preupdate callback returns.", "key": "defined", "sent": "The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " double"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " double"], "ret_type": "int"}, "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_double", "sent": "The leftmost SQL parameter has an index of 1."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_blob", "sent": "The second argument is the index of the SQL parameter to be set."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_text", "sent": "The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired."}, {"API_info": "sqlite3_bind_text64 not exist in API_info", "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_text64", "sent": "The index for \"?NNN\" parameters is the value of NNN."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "The third argument is the value to bind to the parameter.If the third parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_blob_APIName is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null_APIName.", "key": "sqlite3_bind_blob", "sent": "The third argument is the value to bind to the parameter."}, {"API_info": "sqlite3_bind_pointer not exist in API_info", "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_pointer", "sent": "The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999)."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "The first argument to the sqlite3_bind_*_APIName routines is always a pointer to the sqlite3_stmt object returned from sqlite3_prepare_v2_APIName or its variants.", "key": "sqlite3_bind_blob", "sent": "The first argument to the sqlite3_bind_*_APIName routines is always a pointer to the sqlite3_stmt object returned from sqlite3_prepare_v2_APIName or its variants."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:", "key": "sqlite3_bind_blob", "sent": "In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:"}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_blob", "sent": "If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_blob", "sent": "In those routines that have a fourth argument, its value is the number of bytes in the parameter."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_blob", "sent": "To be clear: the value is the number of bytes in the value, not the number of characters."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " sqlite3_int64"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " sqlite3_int64"], "ret_type": "int"}, "paraph": "The second argument is the index of the SQL parameter to be set.The leftmost SQL parameter has an index of 1.When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence.The index for named parameters can be looked up using the sqlite3_bind_parameter_index_APIName API if desired.The index for \"?NNN\" parameters is the value of NNN.The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant (default value: 999).", "key": "sqlite3_bind_int64", "sent": "When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_blob", "sent": "The result of expressions involving strings with embedded NULs is undefined."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "The third argument is the value to bind to the parameter.If the third parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_blob_APIName is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null_APIName.", "key": "sqlite3_bind_blob", "sent": "If the third parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_blob_APIName is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", " int", "n"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", "int"], "ret_type": "int"}, "paraph": "The sqlite3_bind_zeroblob_APIName routine binds a BLOB of length N that is filled with zeroes.A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed.Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using incremental BLOB I/O routines.A negative value for the zeroblob results in a zero-length BLOB.", "key": "sqlite3_bind_zeroblob", "sent": "The sqlite3_bind_zeroblob_APIName routine binds a BLOB of length N that is filled with zeroes."}, {"API_info": {"var": ["sqlite3_stmt*", " int", "n"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", "int"], "ret_type": "int"}, "paraph": "The sqlite3_bind_zeroblob_APIName routine binds a BLOB of length N that is filled with zeroes.A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed.Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using incremental BLOB I/O routines.A negative value for the zeroblob results in a zero-length BLOB.", "key": "sqlite3_bind_zeroblob", "sent": "A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed."}, {"API_info": {"var": ["sqlite3_stmt*", " int", "n"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", "int"], "ret_type": "int"}, "paraph": "The sqlite3_bind_zeroblob_APIName routine binds a BLOB of length N that is filled with zeroes.A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed.Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using incremental BLOB I/O routines.A negative value for the zeroblob results in a zero-length BLOB.", "key": "sqlite3_bind_zeroblob", "sent": "A negative value for the zeroblob results in a zero-length BLOB."}, {"API_info": {"var": ["sqlite3_stmt*", " int", "n"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", "int"], "ret_type": "int"}, "paraph": "The sqlite3_bind_zeroblob_APIName routine binds a BLOB of length N that is filled with zeroes.A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed.Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using incremental BLOB I/O routines.A negative value for the zeroblob results in a zero-length BLOB.", "key": "sqlite3_bind_zeroblob", "sent": "Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using incremental BLOB I/O routines."}, {"API_info": "sqlite3_bind_textnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_text", "sent": "If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated."}, {"API_info": "sqlite3_bind_blobnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_blob", "sent": "If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it.The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if sqlite3_bind_int_APIParam_3 is a NULL pointer or the fourth parameter is negative.If the fifth argument is the special value SQLITE_STATIC_API_constant, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed.If sqlite3_bind_value_APIParam_5 has the value SQLITE_TRANSIENT_API_constant, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*_APIName routine returns.", "key": "sqlite3_bind_blob", "sent": "The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it."}, {"API_info": "sqlite3_bind_pointernot exist in API_info", "paraph": "The sqlite3_bind_pointer_APIName routine causes the I-th parameter in prepared statement S to have an SQL value of NULL, but to also be associated with the pointer P of type T.  D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P.  The T parameter should be a static string, preferably a string literal.The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_bind_pointer", "sent": "The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0."}, {"API_info": "sqlite3_bind_textnot exist in API_info", "paraph": "In those routines that have a fourth argument, its value is the number of bytes in the parameter.To be clear: the value is the number of bytes in the value, not the number of characters.If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator.If the fourth parameter to sqlite3_bind_blob_APIName is negative, then the behavior is undefined.If a non-negative fourth parameter is provided to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName or sqlite3_bind_text64_APIName then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs.The result of expressions involving strings with embedded NULs is undefined.", "key": "sqlite3_bind_text", "sent": "If the fourth parameter to sqlite3_bind_text_APIName or sqlite3_bind_text16_APIName is negative, then the length of the string is the number of bytes up to the first zero terminator."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "Bindings are not cleared by the sqlite3_reset_APIName routine.Unbound parameters are interpreted as NULL.", "key": "sqlite3_bind_blob", "sent": "Bindings are not cleared by the sqlite3_reset_APIName routine."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "Bindings are not cleared by the sqlite3_reset_APIName routine.Unbound parameters are interpreted as NULL.", "key": "sqlite3_bind_text", "sent": "Unbound parameters are interpreted as NULL."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it.The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if sqlite3_bind_int_APIParam_3 is a NULL pointer or the fourth parameter is negative.If the fifth argument is the special value SQLITE_STATIC_API_constant, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed.If sqlite3_bind_value_APIParam_5 has the value SQLITE_TRANSIENT_API_constant, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*_APIName routine returns.", "key": "sqlite3_bind_text", "sent": "If the fifth argument is the special value SQLITE_STATIC_API_constant, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed."}, {"API_info": "sqlite3_bind_textnot exist in API_info", "paraph": "The sixth argument to sqlite3_bind_text64_APIName must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE to specify the encoding of the text in the third parameter.If the sixth argument to sqlite3_bind_text64_APIName is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.", "key": "sqlite3_bind_text", "sent": "The sixth argument to sqlite3_bind_text64_APIName must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE to specify the encoding of the text in the third parameter."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " const sqlite3_value*"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " const sqlite3_value*"], "ret_type": "int"}, "paraph": "The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it.The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if sqlite3_bind_int_APIParam_3 is a NULL pointer or the fourth parameter is negative.If the fifth argument is the special value SQLITE_STATIC_API_constant, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed.If sqlite3_bind_value_APIParam_5 has the value SQLITE_TRANSIENT_API_constant, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*_APIName routine returns.", "key": "sqlite3_bind_value", "sent": "If sqlite3_bind_value_APIParam_5 has the value SQLITE_TRANSIENT_API_constant, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*_APIName routine returns."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "The sqlite3_bind_* routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong.SQLITE_TOOBIG_API_constant might be returned if the size of a string or BLOB exceeds limits imposed by sqlite3_limit_APIName or SQLITE_MAX_LENGTH.SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName if the parameter index is out of range.SQLITE_NOMEM_API_constant be returned by sqlite3_bind_value_APIName if malloc_APIName fails.", "key": "sqlite3_bind_blob", "sent": "The sqlite3_bind_* routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "The sqlite3_bind_* routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong.SQLITE_TOOBIG_API_constant might be returned if the size of a string or BLOB exceeds limits imposed by sqlite3_limit_APIName or SQLITE_MAX_LENGTH.SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName if the parameter index is out of range.SQLITE_NOMEM_API_constant be returned by sqlite3_bind_value_APIName if malloc_APIName fails.", "key": "sqlite3_bind_text", "sent": "SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName if the parameter index is out of range."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " const sqlite3_value*"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " const sqlite3_value*"], "ret_type": "int"}, "paraph": "The sqlite3_bind_* routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong.SQLITE_TOOBIG_API_constant might be returned if the size of a string or BLOB exceeds limits imposed by sqlite3_limit_APIName or SQLITE_MAX_LENGTH.SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName if the parameter index is out of range.SQLITE_NOMEM_API_constant be returned by sqlite3_bind_value_APIName if malloc_APIName fails.", "key": "sqlite3_bind_value", "sent": "SQLITE_NOMEM_API_constant be returned by sqlite3_bind_value_APIName if malloc_APIName fails."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "See also: sqlite3_bind_parameter_count_APIName, sqlite3_bind_parameter_name_APIName, and sqlite3_bind_parameter_index_APIName.", "key": "sqlite3_bind_blob", "sent": "See also: sqlite3_bind_parameter_count_APIName, sqlite3_bind_parameter_name_APIName, and sqlite3_bind_parameter_index_APIName."}, {"API_info": "sqlite3_bind_text not exist in API_info", "paraph": "If any of the sqlite3_bind_*_APIName routines are called with a NULL pointer for the prepared statement or with a prepared statement for which sqlite3_step_APIName has been called more recently than sqlite3_reset_APIName, then the call will return SQLITE_MISUSE_API_constant.If any sqlite3_bind__APIName routine is passed a prepared statement that has been finalized, the result is undefined and probably harmful.", "key": "sqlite3_bind_text", "sent": "If any sqlite3_bind__APIName routine is passed a prepared statement that has been finalized, the result is undefined and probably harmful."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " int"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " int"], "ret_type": "int"}, "paraph": "The sqlite3_bind_* routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong.SQLITE_TOOBIG_API_constant might be returned if the size of a string or BLOB exceeds limits imposed by sqlite3_limit_APIName or SQLITE_MAX_LENGTH.SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName if the parameter index is out of range.SQLITE_NOMEM_API_constant be returned by sqlite3_bind_value_APIName if malloc_APIName fails.", "key": "sqlite3_bind_int", "sent": "SQLITE_TOOBIG_API_constant might be returned if the size of a string or BLOB exceeds limits imposed by sqlite3_limit_APIName or SQLITE_MAX_LENGTH."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.But global versions of those functions must exist in order to be overloaded.", "key": "sqlite3_overload_function", "sent": "But global versions of those functions must exist  ."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "This API makes sure a global version of a function with a particular name and number of parameters exists.If no such function exists before this API is called, a new function is created.The implementation of the new function always causes an exception to be thrown.So the new function is not good for anything by itself.Its only purpose is to be a placeholder function that can be overloaded by a virtual table.", "key": "sqlite3_overload_function", "sent": "If no such function exists before this API is called, a new function is created."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.But global versions of those functions must exist in order to be overloaded.", "key": "sqlite3_overload_function", "sent": "Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "This API makes sure a global version of a function with a particular name and number of parameters exists.If no such function exists before this API is called, a new function is created.The implementation of the new function always causes an exception to be thrown.So the new function is not good for anything by itself.Its only purpose is to be a placeholder function that can be overloaded by a virtual table.", "key": "sqlite3_overload_function", "sent": "So the new function is not good for anything by itself."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "This API makes sure a global version of a function with a particular name and number of parameters exists.If no such function exists before this API is called, a new function is created.The implementation of the new function always causes an exception to be thrown.So the new function is not good for anything by itself.Its only purpose is to be a placeholder function that can be overloaded by a virtual table.", "key": "sqlite3_overload_function", "sent": "The implementation of the new function always causes an exception to be thrown."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "This API makes sure a global version of a function with a particular name and number of parameters exists.If no such function exists before this API is called, a new function is created.The implementation of the new function always causes an exception to be thrown.So the new function is not good for anything by itself.Its only purpose is to be a placeholder function that can be overloaded by a virtual table.", "key": "sqlite3_overload_function", "sent": "This API makes sure a global version of a function with a particular name and number of parameters exists."}, {"API_info": {"var": ["sqlite3*", "zFuncName", "nArg"], "API_desc": " Virtual tables can provide alternative implementations of functions using the xFindFunction method of the virtual table module.", "var_type": ["sqlite3*", "const char *", "int"], "ret_type": "int"}, "paraph": "This API makes sure a global version of a function with a particular name and number of parameters exists.If no such function exists before this API is called, a new function is created.The implementation of the new function always causes an exception to be thrown.So the new function is not good for anything by itself.Its only purpose is to be a placeholder function that can be overloaded by a virtual table.", "key": "sqlite3_overload_function", "sent": "Its only purpose is to be a placeholder function that can be overloaded by a virtual table."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "The callback registered by sqlite3_wal_autocheckpoint_APIName replaces any existing callback registered using sqlite3_wal_hook_APIName.Likewise, registering a callback using sqlite3_wal_hook_APIName disables the automatic checkpoint mechanism configured by sqlite3_wal_autocheckpoint_APIName.", "key": "sqlite3_wal_autocheckpoint", "sent": "The callback registered by sqlite3_wal_autocheckpoint_APIName replaces any existing callback registered using sqlite3_wal_hook_APIName."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.", "key": "sqlite3_wal_autocheckpoint", "sent": "Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "The wal_autocheckpoint pragma can be used to invoke this interface from SQL.", "key": "sqlite3_wal_autocheckpoint", "sent": "The wal_autocheckpoint pragma can be used to invoke this interface from SQL."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Checkpoints initiated by this mechanism are PASSIVE.", "key": "sqlite3_wal_autocheckpoint", "sent": "Checkpoints initiated by this mechanism are PASSIVE."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "The callback registered by sqlite3_wal_autocheckpoint_APIName replaces any existing callback registered using sqlite3_wal_hook_APIName.Likewise, registering a callback using sqlite3_wal_hook_APIName disables the automatic checkpoint mechanism configured by sqlite3_wal_autocheckpoint_APIName.", "key": "sqlite3_wal_autocheckpoint", "sent": "Likewise, registering a callback using sqlite3_wal_hook_APIName disables the automatic checkpoint mechanism configured by sqlite3_wal_autocheckpoint_APIName."}, {"API_info": "sqlite3_bind_textnot exist in API_info", "paraph": "The sixth argument to sqlite3_bind_text64_APIName must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE to specify the encoding of the text in the third parameter.If the sixth argument to sqlite3_bind_text64_APIName is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.", "key": "sqlite3_bind_text", "sent": "If the sixth argument to sqlite3_bind_text64_APIName is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined."}, {"API_info": {"var": ["sqlite3_stmt*", " int", " int"], "API_desc": " In the SQL statement text input to sqlite3_prepare_v2_APIName and its variants, literals may be replaced by a parameter that matches one of following templates:In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier.", "var_type": ["sqlite3_stmt*", " int", " int"], "ret_type": "int"}, "paraph": "The fifth argument to the BLOB and string binding interfaces is a destructor used to dispose of the BLOB or string after SQLite has finished with it.The destructor is called to dispose of the BLOB or string even if the call to the bind API fails, except the destructor is not called if sqlite3_bind_int_APIParam_3 is a NULL pointer or the fourth parameter is negative.If the fifth argument is the special value SQLITE_STATIC_API_constant, then SQLite assumes that the information is in static, unmanaged space and does not need to be freed.If sqlite3_bind_value_APIParam_5 has the value SQLITE_TRANSIENT_API_constant, then SQLite makes its own private copy of the data immediately, before the sqlite3_bind_*_APIName routine returns.", "key": "sqlite3_bind_int", "sent": "The destructor is called to dispose of the BLOB or string  , except the destructor is not called if sqlite3_bind_int_APIParam_3 is a NULL pointer or the fourth parameter is negative ."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.N bytes of data are copied into buffer sqlite3_blob_read_APIParam_2 from the open BLOB, starting at offset sqlite3_blob_read_APIParam_4.", "key": "sqlite3_blob_read", "sent": "sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Every new database connection defaults to having the auto-checkpoint enabled with a threshold of 1000 or SQLITE_DEFAULT_WAL_AUTOCHECKPOINT pages.The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.", "key": "sqlite3_wal_autocheckpoint", "sent": "Every new database connection defaults to having the auto-checkpoint enabled with a threshold of 1000 or SQLITE_DEFAULT_WAL_AUTOCHECKPOINT pages."}, {"API_info": "sqlite3_bind_blob not exist in API_info", "paraph": "If any of the sqlite3_bind_*_APIName routines are called with a NULL pointer for the prepared statement or with a prepared statement for which sqlite3_step_APIName has been called more recently than sqlite3_reset_APIName, then the call will return SQLITE_MISUSE_API_constant.If any sqlite3_bind__APIName routine is passed a prepared statement that has been finalized, the result is undefined and probably harmful.", "key": "sqlite3_bind_blob", "sent": "If any of the sqlite3_bind _ * _ APIName routines are called with a NULL pointer for the prepared statement or with a prepared statement  , then the call will return SQLITE_MISUSE_API_constant ."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "On success, sqlite3_blob_read_APIName returns SQLITE_OK_API_constant.Otherwise, an error code or an extended error code be returned by sqlite3_blob_read_APIName.", "key": "sqlite3_blob_read", "sent": "On success, sqlite3_blob_read_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "If offset sqlite3_blob_read_APIParam_4 is less than sqlite3_blob_read_APIParam_3 bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.If sqlite3_blob_read_APIParam_3 or sqlite3_blob_read_APIParam_4 is less than zero, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.The size of the blob (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.", "key": "sqlite3_blob_read", "sent": "The size of the blob (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "Every new database connection defaults to having the auto-checkpoint enabled with a threshold of 1000 or SQLITE_DEFAULT_WAL_AUTOCHECKPOINT pages.The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application.", "key": "sqlite3_wal_autocheckpoint", "sent": "The use of this interface is only necessary if the default setting is found to be suboptimal for a particular application."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.N bytes of data are copied into buffer sqlite3_blob_read_APIParam_2 from the open BLOB, starting at offset sqlite3_blob_read_APIParam_4.", "key": "sqlite3_blob_read", "sent": "N bytes of data are copied into buffer sqlite3_blob_read_APIParam_2 from the open BLOB, starting at offset sqlite3_blob_read_APIParam_4."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "If offset sqlite3_blob_read_APIParam_4 is less than sqlite3_blob_read_APIParam_3 bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.If sqlite3_blob_read_APIParam_3 or sqlite3_blob_read_APIParam_4 is less than zero, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.The size of the blob (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.", "key": "sqlite3_blob_read", "sent": "If sqlite3_blob_read_APIParam_3 or sqlite3_blob_read_APIParam_4 is less than zero, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read."}, {"API_info": {"var": ["sqlite3 *"], "API_desc": " These interfaces are only available if SQLite is compiled using the SQLITE_ENABLE_PREUPDATE_HOOK compile-time option.The sqlite3_preupdate_hook_APIName interface registers a callback function that is invoked prior to each INSERT, UPDATE, and DELETE operation on a database table.", "var_type": ["sqlite3 *"], "ret_type": "int"}, "paraph": "The sqlite3_preupdate_depth_APIName interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth.", "key": "sqlite3_preupdate_depth", "sent": "The sqlite3_preupdate_depth_APIName interface returns 0 if the preupdate callback was invoked as a result of a direct insert, update, or delete operation; or 1 for inserts, updates, or deletes invoked by top-level triggers; or 2 for changes resulting from triggers called by top-level triggers; and so forth."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "See also: sqlite3_blob_write_APIName.", "key": "sqlite3_blob_read", "sent": "See also: sqlite3_blob_write_APIName."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "On success, sqlite3_blob_read_APIName returns SQLITE_OK_API_constant.Otherwise, an error code or an extended error code be returned by sqlite3_blob_read_APIName.", "key": "sqlite3_blob_read", "sent": "Otherwise, an error code or an extended error code be returned by sqlite3_blob_read_APIName."}, {"API_info": {"var": ["db", "N"], "API_desc": " The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.", "var_type": ["sqlite3 *", "int"], "ret_type": "int"}, "paraph": "The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file.Passing zero or a negative value as the nFrame parameter disables automatic checkpoints entirely.", "key": "sqlite3_wal_autocheckpoint", "sent": "The sqlite3_wal_autocheckpoint_APIName is a wrapper around sqlite3_wal_hook_APIName that causes any database on database connection D to automatically checkpoint after committing a transaction if there are sqlite3_wal_autocheckpoint_APIParam_2 or more frames in the write-ahead log file."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "An attempt to read from an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant.", "key": "sqlite3_blob_read", "sent": "An attempt to read from an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "If offset sqlite3_blob_read_APIParam_4 is less than sqlite3_blob_read_APIParam_3 bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.If sqlite3_blob_read_APIParam_3 or sqlite3_blob_read_APIParam_4 is less than zero, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read.The size of the blob (and hence the maximum value of N+iOffset) can be determined using the sqlite3_blob_bytes_APIName interface.", "key": "sqlite3_blob_read", "sent": "If offset sqlite3_blob_read_APIParam_4 is less than sqlite3_blob_read_APIParam_3 bytes from the end of the BLOB, SQLITE_ERROR_API_constant be returned by sqlite3_blob_read_APIName and no data is read."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.(See SQLITE_VTAB_CONSTRAINT_SUPPORT_API_constant.)Further options may be added in the future.", "key": "sqlite3_vtab_config", "sent": "(See SQLITE_VTAB_CONSTRAINT_SUPPORT_API_constant.)"}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_read", "sent": "Passing any other pointer in to this routine results in undefined and probably undesirable behavior."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.(See SQLITE_VTAB_CONSTRAINT_SUPPORT_API_constant.)Further options may be added in the future.", "key": "sqlite3_vtab_config", "sent": "At present, there is only one option that may be configured using sqlite3_vtab_config_APIName."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.(See SQLITE_VTAB_CONSTRAINT_SUPPORT_API_constant.)Further options may be added in the future.", "key": "sqlite3_vtab_config", "sent": "Further options may be added in the future."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.", "key": "sqlite3_vtab_config", "sent": "If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "This interface allows the size of various constructs to be limited on a connection by connection basis.The first parameter is the database connection whose limit is to be set or queried.The second parameter is one of the limit categories that define a class of constructs to be size limited.The third parameter is the new limit for that construct.", "key": "sqlite3_limit", "sent": "The third parameter is the new limit for that construct."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "This interface allows the size of various constructs to be limited on a connection by connection basis.The first parameter is the database connection whose limit is to be set or queried.The second parameter is one of the limit categories that define a class of constructs to be size limited.The third parameter is the new limit for that construct.", "key": "sqlite3_limit", "sent": "This interface allows the size of various constructs to be limited on a connection by connection basis."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "If the new limit is a negative number, the limit is unchanged.For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME.(The \"_LIMIT_\" in the name is changed to \"_MAX_\".)Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.", "key": "sqlite3_limit", "sent": "(The \"_LIMIT_\" in the name is changed to \"_MAX_\".)"}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "This interface allows the size of various constructs to be limited on a connection by connection basis.The first parameter is the database connection whose limit is to be set or queried.The second parameter is one of the limit categories that define a class of constructs to be size limited.The third parameter is the new limit for that construct.", "key": "sqlite3_limit", "sent": "The first parameter is the database connection whose limit is to be set or queried."}, {"API_info": {"var": ["sqlite3_blob *", "Z", "N", "iOffset"], "API_desc": " sqlite3_blob_read_APIName is used to read data from an open BLOB handle into a caller-supplied buffer.", "var_type": ["sqlite3_blob *", "void *", "int", "int"], "ret_type": "int"}, "paraph": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName.Passing any other pointer in to this routine results in undefined and probably undesirable behavior.", "key": "sqlite3_blob_read", "sent": "This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "This interface allows the size of various constructs to be limited on a connection by connection basis.The first parameter is the database connection whose limit is to be set or queried.The second parameter is one of the limit categories that define a class of constructs to be size limited.The third parameter is the new limit for that construct.", "key": "sqlite3_limit", "sent": "The second parameter is one of the limit categories that define a class of constructs to be size limited."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "If the new limit is a negative number, the limit is unchanged.For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME.(The \"_LIMIT_\" in the name is changed to \"_MAX_\".)Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.", "key": "sqlite3_limit", "sent": "If the new limit is a negative number, the limit is unchanged."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "If the new limit is a negative number, the limit is unchanged.For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME.(The \"_LIMIT_\" in the name is changed to \"_MAX_\".)Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.", "key": "sqlite3_limit", "sent": "For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.If this interface is invoked outside the context of an xConnect or xCreate virtual table method then the behavior is undefined.At present, there is only one option that may be configured using sqlite3_vtab_config_APIName.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface.", "key": "sqlite3_vtab_config", "sent": "sqlite3_vtab_config_APIName may be called by either the xConnect or xCreate method of a virtual table implementation to configure various facets of the virtual table interface."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "If the new limit is a negative number, the limit is unchanged.For each limit category SQLITE_LIMIT_NAME there is a hard upper bound set at compile-time by a C preprocessor macro called SQLITE_MAX_NAME.(The \"_LIMIT_\" in the name is changed to \"_MAX_\".)Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound.", "key": "sqlite3_limit", "sent": "Attempts to increase a limit above its hard upper bound are silently truncated to the hard upper bound."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "The internal databases can be given the large, default limits."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "New run-time limit categories may be added in future releases.", "key": "sqlite3_limit", "sent": "New run-time limit categories may be added in future releases."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Regardless of whether or not the limit was changed, the sqlite3_limit_APIName interface returns the prior value of the limit.Hence, to find the current value of a limit without changing it, simply invoke this interface with sqlite3_limit_APIParam_3 set to -1.", "key": "sqlite3_limit", "sent": "Regardless of whether or not the limit was changed, the sqlite3_limit_APIName interface returns the prior value of the limit."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack."}, {"API_info": "sqlite3_commit_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_commit_hook", "sent": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Regardless of whether or not the limit was changed, the sqlite3_limit_APIName interface returns the prior value of the limit.Hence, to find the current value of a limit without changing it, simply invoke this interface with sqlite3_limit_APIParam_3 set to -1.", "key": "sqlite3_limit", "sent": "Hence, to find the current value of a limit without changing it, simply invoke this interface with sqlite3_limit_APIParam_3 set to -1."}, {"API_info": "sqlite3_commit_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_commit_hook", "sent": "Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden."}, {"API_info": "sqlite3_rollback_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_rollback_hook", "sent": "The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back."}, {"API_info": "sqlite3_commit_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_commit_hook", "sent": "The pArg argument is passed through to the callback."}, {"API_info": {"var": ["sqlite3*", "id", "newVal"], "API_desc": " This interface allows the size of various constructs to be limited on a connection by connection basis.", "var_type": ["sqlite3*", "int", "int"], "ret_type": "int"}, "paraph": "Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources.An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet.The internal databases can be given the large, default limits.Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack.Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL.The size of the database created by an untrusted script can be contained using the max_page_count PRAGMA.", "key": "sqlite3_limit", "sent": "An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet."}, {"API_info": "sqlite3_rollback_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_rollback_hook", "sent": "Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden."}, {"API_info": "sqlite3_bind_pointernot exist in API_info", "paraph": "The sqlite3_bind_pointer_APIName routine causes the I-th parameter in prepared statement S to have an SQL value of NULL, but to also be associated with the pointer P of type T.  D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P.  The T parameter should be a static string, preferably a string literal.The sqlite3_bind_pointer_APIName routine is part of the pointer passing interface added for SQLite 3.20.0.", "key": "sqlite3_bind_pointer", "sent": "The sqlite3_bind_pointer_APIName routine causes the I-th parameter in prepared statement S to have an SQL value of NULL, but to also be associated with the pointer P of type T.  D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P.  The T parameter should be a static string, preferably a string literal."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "The commit and rollback hook callbacks are not reentrant.The callback implementation must not do anything that will modify the database connection that invoked the callback.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place.Note that running any other SQL statements, including SELECT statements, or merely calling sqlite3_prepare_v2_APIName and sqlite3_step_APIName will modify the database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_commit_hook", "sent": "The commit and rollback hook callbacks are not reentrant."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "Registering a NULL function disables the callback.", "key": "sqlite3_commit_hook", "sent": "Registering a NULL function disables the callback."}, {"API_info": "sqlite3_commit_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName interface registers a callback function to be invoked whenever a transaction is committed.Any callback set by a previous call to sqlite3_commit_hook_APIName for the same database connection is overridden.The sqlite3_rollback_hook_APIName interface registers a callback function to be invoked whenever a transaction is rolled back.Any callback set by a previous call to sqlite3_rollback_hook_APIName for the same database connection is overridden.The pArg argument is passed through to the callback.If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.", "key": "sqlite3_commit_hook", "sent": "If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "The commit and rollback hook callbacks are not reentrant.The callback implementation must not do anything that will modify the database connection that invoked the callback.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place.Note that running any other SQL statements, including SELECT statements, or merely calling sqlite3_prepare_v2_APIName and sqlite3_step_APIName will modify the database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_commit_hook", "sent": "The callback implementation must not do anything that will modify the database connection that invoked the callback."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "When the commit hook callback routine returns zero, the COMMIT operation is allowed to continue normally.If the commit hook returns non-zero, then the COMMIT is converted into a ROLLBACK.The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.", "key": "sqlite3_commit_hook", "sent": "If the commit hook returns non-zero, then the COMMIT is converted into a ROLLBACK."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "See also the sqlite3_update_hook_APIName interface.", "key": "sqlite3_commit_hook", "sent": "See also the sqlite3_update_hook_APIName interface."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "When the commit hook callback routine returns zero, the COMMIT operation is allowed to continue normally.If the commit hook returns non-zero, then the COMMIT is converted into a ROLLBACK.The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.", "key": "sqlite3_commit_hook", "sent": "When the commit hook callback routine returns zero, the COMMIT operation is allowed to continue normally."}, {"API_info": "sqlite3_rollback_hook not exist in API_info", "paraph": "The commit and rollback hook callbacks are not reentrant.The callback implementation must not do anything that will modify the database connection that invoked the callback.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place.Note that running any other SQL statements, including SELECT statements, or merely calling sqlite3_prepare_v2_APIName and sqlite3_step_APIName will modify the database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_rollback_hook", "sent": "Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place."}, {"API_info": "sqlite3_rollback_hook not exist in API_info", "paraph": "For the purposes of this API, a transaction is said to have been rolled back if an explicit \"ROLLBACK\" statement is executed, or an error or constraint causes an implicit rollback to occur.The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.", "key": "sqlite3_rollback_hook", "sent": "The rollback callback is not invoked if a transaction is automatically rolled back  ."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf_APIName) and return an appropriate error code.SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint_APIName.SQLite will invoke sqlite3_free_APIName on *pzErrMsg after xEntryPoint_APIName returns.If any xEntryPoint_APIName returns an error, the sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName call that provoked the xEntryPoint_APIName will fail.", "key": "sqlite3_auto_extension", "sent": "SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint_APIName."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf_APIName) and return an appropriate error code.SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint_APIName.SQLite will invoke sqlite3_free_APIName on *pzErrMsg after xEntryPoint_APIName returns.If any xEntryPoint_APIName returns an error, the sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName call that provoked the xEntryPoint_APIName will fail.", "key": "sqlite3_auto_extension", "sent": "SQLite will invoke sqlite3_free_APIName on *pzErrMsg after xEntryPoint_APIName returns."}, {"API_info": "sqlite3_rollback_hook not exist in API_info", "paraph": "When the commit hook callback routine returns zero, the COMMIT operation is allowed to continue normally.If the commit hook returns non-zero, then the COMMIT is converted into a ROLLBACK.The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.", "key": "sqlite3_rollback_hook", "sent": "The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "This interface causes the xEntryPoint_APIName function to be invoked for each new database connection that is created.The idea here is that xEntryPoint_APIName is the entry point for a statically linked SQLite extension that is to be automatically loaded into all new database connections.", "key": "sqlite3_auto_extension", "sent": "This interface causes the xEntryPoint_APIName function to be invoked for each new database connection that is created."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "See also: sqlite3_reset_auto_extension_APIName and sqlite3_cancel_auto_extension_APIName", "key": "sqlite3_auto_extension", "sent": "See also: sqlite3_reset_auto_extension_APIName and sqlite3_cancel_auto_extension_APIName"}, {"API_info": "sqlite3_rollback_hook not exist in API_info", "paraph": "The commit and rollback hook callbacks are not reentrant.The callback implementation must not do anything that will modify the database connection that invoked the callback.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place.Note that running any other SQL statements, including SELECT statements, or merely calling sqlite3_prepare_v2_APIName and sqlite3_step_APIName will modify the database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_rollback_hook", "sent": "Note that running any other SQL statements, including SELECT statements, or merely calling sqlite3_prepare_v2_APIName and sqlite3_step_APIName will modify the database connections for the meaning of \"modify\" in this paragraph."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "Calling sqlite3_auto_extension_APIName with an entry point X that is already on the list of automatic extensions is a harmless no-op.No entry point will be called more than once for each database connection that is opened.", "key": "sqlite3_auto_extension", "sent": "No entry point will be called more than once for each database connection that is opened."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.Calls to sqlite3_close_APIName and sqlite3_close_v2_APIName return SQLITE_OK_API_constant if the sqlite3 object is successfully destroyed and all associated resources are deallocated.", "key": "sqlite3_close", "sent": "The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf_APIName) and return an appropriate error code.SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint_APIName.SQLite will invoke sqlite3_free_APIName on *pzErrMsg after xEntryPoint_APIName returns.If any xEntryPoint_APIName returns an error, the sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName call that provoked the xEntryPoint_APIName will fail.", "key": "sqlite3_auto_extension", "sent": "If any xEntryPoint_APIName returns an error, the sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName call that provoked the xEntryPoint_APIName will fail."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "This interface causes the xEntryPoint_APIName function to be invoked for each new database connection that is created.The idea here is that xEntryPoint_APIName is the entry point for a statically linked SQLite extension that is to be automatically loaded into all new database connections.", "key": "sqlite3_auto_extension", "sent": "The idea here is that xEntryPoint_APIName is the entry point for a statically linked SQLite extension that is to be automatically loaded into all new database connections."}, {"API_info": "sqlite3_commit_hooknot exist in API_info", "paraph": "The sqlite3_commit_hook_APIName and sqlite3_rollback_hook_APIName functions return the P argument from the previous call of the same function on the same database connection D, or NULL for the first call for each function on D.", "key": "sqlite3_commit_hook", "sent": "The sqlite3_commit_hook_APIName and sqlite3_rollback_hook_APIName functions return the P argument from the previous call of the same function on the same database connection D, or NULL for the first call for each function on D."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf_APIName) and return an appropriate error code.SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint_APIName.SQLite will invoke sqlite3_free_APIName on *pzErrMsg after xEntryPoint_APIName returns.If any xEntryPoint_APIName returns an error, the sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName call that provoked the xEntryPoint_APIName will fail.", "key": "sqlite3_auto_extension", "sent": "If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from sqlite3_mprintf_APIName) and return an appropriate error code."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "Calling sqlite3_auto_extension_APIName with an entry point X that is already on the list of automatic extensions is a harmless no-op.No entry point will be called more than once for each database connection that is opened.", "key": "sqlite3_auto_extension", "sent": "Calling sqlite3_auto_extension_APIName with an entry point X that is already on the list of automatic extensions is a harmless no-op."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.Calls to sqlite3_close_APIName and sqlite3_close_v2_APIName return SQLITE_OK_API_constant if the sqlite3 object is successfully destroyed and all associated resources are deallocated.", "key": "sqlite3_close", "sent": "Calls to sqlite3_close_APIName and sqlite3_close_v2_APIName return SQLITE_OK_API_constant if the sqlite3 object is successfully destroyed and all associated resources are deallocated."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_close_v2_APIParam_1 parameter to sqlite3_close_APIName and sqlite3_close_v2_APIName must be either a NULL pointer or an sqlite3 object pointer obtained from sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName, and not previously closed.Calling sqlite3_close_APIName or sqlite3_close_v2_APIName with a NULL pointer argument is a harmless no-op.", "key": "sqlite3_close", "sent": "Calling sqlite3_close_APIName or sqlite3_close_v2_APIName with a NULL pointer argument is a harmless no-op."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If an sqlite3 object is destroyed while a transaction is open, the transaction is automatically rolled back.", "key": "sqlite3_close", "sent": "If an sqlite3 object is destroyed while a transaction is open, the transaction is automatically rolled back."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close_APIName will leave the database connection open and return SQLITE_BUSY_API_constant.If sqlite3_close_v2_APIName is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable \"zombie\" which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished.The sqlite3_close_v2_APIName interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.", "key": "sqlite3_close", "sent": "The sqlite3_close_v2_APIName interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close_APIName will leave the database connection open and return SQLITE_BUSY_API_constant.If sqlite3_close_v2_APIName is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable \"zombie\" which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished.The sqlite3_close_v2_APIName interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.", "key": "sqlite3_close", "sent": "If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close_APIName will leave the database connection open and return SQLITE_BUSY_API_constant."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The sqlite3_update_hook_APIName interface registers a callback function with the database connection identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a rowid table.Any callback set by a previous call to sqlite3_update_hook_APIName for the same database connection is overridden.", "key": "sqlite3_update_hook", "sent": "Any callback set by a previous call to sqlite3_update_hook_APIName for the same database connection is overridden."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Applications should finalize all prepared statements, close all BLOB handles, and finish all sqlite3_backup objects associated with the sqlite3 object prior to attempting to close the object.If sqlite3_close_v2_APIName is called on a database connection that still has outstanding prepared statements, BLOB handles, and/or sqlite3_backup objects then sqlite3_close_APIName returns SQLITE_OK_API_constant and the deallocation of resources is deferred until all prepared statements, BLOB handles, and sqlite3_backup objects are also destroyed.", "key": "sqlite3_close", "sent": "Applications should finalize all prepared statements, close all BLOB handles, and finish all sqlite3_backup objects associated with the sqlite3 object prior to attempting to close the object."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "The final callback parameter is the rowid of the row."}, {"API_info": "sqlite3_commit_hook not exist in API_info", "paraph": "For the purposes of this API, a transaction is said to have been rolled back if an explicit \"ROLLBACK\" statement is executed, or an error or constraint causes an implicit rollback to occur.The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.", "key": "sqlite3_commit_hook", "sent": "For the purposes of this API, a transaction is said to have been rolled back if an explicit \"ROLLBACK\" statement is executed, or an error or constraint causes an implicit rollback to occur."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook is not invoked when internal system tables are modified (i.e.sqlite_master and sqlite_sequence).The update hook is not invoked when WITHOUT ROWID tables are modified.", "key": "sqlite3_update_hook", "sent": "sqlite_master and sqlite_sequence)."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "In the case of an update, this is the rowid after the update takes place."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook is not invoked when internal system tables are modified (i.e.sqlite_master and sqlite_sequence).The update hook is not invoked when WITHOUT ROWID tables are modified.", "key": "sqlite3_update_hook", "sent": "The update hook is not invoked when WITHOUT ROWID tables are modified."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_close_v2_APIParam_1 parameter to sqlite3_close_APIName and sqlite3_close_v2_APIName must be either a NULL pointer or an sqlite3 object pointer obtained from sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName, and not previously closed.Calling sqlite3_close_APIName or sqlite3_close_v2_APIName with a NULL pointer argument is a harmless no-op.", "key": "sqlite3_close", "sent": "The sqlite3_close_v2_APIParam_1 parameter to sqlite3_close_APIName and sqlite3_close_v2_APIName must be either a NULL pointer or an sqlite3 object pointer obtained from sqlite3_open_APIName, sqlite3_open16_APIName, or sqlite3_open_v2_APIName, and not previously closed."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an ON CONFLICT REPLACE clause.Nor is the update hook invoked when rows are deleted using the truncate optimization.The exceptions defined in this paragraph might change in a future release of SQLite.", "key": "sqlite3_update_hook", "sent": "Nor is the update hook invoked when rows are deleted using the truncate optimization."}, {"API_info": "sqlite3_auto_extensionnot exist in API_info", "paraph": "Even though the function prototype shows that xEntryPoint_APIName takes no arguments and returns void, SQLite invokes xEntryPoint_APIName with three arguments and expects an integer result as if the signature of the entry point where as follows:", "key": "sqlite3_auto_extension", "sent": "Even though the function prototype shows that xEntryPoint_APIName takes no arguments and returns void, SQLite invokes xEntryPoint_APIName with three arguments and expects an integer result as if the signature of the entry point where as follows:"}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The sqlite3_update_hook_APIName interface registers a callback function with the database connection identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a rowid table.Any callback set by a previous call to sqlite3_update_hook_APIName for the same database connection is overridden.", "key": "sqlite3_update_hook", "sent": "The sqlite3_update_hook_APIName interface registers a callback function with the database connection identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a rowid table."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table.The first argument to the callback is a copy of the third argument to sqlite3_update_hook_APIName.The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked.The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row.The final callback parameter is the rowid of the row.In the case of an update, this is the rowid after the update takes place.", "key": "sqlite3_update_hook", "sent": "The second callback argument is one of SQLITE_INSERT_API_constant, SQLITE_DELETE_API_constant, or SQLITE_UPDATE_API_constant, depending on the operation that caused the callback to be invoked."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an ON CONFLICT REPLACE clause.Nor is the update hook invoked when rows are deleted using the truncate optimization.The exceptions defined in this paragraph might change in a future release of SQLite.", "key": "sqlite3_update_hook", "sent": "The exceptions defined in this paragraph might change in a future release of SQLite."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook implementation must not do anything that will modify the database connection that invoked the update hook.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the update hook.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_update_hook", "sent": "The update hook implementation must not do anything that will modify the database connection that invoked the update hook."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close_APIName will leave the database connection open and return SQLITE_BUSY_API_constant.If sqlite3_close_v2_APIName is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable \"zombie\" which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished.The sqlite3_close_v2_APIName interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.", "key": "sqlite3_close", "sent": "If sqlite3_close_v2_APIName is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable \"zombie\" which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "See also the sqlite3_commit_hook_APIName, sqlite3_rollback_hook_APIName, and sqlite3_preupdate_hook_APIName interfaces.", "key": "sqlite3_update_hook", "sent": "See also the sqlite3_commit_hook_APIName, sqlite3_rollback_hook_APIName, and sqlite3_preupdate_hook_APIName interfaces."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook implementation must not do anything that will modify the database connection that invoked the update hook.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the update hook.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_update_hook", "sent": "Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook implementation must not do anything that will modify the database connection that invoked the update hook.Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the update hook.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_update_hook", "sent": "Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the update hook."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.In other words, the initial \":\" or \"$\" or \"@\" or \"?\"is included as part of the name.Parameters of the form \"?\"without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".", "key": "sqlite3_bind_parameter_name", "sent": "Parameters of the form \"?\""}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.In other words, the initial \":\" or \"$\" or \"@\" or \"?\"is included as part of the name.Parameters of the form \"?\"without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".", "key": "sqlite3_bind_parameter_name", "sent": "is included as part of the name."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an ON CONFLICT REPLACE clause.Nor is the update hook invoked when rows are deleted using the truncate optimization.The exceptions defined in this paragraph might change in a future release of SQLite.", "key": "sqlite3_update_hook", "sent": "In the current implementation, the update hook is not invoked when conflicting rows are deleted because of an ON CONFLICT REPLACE clause."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The first host parameter has an index of 1, not 0.", "key": "sqlite3_bind_parameter_name", "sent": "The first host parameter has an index of 1, not 0."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_count_APIName, and sqlite3_bind_parameter_index_APIName.", "key": "sqlite3_bind_parameter_name", "sent": "See also: sqlite3_bind_APIName, sqlite3_bind_parameter_count_APIName, and sqlite3_bind_parameter_index_APIName."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The sqlite3_update_hook_APIName function returns the P argument from the previous call on the same database connection D, or NULL for the first call on D.", "key": "sqlite3_update_hook", "sent": "The sqlite3_update_hook_APIName function returns the P argument from the previous call on the same database connection D, or NULL for the first call on D."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "These interfaces return the current status of an sqlite3_str object.", "key": "sqlite3_str_errcode", "sent": "These interfaces return the current status of an sqlite3_str object."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.In other words, the initial \":\" or \"$\" or \"@\" or \"?\"is included as part of the name.Parameters of the form \"?\"without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".", "key": "sqlite3_bind_parameter_name", "sent": "without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\"."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_close_APIName and sqlite3_close_v2_APIName routines are destructors for the sqlite3 object.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Applications should finalize all prepared statements, close all BLOB handles, and finish all sqlite3_backup objects associated with the sqlite3 object prior to attempting to close the object.If sqlite3_close_v2_APIName is called on a database connection that still has outstanding prepared statements, BLOB handles, and/or sqlite3_backup objects then sqlite3_close_APIName returns SQLITE_OK_API_constant and the deallocation of resources is deferred until all prepared statements, BLOB handles, and sqlite3_backup objects are also destroyed.", "key": "sqlite3_close", "sent": "If sqlite3_close_v2_APIName is called on a database connection that still has outstanding prepared statements, BLOB handles, and/or sqlite3_backup objects then sqlite3_close_APIName returns SQLITE_OK_API_constant and the deallocation of resources is deferred until all prepared statements, BLOB handles, and sqlite3_backup objects are also destroyed."}, {"API_info": "sqlite3_update_hooknot exist in API_info", "paraph": "The update hook is not invoked when internal system tables are modified (i.e.sqlite_master and sqlite_sequence).The update hook is not invoked when WITHOUT ROWID tables are modified.", "key": "sqlite3_update_hook", "sent": "The update hook is not invoked when internal system tables are modified (i.e."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "The sqlite3_str_length_APIName method returns the current length, in bytes, of the dynamic string under construction in sqlite3_str object X.The length returned by sqlite3_str_length_APIName does not include the zero-termination byte.", "key": "sqlite3_str_length", "sent": "The length returned by sqlite3_str_length_APIName does not include the zero-termination byte."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "If the value N is out of range or if the N-th parameter is nameless, then NULL be returned by sqlite3_bind_parameter_name_APIName.sqlite3_bind_parameter_name_APIParam_0 is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_name", "sent": "If the value N is out of range or if the N-th parameter is nameless, then NULL be returned by sqlite3_bind_parameter_name_APIName."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "If the value N is out of range or if the N-th parameter is nameless, then NULL be returned by sqlite3_bind_parameter_name_APIName.sqlite3_bind_parameter_name_APIParam_0 is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, or sqlite3_prepare16_v3_APIName.", "key": "sqlite3_bind_parameter_name", "sent": "sqlite3_bind_parameter_name_APIParam_0 is always in UTF-8 encoding  ."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_value_APIName method returns a pointer to the current content of the dynamic string under construction in X.The value returned by sqlite3_str_value_APIName is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same sqlite3_str object.Applications must not used the pointer returned sqlite3_str_value_APIName after any subsequent method call on the same object.Applications may change the content of the string returned by sqlite3_str_value_APIName as long as they do not write into any bytes outside the range of 0 to sqlite3_str_length_APIName and do not read or write any byte after any subsequent sqlite3_str method call.", "key": "sqlite3_str_value", "sent": "The sqlite3_str_value_APIName method returns a pointer to the current content of the dynamic string under construction in X."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "The sqlite3_str_length_APIName method returns the current length, in bytes, of the dynamic string under construction in sqlite3_str object X.The length returned by sqlite3_str_length_APIName does not include the zero-termination byte.", "key": "sqlite3_str_length", "sent": "The sqlite3_str_length_APIName method returns the current length, in bytes, of the dynamic string under construction in sqlite3_str object X."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_value_APIName method returns a pointer to the current content of the dynamic string under construction in X.The value returned by sqlite3_str_value_APIName is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same sqlite3_str object.Applications must not used the pointer returned sqlite3_str_value_APIName after any subsequent method call on the same object.Applications may change the content of the string returned by sqlite3_str_value_APIName as long as they do not write into any bytes outside the range of 0 to sqlite3_str_length_APIName and do not read or write any byte after any subsequent sqlite3_str method call.", "key": "sqlite3_str_value", "sent": "Applications must not used the pointer returned sqlite3_str_value_APIName after any subsequent method call on the same object."}, {"API_info": {"var": ["zOptName"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["const char *"], "ret_type": "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSint"}, "paraph": "The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used_APIName.", "key": "sqlite3_compileoption_used", "sent": "The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used_APIName."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.The sqlite3_str_errcode_APIName method returns SQLITE_NOMEM_API_constant following any out-of-memory error, or SQLITE_TOOBIG_API_constant if the size of the dynamic string exceeds SQLITE_MAX_LENGTH, or SQLITE_OK_API_constant if there have been no errors.", "key": "sqlite3_str_errcode", "sent": "If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code."}, {"API_info": {"var": ["zOptName"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["const char *"], "ret_type": "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSint"}, "paraph": "The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used_APIName.", "key": "sqlite3_compileoption_used", "sent": "The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating  compile time ."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["int"], "ret_type": "const char *"}, "paraph": "The sqlite3_compileoption_get_APIName function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string.If sqlite3_compileoption_get_APIParam_1 is out of range, sqlite3_compileoption_get_APIName returns a NULL pointer.The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get_APIName.", "key": "sqlite3_compileoption_get", "sent": "If sqlite3_compileoption_get_APIParam_1 is out of range, sqlite3_compileoption_get_APIName returns a NULL pointer."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["int"], "ret_type": "const char *"}, "paraph": "The sqlite3_compileoption_get_APIName function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string.If sqlite3_compileoption_get_APIParam_1 is out of range, sqlite3_compileoption_get_APIName returns a NULL pointer.The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get_APIName.", "key": "sqlite3_compileoption_get", "sent": "The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get_APIName."}, {"API_info": {"var": ["zOptName"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["const char *"], "ret_type": "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSint"}, "paraph": "See also: SQL functions sqlite_compileoption_used_APIName and sqlite_compileoption_get_APIName and the compile_options pragma.", "key": "sqlite3_compileoption_used", "sent": "See also: SQL functions sqlite_compileoption_used_APIName and sqlite_compileoption_get_APIName and the compile_options pragma."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "char *"}, "paraph": "The sqlite3_str_value_APIName method returns a pointer to the current content of the dynamic string under construction in X.The value returned by sqlite3_str_value_APIName is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same sqlite3_str object.Applications must not used the pointer returned sqlite3_str_value_APIName after any subsequent method call on the same object.Applications may change the content of the string returned by sqlite3_str_value_APIName as long as they do not write into any bytes outside the range of 0 to sqlite3_str_length_APIName and do not read or write any byte after any subsequent sqlite3_str method call.", "key": "sqlite3_str_value", "sent": "The value returned by sqlite3_str_value_APIName is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same sqlite3_str object."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.Autocommit mode is on by default.Autocommit mode is disabled by a BEGIN statement.Autocommit mode is re-enabled by a COMMIT or ROLLBACK.", "key": "sqlite3_get_autocommit", "sent": "Autocommit mode is on by default."}, {"API_info": {"var": ["zOptName"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["const char *"], "ret_type": "#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGSint"}, "paraph": "Support for the diagnostic functions sqlite3_compileoption_used_APIName and sqlite3_compileoption_get_APIName may be omitted by specifying the SQLITE_OMIT_COMPILEOPTION_DIAGS option at compile time.", "key": "sqlite3_compileoption_used", "sent": "Support for the diagnostic functions sqlite3_compileoption_used_APIName and sqlite3_compileoption_get_APIName may be omitted by specifying the SQLITE_OMIT_COMPILEOPTION_DIAGS option at compile time."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.Autocommit mode is on by default.Autocommit mode is disabled by a BEGIN statement.Autocommit mode is re-enabled by a COMMIT or ROLLBACK.", "key": "sqlite3_get_autocommit", "sent": "Autocommit mode is disabled by a BEGIN statement."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.Autocommit mode is on by default.Autocommit mode is disabled by a BEGIN statement.Autocommit mode is re-enabled by a COMMIT or ROLLBACK.", "key": "sqlite3_get_autocommit", "sent": "Autocommit mode is re-enabled by a COMMIT or ROLLBACK."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.Autocommit mode is on by default.Autocommit mode is disabled by a BEGIN statement.Autocommit mode is re-enabled by a COMMIT or ROLLBACK.", "key": "sqlite3_get_autocommit", "sent": "The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively."}, {"API_info": {"var": ["N"], "API_desc": " The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time.", "var_type": ["int"], "ret_type": "const char *"}, "paraph": "The sqlite3_compileoption_get_APIName function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string.If sqlite3_compileoption_get_APIParam_1 is out of range, sqlite3_compileoption_get_APIName returns a NULL pointer.The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get_APIName.", "key": "sqlite3_compileoption_get", "sent": "The sqlite3_compileoption_get_APIName function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The sqlite3_busy_handler_APIName routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with database connection D when another thread or process has the table locked.The sqlite3_busy_handler_APIName interface is used to implement sqlite3_busy_timeout_APIName and PRAGMA busy_timeout.", "key": "sqlite3_busy_handler", "sent": "The sqlite3_busy_handler_APIName interface is used to implement sqlite3_busy_timeout_APIName and PRAGMA busy_timeout."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " The sqlite3_context_db_handle_APIName interface returns a copy of the pointer to the database connection (the 1st parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function.", "var_type": ["sqlite3_context*"], "ret_type": "sqlite3 *"}, "paraph": "The sqlite3_context_db_handle_APIName interface returns a copy of the pointer to the database connection (the 1_APIConstant parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function.", "key": "sqlite3_context_db_handle", "sent": "The sqlite3_context_db_handle_APIName interface returns a copy of the pointer to the database connection (the 1_APIConstant parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.The sqlite3_str_errcode_APIName method returns SQLITE_NOMEM_API_constant following any out-of-memory error, or SQLITE_TOOBIG_API_constant if the size of the dynamic string exceeds SQLITE_MAX_LENGTH, or SQLITE_OK_API_constant if there have been no errors.", "key": "sqlite3_str_errcode", "sent": "The sqlite3_str_errcode_APIName method returns SQLITE_NOMEM_API_constant following any out-of-memory error, or SQLITE_TOOBIG_API_constant if the size of the dynamic string exceeds SQLITE_MAX_LENGTH, or SQLITE_OK_API_constant if there have been no errors."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If certain kinds of errors occur on a statement within a multi-statement transaction (errors including SQLITE_FULL_API_constant, SQLITE_IOERR_API_constant, SQLITE_NOMEM_API_constant, SQLITE_BUSY_API_constant, and SQLITE_INTERRUPT_API_constant) then the transaction might be rolled back automatically.The only way to find out whether SQLite automatically rolled back the transaction after an error is to use sqlite3_get_autocommit_APIName.", "key": "sqlite3_get_autocommit", "sent": "The only way to find out  is to use sqlite3_get_autocommit_APIName ."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "If the busy callback is NULL, then SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName immediately upon encountering the lock.If the busy callback is not NULL, then the callback might be invoked with two arguments.", "key": "sqlite3_busy_handler", "sent": "If the busy callback is NULL, then SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName immediately upon encountering the lock."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If certain kinds of errors occur on a statement within a multi-statement transaction (errors including SQLITE_FULL_API_constant, SQLITE_IOERR_API_constant, SQLITE_NOMEM_API_constant, SQLITE_BUSY_API_constant, and SQLITE_INTERRUPT_API_constant) then the transaction might be rolled back automatically.The only way to find out whether SQLite automatically rolled back the transaction after an error is to use sqlite3_get_autocommit_APIName.", "key": "sqlite3_get_autocommit", "sent": "If certain kinds of errors occur on a statement within a multi-statement transaction (errors including SQLITE_FULL_API_constant, SQLITE_IOERR_API_constant, SQLITE_NOMEM_API_constant, SQLITE_BUSY_API_constant, and SQLITE_INTERRUPT_API_constant) then the transaction might be rolled back automatically."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "If the busy callback is NULL, then SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName immediately upon encountering the lock.If the busy callback is not NULL, then the callback might be invoked with two arguments.", "key": "sqlite3_busy_handler", "sent": "If the busy callback is not NULL, then the callback might be invoked with two arguments."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_get_autocommit_APIName interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.", "key": "sqlite3_get_autocommit", "sent": "If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler_APIName.The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event.If the busy callback returns 0, then no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application.If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.", "key": "sqlite3_busy_handler", "sent": "The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler_APIName."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler_APIName.The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event.If the busy callback returns 0, then no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application.If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.", "key": "sqlite3_busy_handler", "sent": "If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "If both processes invoke the busy handlers, neither will make any progress."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The default busy callback is NULL.", "key": "sqlite3_busy_handler", "sent": "The default busy callback is NULL."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler_APIName.The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event.If the busy callback returns 0, then no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application.If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.", "key": "sqlite3_busy_handler", "sent": "The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event."}, {"API_info": {"var": ["sqlite3_str*"], "API_desc": " These interfaces return the current status of an sqlite3_str object.If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the sqlite3_str_errcode_APIName method will return an appropriate error code.", "var_type": ["sqlite3_str*"], "ret_type": "int"}, "paraph": "The sqlite3_str_value_APIName method returns a pointer to the current content of the dynamic string under construction in X.The value returned by sqlite3_str_value_APIName is managed by the sqlite3_str object X and might be freed or altered by any subsequent method on the same sqlite3_str object.Applications must not used the pointer returned sqlite3_str_value_APIName after any subsequent method call on the same object.Applications may change the content of the string returned by sqlite3_str_value_APIName as long as they do not write into any bytes outside the range of 0 to sqlite3_str_length_APIName and do not read or write any byte after any subsequent sqlite3_str method call.", "key": "sqlite3_str_length", "sent": "Applications may change the content of the string returned by sqlite3_str_value_APIName as long as they do not write into any bytes outside the range of 0 to sqlite3_str_length_APIName and do not read or write any byte after any subsequent sqlite3_str method call."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "There can only be a single busy handler defined for each database connection.Setting a new busy handler clears any previously set handler.Note that calling sqlite3_busy_timeout_APIName or evaluating PRAGMA busy_timeout=N will change the busy handler and thus clear any previously set busy handler.", "key": "sqlite3_busy_handler", "sent": "There can only be a single busy handler defined for each database connection."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The first argument to the busy handler is a copy of the void* pointer which is the third argument to sqlite3_busy_handler_APIName.The second argument to the busy handler callback is the number of times that the busy handler has been invoked previously for the same locking event.If the busy callback returns 0, then no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application.If the callback returns non-zero, then another attempt is made to access the database and the cycle repeats.", "key": "sqlite3_busy_handler", "sent": "If the busy callback returns 0, then no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The sqlite3_busy_handler_APIName routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with database connection D when another thread or process has the table locked.The sqlite3_busy_handler_APIName interface is used to implement sqlite3_busy_timeout_APIName and PRAGMA busy_timeout.", "key": "sqlite3_busy_handler", "sent": "The sqlite3_busy_handler_APIName routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with database connection D when another thread or process has the table locked."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.In other words, the initial \":\" or \"$\" or \"@\" or \"?\"is included as part of the name.Parameters of the form \"?\"without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".", "key": "sqlite3_bind_parameter_name", "sent": "In other words, the initial \":\" or \"$\" or \"@\" or \"?\""}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "The first process can not proceed  and the second process can not proceed  ."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The presence of a busy handler does not guarantee that it will be invoked when there is lock contention.If SQLite determines that invoking the busy handler could result in a deadlock, it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler.Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock.The first process cannot proceed because it is blocked by the second and the second process cannot proceed because it is blocked by the first.If both processes invoke the busy handlers, neither will make any progress.Therefore, SQLite returns SQLITE_BUSY_API_constant for the first process, hoping that this will induce the first process to release its read lock and allow the second process to proceed.", "key": "sqlite3_busy_handler", "sent": "Consider a scenario where one process is holding a read lock that it is trying to promote to a reserved lock and a second process is holding a reserved lock that it is trying to promote to an exclusive lock."}, {"API_info": {"var": ["sqlite3_stmt*", " int"], "API_desc": " The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.", "var_type": ["sqlite3_stmt*", " int"], "ret_type": "const char *"}, "paraph": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively.In other words, the initial \":\" or \"$\" or \"@\" or \"?\"is included as part of the name.Parameters of the form \"?\"without a following integer have no name and are referred to as \"nameless\" or \"anonymous parameters\".", "key": "sqlite3_bind_parameter_name", "sent": "The sqlite3_bind_parameter_name_APIName interface returns the name of the N-th SQL parameter in the prepared statement P. SQL parameters of the form \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" have a name which is the string \"?NNN\" or \":AAA\" or \"@AAA\" or \"$AAA\" respectively."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "There can only be a single busy handler defined for each database connection.Setting a new busy handler clears any previously set handler.Note that calling sqlite3_busy_timeout_APIName or evaluating PRAGMA busy_timeout=N will change the busy handler and thus clear any previously set busy handler.", "key": "sqlite3_busy_handler", "sent": "Setting a new busy handler clears any previously set handler."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The busy callback should not take any actions which modify the database connection that invoked the busy handler.In other words, the busy handler is not reentrant.Any such actions result in undefined behavior.", "key": "sqlite3_busy_handler", "sent": "Any such actions result in undefined behavior."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The busy callback should not take any actions which modify the database connection that invoked the busy handler.In other words, the busy handler is not reentrant.Any such actions result in undefined behavior.", "key": "sqlite3_busy_handler", "sent": "In other words, the busy handler is not reentrant."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "The busy callback should not take any actions which modify the database connection that invoked the busy handler.In other words, the busy handler is not reentrant.Any such actions result in undefined behavior.", "key": "sqlite3_busy_handler", "sent": "The busy callback should not take any actions which modify the database connection that invoked the busy handler."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "A busy handler must not close the database connection or prepared statement that invoked the busy handler.", "key": "sqlite3_busy_handler", "sent": "A busy handler must not close the database connection or prepared statement that invoked the busy handler."}, {"API_info": "sqlite3_busy_handlernot exist in API_info", "paraph": "There can only be a single busy handler defined for each database connection.Setting a new busy handler clears any previously set handler.Note that calling sqlite3_busy_timeout_APIName or evaluating PRAGMA busy_timeout=N will change the busy handler and thus clear any previously set busy handler.", "key": "sqlite3_busy_handler", "sent": "Note that calling sqlite3_busy_timeout_APIName or evaluating PRAGMA busy_timeout=N will change the busy handler and thus clear any previously set busy handler."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "All calls obtain an exclusive \"checkpoint\" lock on the database file.If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.Even if there is a busy-handler configured, it will not be invoked in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "All calls obtain an exclusive \"checkpoint\" lock on the database file."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database sqlite3_wal_checkpoint_v2_APIParam_2 of database connection sqlite3_wal_checkpoint_v2_APIParam_1 in mode sqlite3_wal_checkpoint_v2_APIParam_3.  Status information is written back into integers pointed to by sqlite3_wal_checkpoint_v2_APIParam_4 and C. The sqlite3_wal_checkpoint_v2_APIParam_3 parameter must be a valid checkpoint mode:", "key": "sqlite3_wal_checkpoint_v2", "sent": "The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database sqlite3_wal_checkpoint_v2_APIParam_2 of database connection sqlite3_wal_checkpoint_v2_APIParam_1 in mode sqlite3_wal_checkpoint_v2_APIParam_3.  Status information is written back into integers pointed to by sqlite3_wal_checkpoint_v2_APIParam_4 and C. The sqlite3_wal_checkpoint_v2_APIParam_3 parameter must be a valid checkpoint mode:"}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "All calls obtain an exclusive \"checkpoint\" lock on the database file.If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.Even if there is a busy-handler configured, it will not be invoked in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": " , it will not be invoked in this case ."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file.If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained.The busy-handler is also invoked while waiting for database readers as described above.If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further.SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file.If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained.The busy-handler is also invoked while waiting for database readers as described above.If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further.SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "The busy-handler is also invoked while waiting for database readers as described above."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file.If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained.The busy-handler is also invoked while waiting for database readers as described above.If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further.SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1.In this case the values written to output parameters *pnLog and *pnCkpt are undefined.If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end.If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately.If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "In this case the values written to output parameters *pnLog and *pnCkpt are undefined."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "All calls obtain an exclusive \"checkpoint\" lock on the database file.If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.Even if there is a busy-handler configured, it will not be invoked in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.If sqlite3_wal_checkpoint_v2_APIParam_5 is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode.Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE_API_constant, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.", "key": "sqlite3_wal_checkpoint_v2", "sent": "Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE_API_constant, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1.In this case the values written to output parameters *pnLog and *pnCkpt are undefined.If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end.If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately.If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The PRAGMA wal_checkpoint command can be used to invoke this interface from SQL.", "key": "sqlite3_wal_checkpoint_v2", "sent": "The PRAGMA wal_checkpoint command can be used to invoke this interface from SQL."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_log_APIParam_2 string must not be NULL.", "key": "sqlite3_log", "sent": "The sqlite3_log_APIParam_2 string must not be NULL."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG_API_constant option to sqlite3_config_APIName.If logging is enabled, the sqlite3_log_APIParam_2 string and subsequent arguments are used with sqlite3_snprintf_APIName to generate the final output string.", "key": "sqlite3_log", "sent": "The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG_API_constant option to sqlite3_config_APIName."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "Unless sqlite3_wal_checkpoint_v2_APIName returns SQLITE_MISUSE_API_constant, the sqlite3_wal_checkpoint_v2_APIName interface sets the error information that is queried by sqlite3_errcode_APIName and sqlite3_errmsg_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "Unless sqlite3_wal_checkpoint_v2_APIName returns SQLITE_MISUSE_API_constant, the sqlite3_wal_checkpoint_v2_APIName interface sets the error information that is queried by sqlite3_errcode_APIName and sqlite3_errmsg_APIName."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1.In this case the values written to output parameters *pnLog and *pnCkpt are undefined.If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end.If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately.If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If database sqlite3_wal_checkpoint_v2_APIParam_2 is the name of an attached database that is not in WAL mode, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName and both *pnLog and *pnCkpt set to -1.If sqlite3_wal_checkpoint_v2_APIParam_2 is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName to the caller.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If sqlite3_wal_checkpoint_v2_APIParam_2 is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName to the caller."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG_API_constant option to sqlite3_config_APIName.If logging is enabled, the sqlite3_log_APIParam_2 string and subsequent arguments are used with sqlite3_snprintf_APIName to generate the final output string.", "key": "sqlite3_log", "sent": "If logging is enabled, the sqlite3_log_APIParam_2 string and subsequent arguments are used with sqlite3_snprintf_APIName to generate the final output string."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_log_APIName interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions.While there is nothing to prevent an application from calling sqlite3_log_APIName, doing so is considered bad form.", "key": "sqlite3_log", "sent": "While there is nothing to prevent an application from calling sqlite3_log_APIName, doing so is considered bad form."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1.In this case the values written to output parameters *pnLog and *pnCkpt are undefined.If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end.If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately.If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "To avoid deadlocks and other threading problems, the sqlite3_log_APIName routine will not use dynamically allocated memory.The log message is stored in a fixed-length buffer on the stack.If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.", "key": "sqlite3_log", "sent": "The log message is stored in a fixed-length buffer on the stack."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "The sqlite3_log_APIName interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions.While there is nothing to prevent an application from calling sqlite3_log_APIName, doing so is considered bad form.", "key": "sqlite3_log", "sent": "The sqlite3_log_APIName interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "To avoid deadlocks and other threading problems, the sqlite3_log_APIName routine will not use dynamically allocated memory.The log message is stored in a fixed-length buffer on the stack.If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.", "key": "sqlite3_log", "sent": "To avoid deadlocks and other threading problems, the sqlite3_log_APIName routine will not use dynamically allocated memory."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If database sqlite3_wal_checkpoint_v2_APIParam_2 is the name of an attached database that is not in WAL mode, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName and both *pnLog and *pnCkpt set to -1.If sqlite3_wal_checkpoint_v2_APIParam_2 is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName to the caller.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If database sqlite3_wal_checkpoint_v2_APIParam_2 is the name of an attached database that is not in WAL mode, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName and both *pnLog and *pnCkpt set to -1."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns.If the table has a column of type INTEGER PRIMARY KEY then that column is another alias for the rowid.", "key": "sqlite3_last_insert_rowid", "sent": "Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\"."}, {"API_info": {"var": ["iErrCode", "zFormat", " ..."], "API_desc": " The sqlite3_log_APIName interface writes a message into the error log established by the SQLITE_CONFIG_LOG option to sqlite3_config_APIName.", "var_type": ["int", "const char *", " ..."], "ret_type": "void"}, "paraph": "To avoid deadlocks and other threading problems, the sqlite3_log_APIName routine will not use dynamically allocated memory.The log message is stored in a fixed-length buffer on the stack.If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.", "key": "sqlite3_log", "sent": "If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g.to flush data accumulated in memory to disk).In this case subsequent calls to sqlite3_last_insert_rowid_APIName return the rowid associated with these internal INSERT operations, which leads to unintuitive results.Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid_APIName before returning control to the user.", "key": "sqlite3_last_insert_rowid", "sent": "to flush data accumulated in memory to disk)."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file.If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained.The busy-handler is also invoked while waiting for database readers as described above.If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further.SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_last_insert_rowid_APIName interface usually returns the rowid of the most recent successful INSERT into a rowid table or virtual table on database connection D. Inserts into WITHOUT ROWID tables are not recorded.If no successful INSERTs into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid_APIName returns zero.", "key": "sqlite3_last_insert_rowid", "sent": "If no successful INSERTs into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid_APIName returns zero."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.If sqlite3_wal_checkpoint_v2_APIParam_5 is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode.Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE_API_constant, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If sqlite3_wal_checkpoint_v2_APIParam_5 is not NULL , then * pnCkpt is set to the total number of checkpointed frames in the log file or to -1 if the checkpoint could not run due to an error or  ."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns.If the table has a column of type INTEGER PRIMARY KEY then that column is another alias for the rowid.", "key": "sqlite3_last_insert_rowid", "sent": "If the table has a column of type INTEGER PRIMARY KEY then that column is another alias for the rowid."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "As well as being set automatically as rows are inserted into database tables, the value returned by sqlite3_last_insert_rowid_APIName may be set explicitly by sqlite3_set_last_insert_rowid_APIName", "key": "sqlite3_last_insert_rowid", "sent": "As well as being set automatically as rows are inserted into database tables, the value returned by sqlite3_last_insert_rowid_APIName may be set explicitly by sqlite3_set_last_insert_rowid_APIName"}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If parameter sqlite3_wal_checkpoint_v2_APIParam_2 is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases attached to database connection sqlite3_wal_checkpoint_v2_APIParam_1.In this case the values written to output parameters *pnLog and *pnCkpt are undefined.If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end.If any other error occurs while processing an attached database, processing is abandoned and the error code be returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately.If no error (SQLITE_BUSY_API_constant or otherwise) is encountered while processing the attached databases, SQLITE_OK_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If an SQLITE_BUSY_API_constant error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName at the end."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "The SQLITE_CHECKPOINT_FULL_API_constant, RESTART and TRUNCATE modes also obtain the exclusive \"writer\" lock on the database file.If the writer lock cannot be obtained immediately, and a busy-handler is configured, it is invoked and the writer lock retried until either the busy-handler returns 0 or the lock is successfully obtained.The busy-handler is also invoked while waiting for database readers as described above.If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further.SQLITE_BUSY_API_constant be returned by sqlite3_wal_checkpoint_v2_APIName in this case.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If the busy-handler returns 0 before the writer lock is obtained or while waiting for database readers, the checkpoint operation proceeds from that point in the same way as SQLITE_CHECKPOINT_PASSIVE_API_constant - checkpointing as many frames as possible without blocking any further."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g.to flush data accumulated in memory to disk).In this case subsequent calls to sqlite3_last_insert_rowid_APIName return the rowid associated with these internal INSERT operations, which leads to unintuitive results.Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid_APIName before returning control to the user.", "key": "sqlite3_last_insert_rowid", "sent": "In this case subsequent calls to sqlite3_last_insert_rowid_APIName return the rowid associated with these internal INSERT operations, which leads to unintuitive results."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "An INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine.Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails.When INSERT OR REPLACE encounters a constraint violation, it does not fail.The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.", "key": "sqlite3_last_insert_rowid", "sent": "When INSERT OR REPLACE encounters a constraint violation, it does not fail."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "If an INSERT occurs within a trigger then this routine will return the rowid of the inserted row as long as the trigger is running.Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.", "key": "sqlite3_last_insert_rowid", "sent": "Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "sqlite3_last_insert_rowid_APIName is accessible to SQL statements via the last_insert_rowid_APIName SQL function.", "key": "sqlite3_last_insert_rowid", "sent": "sqlite3_last_insert_rowid_APIName is accessible to SQL statements via the last_insert_rowid_APIName SQL function."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "If an INSERT occurs within a trigger then this routine will return the rowid of the inserted row as long as the trigger is running.Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.", "key": "sqlite3_last_insert_rowid", "sent": "If an INSERT occurs within a trigger then this routine will return the rowid of the inserted row as long as the trigger is running."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "An INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine.Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails.When INSERT OR REPLACE encounters a constraint violation, it does not fail.The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.", "key": "sqlite3_last_insert_rowid", "sent": "An INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g.to flush data accumulated in memory to disk).In this case subsequent calls to sqlite3_last_insert_rowid_APIName return the rowid associated with these internal INSERT operations, which leads to unintuitive results.Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid_APIName before returning control to the user.", "key": "sqlite3_last_insert_rowid", "sent": "Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid_APIName before returning control to the user."}, {"API_info": {"var": ["db", "zDb", "eMode", "pnLog", "pnCkpt"], "API_desc": " The sqlite3_wal_checkpoint_v2_APIName interface runs a checkpoint operation on database X of database connection D in mode M.  Status information is written back into integers pointed to by L and C. The M parameter must be a valid checkpoint mode:If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.", "var_type": ["sqlite3 *", "const char *", "int", "int *", "int *"], "ret_type": "int"}, "paraph": "If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in WAL mode.If sqlite3_wal_checkpoint_v2_APIParam_5 is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode.Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE_API_constant, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.", "key": "sqlite3_wal_checkpoint_v2", "sent": "If sqlite3_wal_checkpoint_v2_APIParam_4 is not NULL , then * pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or  ."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "SQLite can be compiled with or without mutexes.When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe.When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted.Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.", "key": "sqlite3_threadsafe", "sent": "SQLite can be compiled with or without mutexes."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "An INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine.Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails.When INSERT OR REPLACE encounters a constraint violation, it does not fail.The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.", "key": "sqlite3_last_insert_rowid", "sent": "The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns.If the table has a column of type INTEGER PRIMARY KEY then that column is another alias for the rowid.", "key": "sqlite3_last_insert_rowid", "sent": "The rowid is always available as an undeclared column named ROWID, OID, or _ROWID_ as long as those names are not also used by explicitly declared columns."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "For the purposes of this routine, an INSERT is considered to be successful even if it is subsequently rolled back.", "key": "sqlite3_last_insert_rowid", "sent": "For the purposes of this routine , an INSERT is considered to be successful  ."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "An INSERT that fails due to a constraint violation is not a successful INSERT and does not change the value returned by this routine.Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails.When INSERT OR REPLACE encounters a constraint violation, it does not fail.The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.", "key": "sqlite3_last_insert_rowid", "sent": "Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "SQLite can be compiled with or without mutexes.When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe.When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted.Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.", "key": "sqlite3_threadsafe", "sent": "When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Enabling mutexes incurs a measurable performance penalty.So if speed is of utmost importance, it makes sense to disable the mutexes.But for maximum safety, mutexes should be enabled.The default behavior is for mutexes to be enabled.", "key": "sqlite3_threadsafe", "sent": "Enabling mutexes incurs a measurable performance penalty."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Enabling mutexes incurs a measurable performance penalty.So if speed is of utmost importance, it makes sense to disable the mutexes.But for maximum safety, mutexes should be enabled.The default behavior is for mutexes to be enabled.", "key": "sqlite3_threadsafe", "sent": "But for maximum safety, mutexes should be enabled."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "SQLite can be compiled with or without mutexes.When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe.When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted.Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.", "key": "sqlite3_threadsafe", "sent": "Without the mutexes, it is not safe to use SQLite concurrently from more than one thread."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Enabling mutexes incurs a measurable performance penalty.So if speed is of utmost importance, it makes sense to disable the mutexes.But for maximum safety, mutexes should be enabled.The default behavior is for mutexes to be enabled.", "key": "sqlite3_threadsafe", "sent": "So if speed is of utmost importance, it makes sense to disable the mutexes."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Enabling mutexes incurs a measurable performance penalty.So if speed is of utmost importance, it makes sense to disable the mutexes.But for maximum safety, mutexes should be enabled.The default behavior is for mutexes to be enabled.", "key": "sqlite3_threadsafe", "sent": "The default behavior is for mutexes to be enabled."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "SQLite can be compiled with or without mutexes.When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe.When the SQLITE_THREADSAFE macro is 0, the mutexes are omitted.Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.", "key": "sqlite3_threadsafe", "sent": "When the SQLITE_THREADSAFE C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.", "key": "sqlite3_threadsafe", "sent": "The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "The sqlite3_last_insert_rowid_APIName interface usually returns the rowid of the most recent successful INSERT into a rowid table or virtual table on database connection D. Inserts into WITHOUT ROWID tables are not recorded.If no successful INSERTs into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid_APIName returns zero.", "key": "sqlite3_last_insert_rowid", "sent": "The sqlite3_last_insert_rowid_APIName interface usually returns the rowid of the most recent successful INSERT into a rowid table or virtual table on database connection D. Inserts into WITHOUT ROWID tables are not recorded."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "See the threading mode documentation for additional information.", "key": "sqlite3_threadsafe", "sent": "See the threading mode documentation for additional information."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "This interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag.If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config_APIName with the verbs SQLITE_CONFIG_SINGLETHREAD_API_constant, SQLITE_CONFIG_MULTITHREAD_API_constant, or SQLITE_CONFIG_SERIALIZED_API_constant.The return value of the sqlite3_threadsafe_APIName function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config_APIName.In other words, the return value from sqlite3_threadsafe_APIName is unchanged by calls to sqlite3_config_APIName.", "key": "sqlite3_threadsafe", "sent": "This interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes_APIName.", "key": "sqlite3_total_changes", "sent": "Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "This interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag.If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config_APIName with the verbs SQLITE_CONFIG_SINGLETHREAD_API_constant, SQLITE_CONFIG_MULTITHREAD_API_constant, or SQLITE_CONFIG_SERIALIZED_API_constant.The return value of the sqlite3_threadsafe_APIName function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config_APIName.In other words, the return value from sqlite3_threadsafe_APIName is unchanged by calls to sqlite3_config_APIName.", "key": "sqlite3_threadsafe", "sent": "In other words, the return value from sqlite3_threadsafe_APIName is unchanged by calls to sqlite3_config_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Changes made as part of foreign key actions are included in the count, but those made as part of REPLACE constraint resolution are not.Changes to a view that are intercepted by INSTEAD OF triggers are not counted.", "key": "sqlite3_total_changes", "sent": "Changes to a view that are intercepted by INSTEAD OF triggers are not counted."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "See also:", "key": "sqlite3_total_changes", "sent": "See also:"}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "This interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag.If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config_APIName with the verbs SQLITE_CONFIG_SINGLETHREAD_API_constant, SQLITE_CONFIG_MULTITHREAD_API_constant, or SQLITE_CONFIG_SERIALIZED_API_constant.The return value of the sqlite3_threadsafe_APIName function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config_APIName.In other words, the return value from sqlite3_threadsafe_APIName is unchanged by calls to sqlite3_config_APIName.", "key": "sqlite3_threadsafe", "sent": "The return value of the sqlite3_threadsafe_APIName function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.To avoid memory leaks, the object returned by sqlite3_str_new_APIName must be freed by a subsequent call to sqlite3_str_finish_APIName.", "key": "sqlite3_str_new", "sent": "The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the SQLITE_THREADSAFE macro.", "key": "sqlite3_threadsafe", "sent": "This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the SQLITE_THREADSAFE macro."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "Changes made as part of foreign key actions are included in the count, but those made as part of REPLACE constraint resolution are not.Changes to a view that are intercepted by INSTEAD OF triggers are not counted.", "key": "sqlite3_total_changes", "sent": "Changes made as part of foreign key actions are included in the count, but those made as part of REPLACE constraint resolution are not."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_total_changes_APIName interface only reports the number of rows that changed due to SQL statement run against database connection D.  Any changes by other database connections are ignored.To detect changes against a database file from other database connections use the PRAGMA data_version command or the SQLITE_FCNTL_DATA_VERSION_API_constant file control.", "key": "sqlite3_total_changes", "sent": "To detect changes against a database file from other database connections use the PRAGMA data_version command or the SQLITE_FCNTL_DATA_VERSION_API_constant file control."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIParam_1 parameter to sqlite3_str_new_APIName may be NULL.If the D parameter in sqlite3_str_new_APIName is not NULL, then the maximum length of the string contained in the sqlite3_str object will be the value set for sqlite3_limit_APIName instead of SQLITE_MAX_LENGTH.", "key": "sqlite3_str_new", "sent": "The sqlite3_str_new_APIParam_1 parameter to sqlite3_str_new_APIName may be NULL."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.To avoid memory leaks, the object returned by sqlite3_str_new_APIName must be freed by a subsequent call to sqlite3_str_finish_APIName.", "key": "sqlite3_str_new", "sent": "To avoid memory leaks, the object returned by sqlite3_str_new_APIName must be freed by a subsequent call to sqlite3_str_finish_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "The sqlite3_total_changes_APIName interface only reports the number of rows that changed due to SQL statement run against database connection D.  Any changes by other database connections are ignored.To detect changes against a database file from other database connections use the PRAGMA data_version command or the SQLITE_FCNTL_DATA_VERSION_API_constant file control.", "key": "sqlite3_total_changes", "sent": "The sqlite3_total_changes_APIName interface only reports the number of rows that changed due to SQL statement run against database connection D.  Any changes by other database connections are ignored."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "If a separate thread makes changes on the same database connection while sqlite3_total_changes_APIName is running then the value returned is unpredictable and not meaningful.", "key": "sqlite3_total_changes", "sent": "If a separate thread makes changes on the same database connection while sqlite3_total_changes_APIName is running then the value returned is unpredictable and not meaningful."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.", "var_type": ["sqlite3*"], "ret_type": "int"}, "paraph": "sqlite3_total_changes_APIName returns the total number of rows inserted, modified or deleted by all INSERT, UPDATE or DELETE statements completed since the database connection was opened, including those executed as part of trigger programs.Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes_APIName.", "key": "sqlite3_total_changes", "sent": "sqlite3_total_changes_APIName returns the total number of rows inserted , modified or deleted by all INSERT , UPDATE or DELETE statements completed  ."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument.The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName.At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed.The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error.If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message.", "key": "sqlite3_set_authorizer", "sent": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g.to flush data accumulated in memory to disk).In this case subsequent calls to sqlite3_last_insert_rowid_APIName return the rowid associated with these internal INSERT operations, which leads to unintuitive results.Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using sqlite3_set_last_insert_rowid_APIName before returning control to the user.", "key": "sqlite3_last_insert_rowid", "sent": "Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIName interface always returns a pointer to a valid sqlite3_str object, though in the event of an out-of-memory error sqlite3_str_new_APIParam_0 object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM_API_constant from sqlite3_str_errcode_APIName, always return 0 for sqlite3_str_length_APIName, and always return NULL from sqlite3_str_finish_APIName.It is always safe to use the value returned by sqlite3_str_new_APIName as the sqlite3_str parameter to any of the other sqlite3_str methods.", "key": "sqlite3_str_new", "sent": "It is always safe to use the value returned by sqlite3_str_new_APIName as the sqlite3_str parameter to any of the other sqlite3_str methods."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_threadsafe_APIName function returns zero if and only if SQLite was compiled with mutexing code omitted due to the SQLITE_THREADSAFE compile-time option being set to 0.SQLite can be compiled with or without mutexes.", "var_type": ["void"], "ret_type": "int"}, "paraph": "This interface only reports on the compile-time mutex setting of the SQLITE_THREADSAFE flag.If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config_APIName with the verbs SQLITE_CONFIG_SINGLETHREAD_API_constant, SQLITE_CONFIG_MULTITHREAD_API_constant, or SQLITE_CONFIG_SERIALIZED_API_constant.The return value of the sqlite3_threadsafe_APIName function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config_APIName.In other words, the return value from sqlite3_threadsafe_APIName is unchanged by calls to sqlite3_config_APIName.", "key": "sqlite3_threadsafe", "sent": "If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to sqlite3_config_APIName with the verbs SQLITE_CONFIG_SINGLETHREAD_API_constant, SQLITE_CONFIG_MULTITHREAD_API_constant, or SQLITE_CONFIG_SERIALIZED_API_constant."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "When the callback returns SQLITE_OK_API_constant, that means the operation requested is ok.When the callback returns SQLITE_DENY_API_constant, the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.", "key": "sqlite3_set_authorizer", "sent": "When the callback returns SQLITE_OK_API_constant, that means the operation requested is ok."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument.The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName.At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed.The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error.If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message.", "key": "sqlite3_set_authorizer", "sent": "The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIParam_1 parameter to sqlite3_str_new_APIName may be NULL.If the D parameter in sqlite3_str_new_APIName is not NULL, then the maximum length of the string contained in the sqlite3_str object will be the value set for sqlite3_limit_APIName instead of SQLITE_MAX_LENGTH.", "key": "sqlite3_str_new", "sent": "If the D parameter in sqlite3_str_new_APIName is not NULL, then the maximum length of the string contained in the sqlite3_str object will be the value set for sqlite3_limit_APIName instead of SQLITE_MAX_LENGTH."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer_APIName interface.The second parameter to the callback is an integer action code that specifies the particular action to be authorized.The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized.Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.", "key": "sqlite3_set_authorizer", "sent": "The second parameter to the callback is an integer action code that specifies the particular action to be authorized."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "When the callback returns SQLITE_OK_API_constant, that means the operation requested is ok.When the callback returns SQLITE_DENY_API_constant, the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.", "key": "sqlite3_set_authorizer", "sent": "When the callback returns SQLITE_DENY_API_constant, the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer_APIName interface.The second parameter to the callback is an integer action code that specifies the particular action to be authorized.The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized.Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.", "key": "sqlite3_set_authorizer", "sent": "The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer_APIName interface."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument.The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName.At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed.The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error.If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message.", "key": "sqlite3_set_authorizer", "sent": "At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "If the action code is SQLITE_READ_API_constant and the callback returns SQLITE_IGNORE_API_constant then the prepared statement statement is constructed to substitute a NULL value in place of the table column that would have been read if SQLITE_OK_API_constant had been returned.The SQLITE_IGNORE_API_constant return can be used to deny an untrusted user access to individual columns of a table.When a table is referenced by a SELECT but no column values are extracted from that table (for example in a query like \"SELECT count(*) FROM tab\") then the SQLITE_READ_API_constant authorizer callback is invoked once for that table with a column name that is an empty string.If the action code is SQLITE_DELETE_API_constant and the callback returns SQLITE_IGNORE_API_constant then the DELETE operation proceeds but the truncate optimization is disabled and all rows are deleted individually.", "key": "sqlite3_set_authorizer", "sent": "The SQLITE_IGNORE_API_constant return can be used to deny an untrusted user access to individual columns of a table."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "An authorizer is used when preparing SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database.For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database.But the application does not want the user to be able to make arbitrary changes to the database.An authorizer could then be put in place while the user-entered SQL is being prepared that disallows everything except SELECT statements.", "key": "sqlite3_set_authorizer", "sent": "But the application does not want the user to be able to make arbitrary changes to the database."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument.The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName.At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed.The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error.If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message.", "key": "sqlite3_set_authorizer", "sent": "If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "An authorizer is used when preparing SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database.For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database.But the application does not want the user to be able to make arbitrary changes to the database.An authorizer could then be put in place while the user-entered SQL is being prepared that disallows everything except SELECT statements.", "key": "sqlite3_set_authorizer", "sent": "For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer_APIName interface.The second parameter to the callback is an integer action code that specifies the particular action to be authorized.The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized.Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.", "key": "sqlite3_set_authorizer", "sent": "Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The first parameter to the authorizer callback is a copy of the third parameter to the sqlite3_set_authorizer_APIName interface.The second parameter to the callback is an integer action code that specifies the particular action to be authorized.The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized.Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback.", "key": "sqlite3_set_authorizer", "sent": "The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "This routine registers an authorizer callback with a particular database connection, supplied in the first argument.The authorizer callback is invoked as SQL statements are being compiled by sqlite3_prepare_APIName or its variants sqlite3_prepare_v2_APIName, sqlite3_prepare_v3_APIName, sqlite3_prepare16_APIName, sqlite3_prepare16_v2_APIName, and sqlite3_prepare16_v3_APIName.At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed.The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error.If the authorizer callback returns any value other than SQLITE_IGNORE_API_constant, SQLITE_OK_API_constant, or SQLITE_DENY_API_constant then the sqlite3_prepare_v2_APIName or equivalent call that triggered the authorizer will fail with an error message.", "key": "sqlite3_set_authorizer", "sent": "The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "If the action code is SQLITE_READ_API_constant and the callback returns SQLITE_IGNORE_API_constant then the prepared statement statement is constructed to substitute a NULL value in place of the table column that would have been read if SQLITE_OK_API_constant had been returned.The SQLITE_IGNORE_API_constant return can be used to deny an untrusted user access to individual columns of a table.When a table is referenced by a SELECT but no column values are extracted from that table (for example in a query like \"SELECT count(*) FROM tab\") then the SQLITE_READ_API_constant authorizer callback is invoked once for that table with a column name that is an empty string.If the action code is SQLITE_DELETE_API_constant and the callback returns SQLITE_IGNORE_API_constant then the DELETE operation proceeds but the truncate optimization is disabled and all rows are deleted individually.", "key": "sqlite3_set_authorizer", "sent": "If the action code is SQLITE_DELETE_API_constant and the callback returns SQLITE_IGNORE_API_constant then the DELETE operation proceeds but the truncate optimization is disabled and all rows are deleted individually."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " Each entry in most SQLite tables (except for WITHOUT ROWID tables) has a unique 64-bit signed integer key called the \"rowid\".", "var_type": ["sqlite3*"], "ret_type": "sqlite3_int64"}, "paraph": "If a separate thread performs a new INSERT on the same database connection while the sqlite3_last_insert_rowid_APIName function is running and thus changes the last insert rowid, then the value returned by sqlite3_last_insert_rowid_APIName is unpredictable and might not equal either the old or the new last insert rowid.", "key": "sqlite3_last_insert_rowid", "sent": "If a separate thread performs a new INSERT on the same database connection while the sqlite3_last_insert_rowid_APIName function is running and thus changes the last insert rowid, then the value returned by sqlite3_last_insert_rowid_APIName is unpredictable and might not equal either the old or the new last insert rowid."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "If the action code is SQLITE_READ_API_constant and the callback returns SQLITE_IGNORE_API_constant then the prepared statement statement is constructed to substitute a NULL value in place of the table column that would have been read if SQLITE_OK_API_constant had been returned.The SQLITE_IGNORE_API_constant return can be used to deny an untrusted user access to individual columns of a table.When a table is referenced by a SELECT but no column values are extracted from that table (for example in a query like \"SELECT count(*) FROM tab\") then the SQLITE_READ_API_constant authorizer callback is invoked once for that table with a column name that is an empty string.If the action code is SQLITE_DELETE_API_constant and the callback returns SQLITE_IGNORE_API_constant then the DELETE operation proceeds but the truncate optimization is disabled and all rows are deleted individually.", "key": "sqlite3_set_authorizer", "sent": "If the action code is SQLITE_READ_API_constant and the callback returns SQLITE_IGNORE_API_constant then the prepared statement statement is constructed to substitute a NULL value in place of the table column that would have been read if SQLITE_OK_API_constant had been returned."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "An authorizer is used when preparing SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database.For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database.But the application does not want the user to be able to make arbitrary changes to the database.An authorizer could then be put in place while the user-entered SQL is being prepared that disallows everything except SELECT statements.", "key": "sqlite3_set_authorizer", "sent": "An authorizer is used when preparing SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "If the action code is SQLITE_READ_API_constant and the callback returns SQLITE_IGNORE_API_constant then the prepared statement statement is constructed to substitute a NULL value in place of the table column that would have been read if SQLITE_OK_API_constant had been returned.The SQLITE_IGNORE_API_constant return can be used to deny an untrusted user access to individual columns of a table.When a table is referenced by a SELECT but no column values are extracted from that table (for example in a query like \"SELECT count(*) FROM tab\") then the SQLITE_READ_API_constant authorizer callback is invoked once for that table with a column name that is an empty string.If the action code is SQLITE_DELETE_API_constant and the callback returns SQLITE_IGNORE_API_constant then the DELETE operation proceeds but the truncate optimization is disabled and all rows are deleted individually.", "key": "sqlite3_set_authorizer", "sent": "When a table is referenced by a SELECT but no column values are extracted from that table (for example in a query like \"SELECT count(*) FROM tab\") then the SQLITE_READ_API_constant authorizer callback is invoked once for that table with a column name that is an empty string."}, {"API_info": {"var": ["sqlite3*"], "API_desc": " The sqlite3_str_new_APIName interface allocates and initializes a new sqlite3_str object.", "var_type": ["sqlite3*"], "ret_type": "sqlite3_str *"}, "paraph": "The sqlite3_str_new_APIName interface always returns a pointer to a valid sqlite3_str object, though in the event of an out-of-memory error sqlite3_str_new_APIParam_0 object might be a special singleton that will silently reject new text, always return SQLITE_NOMEM_API_constant from sqlite3_str_errcode_APIName, always return 0 for sqlite3_str_length_APIName, and always return NULL from sqlite3_str_finish_APIName.It is always safe to use the value returned by sqlite3_str_new_APIName as the sqlite3_str parameter to any of the other sqlite3_str methods.", "key": "sqlite3_str_new", "sent": "The sqlite3_str_new_APIName interface always returns a pointer to a valid sqlite3_str object ,  ."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Only a single authorizer can be in place on a database connection at a time.Each call to sqlite3_set_authorizer overrides the previous call.Disable the authorizer by installing a NULL callback.The authorizer is disabled by default.", "key": "sqlite3_set_authorizer", "sent": "Each call to sqlite3_set_authorizer overrides the previous call."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Only a single authorizer can be in place on a database connection at a time.Each call to sqlite3_set_authorizer overrides the previous call.Disable the authorizer by installing a NULL callback.The authorizer is disabled by default.", "key": "sqlite3_set_authorizer", "sent": "Disable the authorizer by installing a NULL callback."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "An authorizer is used when preparing SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database.For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database.But the application does not want the user to be able to make arbitrary changes to the database.An authorizer could then be put in place while the user-entered SQL is being prepared that disallows everything except SELECT statements.", "key": "sqlite3_set_authorizer", "sent": "An authorizer could then be put in place while the user-entered SQL is being prepared that disallows everything except SELECT statements."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Only a single authorizer can be in place on a database connection at a time.Each call to sqlite3_set_authorizer overrides the previous call.Disable the authorizer by installing a NULL callback.The authorizer is disabled by default.", "key": "sqlite3_set_authorizer", "sent": "The authorizer is disabled by default."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Only a single authorizer can be in place on a database connection at a time.Each call to sqlite3_set_authorizer overrides the previous call.Disable the authorizer by installing a NULL callback.The authorizer is disabled by default.", "key": "sqlite3_set_authorizer", "sent": "Only a single authorizer can be in place on a database connection at a time."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_set_authorizer", "sent": "The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Applications that need to process SQL from untrusted sources might also consider lowering resource limits using sqlite3_limit_APIName and limiting database size using the max_page_count PRAGMA in addition to using an authorizer.", "key": "sqlite3_set_authorizer", "sent": "Applications that need to process SQL from untrusted sources might also consider lowering resource limits using sqlite3_limit_APIName and limiting database size using the max_page_count PRAGMA in addition to using an authorizer."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "When sqlite3_prepare_v2_APIName is used to prepare a statement, the statement might be re-prepared during sqlite3_step_APIName due to a schema change.Hence, the application should ensure that the correct authorizer callback remains in place during the sqlite3_step_APIName.", "key": "sqlite3_set_authorizer", "sent": "When sqlite3_prepare_v2_APIName is used to prepare a statement, the statement might be re-prepared during sqlite3_step_APIName due to a schema change."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback.Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph.", "key": "sqlite3_set_authorizer", "sent": "Note that sqlite3_prepare_v2_APIName and sqlite3_step_APIName both modify their database connections for the meaning of \"modify\" in this paragraph."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "When sqlite3_prepare_v2_APIName is used to prepare a statement, the statement might be re-prepared during sqlite3_step_APIName due to a schema change.Hence, the application should ensure that the correct authorizer callback remains in place during the sqlite3_step_APIName.", "key": "sqlite3_set_authorizer", "sent": "Hence, the application should ensure that the correct authorizer callback remains in place during the sqlite3_step_APIName."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Note that the authorizer callback is invoked only during sqlite3_prepare_APIName or its variants.Authorization is not performed during statement evaluation in sqlite3_step_APIName, unless as stated in the previous paragraph, sqlite3_step_APIName invokes sqlite3_prepare_v2_APIName to reprepare a statement after a schema change.", "key": "sqlite3_set_authorizer", "sent": "Note that the authorizer callback is invoked only during sqlite3_prepare_APIName or its variants."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "A database connection handle is usually returned in * ppDb ,  ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "Otherwise an error code be returned by sqlite3_open_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The default encoding will be UTF-8 for databases created using sqlite3_open_APIName or sqlite3_open_v2_APIName.The default encoding for databases created using sqlite3_open16_APIName will be UTF-16 in the native byte order.", "key": "sqlite3_open", "sent": "The default encoding will be UTF-8 for databases created using sqlite3_open_APIName or sqlite3_open_v2_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The default encoding will be UTF-8 for databases created using sqlite3_open_APIName or sqlite3_open_v2_APIName.The default encoding for databases created using sqlite3_open16_APIName will be UTF-16 in the native byte order.", "key": "sqlite3_open", "sent": "The default encoding for databases created using sqlite3_open16_APIName will be UTF-16 in the native byte order."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines."}, {"API_info": "sqlite3_set_authorizernot exist in API_info", "paraph": "Note that the authorizer callback is invoked only during sqlite3_prepare_APIName or its variants.Authorization is not performed during statement evaluation in sqlite3_step_APIName, unless as stated in the previous paragraph, sqlite3_step_APIName invokes sqlite3_prepare_v2_APIName to reprepare a statement after a schema change.", "key": "sqlite3_set_authorizer", "sent": "Authorization is not performed during statement evaluation in sqlite3_step_APIName, unless as stated in the previous paragraph, sqlite3_step_APIName invokes sqlite3_prepare_v2_APIName to reprepare a statement after a schema change."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "These routines open an SQLite database file as specified by the sqlite3_open_APIParam_1 argument.The sqlite3_open_APIParam_1 argument is interpreted as UTF-8 for sqlite3_open_APIName and sqlite3_open_v2_APIName and as UTF-16 in the native byte order for sqlite3_open16_APIName.A database connection handle is usually returned in *ppDb, even if an error occurs.The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.If the database is opened (and/or created) successfully, then SQLITE_OK_API_constant be returned by sqlite3_open_APIName.Otherwise an error code be returned by sqlite3_open_APIName.The sqlite3_errmsg_APIName or sqlite3_errmsg16_APIName routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open_APIName routines.", "key": "sqlite3_open", "sent": "The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The sqlite3_open_v2_APIName interface works like sqlite3_open_APIName except that it accepts two additional parameters for additional control over the new database connection.The flags parameter to sqlite3_open_v2_APIName can take one of the following three values, optionally combined with the SQLITE_OPEN_NOMUTEX_API_constant, SQLITE_OPEN_FULLMUTEX_API_constant, SQLITE_OPEN_SHAREDCACHE_API_constant, SQLITE_OPEN_PRIVATECACHE_API_constant, and/or SQLITE_OPEN_URI_API_constant flags:", "key": "sqlite3_open", "sent": "The sqlite3_open_v2_APIName interface works like sqlite3_open_APIName except that it accepts two additional parameters for additional control over the new database connection."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Whether or not an error occurs when it is opened, resources associated with the sqlite3 should be released by passing it to sqlite3_close_APIName when it is no longer required.", "key": "sqlite3_open_v2", "sent": " , resources associated with sqlite3 should be released by passing sqlite3 to sqlite3_close_APIName when it is no longer required ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Whether or not an error occurs when it is opened, resources associated with the sqlite3 should be released by passing it to sqlite3_close_APIName when it is no longer required.", "key": "sqlite3_open", "sent": " , resources associated with sqlite3 should be released by passing sqlite3 to sqlite3_close_APIName when it is no longer required ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The sqlite3_open_v2_APIName interface works like sqlite3_open_APIName except that it accepts two additional parameters for additional control over the new database connection.The flags parameter to sqlite3_open_v2_APIName can take one of the following three values, optionally combined with the SQLITE_OPEN_NOMUTEX_API_constant, SQLITE_OPEN_FULLMUTEX_API_constant, SQLITE_OPEN_SHAREDCACHE_API_constant, SQLITE_OPEN_PRIVATECACHE_API_constant, and/or SQLITE_OPEN_URI_API_constant flags:", "key": "sqlite3_open", "sent": "The flags parameter to sqlite3_open_v2_APIName can take one of the following three values, optionally combined with the SQLITE_OPEN_NOMUTEX_API_constant, SQLITE_OPEN_FULLMUTEX_API_constant, SQLITE_OPEN_SHAREDCACHE_API_constant, SQLITE_OPEN_PRIVATECACHE_API_constant, and/or SQLITE_OPEN_URI_API_constant flags:"}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The fourth parameter to sqlite3_open_v2_APIName is the name of the sqlite3_vfs object that defines the operating system interface that the new database connection should use.If the fourth parameter is a NULL pointer then the default sqlite3_vfs object is used.", "key": "sqlite3_open", "sent": "If the fourth parameter is a NULL pointer then the default sqlite3_vfs object is used."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is \":memory:\", then a private, temporary in-memory database is created for the connection.This in-memory database will vanish when the database connection is closed.Future versions of SQLite might make use of additional special filenames that begin with the \":\" character.It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a \":\" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as \"./\" to avoid ambiguity.", "key": "sqlite3_open", "sent": "This in-memory database will vanish when the database connection is closed."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "If the SQLITE_OPEN_NOMUTEX_API_constant flag is set, then the database connection opens in the multi-thread threading mode as long as the single-thread mode has not been set at compile-time or start-time.If the SQLITE_OPEN_FULLMUTEX_API_constant flag is set then the database connection opens in the serialized threading mode unless single-thread was previously selected at compile-time or start-time.The SQLITE_OPEN_SHAREDCACHE_API_constant flag causes the database connection to be eligible to use shared cache mode, regardless of whether or not shared cache is enabled using sqlite3_enable_shared_cache_APIName.The SQLITE_OPEN_PRIVATECACHE_API_constant flag causes the database connection to not participate in shared cache mode even if it is enabled.", "key": "sqlite3_open_v2", "sent": "The SQLITE_OPEN_PRIVATECACHE_API_constant flag causes the database connection to not participate in shared cache mode  ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the SQLITE_OPEN_NOMUTEX_API_constant flag is set, then the database connection opens in the multi-thread threading mode as long as the single-thread mode has not been set at compile-time or start-time.If the SQLITE_OPEN_FULLMUTEX_API_constant flag is set then the database connection opens in the serialized threading mode unless single-thread was previously selected at compile-time or start-time.The SQLITE_OPEN_SHAREDCACHE_API_constant flag causes the database connection to be eligible to use shared cache mode, regardless of whether or not shared cache is enabled using sqlite3_enable_shared_cache_APIName.The SQLITE_OPEN_PRIVATECACHE_API_constant flag causes the database connection to not participate in shared cache mode even if it is enabled.", "key": "sqlite3_open", "sent": "If the SQLITE_OPEN_FULLMUTEX_API_constant flag is set then the database connection opens in the serialized threading mode unless single-thread was previously selected at compile-time or start-time."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is \":memory:\", then a private, temporary in-memory database is created for the connection.This in-memory database will vanish when the database connection is closed.Future versions of SQLite might make use of additional special filenames that begin with the \":\" character.It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a \":\" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as \"./\" to avoid ambiguity.", "key": "sqlite3_open16", "sent": "Future versions of SQLite might make use of additional special filenames that begin with the \":\" character."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Whether or not an error occurs when it is opened, resources associated with the sqlite3 should be released by passing it to sqlite3_close_APIName when it is no longer required.", "key": "sqlite3_open16", "sent": " , resources associated with sqlite3 should be released by passing sqlite3 to sqlite3_close_APIName when it is no longer required ."},  {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the 3_APIConstant parameter to sqlite3_open_v2_APIName is not one of the combinations shown above optionally combined with other SQLITE_OPEN_* bits then the behavior is undefined.", "key": "sqlite3_open", "sent": "If the 3_APIConstant parameter to sqlite3_open_v2_APIName is not one of the combinations shown above optionally combined with other SQLITE_OPEN_* bits then the behavior is undefined."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is an empty string, then a private, temporary on-disk database will be created.This private database will be automatically deleted as soon as the database connection is closed.", "key": "sqlite3_open16", "sent": "This private database will be automatically deleted as soon as the database connection is closed."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is an empty string, then a private, temporary on-disk database will be created.This private database will be automatically deleted as soon as the database connection is closed.", "key": "sqlite3_open", "sent": "If the sqlite3_open_APIParam_1 is an empty string, then a private, temporary on-disk database will be created."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The fourth parameter to sqlite3_open_v2_APIName is the name of the sqlite3_vfs object that defines the operating system interface that the new database connection should use.If the fourth parameter is a NULL pointer then the default sqlite3_vfs object is used.", "key": "sqlite3_open", "sent": "The fourth parameter to sqlite3_open_v2_APIName is the name of the sqlite3_vfs object that defines the operating system interface that the new database connection should use."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If URI sqlite3_open_APIParam_1 interpretation is enabled, and the sqlite3_open_APIParam_1 argument begins with \"file:\", then the sqlite3_open_APIParam_1 is interpreted as a URI.URI sqlite3_open_APIParam_1 interpretation is enabled if the SQLITE_OPEN_URI_API_constant flag is set in sqlite3_open_APIParam_3 to sqlite3_open_v2_APIName, or if it has been enabled globally using the SQLITE_CONFIG_URI_API_constant option with the sqlite3_config_APIName method or by the SQLITE_USE_URI compile-time option.URI sqlite3_open_APIParam_1 interpretation is turned off by default, but future releases of SQLite might enable URI sqlite3_open_APIParam_1 interpretation by default.See \"URI filenames\" for additional information.", "key": "sqlite3_open", "sent": "See \"URI filenames\" for additional information."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the SQLITE_OPEN_NOMUTEX_API_constant flag is set, then the database connection opens in the multi-thread threading mode as long as the single-thread mode has not been set at compile-time or start-time.If the SQLITE_OPEN_FULLMUTEX_API_constant flag is set then the database connection opens in the serialized threading mode unless single-thread was previously selected at compile-time or start-time.The SQLITE_OPEN_SHAREDCACHE_API_constant flag causes the database connection to be eligible to use shared cache mode, regardless of whether or not shared cache is enabled using sqlite3_enable_shared_cache_APIName.The SQLITE_OPEN_PRIVATECACHE_API_constant flag causes the database connection to not participate in shared cache mode even if it is enabled.", "key": "sqlite3_open16", "sent": "The SQLITE_OPEN_SHAREDCACHE_API_constant flag causes the database connection to be eligible to use shared cache mode , regardless of  ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI filenames are parsed according to RFC 3986.If the URI contains an authority, then it must be either an empty string or the string \"localhost\".If the authority is not an empty string or \"localhost\", an error be returned by sqlite3_open16_APIName to the caller.The fragment component of a URI, if present, is ignored.", "key": "sqlite3_open", "sent": "URI filenames are parsed according to RFC 3986."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is \":memory:\", then a private, temporary in-memory database is created for the connection.This in-memory database will vanish when the database connection is closed.Future versions of SQLite might make use of additional special filenames that begin with the \":\" character.It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a \":\" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as \"./\" to avoid ambiguity.", "key": "sqlite3_open_v2", "sent": "It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a \":\" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as \"./\" to avoid ambiguity."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If URI sqlite3_open_APIParam_1 interpretation is enabled, and the sqlite3_open_APIParam_1 argument begins with \"file:\", then the sqlite3_open_APIParam_1 is interpreted as a URI.URI sqlite3_open_APIParam_1 interpretation is enabled if the SQLITE_OPEN_URI_API_constant flag is set in sqlite3_open_APIParam_3 to sqlite3_open_v2_APIName, or if it has been enabled globally using the SQLITE_CONFIG_URI_API_constant option with the sqlite3_config_APIName method or by the SQLITE_USE_URI compile-time option.URI sqlite3_open_APIParam_1 interpretation is turned off by default, but future releases of SQLite might enable URI sqlite3_open_APIParam_1 interpretation by default.See \"URI filenames\" for additional information.", "key": "sqlite3_open", "sent": "URI sqlite3_open_APIParam_1 interpretation is turned off by default, but future releases of SQLite might enable URI sqlite3_open_APIParam_1 interpretation by default."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If URI sqlite3_open_APIParam_1 interpretation is enabled, and the sqlite3_open_APIParam_1 argument begins with \"file:\", then the sqlite3_open_APIParam_1 is interpreted as a URI.URI sqlite3_open_APIParam_1 interpretation is enabled if the SQLITE_OPEN_URI_API_constant flag is set in sqlite3_open_APIParam_3 to sqlite3_open_v2_APIName, or if it has been enabled globally using the SQLITE_CONFIG_URI_API_constant option with the sqlite3_config_APIName method or by the SQLITE_USE_URI compile-time option.URI sqlite3_open_APIParam_1 interpretation is turned off by default, but future releases of SQLite might enable URI sqlite3_open_APIParam_1 interpretation by default.See \"URI filenames\" for additional information.", "key": "sqlite3_open", "sent": "If URI sqlite3_open_APIParam_1 interpretation is enabled, and the sqlite3_open_APIParam_1 argument begins with \"file:\", then the sqlite3_open_APIParam_1 is interpreted as a URI."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the SQLITE_OPEN_NOMUTEX_API_constant flag is set, then the database connection opens in the multi-thread threading mode as long as the single-thread mode has not been set at compile-time or start-time.If the SQLITE_OPEN_FULLMUTEX_API_constant flag is set then the database connection opens in the serialized threading mode unless single-thread was previously selected at compile-time or start-time.The SQLITE_OPEN_SHAREDCACHE_API_constant flag causes the database connection to be eligible to use shared cache mode, regardless of whether or not shared cache is enabled using sqlite3_enable_shared_cache_APIName.The SQLITE_OPEN_PRIVATECACHE_API_constant flag causes the database connection to not participate in shared cache mode even if it is enabled.", "key": "sqlite3_open", "sent": "If the SQLITE_OPEN_NOMUTEX_API_constant flag is set, then the database connection opens in the multi-thread threading mode as long as the single-thread mode has not been set at compile-time or start-time."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI filenames are parsed according to RFC 3986.If the URI contains an authority, then it must be either an empty string or the string \"localhost\".If the authority is not an empty string or \"localhost\", an error be returned by sqlite3_open16_APIName to the caller.The fragment component of a URI, if present, is ignored.", "key": "sqlite3_open", "sent": "If the URI contains an authority, then it must be either an empty string or the string \"localhost\"."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI filenames are parsed according to RFC 3986.If the URI contains an authority, then it must be either an empty string or the string \"localhost\".If the authority is not an empty string or \"localhost\", an error be returned by sqlite3_open16_APIName to the caller.The fragment component of a URI, if present, is ignored.", "key": "sqlite3_open16", "sent": "If the authority is not an empty string or \"localhost\", an error be returned by sqlite3_open16_APIName to the caller."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "URI filenames are parsed according to RFC 3986.If the URI contains an authority, then it must be either an empty string or the string \"localhost\".If the authority is not an empty string or \"localhost\", an error be returned by sqlite3_open16_APIName to the caller.The fragment component of a URI, if present, is ignored.", "key": "sqlite3_open_v2", "sent": "The fragment component of a URI, if present, is ignored."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "SQLite uses the path component of the URI as the name of the disk file which contains the database.If the path begins with a '/' character, then it is interpreted as an absolute path.If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path.On windows, the first component of an absolute path is a drive specification (e.g.\"C:\").", "key": "sqlite3_open", "sent": "SQLite uses the path component of the URI as the name of the disk file which contains the database."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "SQLite uses the path component of the URI as the name of the disk file which contains the database.If the path begins with a '/' character, then it is interpreted as an absolute path.If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path.On windows, the first component of an absolute path is a drive specification (e.g.\"C:\").", "key": "sqlite3_open_v2", "sent": "\"C:\")."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a custom VFS implementation.SQLite and its built-in VFSes interpret the following query parameters:", "key": "sqlite3_open16", "sent": "SQLite and its built-in VFSes interpret the following query parameters:"}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Specifying an unknown parameter in the query component of a URI is not an error.Future versions of SQLite might understand additional query parameters.See \"query parameters with special meaning to SQLite\" for additional information.", "key": "sqlite3_open16", "sent": "Future versions of SQLite might understand additional query parameters."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Specifying an unknown parameter in the query component of a URI is not an error.Future versions of SQLite might understand additional query parameters.See \"query parameters with special meaning to SQLite\" for additional information.", "key": "sqlite3_open", "sent": "Specifying an unknown parameter in the query component of a URI is not an error."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "Specifying an unknown parameter in the query component of a URI is not an error.Future versions of SQLite might understand additional query parameters.See \"query parameters with special meaning to SQLite\" for additional information.", "key": "sqlite3_open_v2", "sent": "See \"query parameters with special meaning to SQLite\" for additional information."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI.A hexadecimal escape sequence consists of a percent sign - \"%\" - followed by exactly two hexadecimal digits specifying an octet value.Before the path or query components of a URI sqlite3_open16_APIParam_1 are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet.If this process generates an invalid UTF-8 encoding, the results are undefined.", "key": "sqlite3_open", "sent": "URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a custom VFS implementation.SQLite and its built-in VFSes interpret the following query parameters:", "key": "sqlite3_open", "sent": "The query component of a URI may contain parameters that are interpreted either by SQLite itself, or by a custom VFS implementation."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If URI sqlite3_open_APIParam_1 interpretation is enabled, and the sqlite3_open_APIParam_1 argument begins with \"file:\", then the sqlite3_open_APIParam_1 is interpreted as a URI.URI sqlite3_open_APIParam_1 interpretation is enabled if the SQLITE_OPEN_URI_API_constant flag is set in sqlite3_open_APIParam_3 to sqlite3_open_v2_APIName, or if it has been enabled globally using the SQLITE_CONFIG_URI_API_constant option with the sqlite3_config_APIName method or by the SQLITE_USE_URI compile-time option.URI sqlite3_open_APIParam_1 interpretation is turned off by default, but future releases of SQLite might enable URI sqlite3_open_APIParam_1 interpretation by default.See \"URI filenames\" for additional information.", "key": "sqlite3_open", "sent": "URI sqlite3_open_APIParam_1 interpretation is enabled if the SQLITE_OPEN_URI_API_constant flag is set in sqlite3_open_APIParam_3 to sqlite3_open_v2_APIName, or if it has been enabled globally using the SQLITE_CONFIG_URI_API_constant option with the sqlite3_config_APIName method or by the SQLITE_USE_URI compile-time option."}, {"API_info": {"var": ["filename", "ppDb", "flags", "zVfs"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **", "int", "const char *"], "ret_type": "int"}, "paraph": "URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI.A hexadecimal escape sequence consists of a percent sign - \"%\" - followed by exactly two hexadecimal digits specifying an octet value.Before the path or query components of a URI sqlite3_open16_APIParam_1 are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet.If this process generates an invalid UTF-8 encoding, the results are undefined.", "key": "sqlite3_open_v2", "sent": "If this process generates an invalid UTF-8 encoding, the results are undefined."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "See also: sqlite3_temp_directory", "key": "sqlite3_open", "sent": "See also: sqlite3_temp_directory"}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Note to Windows Runtime users:  The temporary directory must be set prior to calling sqlite3_open_APIName or sqlite3_open_v2_APIName.Otherwise, various features that require the use of temporary files may fail.", "key": "sqlite3_open", "sent": "Otherwise, various features that require the use of temporary files may fail."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Note to Windows users:  The encoding used for the sqlite3_open_APIParam_1 argument of sqlite3_open_APIName and sqlite3_open_v2_APIName must be UTF-8, not whatever codepage is currently defined.Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open_APIName or sqlite3_open_v2_APIName.", "key": "sqlite3_open", "sent": "Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open_APIName or sqlite3_open_v2_APIName."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface is not threadsafe.The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config_APIName is running.", "key": "sqlite3_config", "sent": "The sqlite3_config_APIName interface is not threadsafe."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.The default configuration is recommended for most applications and so this routine is usually not necessary.It is provided to support rare applications with unusual needs.", "key": "sqlite3_config", "sent": "It is provided to support rare applications with unusual needs."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Note to Windows Runtime users:  The temporary directory must be set prior to calling sqlite3_open_APIName or sqlite3_open_v2_APIName.Otherwise, various features that require the use of temporary files may fail.", "key": "sqlite3_open", "sent": "Note to Windows Runtime users:  The temporary directory must be set prior to calling sqlite3_open_APIName or sqlite3_open_v2_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "Note to Windows users:  The encoding used for the sqlite3_open_APIParam_1 argument of sqlite3_open_APIName and sqlite3_open_v2_APIName must be UTF-8, not whatever codepage is currently defined.Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open_APIName or sqlite3_open_v2_APIName.", "key": "sqlite3_open", "sent": "Note to Windows users:  The encoding used for the sqlite3_open_APIParam_1 argument of sqlite3_open_APIName and sqlite3_open_v2_APIName must be UTF-8, not whatever codepage is currently defined."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.The default configuration is recommended for most applications and so this routine is usually not necessary.It is provided to support rare applications with unusual needs.", "key": "sqlite3_config", "sent": "The default configuration is recommended for most applications and so this routine is usually not necessary."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface may only be invoked prior to library initialization using sqlite3_initialize_APIName or after shutdown by sqlite3_shutdown_APIName.If sqlite3_config_APIName is called after sqlite3_initialize_APIName and before sqlite3_shutdown_APIName then it will return SQLITE_MISUSE_API_constant.Note, however, that sqlite3_config_APIName can be called as part of the implementation of an application-defined sqlite3_os_init_APIName.", "key": "sqlite3_config", "sent": "If sqlite3_config_APIName is called after sqlite3_initialize_APIName and before sqlite3_shutdown_APIName then it will return SQLITE_MISUSE_API_constant."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface is not threadsafe.The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config_APIName is running.", "key": "sqlite3_config", "sent": "The application must ensure that no other SQLite interfaces are invoked by other threads while sqlite3_config_APIName is running."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface may only be invoked prior to library initialization using sqlite3_initialize_APIName or after shutdown by sqlite3_shutdown_APIName.If sqlite3_config_APIName is called after sqlite3_initialize_APIName and before sqlite3_shutdown_APIName then it will return SQLITE_MISUSE_API_constant.Note, however, that sqlite3_config_APIName can be called as part of the implementation of an application-defined sqlite3_os_init_APIName.", "key": "sqlite3_config", "sent": "The sqlite3_config_APIName interface may only be invoked prior to library initialization using sqlite3_initialize_APIName or after shutdown by sqlite3_shutdown_APIName."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.The default configuration is recommended for most applications and so this routine is usually not necessary.It is provided to support rare applications with unusual needs.", "key": "sqlite3_config", "sent": "The sqlite3_config_APIName interface is used to make global configuration changes to SQLite  ."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI.A hexadecimal escape sequence consists of a percent sign - \"%\" - followed by exactly two hexadecimal digits specifying an octet value.Before the path or query components of a URI sqlite3_open16_APIParam_1 are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet.If this process generates an invalid UTF-8 encoding, the results are undefined.", "key": "sqlite3_open16", "sent": "Before the path or query components of a URI sqlite3_open16_APIParam_1 are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The first argument to sqlite3_config_APIName is an integer configuration option that determines what property of SQLite is to be configured.Subsequent arguments vary depending on the configuration option in sqlite3_config_APIParam_1.", "key": "sqlite3_config", "sent": "Subsequent arguments vary depending on the configuration option in sqlite3_config_APIParam_1."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "SQLite uses the path component of the URI as the name of the disk file which contains the database.If the path begins with a '/' character, then it is interpreted as an absolute path.If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path.On windows, the first component of an absolute path is a drive specification (e.g.\"C:\").", "key": "sqlite3_open16", "sent": "On windows, the first component of an absolute path is a drive specification (e.g."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "When a configuration option is set, sqlite3_config_APIName returns SQLITE_OK_API_constant.If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero error code.", "key": "sqlite3_config", "sent": "When a configuration option is set, sqlite3_config_APIName returns SQLITE_OK_API_constant."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_config_APIName interface may only be invoked prior to library initialization using sqlite3_initialize_APIName or after shutdown by sqlite3_shutdown_APIName.If sqlite3_config_APIName is called after sqlite3_initialize_APIName and before sqlite3_shutdown_APIName then it will return SQLITE_MISUSE_API_constant.Note, however, that sqlite3_config_APIName can be called as part of the implementation of an application-defined sqlite3_os_init_APIName.", "key": "sqlite3_config", "sent": "Note, however, that sqlite3_config_APIName can be called as part of the implementation of an application-defined sqlite3_os_init_APIName."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "The first argument to sqlite3_config_APIName is an integer configuration option that determines what property of SQLite is to be configured.Subsequent arguments vary depending on the configuration option in sqlite3_config_APIParam_1.", "key": "sqlite3_config", "sent": "The first argument to sqlite3_config_APIName is an integer configuration option that determines what property of SQLite is to be configured."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement sqlite3_stmt_busy_APIParam_1 has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE_API_constant from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.The sqlite3_stmt_busy_APIName interface returns false if sqlite3_stmt_busy_APIParam_1 is a NULL pointer.If sqlite3_stmt_busy_APIParam_1 is not a NULL pointer and is not a pointer to a valid prepared statement object, then the behavior is undefined and probably undesirable.", "key": "sqlite3_stmt_busy", "sent": "The sqlite3_stmt_busy_APIName interface returns false if sqlite3_stmt_busy_APIParam_1 is a NULL pointer."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.The interface is similar to sqlite3_config_APIName except that the changes apply to a single database connection (specified in sqlite3_db_config_APIParam_1).", "key": "sqlite3_db_config", "sent": "The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "The second argument to sqlite3_db_config(D,V,...)  is the configuration verb - an integer code that indicates what aspect of the database connection is being configured.Subsequent arguments vary depending on the configuration verb.", "key": "sqlite3_db_config", "sent": "Subsequent arguments vary depending on the configuration verb."}, {"API_info": {"var": ["int", " ..."], "API_desc": " The sqlite3_config_APIName interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application.", "var_type": ["int", " ..."], "ret_type": "int"}, "paraph": "When a configuration option is set, sqlite3_config_APIName returns SQLITE_OK_API_constant.If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero error code.", "key": "sqlite3_config", "sent": "If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero error code."}, {"API_info": {"var": ["db", "azKeep"], "API_desc": " The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer.", "var_type": ["sqlite3 *", "const char **"], "ret_type": "int"}, "paraph": "See also: sqlite3_create_module_APIName", "key": "sqlite3_drop_modules", "sent": "See also: sqlite3_create_module_APIName"}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.The interface is similar to sqlite3_config_APIName except that the changes apply to a single database connection (specified in sqlite3_db_config_APIParam_1).", "key": "sqlite3_db_config", "sent": "The interface is similar to sqlite3_config_APIName except that the changes apply to a single database connection (specified in sqlite3_db_config_APIParam_1)."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "Calls to sqlite3_db_config_APIName return SQLITE_OK_API_constant if and only if the call is considered successful.", "key": "sqlite3_db_config", "sent": "Calls to sqlite3_db_config_APIName return SQLITE_OK_API_constant if and only if the call is considered successful."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This interface can be used in combination sqlite3_next_stmt_APIName to locate all prepared statements associated with a database connection that are in need of being reset.This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.", "key": "sqlite3_stmt_busy", "sent": "This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open."}, {"API_info": {"var": ["db", "azKeep"], "API_desc": " The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer.", "var_type": ["sqlite3 *", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection sqlite3_drop_modules_APIParam_1 except those named on list sqlite3_drop_modules_APIParam_2. The sqlite3_drop_modules_APIParam_2 parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer.If the sqlite3_drop_modules_APIParam_2 parameter is NULL, then all virtual table modules are removed.", "key": "sqlite3_drop_modules", "sent": "If the sqlite3_drop_modules_APIParam_2 parameter is NULL, then all virtual table modules are removed."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "This interface can be used in combination sqlite3_next_stmt_APIName to locate all prepared statements associated with a database connection that are in need of being reset.This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.", "key": "sqlite3_stmt_busy", "sent": "This interface can be used in combination sqlite3_next_stmt_APIName to locate all prepared statements associated with a database connection that are in need of being reset."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement sqlite3_stmt_busy_APIParam_1 has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE_API_constant from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.The sqlite3_stmt_busy_APIName interface returns false if sqlite3_stmt_busy_APIParam_1 is a NULL pointer.If sqlite3_stmt_busy_APIParam_1 is not a NULL pointer and is not a pointer to a valid prepared statement object, then the behavior is undefined and probably undesirable.", "key": "sqlite3_stmt_busy", "sent": "The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement sqlite3_stmt_busy_APIParam_1 has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE_API_constant from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "SQLite uses the path component of the URI as the name of the disk file which contains the database.If the path begins with a '/' character, then it is interpreted as an absolute path.If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path.On windows, the first component of an absolute path is a drive specification (e.g.\"C:\").", "key": "sqlite3_open", "sent": "If the path begins with a '/' character, then it is interpreted as an absolute path."}, {"API_info": {"var": ["sqlite3*", "op", " ..."], "API_desc": " The sqlite3_db_config_APIName interface is used to make configuration changes to a database connection.", "var_type": ["sqlite3*", "int", " ..."], "ret_type": "int"}, "paraph": "The second argument to sqlite3_db_config(D,V,...)  is the configuration verb - an integer code that indicates what aspect of the database connection is being configured.Subsequent arguments vary depending on the configuration verb.", "key": "sqlite3_db_config", "sent": "The second argument to sqlite3_db_config(D,V,...)  is the configuration verb - an integer code that indicates what aspect of the database connection is being configured."}, {"API_info": {"var": ["sqlite3_stmt*"], "API_desc": " The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement S has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.", "var_type": ["sqlite3_stmt*"], "ret_type": "int"}, "paraph": "The sqlite3_stmt_busy_APIName interface returns true (non-zero) if the prepared statement sqlite3_stmt_busy_APIParam_1 has been stepped at least once using sqlite3_step_APIName but has neither run to completion (returned SQLITE_DONE_API_constant from sqlite3_step_APIName) nor been reset using sqlite3_reset_APIName.The sqlite3_stmt_busy_APIName interface returns false if sqlite3_stmt_busy_APIParam_1 is a NULL pointer.If sqlite3_stmt_busy_APIParam_1 is not a NULL pointer and is not a pointer to a valid prepared statement object, then the behavior is undefined and probably undesirable.", "key": "sqlite3_stmt_busy", "sent": "If sqlite3_stmt_busy_APIParam_1 is not a NULL pointer and is not a pointer to a valid prepared statement object, then the behavior is undefined and probably undesirable."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "The usual case is that sqlite3_serialize_APIName copies the serialization of the database into memory obtained from sqlite3_malloc64_APIName and returns a pointer to that memory.The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak.However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY_API_constant bit, then no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists.A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is set but no contiguous copy of the database exists.", "key": "sqlite3_serialize", "sent": "The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "For an ordinary on-disk database file, the serialization is just a copy of the disk file.For an in-memory database or a \"TEMP\" database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.", "key": "sqlite3_serialize", "sent": "For an ordinary on-disk database file, the serialization is just a copy of the disk file."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_DESERIALIZE option.", "key": "sqlite3_serialize", "sent": "This interface is only available if SQLite is compiled with the SQLITE_ENABLE_DESERIALIZE option."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "If the sqlite3_open_APIParam_1 is \":memory:\", then a private, temporary in-memory database is created for the connection.This in-memory database will vanish when the database connection is closed.Future versions of SQLite might make use of additional special filenames that begin with the \":\" character.It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a \":\" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as \"./\" to avoid ambiguity.", "key": "sqlite3_open", "sent": "If the sqlite3_open_APIParam_1 is \":memory:\", then a private, temporary in-memory database is created for the connection."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "A call to sqlite3_serialize_APIName might return NULL even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is omitted from argument sqlite3_serialize_APIParam_4 if a memory allocation error occurs.", "key": "sqlite3_serialize", "sent": "A call to sqlite3_serialize_APIName might return NULL  ."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the sqlite3_serialize_APIParam_2 database on database connection D. If sqlite3_serialize_APIParam_3 is not a NULL pointer, then the size of the database in bytes is written into *P.", "key": "sqlite3_serialize", "sent": "The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the sqlite3_serialize_APIParam_2 database on database connection D. If sqlite3_serialize_APIParam_3 is not a NULL pointer, then the size of the database in bytes is written into *P."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.Sharing is enabled if the argument is true and disabled if the argument is false.", "key": "sqlite3_enable_shared_cache", "sent": "This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "The usual case is that sqlite3_serialize_APIName copies the serialization of the database into memory obtained from sqlite3_malloc64_APIName and returns a pointer to that memory.The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak.However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY_API_constant bit, then no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists.A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is set but no contiguous copy of the database exists.", "key": "sqlite3_serialize", "sent": "The usual case is that sqlite3_serialize_APIName copies the serialization of the database into memory obtained from sqlite3_malloc64_APIName and returns a pointer to that memory."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "For an ordinary on-disk database file, the serialization is just a copy of the disk file.For an in-memory database or a \"TEMP\" database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk.", "key": "sqlite3_serialize", "sent": "For an in-memory database or a \"TEMP\" database, the serialization is the same sequence of bytes which would be written to disk if that database where backed up to disk."}, {"API_info": {"var": ["db", "azKeep"], "API_desc": " The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer.", "var_type": ["sqlite3 *", "const char **"], "ret_type": "int"}, "paraph": "The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection sqlite3_drop_modules_APIParam_1 except those named on list sqlite3_drop_modules_APIParam_2. The sqlite3_drop_modules_APIParam_2 parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer.If the sqlite3_drop_modules_APIParam_2 parameter is NULL, then all virtual table modules are removed.", "key": "sqlite3_drop_modules", "sent": "The sqlite3_drop_modules_APIName interface removes all virtual table modules from database connection sqlite3_drop_modules_APIParam_1 except those named on list sqlite3_drop_modules_APIParam_2. The sqlite3_drop_modules_APIParam_2 parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "The usual case is that sqlite3_serialize_APIName copies the serialization of the database into memory obtained from sqlite3_malloc64_APIName and returns a pointer to that memory.The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak.However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY_API_constant bit, then no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists.A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is set but no contiguous copy of the database exists.", "key": "sqlite3_serialize", "sent": "A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is set but no contiguous copy of the database exists."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const char *", "sqlite3 **"], "ret_type": "int"}, "paraph": "URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI.A hexadecimal escape sequence consists of a percent sign - \"%\" - followed by exactly two hexadecimal digits specifying an octet value.Before the path or query components of a URI sqlite3_open16_APIParam_1 are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet.If this process generates an invalid UTF-8 encoding, the results are undefined.", "key": "sqlite3_open", "sent": "A hexadecimal escape sequence consists of a percent sign - \"%\" - followed by exactly two hexadecimal digits specifying an octet value."}, {"API_info": {"var": ["filename", "ppDb"], "API_desc": " These routines open an SQLite database file as specified by the filename argument.", "var_type": ["const void *", "sqlite3 **"], "ret_type": "int"}, "paraph": "SQLite uses the path component of the URI as the name of the disk file which contains the database.If the path begins with a '/' character, then it is interpreted as an absolute path.If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path.On windows, the first component of an absolute path is a drive specification (e.g.\"C:\").", "key": "sqlite3_open16", "sent": "If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path."}, {"API_info": {"var": ["db", "zSchema", "piSize", "mFlags"], "API_desc": " The sqlite3_serialize_APIName interface returns a pointer to memory that is a serialization of the S database on database connection D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.For an ordinary on-disk database file, the serialization is just a copy of the disk file.", "var_type": ["sqlite3 *", "const char *", "sqlite3_int64 *", "unsigned int"], "ret_type": "unsigned char *"}, "paraph": "The usual case is that sqlite3_serialize_APIName copies the serialization of the database into memory obtained from sqlite3_malloc64_APIName and returns a pointer to that memory.The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak.However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY_API_constant bit, then no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists.A contiguous memory representation of the database will usually only exist if there has been a prior call to sqlite3_deserialize(D,S,...) with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY_API_constant bit is set but no contiguous copy of the database exists.", "key": "sqlite3_serialize", "sent": "However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY_API_constant bit, then no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Cache sharing is enabled and disabled for an entire process.This is a change as of SQLite version 3.5.0 (2007-09-04).In prior versions of SQLite, sharing was enabled or disabled for each thread separately.", "key": "sqlite3_enable_shared_cache", "sent": "Cache sharing is enabled and disabled for an entire process."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Cache sharing is enabled and disabled for an entire process.This is a change as of SQLite version 3.5.0 (2007-09-04).In prior versions of SQLite, sharing was enabled or disabled for each thread separately.", "key": "sqlite3_enable_shared_cache", "sent": "This is a change as of SQLite version 3.5.0 (2007-09-04)."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.Sharing is enabled if the argument is true and disabled if the argument is false.", "key": "sqlite3_enable_shared_cache", "sent": "Sharing is enabled if the argument is true and disabled if the argument is false."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Cache sharing is enabled and disabled for an entire process.This is a change as of SQLite version 3.5.0 (2007-09-04).In prior versions of SQLite, sharing was enabled or disabled for each thread separately.", "key": "sqlite3_enable_shared_cache", "sent": "In prior versions of SQLite, sharing was enabled or disabled for each thread separately."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "This routine returns SQLITE_OK_API_constant if shared cache was enabled or disabled successfully.An error code be returned by sqlite3_enable_shared_cache_APIName otherwise.", "key": "sqlite3_enable_shared_cache", "sent": "An error code be returned by sqlite3_enable_shared_cache_APIName otherwise."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "This routine returns SQLITE_OK_API_constant if shared cache was enabled or disabled successfully.An error code be returned by sqlite3_enable_shared_cache_APIName otherwise.", "key": "sqlite3_enable_shared_cache", "sent": "This routine returns SQLITE_OK_API_constant if shared cache was enabled or disabled successfully."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Shared cache is disabled by default.But this might change in future releases of SQLite.Applications that care about shared cache setting should set it explicitly.", "key": "sqlite3_enable_shared_cache", "sent": "Shared cache is disabled by default."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The cache sharing mode set by this interface effects all subsequent calls to sqlite3_open_APIName, sqlite3_open_v2_APIName, and sqlite3_open16_APIName.Existing database connections continue use the sharing mode that was in effect at the time they were opened.", "key": "sqlite3_enable_shared_cache", "sent": "Existing database connections continue use the sharing mode that was in effect at the time they were opened."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Shared cache is disabled by default.But this might change in future releases of SQLite.Applications that care about shared cache setting should set it explicitly.", "key": "sqlite3_enable_shared_cache", "sent": "But this might change in future releases of SQLite."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Shared cache is disabled by default.But this might change in future releases of SQLite.Applications that care about shared cache setting should set it explicitly.", "key": "sqlite3_enable_shared_cache", "sent": "Applications that care about shared cache setting should set it explicitly."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "The cache sharing mode set by this interface effects all subsequent calls to sqlite3_open_APIName, sqlite3_open_v2_APIName, and sqlite3_open16_APIName.Existing database connections continue use the sharing mode that was in effect at the time they were opened.", "key": "sqlite3_enable_shared_cache", "sent": "The cache sharing mode set by this interface effects all subsequent calls to sqlite3_open_APIName, sqlite3_open_v2_APIName, and sqlite3_open16_APIName."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "See Also:  SQLite Shared-Cache Mode", "key": "sqlite3_enable_shared_cache", "sent": "See Also:  SQLite Shared-Cache Mode"}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "This interface is threadsafe on processors where writing a 32-bit integer is atomic.", "key": "sqlite3_enable_shared_cache", "sent": "This interface is threadsafe on processors where writing a 32-bit integer is atomic."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE_API_constant.On those systems, shared cache mode should be enabled per-database connection via sqlite3_open_v2_APIName with SQLITE_OPEN_SHAREDCACHE_API_constant.", "key": "sqlite3_enable_shared_cache", "sent": "Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE_API_constant."}, {"API_info": {"var": ["int"], "API_desc": " This routine enables or disables the sharing of the database cache and schema data structures between connections to the same database.", "var_type": ["int"], "ret_type": "int"}, "paraph": "Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE_API_constant.On those systems, shared cache mode should be enabled per-database connection via sqlite3_open_v2_APIName with SQLITE_OPEN_SHAREDCACHE_API_constant.", "key": "sqlite3_enable_shared_cache", "sent": "On those systems, shared cache mode should be enabled per-database connection via sqlite3_open_v2_APIName with SQLITE_OPEN_SHAREDCACHE_API_constant."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " The sqlite3_user_data_APIName interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function.This routine must be called from the same thread in which the application-defined function is running.", "var_type": ["sqlite3_context*"], "ret_type": "void *"}, "paraph": "This routine must be called from the same thread in which the application-defined function is running.", "key": "sqlite3_user_data", "sent": "This routine must be called from the same thread in which the application-defined function is running."}, {"API_info": {"var": ["db", "zDbName"], "API_desc": " The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database N of connection D.  The main database file has the name \"main\".", "var_type": ["sqlite3 *", "const char *"], "ret_type": "const char *"}, "paraph": "The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database sqlite3_db_filename_APIParam_2 of connection D.  The main database file has the name \"main\".If there is no attached database sqlite3_db_filename_APIParam_2 on the database connection D, or if database sqlite3_db_filename_APIParam_2 is a temporary or in-memory database, then sqlite3_db_filename_APIName will return either a NULL pointer or an empty string.", "key": "sqlite3_db_filename", "sent": "The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database sqlite3_db_filename_APIParam_2 of connection D.  The main database file has the name \"main\"."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine initializes the SQLite library.The sqlite3_shutdown_APIName routine deallocates any resources that were allocated by sqlite3_initialize_APIName.These routines are designed to aid in process initialization and shutdown on embedded systems.Workstation applications using SQLite normally do not need to invoke either of these routines.", "key": "sqlite3_initialize", "sent": "The sqlite3_initialize_APIName routine initializes the SQLite library."}, {"API_info": {"var": ["db", "zDbName"], "API_desc": " The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database N of connection D.  The main database file has the name \"main\".", "var_type": ["sqlite3 *", "const char *"], "ret_type": "const char *"}, "paraph": "The filename returned by sqlite3_db_filename_APIName is the output of the xFullPathname method of the VFS.In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.", "key": "sqlite3_db_filename", "sent": "The filename returned by sqlite3_db_filename_APIName is the output of the xFullPathname method of the VFS."}, {"API_info": {"var": ["sqlite3*", "zSQL"], "API_desc": " The xCreate and xConnect methods of a virtual table module call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.", "var_type": ["sqlite3*", "const char *"], "ret_type": "int"}, "paraph": "The xCreate and xConnect methods of a virtual table module call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement.", "key": "sqlite3_declare_vtab", "sent": "The xCreate and xConnect methods of a virtual table module call this interface to declare the format (the names and datatypes of the columns) of the virtual tables they implement."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine initializes the SQLite library.The sqlite3_shutdown_APIName routine deallocates any resources that were allocated by sqlite3_initialize_APIName.These routines are designed to aid in process initialization and shutdown on embedded systems.Workstation applications using SQLite normally do not need to invoke either of these routines.", "key": "sqlite3_initialize", "sent": "The sqlite3_shutdown_APIName routine deallocates any resources that were allocated by sqlite3_initialize_APIName."}, {"API_info": {"var": ["sqlite3_context*"], "API_desc": " The sqlite3_user_data_APIName interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function.This routine must be called from the same thread in which the application-defined function is running.", "var_type": ["sqlite3_context*"], "ret_type": "void *"}, "paraph": "The sqlite3_user_data_APIName interface returns a copy of the pointer that was the pUserData parameter (the 5_APIConstant parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function.", "key": "sqlite3_user_data", "sent": "The sqlite3_user_data_APIName interface returns a copy of the pointer that was the pUserData parameter (the 5_APIConstant parameter) of the sqlite3_create_function_APIName and sqlite3_create_function16_APIName routines that originally registered the application defined function."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine initializes the SQLite library.The sqlite3_shutdown_APIName routine deallocates any resources that were allocated by sqlite3_initialize_APIName.These routines are designed to aid in process initialization and shutdown on embedded systems.Workstation applications using SQLite normally do not need to invoke either of these routines.", "key": "sqlite3_initialize", "sent": "These routines are designed to aid in process initialization and shutdown on embedded systems."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_initialize_APIName is an \"effective\" call if it is the first time sqlite3_initialize_APIName is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize_APIName is invoked following a call to sqlite3_shutdown_APIName.Only an effective call of sqlite3_initialize_APIName does any initialization.All other calls are harmless no-ops.", "key": "sqlite3_initialize", "sent": "All other calls are harmless no-ops."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_initialize_APIName is an \"effective\" call if it is the first time sqlite3_initialize_APIName is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize_APIName is invoked following a call to sqlite3_shutdown_APIName.Only an effective call of sqlite3_initialize_APIName does any initialization.All other calls are harmless no-ops.", "key": "sqlite3_initialize", "sent": "Only an effective call of sqlite3_initialize_APIName does any initialization."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine initializes the SQLite library.The sqlite3_shutdown_APIName routine deallocates any resources that were allocated by sqlite3_initialize_APIName.These routines are designed to aid in process initialization and shutdown on embedded systems.Workstation applications using SQLite normally do not need to invoke either of these routines.", "key": "sqlite3_initialize", "sent": "Workstation applications using SQLite normally do not need to invoke either of these routines."}, {"API_info": {"var": ["db", "zDbName"], "API_desc": " The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database N of connection D.  The main database file has the name \"main\".", "var_type": ["sqlite3 *", "const char *"], "ret_type": "const char *"}, "paraph": "The filename returned by sqlite3_db_filename_APIName is the output of the xFullPathname method of the VFS.In other words, the filename will be an absolute pathname, even if the filename used to open the database originally was a URI or relative pathname.", "key": "sqlite3_db_filename", "sent": "In other words , the filename will be an absolute pathname ,  ."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_shutdown_APIName is an \"effective\" call if it is the first call to sqlite3_shutdown_APIName since the last sqlite3_initialize_APIName.Only an effective call to sqlite3_shutdown_APIName does any deinitialization.All other valid calls to sqlite3_shutdown_APIName are harmless no-ops.", "key": "sqlite3_shutdown", "sent": "Only an effective call to sqlite3_shutdown_APIName does any deinitialization."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_shutdown_APIName is an \"effective\" call if it is the first call to sqlite3_shutdown_APIName since the last sqlite3_initialize_APIName.Only an effective call to sqlite3_shutdown_APIName does any deinitialization.All other valid calls to sqlite3_shutdown_APIName are harmless no-ops.", "key": "sqlite3_shutdown", "sent": "All other valid calls to sqlite3_shutdown_APIName are harmless no-ops."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName interface is threadsafe, but sqlite3_shutdown_APIName is not.The sqlite3_shutdown_APIName interface must only be called from a single thread.All open database connections must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown_APIName.", "key": "sqlite3_initialize", "sent": "The sqlite3_initialize_APIName interface is threadsafe, but sqlite3_shutdown_APIName is not."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName interface is threadsafe, but sqlite3_shutdown_APIName is not.The sqlite3_shutdown_APIName interface must only be called from a single thread.All open database connections must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown_APIName.", "key": "sqlite3_shutdown", "sent": "The sqlite3_shutdown_APIName interface must only be called from a single thread."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_shutdown_APIName is an \"effective\" call if it is the first call to sqlite3_shutdown_APIName since the last sqlite3_initialize_APIName.Only an effective call to sqlite3_shutdown_APIName does any deinitialization.All other valid calls to sqlite3_shutdown_APIName are harmless no-ops.", "key": "sqlite3_initialize", "sent": "A call to sqlite3_shutdown_APIName is an \"effective\" call if it is the first call to sqlite3_shutdown_APIName since the last sqlite3_initialize_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Among other things, sqlite3_initialize_APIName will invoke sqlite3_os_init_APIName.Similarly, sqlite3_shutdown_APIName will invoke sqlite3_os_end_APIName.", "key": "sqlite3_initialize", "sent": "Among other things, sqlite3_initialize_APIName will invoke sqlite3_os_init_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "Among other things, sqlite3_initialize_APIName will invoke sqlite3_os_init_APIName.Similarly, sqlite3_shutdown_APIName will invoke sqlite3_os_end_APIName.", "key": "sqlite3_shutdown", "sent": "Similarly, sqlite3_shutdown_APIName will invoke sqlite3_os_end_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine returns SQLITE_OK_API_constant on success.If for some reason, sqlite3_initialize_APIName is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) sqlite3_initialize_APIName returns an error code other than SQLITE_OK_API_constant.", "key": "sqlite3_initialize", "sent": "The sqlite3_initialize_APIName routine returns SQLITE_OK_API_constant on success."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName interface is threadsafe, but sqlite3_shutdown_APIName is not.The sqlite3_shutdown_APIName interface must only be called from a single thread.All open database connections must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown_APIName.", "key": "sqlite3_shutdown", "sent": "All open database connections must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine returns SQLITE_OK_API_constant on success.If for some reason, sqlite3_initialize_APIName is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) sqlite3_initialize_APIName returns an error code other than SQLITE_OK_API_constant.", "key": "sqlite3_initialize", "sent": "If for some reason, sqlite3_initialize_APIName is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) sqlite3_initialize_APIName returns an error code other than SQLITE_OK_API_constant."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "Future releases of SQLite may require this."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_os_init_APIName routine does operating-system specific initialization of the SQLite library.The sqlite3_os_end_APIName routine undoes the effect of sqlite3_os_init_APIName.Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default sqlite3_vfs module, or setting up a default configuration using sqlite3_config_APIName.", "key": "sqlite3_os_init", "sent": "The sqlite3_os_end_APIName routine undoes the effect of sqlite3_os_init_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_os_init_APIName routine does operating-system specific initialization of the SQLite library.The sqlite3_os_end_APIName routine undoes the effect of sqlite3_os_init_APIName.Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default sqlite3_vfs module, or setting up a default configuration using sqlite3_config_APIName.", "key": "sqlite3_os_init", "sent": "The sqlite3_os_init_APIName routine does operating-system specific initialization of the SQLite library."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_os_init", "sent": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_initialize", "sent": "The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_initialize", "sent": "The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_os_init", "sent": "Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_os_init", "sent": "When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_initialize_APIName routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize_APIName directly.For example, sqlite3_open_APIName calls sqlite3_initialize_APIName so the SQLite library will be automatically initialized when sqlite3_open_APIName is called if it has not be initialized already.However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface.For maximum portability, it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface.Future releases of SQLite may require this.In other words, the behavior exhibited when SQLite is compiled with SQLITE_OMIT_AUTOINIT might become the default behavior in some future release of SQLite.", "key": "sqlite3_initialize", "sent": "However, if SQLite is compiled with the SQLITE_OMIT_AUTOINIT compile-time option, then the automatic calls to sqlite3_initialize_APIName are omitted and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "A call to sqlite3_initialize_APIName is an \"effective\" call if it is the first time sqlite3_initialize_APIName is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize_APIName is invoked following a call to sqlite3_shutdown_APIName.Only an effective call of sqlite3_initialize_APIName does any initialization.All other calls are harmless no-ops.", "key": "sqlite3_initialize", "sent": "A call to sqlite3_initialize_APIName is an \"effective\" call if it is the first time sqlite3_initialize_APIName is invoked during the lifetime of the process, or if it is the first time sqlite3_initialize_APIName is invoked following a call to sqlite3_shutdown_APIName."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly.The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName.The sqlite3_os_init_APIName interface is called automatically by sqlite3_initialize_APIName and sqlite3_os_end_APIName is called by sqlite3_shutdown_APIName.Appropriate implementations for sqlite3_os_init_APIName and sqlite3_os_end_APIName are built into SQLite when it is compiled for Unix, Windows, or OS/2.When built for other platforms (using the SQLITE_OS_OTHER=1 compile-time option) the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName.An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure.", "key": "sqlite3_os_init", "sent": "An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure."}, {"API_info": {"var": ["db", "zDbName"], "API_desc": " The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database N of connection D.  The main database file has the name \"main\".", "var_type": ["sqlite3 *", "const char *"], "ret_type": "const char *"}, "paraph": "The sqlite3_db_filename_APIName interface returns a pointer to a filename associated with database sqlite3_db_filename_APIParam_2 of connection D.  The main database file has the name \"main\".If there is no attached database sqlite3_db_filename_APIParam_2 on the database connection D, or if database sqlite3_db_filename_APIParam_2 is a temporary or in-memory database, then sqlite3_db_filename_APIName will return either a NULL pointer or an empty string.", "key": "sqlite3_db_filename", "sent": "If there is no attached database sqlite3_db_filename_APIParam_2 on the database connection D, or if database sqlite3_db_filename_APIParam_2 is a temporary or in-memory database, then sqlite3_db_filename_APIName will return either a NULL pointer or an empty string."}, {"API_info": {"var": ["void"], "API_desc": " The sqlite3_initialize_APIName routine initializes the SQLite library.", "var_type": ["void"], "ret_type": "int"}, "paraph": "The sqlite3_os_init_APIName routine does operating-system specific initialization of the SQLite library.The sqlite3_os_end_APIName routine undoes the effect of sqlite3_os_init_APIName.Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default sqlite3_vfs module, or setting up a default configuration using sqlite3_config_APIName.", "key": "sqlite3_os_init", "sent": "Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default sqlite3_vfs module, or setting up a default configuration using sqlite3_config_APIName."}]