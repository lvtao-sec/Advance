The application must ensure that the 1_APIConstant parameter to sqlite3_exec_APIName is a valid and open database connection
resources associated with the sqlite3_open_v2_APIParam_2 should be released by passing sqlite3_open_v2_APIParam_2 to sqlite3_close_APIName.
The safest policy is to invoke these routines in one of the following ways
But for maximum safety , mutexes should be enabled
One way around this problem is to check the extended error code returned by an sqlite3_step_APIName call
Any such actions result in undefined behavior
The use of the UTF-8 interfaces is preferred , as SQLite currently does all parsing using UTF-8
The incremental blob I/O routines can only read or overwriting existing blob content
The only way to find out whether SQLite automatically rolled back the transaction after an error is to use sqlite3_get_autocommit_APIName
Applications that need to process SQL from untrusted sources might also consider lowering resource limits using sqlite3_limit_APIName and limiting database size using the max_page_count PRAGMA in addition to using an authorizer
Only the row can be changed
Any attempt to use these routines on an unprotected sqlite3_value is not threadsafe
The following must be true for sqlite3_snapshot_get_APIName to succeed
the database connection must not be in autocommit mode
the database handle must have no active statements
Only built-in memory allocators can be used
Only an effective call to sqlite3_shutdown_APIName does any deinitialization
Nevertheless , best practice is to avoid using keywords as identifiers
There can only be a single busy handler for a particular database connection at any given moment
Only a single authorizer can be in place on a database connection at a time
the result is undefined and probably harmful
the application must supply a suitable implementation for sqlite3_os_init_APIName and sqlite3_os_end_APIName
As long as the input parameter is correct , these routines can only fail
Applications must always be prepared to encounter a NULL pointer in any of the third through the sixth parameters of the authorization callback
The third and fourth parameters to sqlite3_table_column_metadata_APIName are the table and column name of the desired column , respectively
The unlock-notify callback is not reentrant
Callback implementations should return zero to ensure future compatibility
The callback function should normally return SQLITE_OK_API_constant
Applications that invoke sqlite3_create_collation_v2_APIName with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them
Applications must not used the pointer returned by sqlite3_str_value_APIName after any subsequent method call on the same object
The authorizer callback should return SQLITE_OK_API_constant to allow the action, SQLITE_IGNORE_API_constant to disallow the specific action but allow the SQL statement to continue to be compiled, or SQLITE_DENY_API_constant to cause the entire SQL statement to be rejected with an error
The sqlite3_uri_boolean_APIName routine assumes that sqlite3_uri_boolean_APIParam_2 is a boolean parameter and returns true or false according to the value of sqlite3_uri_boolean_APIParam_2.
The sqlite3_uri_boolean_APIName routine returns true if the value of query parameter sqlite3_uri_boolean_APIParam_2 is one of "yes", "true", or "on" in any case or if the value begins with a non-zero number
sqlite3_uri_parameter_APIName returns NULL and sqlite3_uri_boolean_APIName returns B
the value returned is unpredictable and not meaningful
The collating function must return an integer that is negative, zero, or positive
The sqlite3_mutex_notheld_APIName interface should also return 1 when given a NULL pointer
These routines should return true
zero is returned by sqlite3_uri_int64_APIName
The sqlite3_value_frombind_APIName interface returns non-zero if the value sqlite3_value_frombind_APIParam_1 originated from one of the sqlite3_bind_APIName interfaces
sqlite3_uri_boolean_APIName returns (B!=0).
The sqlite3_value_dup_APIName interface returns NULL if sqlite3_value_dup_APIParam_1 is NULL or if a memory allocation fails
sqlite3_value_frombind_APIName returns zero
a NULL pointer is returned by sqlite3_vfs_find_APIName
The sqlite3_str_errcode_APIName method returns SQLITE_NOMEM_API_constant following any out-of-memory error, or SQLITE_TOOBIG_API_constant if the size of the dynamic string exceeds SQLITE_MAX_LENGTH, or SQLITE_OK_API_constant if there have been no errors
subsequent calls to sqlite3_value_type_APIName might return SQLITE_TEXT_API_constant
 sqlite3_value_pointer_APIName will return the pointer P. Otherwise, sqlite3_value_pointer_APIName returns a NULL
sqlite3_uri_parameter_APIName returns the value of the sqlite3_uri_parameter_APIParam_2 parameter if it exists or a NULL pointer if sqlite3_uri_parameter_APIParam_2 does not appear as a query parameter on sqlite3_uri_parameter_APIParam_1. 
If sqlite3_uri_parameter_APIParam_2 is a query parameter of sqlite3_uri_parameter_APIParam_1 has no explicit value, sqlite3_uri_parameter_APIName returns a pointer to an empty string
SQLITE_NOMEM_API_constant is returned by sqlite3_bind_value_APIName if malloc_APIName fails
SQLITE_RANGE_API_constant is returned by sqlite3_bind_text_APIName 
The sqlite3_win32_set_directory interface returns SQLITE_OK_API_constant to indicate success, SQLITE_ERROR_API_constant if the sqlite3_win32_set_directory_APIParam_1 is unsupported, or SQLITE_NOMEM_API_constant if memory could not be allocated
The sqlite3_bind_ routines return SQLITE_OK_API_constant on success or an error code if anything goes wrong
then the call will return SQLITE_MISUSE_API_constant .
SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName immediately upon encountering the lock
 no additional attempts are made to access the database and SQLITE_BUSY_API_constant is returned by sqlite3_busy_handler_APIName to the application
sqlite3_column_bytes_APIName returns zero
sqlite3_column_bytes16_APIName returns zero
The return value from sqlite3_column_blob_APIName for a zero-length BLOB is a NULL pointer
The values returned by sqlite3_column_bytes_APIName and sqlite3_column_bytes16_APIName do not include the zero terminators at the end of the string
The underlying xFileControl method might also return SQLITE_ERROR_API_constant
sqlite3_db_filename_APIName will return either a NULL pointer or an empty string
sqlite3_finalize_APIName returns SQLITE_OK_API_constant
the value returned by sqlite3_snapshot_cmp_APIName is undefined
SQLITE_ERROR_API_constant is returned by sqlite3_snapshot_open_APIName
In the legacy interface, the return value will be either SQLITE_BUSY_API_constant, SQLITE_DONE_API_constant, SQLITE_ROW_API_constant, SQLITE_ERROR_API_constant, or SQLITE_MISUSE_API_constant
The sqlite3_stmt_readonly_APIName interface returns true
The sqlite3_strglob_APIName interface returns zero
The sqlite3_strlike_APIName interface returns zero
the lock cannot be obtained and SQLITE_BUSY_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName
sqlite3_vtab_nochange_APIName returns true, during which the column value will not change
The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string
a NULL pointer is returned by sqlite3_column_name_APIName
the routine should return 1
The only exception is that if SQLite is unable to allocate memory to hold the sqlite3 object, a NULL will be written into *ppDb instead of a pointer to the sqlite3 object.
the values returned by sqlite3_status_APIName are undefined
Within the xUpdate method of a virtual table, the sqlite3_value_nochange_APIName interface returns true if and only if the column corresponding to sqlite3_value_nochange_APIParam_1 is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior xColumn method call that was invoked to extracted the value for that column returned without setting a result
The value returned by sqlite3_column_type_APIName is only meaningful
A zero is returned by sqlite3_bind_parameter_index_APIName
The sqlite3_aggregate_context_APIName routine returns a NULL pointer when first called if sqlite3_aggregate_context_APIParam_2 is less than or equal to zero or if a memory allocate error occurs
NULL is returned by sqlite3_bind_parameter_name_APIName
On success, SQLITE_OK_API_constant is returned by sqlite3_blob_open_APIName and the new BLOB handle is stored in ppBlob
an error code is returned by sqlite3_blob_close_APIName and the transaction rolled back
On success, sqlite3_blob_read_APIName returns SQLITE_OK_API_constant
Otherwise, an error code or an extended error code is returned by sqlite3_blob_read_APIName
Calls to sqlite3_blob_read_APIName and sqlite3_blob_write_APIName for an expired BLOB handle fail with a return code of SQLITE_ABORT_API_constant
SQLITE_ERROR_API_constant is returned by sqlite3_blob_read_APIName and no data is read
Otherwise an error code is returned by sqlite3_blob_open_APIName
All subsequent calls to sqlite3_blob_read_APIName, sqlite3_blob_write_APIName or sqlite3_blob_reopen_APIName on an aborted blob handle immediately return SQLITE_ABORT_API_constant
an SQLite error code is returned by sqlite3_blob_reopen_APIName and the blob handle is considered aborted
sqlite3_blob_write_APIName returns SQLITE_OK_API_constant
Calling sqlite3_blob_bytes_APIName on an aborted blob handle always returns zero
Otherwise, an error code or an extended error code is returned by sqlite3_blob_write_APIName
sqlite3_blob_write_APIName returns SQLITE_READ_API_constantONLY
SQLITE_ERROR_API_constant is returned by sqlite3_blob_write_APIName and no data is written
After at least "ms" milliseconds of sleeping, the handler returns 0 which causes sqlite3_step_APIName to return SQLITE_BUSY_API_constant
The value returned by sqlite3_changes_APIName immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero
it will return SQLITE_MISUSE_API_constant
sqlite3_config_APIName returns SQLITE_OK_API_constant
The sqlite3_data_count_APIName routine also returns 0 
The sqlite3_data_count_APIName routine returns 0 
The sqlite3_cancel_auto_extension_APIName routine returns 1
The sqlite3_cancel_auto_extension_APIName routine returns 0
Otherwise, sqlite3_db_cacheflush_APIName returns SQLITE_OK_API_constant
this routine returns a non-zero error code
sqlite3_data_count_APIName returns 0
sqlite3_db_mutex_APIName returns a NULL pointer
The sqlite3_db_status_APIName routine returns SQLITE_OK_API_constant on success and a non-zero error code on failure
processing is abandoned and an SQLite error code is returned by sqlite3_db_cacheflush_APIName to the caller immediately
The sqlite3_db_readonly_APIName interface returns 1 if the database sqlite3_db_readonly_APIParam_2 of connection sqlite3_db_readonly_APIParam_1 is read-only, 0 if it is read/write, or -1 if sqlite3_db_readonly_APIParam_2 is not the name of a database on connection sqlite3_db_readonly_APIParam_1
This routine returns SQLITE_OK_API_constant
An SQL operation that is interrupted will return SQLITE_INTERRUPT_API_constant
the sqlite3_exec_APIName routine returns SQLITE_ABORT_API_constant without invoking the callback again and without running any subsequent SQL statements
sqlite3_finalize_APIName returns the appropriate error code or extended error code
sqlite3_last_insert_rowid_APIName returns zero
The sqlite3_load_extension_APIName interface returns SQLITE_OK_API_constant on success and SQLITE_ERROR_API_constant if something goes wrong
sqlite3_next_stmt_APIName returns NULL
The sqlite3_release_memory_APIName routine is a no-op returning zero
sqlite3_snapshot_get_APIName may also return SQLITE_NOMEM_API_constant
A call to sqlite3_serialize_APIName might return NULL
sqlite3_reset_APIName returns an appropriate error code
SQLITE_ERROR_API_constant is returned by sqlite3_snapshot_get_APIName
Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2
no memory allocations are made, and the sqlite3_serialize_APIName function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists
SQLITE_ERROR_API_constant_SNAPSHOT is returned by sqlite3_snapshot_open_APIName
The sqlite3_snapshot_open_APIName interface returns SQLITE_OK_API_constant on success or an appropriate error code if it fails
In the "v2" interface, the more specific error code is returned directly by sqlite3_step_APIName
Failure to reset the prepared statement using sqlite3_reset_APIName would result in an SQLITE_MISUSE_API_constant return from sqlite3_step_APIName
The sqlite3_stmt_busy_APIName interface returns false
The sqlite3_stmt_isexplain_APIName interface returns 0 
But , sqlite3_stmt_readonly_APIName would still return true
SQLITE_ROW_API_constant is returned each time a new row of data is ready for processing by the caller
The sqlite3_stmt_isexplain_APIName interface returns 1
The sqlite3_stmt_busy_APIName interface returns true
In the legacy interface, the sqlite3_step_APIName API always returns a generic error code, SQLITE_ERROR_API_constant, following any error other than SQLITE_BUSY_API_constant and SQLITE_MISUSE_API_constant
The sqlite3_stmt_readonly_APIName interface returns true for BEGIN , but the BEGIN IMMEDIATE and BEGIN EXCLUSIVE commands do touch the database and so sqlite3_stmt_readonly_APIName returns false for those commands
Transaction control statements such as BEGIN , COMMIT , ROLLBACK , SAVEPOINT , and RELEASE cause sqlite3_stmt_readonly_APIName to return true
The sqlite3_str_finish_APIName interface may return a NULL pointer if any errors were encountered during construction of the string
The sqlite3_str_finish_APIName interface will also return a NULL pointer
The sqlite3_table_column_metadata_APIName interface returns SQLITE_ERROR_API_constant and if the specified column does not exist
Note that sqlite3_strglob_APIName returns zero on a match and non-zero, the same as sqlite3_stricmp_APIName and sqlite3_strnicmp_APIName
The sqlite3_table_column_metadata_APIName interface returns SQLITE_OK_API_constant and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists
The memory pointed to by the character pointers returned for the declaration type and collation sequence is valid until the next call to any SQLite API function
sqlite3_table_column_metadata_APIName returns an error 
sqlite3_unlock_notify_APIName always returns SQLITE_OK_API_constant
SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName
SQLITE_LOCKED_API_constant is returned by sqlite3_unlock_notify_APIName and no unlock-notify callback is registered
In that case, sqlite3_value_nochange_APIName will return true for the same column in the xUpdate method
SQLITE_BUSY_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName
The sqlite3_update_hook_APIName function returns the P argument from the previous call on the same database connection D, or NULL for the first call on D
SQLITE_OK_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName
SQLITE_ERROR_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName to the caller
processing is abandoned and the error code is returned by sqlite3_wal_checkpoint_v2_APIName to the caller immediately
The value returned by sqlite3_vtab_on_conflict_APIName is one of SQLITE_ROLLBACK_API_constant, SQLITE_IGNORE_API_constant, SQLITE_FAIL_API_constant, SQLITE_ABORT_API_constant, or SQLITE_REPLACE_API_constant, according to the ON CONFLICT mode of the SQL statement that triggered the call to the xUpdate method of the virtual table
SQLITE_OK_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName and both pnLog and pnCkpt set to -1
the operation is still attempted on any remaining attached databases and SQLITE_BUSY_API_constant is returned by sqlite3_wal_checkpoint_v2_APIName at the end
Calls to sqlite3_close_APIName and sqlite3_close_v2_APIName return SQLITE_OK_API_constant 
These routine sqlite3_column_database_name_APIName sqlite3_column_database_name16_APIName sqlite3_column_table_name_APIName sqlite3_column_table_name16_APIName sqlite3_column_origin_name_APIName sqlite3_column_origin_name16_APIName might also return NULL
sqlite3_close_APIName will leave the database connection open and return SQLITE_BUSY_API_constant
sqlite3_column_database_name_APIName sqlite3_column_database_name16_APIName sqlite3_column_table_name_APIName sqlite3_column_table_name16_APIName sqlite3_column_origin_name_APIName sqlite3_column_origin_name16_APIName return NULL
a NULL pointer is returned by sqlite3_column_decltype16_APIName
sqlite3_column_decltype_APIName and sqlite3_column_decltype16_APIName would return the string "VARIANT" for the second result column , and a NULL pointer for the first result column
sqlite3_compileoption_get_APIName returns a NULL pointer
sqlite3_complete_APIName and sqlite3_complete16_APIName return 0
The sqlite3_compileoption_used_APIName function returns 0 or 1 indicating whether the specified option was defined at compile time
SQLITE_NOMEM_API_constant is returned by sqlite3_complete16_APIName
These routines return 1
sqlite3_close_v2_APIName returns SQLITE_OK_API_constant and the deallocation of resources is deferred until all prepared statements, BLOB handles, and sqlite3_backup objects are also destroyed
The sqlite3_commit_hook_APIName and sqlite3_rollback_hook_APIName functions return the P argument from the previous call of the same function on the same database connection D, or NULL for the first call for each function on D
The SQLITE_OMIT_TRACE compile-time option causes sqlite3_expanded_sql_APIName to always return NULL
it returns a NULL pointer
sqlite3_malloc_APIName returns a NULL pointer
sqlite3_msize_APIName returns zero
sqlite3_realloc_APIName returns NULL
the sqlite3_errcode_APIName interface returns the numeric result code or extended result code for that API call
The sqlite3_expanded_sql_APIName interface returns NULL 
sqlite3_sql_APIName will return the original string, "SELECT $abc,:xyz" but sqlite3_expanded_sql_APIName will return "SELECT 2345,NULL".
The sqlite3_initialize_APIName routine returns SQLITE_OK_API_constant on success
the sqlite3_get_auxdata_APIName interface returns a NULL pointer
sqlite3_initialize_APIName returns an error code other than SQLITE_OK_API_constant
Subsequent calls to sqlite3_get_auxdata_APIName return NULL
The sqlite3_keyword_name_APIName routine returns SQLITE_OK_API_constant if sqlite3_keyword_name_APIParam_1 is within bounds and SQLITE_ERROR_API_constant if not
The sqlite3_libversion_number_APIName function returns an integer equal to SQLITE_VERSION_API_constant_NUMBER
The sqlite3_keyword_check_APIName returning zero 
The sqlite3_mprintf_APIName and sqlite3_vmprintf_APIName routines return a NULL pointer 
The sqlite3_mutex_alloc_APIName routine returns NULL
The sqlite3_mutex_try_APIName interface returns SQLITE_OK_API_constant upon successful entry
On those systems, sqlite3_mutex_try_APIName will always return SQLITE_BUSY_API_constant
Otherwise an error code is returned by sqlite3_open_APIName
sqlite3_mutex_enter_APIName will block and sqlite3_mutex_try_APIName will return SQLITE_BUSY_API_constant
SQLITE_OK_API_constant is returned by sqlite3_open_APIName
an error is returned by sqlite3_open16_APIName to the caller
The sqlite3_preupdate_depth_APIName interface returns 0 
The sqlite3_status_APIName and sqlite3_status64_APIName routines return SQLITE_OK_API_constant on success and a non-zero error code on failure
The sqlite3_preupdate_depth_APIName interface returns 1
The sqlite3_preupdate_depth_APIName interface returns 2
the sqlite3_str_errcode_APIName method will return an appropriate error code
sqlite3_value_type_APIParam_0 is one of SQLITE_INTEGER_API_constant, SQLITE_FLOAT_API_constant, SQLITE_TEXT_API_constant, SQLITE_BLOB_API_constant, or SQLITE_NULL_API_constant
The sqlite3_uri_boolean_APIName routines returns false 
 the return value is arbitrary and meaningless
Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the sqlite3_errcode_APIName immediately after the suspect return value is obtained and before any other SQLite interface is called on the same database connection
Any attempt to create a function with a longer name will result in SQLITE_MISUSE_API_constant being returned
The sqlite3_get_autocommit_APIName interface returns non-zero or zero 
the return value is undefined
Strings returned by sqlite3_column_text_APIName and sqlite3_column_text16_APIName, even empty strings, are always zero-terminated
pointers returned by prior calls to sqlite3_column_blob_APIName, sqlite3_column_text_APIName, and/or sqlite3_column_text16_APIName may be invalidated
The pointers returned are valid until a type conversion occurs as described above, or until sqlite3_step_APIName or sqlite3_reset_APIName or sqlite3_finalize_APIName is called
this routine simply checks for the existence of the table and returns SQLITE_OK_API_constant 
this routine simply checks for the existence of the table and returns SQLITE_ERROR_API_constant 
An application-supplied implementation of sqlite3_os_init_APIName or sqlite3_os_end_APIName must return SQLITE_OK_API_constant on success and some other error code upon failure
Calls to sqlite3_db_config_APIName return SQLITE_OK_API_constant
sqlite3_reset_APIName returns SQLITE_OK_API_constant
it will go ahead and return SQLITE_BUSY_API_constant to the application instead of invoking the busy handler
then SQLITE_ERROR_API_constant is returned by sqlite3_file_control_APIName
The application should only invoke sqlite3_initialize_APIName and sqlite3_shutdown_APIName
A collating function must always return the same answer given the same inputs
The collating function must obey the following properties for all strings A , B , and C
sqlite3_aggregate_context_APIName must be called from the same thread in which the aggregate SQL function is running
To avoid a resource leak , every open BLOB handle should eventually be released by a call to sqlite3_blob_close_APIName
This routine only works on a BLOB handle which has been created by a prior successful call to sqlite3_blob_open_APIName and which has not been closed by sqlite3_blob_close_APIName
The sqlite3_config_APIName interface may only be invoked prior to library initialization using sqlite3_initialize_APIName or after shutdown by sqlite3_shutdown_APIName
Applications that care about shared cache setting should set it explicitly
The application must finalize every prepared statement
The use of the sqlite3_enable_load_extension_APIName interface should be avoided
It is recommended that the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method be used to enable only this interface
The progress handler callback must not do anything that will modify the database connection that invoked the progress handler
This interface sqlite3_deserialize_APIName is only available
The sqlite3_snapshot_free_APIName interface is only available
This interface sqlite3_snapshot_recover_APIName is only available
The sqlite3_snapshot_get_APIName interface is only available
The sqlite3_snapshot_open_APIName interface is only available
sqlite3_step_APIName should not be called again on the VM
You must call sqlite3_reset_APIName or sqlite3_finalize_APIName
sqlite3_step_APIName should not be called again on this virtual machine without first calling sqlite3_reset_APIName to reset the virtual machine back to its initial state
you should rollback the transaction before continuing
This API sqlite3_stmt_scanstatus_reset_APIName is only available
sqlite3_stmt_scanstatus_APIName is only available
After a prepared statement has been prepared using any of sqlite3_prepare_v2_APIName , sqlite3_prepare_v3_APIName , sqlite3_prepare16_v2_APIName , or sqlite3_prepare16_v3_APIName or one of the legacy interfaces sqlite3_prepare_APIName or sqlite3_prepare16_APIName , sqlite3_step_APIName must be called one or more times to evaluate the statement
This API sqlite3_unlock_notify_APIName is only available
This routine sqlite3_user_data_APIName must be called from the same thread in which the application-defined function is running
The update hook implementation must not do anything that will modify the database connection that invoked the update hook
Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the update hook
The use of this interface is only necessary
The callback function should register the desired collation using sqlite3_create_collation_APIName , sqlite3_create_collation16_APIName , or sqlite3_create_collation_v2_APIName
The callback implementation must not do anything that will modify the database connection that invoked the callback
These APIs are only available
Applications should finalize all prepared statements , close all BLOB handles , and finish all sqlite3_backup objects associated with the sqlite3 object prior to attempting to close the object
Any actions to modify the database connection must be deferred until after the completion of the sqlite3_step_APIName call that triggered the commit or rollback hook in the first place
sqlite3_column_name_APIParam_0 pointer is valid until either the prepared statement is destroyed by sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the next call to sqlite3_column_name_APIName or sqlite3_column_name16_APIName on the same column
The application does not need to worry about freeing the result
After being freed , memory should neither be read nor written
Module names must be registered before creating a new virtual table using the module and before using a preexisting virtual table for the module
Memory to hold the error message string is managed internally and must not be freed by the application
The string returned by sqlite3_expanded_sql_APIName must be free by the application by passing it to sqlite3_free_APIName
A sqlite3_free_table_APIParam_1 table should be deallocated using sqlite3_free_table_APIName
The sqlite3_shutdown_APIName interface must only be called from a single thread
the calling function must not try to call sqlite3_free_APIName directly
These routines must be called from the same thread in which the SQL function is running
All open database connections must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown_APIName
The application should never invoke either sqlite3_os_init_APIName or sqlite3_os_end_APIName directly
After the application has finished with the result from sqlite3_get_table_APIName , it must pass the result table pointer to sqlite3_free_table_APIName
so that an application usually does not need to invoke sqlite3_initialize_APIName directly
The strings returned by these two routines should be released by sqlite3_free_APIName
Hence sqlite3_set_auxdata_APIName should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata_APIName has been called
However , and the application must call sqlite3_initialize_APIName directly prior to using any other SQLite interface
Static mutexes are for internal use by SQLite only
Applications that use SQLite mutexes should use only the dynamic mutexes returned by SQLITE_MUTEX_FAST_API_constant or SQLITE_MUTEX_RECURSIVE_API_constant
Some systems do not support the operation implemented by sqlite3_mutex_try_APIName
the mutex must be exited an equal number of times before another thread can enter
The SQLite core never uses these routines except inside an assert_APIName and applications are advised to follow the lead of the core
External mutex implementations are only required to provide these routines
The temporary directory must be set prior to calling sqlite3_open_APIName or sqlite3_open_v2_APIName
the application must supply a custom mutex implementation using the SQLITE_CONFIG_MUTEX_API_constant option of the sqlite3_config_APIName function before calling sqlite3_initialize_APIName or any other public sqlite3 _ function that calls sqlite3_initialize_APIName
These interfaces are only available
Use the sqlite3_trace_v2_APIName interface instead of the routines described here
This must only be used within SQLITE_UPDATE_API_constant and SQLITE_DELETE_API_constant preupdate callbacks
This must only be used within SQLITE_INSERT_API_constant and SQLITE_UPDATE_API_constant preupdate callbacks
These interfaces are available only on Windows
These routines must be called from the same thread as the SQL function that supplied the sqlite3_value parameters
The sqlite3_prepare_APIName interface is legacy and should be avoided
The database connection must not have been closed
To execute an SQL statement , it must first be compiled into a byte-code program using one of these routines
However , such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running
application-defined SQL functions must be added to each database connection separately
The authorizer callback must not do anything that will modify the database connection that invoked the authorizer callback
There can only be a single busy handler defined for each database connection
A busy handler must not close the database connection or prepared statement that invoked the busy handler
The busy callback should not take any actions which modify the database connection that invoked the busy handler
Hence , the sqlite3_column_value_APIName interface is normally only useful within the implementation of application-defined SQL functions or virtual tables , not within top-level application code
you should call sqlite3_column_text_APIName , sqlite3_column_blob_APIName , or sqlite3_column_text16_APIName first to force the result into the desired format , invoke sqlite3_column_bytes_APIName or sqlite3_column_bytes16_APIName to find the size of the result
The application must ensure that no other SQLite interfaces are invoked by other threads
This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE_API_constant
But it is not safe to call this routine with a database connection that is closed or might close before sqlite3_interrupt_APIName returns
It is a grievous error for the application to try to use a prepared statement after it has been finalized
It is recommended that extension loading be disabled using the SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION_API_constant method rather than this interface , so the load_extension_APIName SQL function remains disabled
Any use of a prepared statement after it has been finalized can result in undefined and undesirable behavior such as segfaults and heap corruption
The caller is responsible for freeing sqlite3_serialize_APIParam_0 to avoid a memory leak
doing so is considered bad form
For all versions of SQLite up to and including 3.6.23.1, a call to sqlite3_reset_APIName was required after sqlite3_step_APIName returned anything other than SQLITE_ROW_API_constant before any subsequent invocation of sqlite3_step_APIName
sqlite3_test_control_APIName is not for use by applications
Without the mutexes , it is not safe to use SQLite concurrently from more than one thread
The sqlite3_trace_v2_APIName interface is intended to replace the legacy interfaces sqlite3_trace_APIName and sqlite3_profile_APIName , both of which are deprecated
Only sqlite3_free_table_APIName is able to release the memory properly and safely
For maximum portability , it is recommended that applications always invoke sqlite3_initialize_APIName directly prior to using any other SQLite interface
These routines sqlite3_trace_APIName and sqlite3_profile_APIName are deprecated
The older interfaces are retained for backwards compatibility , but their use is discouraged
The sqlite3_prepare_v2_APIName , sqlite3_prepare_v3_APIName , sqlite3_prepare16_v2_APIName , and sqlite3_prepare16_v3_APIName interfaces are recommended for all new programs
This interface is only available
The calling function should free this memory by calling sqlite3_free_APIName
Only the following subset of interfaces are subject to out-of-memory errors
The implementation of the new function always causes an exception to be thrown
The sqlite3_snapshot object returned from a successful call to sqlite3_snapshot_get_APIName must be freed using sqlite3_snapshot_free_APIName to avoid a memory leak
Calling sqlite3_blob_close_APIName with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour
Moving an existing BLOB handle to a new row is faster than closing the existing handle and opening a new one
An attempt to write to an expired BLOB handle fails with an error code of SQLITE_ABORT_API_constant
The sqlite3_config_APIName interface is not threadsafe
a crash or deadlock may be the result
an infinite loop might be the result
Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action , using this API may cause the application to deadlock
the behavior is undefined
that collation is no longer usable
the results are undefined
That capability is no longer provided
Use of this interface is not recommended
the behavior of SQLite is undefined
It is not safe to pass a sqlite3_free_table_APIParam_1 table directly to sqlite3_free_APIName
Memory corruption , a segmentation fault , or other severe error might result
the behavior of sqlite3_msize_APIName is undefined and possibly harmful
The sqlite3_initialize_APIName interface is threadsafe , but sqlite3_shutdown_APIName is not
pointers calls to sqlite3_keyword_name_APIName result in undefined behavior
Attempting to deallocate a static mutex results in undefined behavior
The parameter name must be given in UTF-8
The first parameter must be a copy of the SQL function context that is first parameter to the xStep or xFinal callback routine that implements the aggregate function
The new row must meet the same criteria as for sqlite3_blob_open_APIName - it must exist and there must be either a blob or text value stored in the nominated column
To avoid memory leaks, the application should invoke sqlite3_free_APIName on error message strings returned through the 5_APIConstant parameter of sqlite3_exec_APIName after the error message string is no longer needed
The sqlite3_log_APIParam_2 string must not be NULL
The database connection pointer sqlite3_next_stmt_APIParam_1 in a call to sqlite3_next_stmt_APIName must refer to an open database connection and must not be a NULL pointer
The `` iScanStatusOp '' must be one of the scanstatus options or the behavior of this interface is undefined
To avoid memory leaks, the object returned by sqlite3_str_new_APIName must be freed by a subsequent call to sqlite3_str_finish_APIName
The calling application should pass sqlite3_str_finish_APIParam_0 to sqlite3_free_APIName to avoid a memory leak
The M argument should be the bitwise OR-ed combination of zero or more SQLITE_TRACE_API_constant constants
xBestInde_APIParam_0 must be the sqlite3_index_info object that is the first parameter to the xBestIndex_APIName method
The second argument must be an index into the aConstraint array belonging to the sqlite3_index_info structure passed to xBestIndex
The sqlite3_close_v2_APIParam_1 parameter to sqlite3_close_APIName and sqlite3_close_v2_APIName must be either a NULL pointer or an sqlite3 object pointer obtained from sqlite3_open_APIName , sqlite3_open16_APIName , or sqlite3_open_v2_APIName , and not previously closed
The sqlite3_create_collation_APIParam_3 sqlite3_create_collation_v2_APIParam_3 sqlite3_create_collation16_APIParam_3 must be one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, SQLITE_UTF16, SQLITE_UTF16_ALIGNED.
The input to sqlite3_complete_APIName must be a zero-terminated UTF-8 string
The input to sqlite3_complete16_APIName must be a zero-terminated UTF-16 string in native byte order
The sqlite3_malloc64_APIName routine works just like sqlite3_malloc_APIName except that sqlite3_malloc_APIParam_1 is an unsigned 64-bit integer instead of a signed 32-bit integer
The sqlite3_realloc64_APIName interfaces works the same as sqlite3_realloc_APIName except that sqlite3_realloc_APIParam_2 is a 64-bit unsigned integer instead of a 32-bit signed integer
The application must not read or write any part of a block of memory after it has been released using sqlite3_free_APIName or sqlite3_realloc_APIName
The pointer arguments to sqlite3_free_APIName and sqlite3_realloc_APIName must be either NULL or else pointers obtained from a prior invocation of sqlite3_malloc_APIName or sqlite3_realloc_APIName that have not yet been released
The value of the sqlite3_get_auxdata_APIParam_2 parameter to these interfaces should be non-negative
The argument to sqlite3_mutex_alloc_APIName must be one of these integer constants
Filenames containing international characters must be converted to UTF-8 prior to passing them into sqlite3_open_APIName or sqlite3_open_v2_APIName
The encoding used for the sqlite3_open_APIParam_1 argument of sqlite3_open_APIName and sqlite3_open_v2_APIName must be UTF-8 , not whatever codepage is currently defined
It is recommended that when a database sqlite3_open_v2_APIParam_1 actually does begin with a ":" character you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as "./" to avoid ambiguity.
it must be either an empty string or the string `` localhost ''
The N parameter must be between 0 and one less than the number of columns or the behavior will be undefined
The sqlite3_result_text64_APIName interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth parameter, which must be one of SQLITE_UTF8_API_constant, SQLITE_UTF16_API_constant, SQLITE_UTF16_API_constantBE, or SQLITE_UTF16_API_constantLE
sqlite3_str_append_APIParam_2 must contain at least sqlite3_str_append_APIParam_3 non-zero bytes of content
it must be the byte offset into the string where the NULL terminator would appear if the string where NULL terminated
These routines work only with protected sqlite3_value objects
sqlite3_str_append_APIParam_3 must be non-negative
The NNN value must be between 1 and the sqlite3_limit_APIName parameter SQLITE_LIMIT_VARIABLE_NUMBER_API_constant
The sqlite3_win32_set_directory_APIParam_2 parameter should be NULL to cause the previous value to be freed via sqlite3_free
The sqlite3_win32_set_directory8 and sqlite3_win32_set_directory16 interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16 , respectively
The sqlite3_bind_text64_APIParam_6 must be one of SQLITE_UTF8_API_constant , SQLITE_UTF16_API_constant , SQLITE_UTF16_API_constantBE , or SQLITE_UTF16_API_constantLE to specify the encoding of the text in the third parameter
sqlite3_create_function_APIParam_7 and sqlite3_create_function_APIParam_8 must both be non-NULL
An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc
NULL pointers must be passed as sqlite3_create_function_APIParam_7 and sqlite3_create_function_APIParam_8
sqlite3_prepare_v3_APIName differs from sqlite3_prepare_v2_APIName only in having the extra sqlite3_prepare_v3_APIParam_4 , which is a bit array consisting of zero or more of the SQLITE_PREPARE_PERSISTENT, SQLITE_PREPARE_NORMALIZE and SQLITE_PREPARE_NO_VTAB
sqlite3_bind_pointer_APIParam_5 is either a NULL pointer or a pointer to a destructor function for sqlite3_bind_pointer_APIParam_3
The third through sixth parameters to the callback are either NULL pointers or zero-terminated strings that contain additional details about the action to be authorized
Hence, the application should ensure that the correct authorizer callback remains in place during the sqlite3_step_APIName.
In a multithreaded environment , an unprotected sqlite3_value object may only be used safely with sqlite3_bind_value_APIName and sqlite3_result_value_APIName
sqlite3_create_window_function_APIParam_8 and sqlite3_create_window_function_APIParam_9 may either both be NULL , in which case a regular aggregate function is created , or must both be non-NULL , in which case the new function may be used as either an aggregate or aggregate window function
The first host parameter has an index of 1 , not 0
sqlite3_bind_parameter_name_APIParam_0 is always in UTF-8 encoding
However , the column , table , or database of a BLOB handle can not be changed after the BLOB handle is opened
Testing suggests that , most applications will achieve adequate soft heap limit enforcement without the use of SQLITE_ENABLE_MEMORY_MANAGEMENT
For `` X LIKE P '' without the ESCAPE clause , set the sqlite3_strlike_APIParam_3 parameter of sqlite3_strlike_APIName to 0
The second callback argument is one of SQLITE_INSERT_API_constant , SQLITE_DELETE_API_constant , or SQLITE_UPDATE_API_constant , depending on the operation that caused the callback to be invoked
sqlite3_column_decltype16_APIParam_0 is always UTF-8 encoded
sqlite3_collation_needed_APIParam_2 and sqlite3_collation_needed16_APIParam_2 is one of SQLITE_UTF8_API_constant , SQLITE_UTF16_API_constantBE , or SQLITE_UTF16_API_constantLE , indicating the most desirable form of the collation sequence function required
sqlite3_column_origin_name_APIParam_0 is valid until the prepared statement is destroyed using sqlite3_finalize_APIName or until the statement is automatically reprepared by the first call to sqlite3_step_APIName for a particular run or until the same information is requested again in a different encoding
The default encoding for databases created using sqlite3_open16_APIName will be UTF-16 in the native byte order
The flags parameter to sqlite3_open_v2_APIName can take one of the following three values , optionally combined with the SQLITE_OPEN_NOMUTEX_API_constant , SQLITE_OPEN_FULLMUTEX_API_constant , SQLITE_OPEN_SHAREDCACHE_API_constant , SQLITE_OPEN_PRIVATECACHE_API_constant , and/or SQLITE_OPEN_URI_API_constant flags
It is recommended that you should prefix the sqlite3_open_v2_APIParam_1 with a pathname such as "./" to avoid ambiguity.
Note that the name length limit is in UTF-8 bytes , not characters nor UTF-16 bytes
To delete an existing SQL function or aggregate , pass NULL pointers for all three function callbacks
The length of the name is limited to 255 bytes in a UTF-8 representation , exclusive of the zero-terminator
A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg
 that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated.
there is a small performance advantage to passing an sqlite3_prepare16_v2_APIParam_3 parameter that is the number of bytes in the input string including the nul-terminator
Do not pass the pointers returned from sqlite3_column_blob_APIName, sqlite3_column_text_APIName, etc
For security reasons , the SQLITE_DIRECTONLY_API_constant flag is recommended for any application-defined SQL function that has side-effects
The SQLite query planner is able to perform additional optimizations on deterministic functions , so use of the SQLITE_DETERMINISTIC_API_constant flag is recommended where possible
sqlite3_column_type_APIParam_0 is one of SQLITE_INTEGER_API_constant , SQLITE_FLOAT_API_constant , SQLITE_TEXT_API_constant , SQLITE_BLOB_API_constant , or SQLITE_NULL_API_constant
At present , there is only one option that may be configured using sqlite3_vtab_config_APIName
The third parameter to the preupdate callback is one of the constants SQLITE_INSERT_API_constant , SQLITE_DELETE_API_constant , or SQLITE_UPDATE_API_constant to identify the kind of update operation that is about to occur
the soft heap limit is advisory only
A call to sqlite3_snapshot_open_APIName will fail
the behavior is undefined and probably undesirable
the result is undefined behavior
the busy handler is not reentrant
Type conversions and pointer invalidations might occur in the following cases
On those systems , shared cache mode should be enabled per-database connection via sqlite3_open_v2_APIName with SQLITE_OPEN_SHAREDCACHE_API_constant
the value returned by sqlite3_last_insert_rowid_APIName is unpredictable and might not equal either the old or the new last insert rowid
Developers might also want to use the sqlite3_set_authorizer_APIName interface to further control untrusted SQL
Passing any other pointer into this routine results in undefined and probably undesirable behavior
The sqlite3_finalize_APIName routine can be called at any point after any call to sqlite3_step_APIName regardless of 
the result of the comparison is undefined
the value returned is unpredictable and not meaningful
the results are undefined
Even reading previously freed memory might result in a segmentation fault or other severe error
For an INSERT operation on a rowid table , or any operation on a WITHOUT ROWID table , the value of the sixth parameter is undefined
the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined
The result of expressions involving strings with embedded NULs is undefined
the behavior of this routine is undefined and probably undesirable
The calling procedure is responsible for deleting the compiled SQL statement using sqlite3_finalize_APIName after it has finished with it
then the behavior is undefined.
 the results are undefined
the result is undefined
Do not mix calls to sqlite3_column_text_APIName or sqlite3_column_blob_APIName with calls to sqlite3_column_bytes16_APIName , and do not mix calls to sqlite3_column_text16_APIName with calls to sqlite3_column_bytes_APIName
but sometimes they are not possible and in those cases prior pointers are invalidated
sqlite3_blob_open_APIName fails with SQLITE_ERROR_API_constant
