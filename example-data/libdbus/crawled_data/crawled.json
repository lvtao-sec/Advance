[{"sent": "that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName", "key": "dbus_message_iter_get_fixed_array", "cond": "null", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "prop": "dbus_message_iter_get_fixed_array_APIParam_1 is the iterator", "API_info": {"var_type": ["DBusMessageIter *", "void *", "int *"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}},{"key": "dbus_error_free", "paraph": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName . dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "sent": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusError *"], "desc": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "var": ["error"]}}, {"key": "dbus_error_free", "paraph": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName . dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "sent": "dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "API_info": {"ret_type": "void", "var_type": ["DBusError *"], "desc": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "var": ["error"]}}, {"key": "dbus_error_has_name", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "sent": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *", "const char *"], "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var": ["error", "name"]}}, {"key": "dbus_error_has_name", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "sent": "dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *", "const char *"], "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var": ["error", "name"]}}, {"key": "dbus_error_has_name", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "sent": "dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *", "const char *"], "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var": ["error", "name"]}}, {"key": "dbus_error_has_name", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "sent": "dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *", "const char *"], "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var": ["error", "name"]}}, {"key": "dbus_error_init", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "sent": "Initializes a DBusError structure.", "API_info": {"ret_type": "void", "var_type": ["DBusError *"], "desc": "Initializes a DBusError structure.", "var": ["error"]}}, {"key": "dbus_error_init", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "sent": "Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point.", "API_info": {"ret_type": "void", "var_type": ["DBusError *"], "desc": "Initializes a DBusError structure.", "var": ["error"]}}, {"key": "dbus_error_init", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "sent": "dbus_error_init_APIParam_1 is the DBusError", "API_info": {"ret_type": "void", "var_type": ["DBusError *"], "desc": "Initializes a DBusError structure.", "var": ["error"]}}, {"key": "dbus_error_is_set", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "sent": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *"], "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var": ["error"]}}, {"key": "dbus_error_is_set", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "sent": "dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *"], "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var": ["error"]}}, {"key": "dbus_error_is_set", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "sent": "dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusError *"], "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var": ["error"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "dbus_move_error_APIParam_1 is reinitialized to an empty error.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "dbus_move_error_APIParam_2 may not contain an existing error.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "If the destination is NULL , just frees and reinits the source error.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "dbus_move_error_APIParam_1 is the source error.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_move_error", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "sent": "dbus_move_error_APIParam_2 is the destination error or NULL", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "DBusError *"], "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var": ["src", "dest"]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "Does nothing if dbus_set_error_APIParam_1 is NULL .", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "It will not hurt you.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "sent": "dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *", " ... "], "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var": ["error", "name", "format", " ... "]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "Does nothing if dbus_set_error_const_APIParam_1 is NULL .", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "You probably want dbus_set_error_APIName instead, in most cases.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL.", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!).", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_set_error_const", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "sent": "dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "API_info": {"ret_type": "void", "var_type": ["DBusError *", "const char *", "const char *"], "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var": ["error", "name", "message"]}}, {"key": "dbus_free", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "sent": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "API_info": {"ret_type": "void", "var_type": ["void *"], "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory"]}}, {"key": "dbus_free", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "sent": "If passed NULL , does nothing.", "API_info": {"ret_type": "void", "var_type": ["void *"], "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory"]}}, {"key": "dbus_free", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "sent": "dbus_free_APIParam_1 is block to be freed", "API_info": {"ret_type": "void", "var_type": ["void *"], "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory"]}}, {"key": "dbus_free_string_array", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "sent": "Frees a NULL -terminated array of strings.", "API_info": {"ret_type": "void", "var_type": ["char **"], "desc": "Frees a NULL -terminated array of strings.", "var": ["str_array"]}}, {"key": "dbus_free_string_array", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "sent": "If passed NULL , does nothing.", "API_info": {"ret_type": "void", "var_type": ["char **"], "desc": "Frees a NULL -terminated array of strings.", "var": ["str_array"]}}, {"key": "dbus_free_string_array", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "sent": "dbus_free_string_array_APIParam_1 is the array to be freed", "API_info": {"ret_type": "void", "var_type": ["char **"], "desc": "Frees a NULL -terminated array of strings.", "var": ["str_array"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc_APIParam_0 must be released with dbus_free_APIName .", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "Returns NULL if the allocation fails.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "Free dbus_malloc_APIName memory with dbus_free_APIName only.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName .", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "Free it with dbus_free_APIName only.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate.", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_malloc0", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "sent": "dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "API_info": {"ret_type": "DBUS_MALLOC void *", "var_type": ["size_t"], "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var": ["bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms.", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "Returns NULL if the resize fails.", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "If the resize fails, the dbus_realloc_APIParam_1 is not freed.", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "dbus_realloc_APIParam_1 is block to be resized.", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block.", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_realloc", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "sent": "dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "API_info": {"ret_type": "void *", "var_type": ["void *", "size_t"], "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var": ["memory", "bytes"]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "It only frees libdbus-internal data structures.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName .", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName .", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "(Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.)", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty.", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName .", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_shutdown", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "sent": "One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "API_info": {"ret_type": "void", "var_type": [" void "], "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "Obtains the machine UUID of the machine this process is running on.", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName .", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly.", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "In the latter case, a warning is logged.", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName .", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "API_info": {"ret_type": "char *", "var_type": [" void "], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": [" void "]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "Gets the DYNAMICALLY LINKED version of libdbus.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "In other words, you can get either the runtime or the compile-time version.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "Think carefully about which of these you want in a given case.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "The MINOR is an odd number for development releases and an even number for stable releases.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "dbus_get_version_APIParam_1 is pointer to return the major version, or NULL.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL.", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_get_version", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "sent": "dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "API_info": {"ret_type": "void", "var_type": ["int *", "int *", "int *"], "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var": ["major_version_p", "minor_version_p", "micro_version_p"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "Wrapper for setenv_APIName.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "This is because we can not rely on internal implementation details of the underlying libc library.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_setenv_APIParam_1 is name of environment variable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_setenv", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "const char *"], "desc": "Wrapper for setenv_APIName.", "var": ["varname", "value"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "Obtains the machine UUID of the machine this process is running on.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName .", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves).", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "The machine ID can also be used to create unique per-machine instances.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "For example, you could use it in bus names or X selection names.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification.", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_try_get_local_machine_id", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "sent": "Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "API_info": {"ret_type": "char *", "var_type": ["DBusError *"], "desc": "Obtains the machine UUID of the machine this process is running on.", "var": ["error"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated slot is global, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "all DBusPendingCall objects will have a slot with the given integer ID reserved.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var": ["slot_p"]}}, {"key": "dbus_pending_call_block", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "sent": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var": ["pending"]}}, {"key": "dbus_pending_call_block", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "sent": "The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var": ["pending"]}}, {"key": "dbus_pending_call_block", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "sent": "If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var": ["pending"]}}, {"key": "dbus_pending_call_block", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "sent": "Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var": ["pending"]}}, {"key": "dbus_pending_call_block", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "sent": "This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "If you cancel the call, no reply is received unless the the reply was already received before you canceled.", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_cancel", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "sent": "dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var": ["pending"]}}, {"key": "dbus_pending_call_free_data_slot", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Deallocates a global ID for DBusPendingCall data slots.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var": ["slot_p"]}}, {"key": "dbus_pending_call_free_data_slot", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var": ["slot_p"]}}, {"key": "dbus_pending_call_free_data_slot", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var": ["slot_p"]}}, {"key": "dbus_pending_call_free_data_slot", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var": ["slot_p"]}}, {"key": "dbus_pending_call_get_completed", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "sent": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *"], "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var": ["pending"]}}, {"key": "dbus_pending_call_get_completed", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "sent": "dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *"], "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var": ["pending"]}}, {"key": "dbus_pending_call_get_completed", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "sent": "dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *"], "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var": ["pending"]}}, {"key": "dbus_pending_call_get_data", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "sent": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "API_info": {"ret_type": "void *", "var_type": ["DBusPendingCall *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var": ["pending", "slot"]}}, {"key": "dbus_pending_call_get_data", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "sent": "The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed).", "API_info": {"ret_type": "void *", "var_type": ["DBusPendingCall *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var": ["pending", "slot"]}}, {"key": "dbus_pending_call_get_data", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "sent": "dbus_pending_call_get_data_APIParam_1 is the pending_call.", "API_info": {"ret_type": "void *", "var_type": ["DBusPendingCall *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var": ["pending", "slot"]}}, {"key": "dbus_pending_call_get_data", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "sent": "dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from.", "API_info": {"ret_type": "void *", "var_type": ["DBusPendingCall *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var": ["pending", "slot"]}}, {"key": "dbus_pending_call_get_data", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "sent": "dbus_pending_call_get_data_APIName return the data, or NULL if not found", "API_info": {"ret_type": "void *", "var_type": ["DBusPendingCall *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var": ["pending", "slot"]}}, {"key": "dbus_pending_call_ref", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "sent": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "API_info": {"ret_type": "DBusPendingCall *", "var_type": ["DBusPendingCall *"], "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var": ["pending"]}}, {"key": "dbus_pending_call_ref", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "sent": "dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object.", "API_info": {"ret_type": "DBusPendingCall *", "var_type": ["DBusPendingCall *"], "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var": ["pending"]}}, {"key": "dbus_pending_call_ref", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "sent": "dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "API_info": {"ret_type": "DBusPendingCall *", "var_type": ["DBusPendingCall *"], "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var": ["pending"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "dbus_pending_call_set_data_APIParam_1 is the pending_call.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_data", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "sent": "dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var": ["pending", "slot", "data", "free_data_func"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_set_notify", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "sent": "dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"], "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var": ["pending", "function", "user_data", "free_user_data"]}}, {"key": "dbus_pending_call_steal_reply", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "sent": "Gets the reply, or returns NULL if none has been received yet.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusPendingCall *"], "desc": "Gets the reply, or returns NULL if none has been received yet.", "var": ["pending"]}}, {"key": "dbus_pending_call_steal_reply", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "sent": "Ownership of the reply message passes to the caller.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusPendingCall *"], "desc": "Gets the reply, or returns NULL if none has been received yet.", "var": ["pending"]}}, {"key": "dbus_pending_call_steal_reply", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "sent": "dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusPendingCall *"], "desc": "Gets the reply, or returns NULL if none has been received yet.", "var": ["pending"]}}, {"key": "dbus_pending_call_steal_reply", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "sent": "dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusPendingCall *"], "desc": "Gets the reply, or returns NULL if none has been received yet.", "var": ["pending"]}}, {"key": "dbus_pending_call_steal_reply", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "sent": "dbus_pending_call_steal_reply_APIName return the reply message or NULL", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusPendingCall *"], "desc": "Gets the reply, or returns NULL if none has been received yet.", "var": ["pending"]}}, {"key": "dbus_pending_call_unref", "paraph": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "sent": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "API_info": {"ret_type": "void", "var_type": ["DBusPendingCall *"], "desc": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "var": ["pending"]}}, {"key": "_dbus_message_get_n_unix_fds", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "sent": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusMessage *"], "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var": ["message"]}}, {"key": "_dbus_message_get_n_unix_fds", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "sent": "_dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1.", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusMessage *"], "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var": ["message"]}}, {"key": "_dbus_message_get_n_unix_fds", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "sent": "_dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusMessage *"], "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated slot is global, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "all DBusMessage objects will have a slot with the given integer ID reserved.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var": ["slot_p"]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "The variable argument list should contain the type of each argument followed by the value to append.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "To append a basic type, specify its type code followed by the address of the value.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "If you need those you need to manually recurse into the array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "Hence you may close the descriptor immediately after this call.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "For strings it works to write const char *array = \"Hello\" and then use &array though.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "If you do not do this then libdbus will not know to stop and will read invalid memory.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "sent": "dbus_message_append_args_APIName return TRUE on success", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", " ... "], "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var": ["message", "first_arg_type", " ... "]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "See also dbus_message_append_args .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "dbus_message_append_args_valist_APIParam_2 is type of first argument.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_append_args_valist", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "sent": "dbus_message_append_args_valist_APIName return TRUE on success", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "int", "va_list"], "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var": ["message", "first_arg_type", "var_args"]}}, {"key": "dbus_message_contains_unix_fds", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "sent": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var": ["message"]}}, {"key": "dbus_message_contains_unix_fds", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "sent": "dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var": ["message"]}}, {"key": "dbus_message_contains_unix_fds", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "sent": "dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var": ["message"]}}, {"key": "dbus_message_copy", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "sent": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const DBusMessage *"], "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var": ["message"]}}, {"key": "dbus_message_copy", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "sent": "Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const DBusMessage *"], "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var": ["message"]}}, {"key": "dbus_message_copy", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "sent": "dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const DBusMessage *"], "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var": ["message"]}}, {"key": "dbus_message_copy", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "sent": "dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const DBusMessage *"], "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var": ["message"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "dbus_message_demarshal_APIParam_3 is the location to save errors to.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "sent": "dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "int", "DBusError *"], "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var": ["str", "len", "error"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled.", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled.", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_demarshal_bytes_needed", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "sent": "Otherwise returns the number of bytes to be demarshalled", "API_info": {"ret_type": "int", "var_type": ["const char *", "int"], "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var": ["buf", "len"]}}, {"key": "dbus_message_free_data_slot", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Deallocates a global ID for message data slots.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for message data slots.", "var": ["slot_p"]}}, {"key": "dbus_message_free_data_slot", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for message data slots.", "var": ["slot_p"]}}, {"key": "dbus_message_free_data_slot", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for message data slots.", "var": ["slot_p"]}}, {"key": "dbus_message_free_data_slot", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for message data slots.", "var": ["slot_p"]}}, {"key": "dbus_message_get_allow_interactive_authorization", "paraph": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set. dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "sent": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set.", "var": ["message"]}}, {"key": "dbus_message_get_allow_interactive_authorization", "paraph": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set. dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "sent": "dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set.", "var": ["message"]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "To get a string array pass in \"char ***array_location\" and \"int *n_elements\".", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "If you need them without this flag set, make sure to unset it with fcntl_APIName.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "The list is terminated with DBUS_TYPE_INVALID .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "They point into the DBusMessage .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "sent": "dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "], "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var": ["message", "error", "first_arg_type", " ... "]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "dbus_message_get_args_valist_APIParam_3 is type of the first argument.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_args_valist", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "sent": "dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"], "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var": ["message", "error", "first_arg_type", "var_args"]}}, {"key": "dbus_message_get_auto_start", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "sent": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var": ["message"]}}, {"key": "dbus_message_get_auto_start", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "sent": "dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var": ["message"]}}, {"key": "dbus_message_get_auto_start", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "sent": "dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var": ["message"]}}, {"key": "dbus_message_get_container_instance", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "sent": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_container_instance", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_container_instance", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_container_instance", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_data", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "sent": "Retrieves data previously set with dbus_message_set_data_APIName .", "API_info": {"ret_type": "void*", "var_type": ["DBusMessage *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var": ["message", "slot"]}}, {"key": "dbus_message_get_data", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "sent": "The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed).", "API_info": {"ret_type": "void*", "var_type": ["DBusMessage *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var": ["message", "slot"]}}, {"key": "dbus_message_get_data", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "sent": "dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1.", "API_info": {"ret_type": "void*", "var_type": ["DBusMessage *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var": ["message", "slot"]}}, {"key": "dbus_message_get_data", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "sent": "dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from.", "API_info": {"ret_type": "void*", "var_type": ["DBusMessage *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var": ["message", "slot"]}}, {"key": "dbus_message_get_data", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "sent": "dbus_message_get_data_APIName return the data, or NULL if not found", "API_info": {"ret_type": "void*", "var_type": ["DBusMessage *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var": ["message", "slot"]}}, {"key": "dbus_message_get_destination", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "sent": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var": ["message"]}}, {"key": "dbus_message_get_destination", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "sent": "dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var": ["message"]}}, {"key": "dbus_message_get_destination", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "sent": "dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var": ["message"]}}, {"key": "dbus_message_get_destination", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "sent": "dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var": ["message"]}}, {"key": "dbus_message_get_error_name", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "sent": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_error_name", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "sent": "dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_error_name", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "sent": "dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_error_name", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "sent": "dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "The interface name is fully-qualified (namespaced).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "Returns NULL if none.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_interface", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "sent": "dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_member", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "sent": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_member", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "sent": "Returns NULL if none.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_member", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "sent": "dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_member", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "sent": "dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_member", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "sent": "dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_no_reply", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "sent": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var": ["message"]}}, {"key": "dbus_message_get_no_reply", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "sent": "dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var": ["message"]}}, {"key": "dbus_message_get_no_reply", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "sent": "dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *"], "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "Returns NULL if none.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "See also dbus_message_get_path_decomposed_APIName .", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "sent": "dbus_message_get_path_APIName return the path (should not be freed) or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\".", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "See also dbus_message_get_path_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_path_decomposed", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "sent": "dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char ***"], "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var": ["message", "path"]}}, {"key": "dbus_message_get_reply_serial", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "sent": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var": ["message"]}}, {"key": "dbus_message_get_reply_serial", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "sent": "dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var": ["message"]}}, {"key": "dbus_message_get_reply_serial", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "sent": "dbus_message_get_reply_serial_APIName return the reply serial", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "The sender is filled in by the dbus_message_get_sender_APIParam_1 bus.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "Connections may own multiple other bus names, but those are not found in the sender field.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_sender", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "sent": "dbus_message_get_sender_APIName return the unique name of the sender or NULL", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "All messages received on a connection will have a serial provided by the remote application.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1.", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "sent": "dbus_message_get_serial_APIName return the serial", "API_info": {"ret_type": "dbus_uint32_t", "var_type": ["DBusMessage *"], "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "the arguments in the dbus_message_get_signature_APIParam_1 payload.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "The signature is a string made up of type codes such as DBUS_TYPE_INT32 .", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ).", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "sent": "dbus_message_get_signature_APIName return the type signature", "API_info": {"ret_type": "const char *", "var_type": ["DBusMessage *"], "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var": ["message"]}}, {"key": "dbus_message_get_type", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "sent": "Gets the type of a dbus_message_get_type_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusMessage *"], "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_get_type", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "sent": "Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type.", "API_info": {"ret_type": "int", "var_type": ["DBusMessage *"], "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_get_type", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "sent": "DBUS_MESSAGE_TYPE_INVALID will never be returned.", "API_info": {"ret_type": "int", "var_type": ["DBusMessage *"], "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_get_type", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "sent": "dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusMessage *"], "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_get_type", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "sent": "dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "API_info": {"ret_type": "int", "var_type": ["DBusMessage *"], "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_has_destination", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "sent": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var": ["message", "name"]}}, {"key": "dbus_message_has_destination", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "sent": "If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var": ["message", "name"]}}, {"key": "dbus_message_has_destination", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "sent": "dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var": ["message", "name"]}}, {"key": "dbus_message_has_destination", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "sent": "dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var": ["message", "name"]}}, {"key": "dbus_message_has_destination", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "sent": "dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var": ["message", "name"]}}, {"key": "dbus_message_has_interface", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "sent": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var": ["message", "iface"]}}, {"key": "dbus_message_has_interface", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "sent": "dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var": ["message", "iface"]}}, {"key": "dbus_message_has_interface", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "sent": "dbus_message_has_interface_APIParam_2 is the interface name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var": ["message", "iface"]}}, {"key": "dbus_message_has_interface", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "sent": "dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var": ["message", "iface"]}}, {"key": "dbus_message_has_member", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "sent": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var": ["message", "member"]}}, {"key": "dbus_message_has_member", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "sent": "dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var": ["message", "member"]}}, {"key": "dbus_message_has_member", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "sent": "dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var": ["message", "member"]}}, {"key": "dbus_message_has_member", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "sent": "dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var": ["message", "member"]}}, {"key": "dbus_message_has_path", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "sent": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var": ["message", "path"]}}, {"key": "dbus_message_has_path", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "sent": "The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var": ["message", "path"]}}, {"key": "dbus_message_has_path", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "sent": "dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var": ["message", "path"]}}, {"key": "dbus_message_has_path", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "sent": "dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var": ["message", "path"]}}, {"key": "dbus_message_has_path", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "sent": "dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var": ["message", "path"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "sent": "dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var": ["message", "name"]}}, {"key": "dbus_message_has_signature", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "sent": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var": ["message", "signature"]}}, {"key": "dbus_message_has_signature", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "sent": "dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var": ["message", "signature"]}}, {"key": "dbus_message_has_signature", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "sent": "dbus_message_has_signature_APIParam_2 is typecode array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var": ["message", "signature"]}}, {"key": "dbus_message_has_signature", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "sent": "dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var": ["message", "signature"]}}, {"key": "dbus_message_is_error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "sent": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var": ["message", "error_name"]}}, {"key": "dbus_message_is_error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "sent": "If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var": ["message", "error_name"]}}, {"key": "dbus_message_is_error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "sent": "dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var": ["message", "error_name"]}}, {"key": "dbus_message_is_error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "sent": "dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var": ["message", "error_name"]}}, {"key": "dbus_message_is_error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "sent": "dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var": ["message", "error_name"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "If the interface field is missing, then it will be assumed equal to the provided interface.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_method_call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "sent": "dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var": ["message", "iface", "method"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_is_signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "sent": "dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var": ["message", "iface", "signal_name"]}}, {"key": "dbus_message_iter_abandon_container", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "sent": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "sent": "Once this returns, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "sent": "This should only be used to abandon creation of a message when you have open containers.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "sent": "dbus_message_iter_abandon_container_APIParam_1 is the append iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "sent": "dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "Once this returns, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_abandon_container_if_open", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "sent": "dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "The basic types are the non-container types such as integer and string.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "So for string, const char**.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "For integer, dbus_int32_t*.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "Hence you may close the descriptor immediately after this call.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_basic_APIParam_1 is the append iterator.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_basic", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *"], "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var": ["iter", "type", "value"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "Appends a block of fixed-length values to an array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "The fixed-length types are all basic types that are not string-like.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "So int32, double, bool, etc.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "(Unix file descriptors however are not supported.)", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "The \"value\" argument should be the address of the array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "So for integer, \"dbus_int32_t**\" is expected for example.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "For strings it works to write const char *array = \"Hello\" and then use &array though.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_append_fixed_array", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const void *", "int"], "desc": "Appends a block of fixed-length values to an array.", "var": ["iter", "element_type", "value", "n_elements"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_close_container_APIParam_1 is the append iterator.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_close_container_APIParam_2 is sub-iterator to close.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_close_container", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_close_container_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_get_arg_type", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "sent": "Returns the argument type of the argument that the message iterator points to.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the argument type of the argument that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_arg_type", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "sent": "If the iterator is at the end of the message, returns DBUS_TYPE_INVALID .", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the argument type of the argument that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_arg_type", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "sent": "You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the argument type of the argument that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_arg_type", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "sent": "dbus_message_iter_get_arg_type_APIName return the argument type", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the argument type of the argument that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "Returns the number of bytes in the array as marshaled in the wire protocol.", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "The iterator must currently be inside an array-typed value.", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid.", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "Why would you want to know how many bytes are in the array as marshaled in the wire protocol?", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "Use dbus_message_iter_get_element_count_APIName instead.", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "dbus_message_iter_get_array_len_APIParam_1 is the iterator.", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_array_len", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "sent": "dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "API_info": {"ret_type": "DBUS_DEPRECATED int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "Basic types are the non-containers such as integer and string.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\".", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "This call duplicates Unix file descriptors when reading them.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "It is your job to close them when you do not need them anymore.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "If you need them without this flag set, make sure to unset it with fcntl_APIName.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.)", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "dbus_message_iter_get_basic_APIParam_1 is the iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_basic", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "sent": "dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *"], "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var": ["iter", "value"]}}, {"key": "dbus_message_iter_get_element_count", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "sent": "Returns the number of elements in the array-typed value pointed to by the iterator.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_count", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "sent": "Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_count", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "sent": "dbus_message_iter_get_element_count_APIParam_1 is the iterator.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_count", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "sent": "dbus_message_iter_get_element_count_APIName return the number of elements in the array", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_type", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "sent": "Returns the element type of the array that the message iterator points to.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the element type of the array that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_type", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "sent": "Note that you need to check that the iterator points to an array prior to using this function.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the element type of the array that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_type", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "sent": "dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the element type of the array that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_element_type", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "sent": "dbus_message_iter_get_element_type_APIName return the array element type", "API_info": {"ret_type": "int", "var_type": ["DBusMessageIter *"], "desc": "Returns the element type of the array that the message iterator points to.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "Reads a block of fixed-length values from the message iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "Fixed-length values are those basic types that are not string-like, such as integers, bool, double.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ).", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "(However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.)", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "dbus_message_iter_get_fixed_array_APIParam_1 is the iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_fixed_array", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "sent": "dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "void *", "int *"], "desc": "Reads a block of fixed-length values from the message iterator.", "var": ["iter", "value", "n_elements"]}}, {"key": "dbus_message_iter_get_signature", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "sent": "Returns the current signature of a message iterator.", "API_info": {"ret_type": "char *", "var_type": ["DBusMessageIter *"], "desc": "Returns the current signature of a message iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_signature", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "sent": "This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value.", "API_info": {"ret_type": "char *", "var_type": ["DBusMessageIter *"], "desc": "Returns the current signature of a message iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_signature", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "sent": "dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName .", "API_info": {"ret_type": "char *", "var_type": ["DBusMessageIter *"], "desc": "Returns the current signature of a message iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_signature", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "sent": "dbus_message_iter_get_signature_APIParam_1 is the message iterator.", "API_info": {"ret_type": "char *", "var_type": ["DBusMessageIter *"], "desc": "Returns the current signature of a message iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_get_signature", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "sent": "dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "API_info": {"ret_type": "char *", "var_type": ["DBusMessageIter *"], "desc": "Returns the current signature of a message iterator.", "var": ["iter"]}}, {"key": "dbus_message_iter_has_next", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "sent": "Checks if an iterator has any more fields.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Checks if an iterator has any more fields.", "var": ["iter"]}}, {"key": "dbus_message_iter_has_next", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "sent": "dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Checks if an iterator has any more fields.", "var": ["iter"]}}, {"key": "dbus_message_iter_has_next", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "sent": "dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Checks if an iterator has any more fields.", "var": ["iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "When possible, dbus_message_get_args_APIName is much more convenient.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "Some types of argument can only be read with DBusMessageIter however.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "sent": "dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init_append", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "sent": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init_append", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "sent": "Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init_append", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "sent": "dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init_append", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "sent": "dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "DBusMessageIter *"], "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var": ["message", "iter"]}}, {"key": "dbus_message_iter_init_closed", "paraph": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED . The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "sent": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *"], "desc": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "var": ["iter"]}}, {"key": "dbus_message_iter_init_closed", "paraph": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED . The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "sent": "The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *"], "desc": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "var": ["iter"]}}, {"key": "dbus_message_iter_next", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "sent": "Moves the iterator to the next field, if any.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Moves the iterator to the next field, if any.", "var": ["iter"]}}, {"key": "dbus_message_iter_next", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "sent": "If there no next field, returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Moves the iterator to the next field, if any.", "var": ["iter"]}}, {"key": "dbus_message_iter_next", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "sent": "If the iterator moves forward, returns TRUE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Moves the iterator to the next field, if any.", "var": ["iter"]}}, {"key": "dbus_message_iter_next", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "sent": "dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Moves the iterator to the next field, if any.", "var": ["iter"]}}, {"key": "dbus_message_iter_next", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "sent": "dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *"], "desc": "Moves the iterator to the next field, if any.", "var": ["iter"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "Appends a container-typed value to the message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "Container types are for example struct, variant, and array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_open_container_APIParam_1 is the append iterator.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_open_container", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "sent": "dbus_message_iter_open_container_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"], "desc": "Appends a container-typed value to the message.", "var": ["iter", "type", "contained_signature", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "Note that this recurses into a value, not a type, so you can only recurse if the value exists.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "There no array of int32 to recurse into.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "dbus_message_iter_recurse_APIParam_1 is the message iterator.", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_iter_recurse", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "sent": "dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "API_info": {"ret_type": "void", "var_type": ["DBusMessageIter *", "DBusMessageIter *"], "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var": ["iter", "sub"]}}, {"key": "dbus_message_lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "sent": "Locks a dbus_message_lock_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Locks a dbus_message_lock_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "sent": "Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Locks a dbus_message_lock_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "sent": "Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Locks a dbus_message_lock_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "sent": "dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Locks a dbus_message_lock_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "sent": "dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Locks a dbus_message_lock_APIParam_1.", "var": ["message"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "dbus_message_marshal_APIParam_1 is the DBusMessage.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "dbus_message_marshal_APIParam_2 is the location to save the marshalled form to.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_marshal", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "sent": "dbus_message_marshal_APIName return FALSE if there was not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "char **", "int *"], "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var": ["msg", "marshalled_data_p", "len_p"]}}, {"key": "dbus_message_new", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "sent": "Constructs a new message of the given message type.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["int"], "desc": "Constructs a new message of the given message type.", "var": ["message_type"]}}, {"key": "dbus_message_new", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "sent": "Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["int"], "desc": "Constructs a new message of the given message type.", "var": ["message_type"]}}, {"key": "dbus_message_new", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "sent": "Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["int"], "desc": "Constructs a new message of the given message type.", "var": ["message_type"]}}, {"key": "dbus_message_new", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "sent": "dbus_message_new_APIParam_1 is type of message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["int"], "desc": "Constructs a new message of the given message type.", "var": ["message_type"]}}, {"key": "dbus_message_new", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "sent": "dbus_message_new_APIName return new message or NULL if no memory", "API_info": {"ret_type": "DBusMessage *", "var_type": ["int"], "desc": "Constructs a new message of the given message type.", "var": ["message_type"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "Creates a new message that is an error reply to another message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "Error replies are most common in response to method calls, but can be returned in reply to any message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "The error name must be a valid error name according to the syntax given in the D-Bus specification.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "If you do not want to make up an error name just use DBUS_ERROR_FAILED .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "dbus_message_new_error_APIParam_1 is the message we're replying to.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "dbus_message_new_error_APIParam_2 is the error name.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message).", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "sent": "dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *"], "desc": "Creates a new message that is an error reply to another message.", "var": ["reply_to", "error_name", "error_message"]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "dbus_message_new_error_printf_APIParam_2 is the error name.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_error_printf", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "sent": "dbus_message_new_error_printf_APIName return a new error message", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "], "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var": ["reply_to", "error_name", "error_format", " ... "]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Returns NULL if memory can not be allocated for the message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus).", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification).", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_call_APIParam_3 is interface to invoke.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_call", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *", "const char *"], "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var": ["destination", "path", "iface", "method"]}}, {"key": "dbus_message_new_method_return", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Constructs a message that is a reply to a method call.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Constructs a message that is a reply to a method call.", "var": ["method_call"]}}, {"key": "dbus_message_new_method_return", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Returns NULL if memory can not be allocated for the message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Constructs a message that is a reply to a method call.", "var": ["method_call"]}}, {"key": "dbus_message_new_method_return", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_return_APIParam_1 is the message being replied to.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Constructs a message that is a reply to a method call.", "var": ["method_call"]}}, {"key": "dbus_message_new_method_return", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Constructs a message that is a reply to a method call.", "var": ["method_call"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Constructs a new message representing a signal emission.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Returns NULL if memory can not be allocated for the message.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields).", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_new_signal", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "sent": "dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "API_info": {"ret_type": "DBusMessage *", "var_type": ["const char *", "const char *", "const char *"], "desc": "Constructs a new message representing a signal emission.", "var": ["path", "iface", "name"]}}, {"key": "dbus_message_ref", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "sent": "Increments the reference count of a DBusMessage .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Increments the reference count of a DBusMessage .", "var": ["message"]}}, {"key": "dbus_message_ref", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "sent": "dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Increments the reference count of a DBusMessage .", "var": ["message"]}}, {"key": "dbus_message_ref", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "sent": "dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusMessage *"], "desc": "Increments the reference count of a DBusMessage .", "var": ["message"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION .", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_allow_interactive_authorization", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "sent": "dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var": ["message", "allow"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "In case of failure, the reply will be an error.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "The flag is set to TRUE by default, i.e.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "auto starting is the default.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_auto_start", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "sent": "dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var": ["message", "auto_start"]}}, {"key": "dbus_message_set_container_instance", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "sent": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_container_instance", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "sent": "The path must contain only valid characters for an object path as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_container_instance", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "sent": "dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_container_instance", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "sent": "dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_container_instance", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "sent": "dbus_message_set_container_instance_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_data", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "sent": "dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var": ["message", "slot", "data", "free_data_func"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "Sets the message dbus_message_set_destination_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_destination", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "sent": "dbus_message_set_destination_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var": ["message", "destination"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "The name is fully-qualified (namespaced).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "The error name must contain only valid characters as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "dbus_message_set_error_name_APIParam_2 is the name or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_error_name", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "sent": "dbus_message_set_error_name_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var": ["message", "error_name"]}}, {"key": "dbus_message_set_interface", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "sent": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "iface"]}}, {"key": "dbus_message_set_interface", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "sent": "The interface name must contain only valid characters as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "iface"]}}, {"key": "dbus_message_set_interface", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "sent": "dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "iface"]}}, {"key": "dbus_message_set_interface", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "sent": "dbus_message_set_interface_APIParam_2 is the interface or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "iface"]}}, {"key": "dbus_message_set_interface", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "sent": "dbus_message_set_interface_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "iface"]}}, {"key": "dbus_message_set_member", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "sent": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "member"]}}, {"key": "dbus_message_set_member", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "sent": "The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "member"]}}, {"key": "dbus_message_set_member", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "sent": "dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "member"]}}, {"key": "dbus_message_set_member", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "sent": "dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "member"]}}, {"key": "dbus_message_set_member", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "sent": "dbus_message_set_member_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "member"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "The flag is FALSE by default, that is by default the other end is required to reply.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_no_reply", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "sent": "dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_bool_t"], "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var": ["message", "no_reply"]}}, {"key": "dbus_message_set_path", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "sent": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_path", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "sent": "The path must contain only valid characters as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_path", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "sent": "dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_path", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "sent": "dbus_message_set_path_APIParam_2 is the path or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_path", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "sent": "dbus_message_set_path_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var": ["message", "object_path"]}}, {"key": "dbus_message_set_reply_serial", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "sent": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var": ["message", "reply_serial"]}}, {"key": "dbus_message_set_reply_serial", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "sent": "dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var": ["message", "reply_serial"]}}, {"key": "dbus_message_set_reply_serial", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "sent": "dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var": ["message", "reply_serial"]}}, {"key": "dbus_message_set_reply_serial", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "sent": "dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var": ["message", "reply_serial"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "Usually you do not want to call this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_sender", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "sent": "dbus_message_set_sender_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusMessage *", "const char *"], "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var": ["message", "sender"]}}, {"key": "dbus_message_set_serial", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "sent": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var": ["message", "serial"]}}, {"key": "dbus_message_set_serial", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "sent": "This can only be done once on a dbus_message_set_serial_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var": ["message", "serial"]}}, {"key": "dbus_message_set_serial", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "sent": "DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection .", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var": ["message", "serial"]}}, {"key": "dbus_message_set_serial", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "sent": "dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var": ["message", "serial"]}}, {"key": "dbus_message_set_serial", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "sent": "dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *", "dbus_uint32_t"], "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var": ["message", "serial"]}}, {"key": "dbus_message_type_from_string", "paraph": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "sent": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "API_info": {"ret_type": "int", "var_type": ["const char *"], "desc": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "var": ["type_str"]}}, {"key": "dbus_message_type_to_string", "paraph": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "sent": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "API_info": {"ret_type": "const char*", "var_type": ["int"], "desc": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "var": ["type"]}}, {"key": "dbus_message_unref", "paraph": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "sent": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "API_info": {"ret_type": "void", "var_type": ["DBusMessage *"], "desc": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "var": ["message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_set_error_from_message", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "sent": "dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusError *", "DBusMessage *"], "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var": ["error", "message"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "Returns the current type pointed to by the iterator.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "If the iterator is pointing at a type code such as ', then the iterator will be returned directly.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "DBUS_TYPE_STRUCT, not '('.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "dbus_signature_iter_get_current_type_APIName return current type (e.g.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_current_type", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "sent": "DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the current type pointed to by the iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_element_type", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "sent": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_element_type", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "sent": "Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY .", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_element_type", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "sent": "dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator.", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_element_type", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "sent": "dbus_signature_iter_get_element_type_APIName return current array element type", "API_info": {"ret_type": "int", "var_type": ["const DBusSignatureIter *"], "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "Returns the signature of the single complete type starting at the given iterator.", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned.", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned.", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator.", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory.", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_get_signature", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "sent": "Should be freed with dbus_free_APIName", "API_info": {"ret_type": "char *", "var_type": ["const DBusSignatureIter *"], "desc": "Returns the signature of the single complete type starting at the given iterator.", "var": ["iter"]}}, {"key": "dbus_signature_iter_init", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "sent": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusSignatureIter *", "const char *"], "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var": ["iter", "signature"]}}, {"key": "dbus_signature_iter_init", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "sent": "dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function.", "API_info": {"ret_type": "void", "var_type": ["DBusSignatureIter *", "const char *"], "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var": ["iter", "signature"]}}, {"key": "dbus_signature_iter_init", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "sent": "dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize.", "API_info": {"ret_type": "void", "var_type": ["DBusSignatureIter *", "const char *"], "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var": ["iter", "signature"]}}, {"key": "dbus_signature_iter_init", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "sent": "dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "API_info": {"ret_type": "void", "var_type": ["DBusSignatureIter *", "const char *"], "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var": ["iter", "signature"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "Skip to the next value on this \"level\".", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "e.g.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "the next field in a struct, the next value in an array.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "Returns FALSE at the end of the current container.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "dbus_signature_iter_next_APIParam_1 is the iterator.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_next", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "sent": "dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusSignatureIter *"], "desc": "Skip to the next value on this \"level\".", "var": ["iter"]}}, {"key": "dbus_signature_iter_recurse", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "sent": "Initialize a new iterator pointing to the first type in the current container.", "API_info": {"ret_type": "void", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"], "desc": "Initialize a new iterator pointing to the first type in the current container.", "var": ["iter", "subiter"]}}, {"key": "dbus_signature_iter_recurse", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "sent": "The results are undefined when calling this if the current type is a non-container (i.e.", "API_info": {"ret_type": "void", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"], "desc": "Initialize a new iterator pointing to the first type in the current container.", "var": ["iter", "subiter"]}}, {"key": "dbus_signature_iter_recurse", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "sent": "if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ).", "API_info": {"ret_type": "void", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"], "desc": "Initialize a new iterator pointing to the first type in the current container.", "var": ["iter", "subiter"]}}, {"key": "dbus_signature_iter_recurse", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "sent": "dbus_signature_iter_recurse_APIParam_1 is the current interator.", "API_info": {"ret_type": "void", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"], "desc": "Initialize a new iterator pointing to the first type in the current container.", "var": ["iter", "subiter"]}}, {"key": "dbus_signature_iter_recurse", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "sent": "dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "API_info": {"ret_type": "void", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"], "desc": "Initialize a new iterator pointing to the first type in the current container.", "var": ["iter", "subiter"]}}, {"key": "dbus_signature_validate", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "sent": "Check a type dbus_signature_validate_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "sent": "Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "sent": "dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "sent": "dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "sent": "dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "\"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "More than one complete type would mean for example \"ii\" or two integers in sequence.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_signature_validate_single", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "sent": "dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var": ["signature", "error"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "So all numbers and strings are basic types and structs, arrays, and variants are not basic types.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "DBUS_TYPE_INVALID is not a basic type.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "sent": "dbus_type_is_basic_APIName return TRUE if type is basic", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "A \"container type\" can contain basic types, or nested container types.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "DBUS_TYPE_INVALID is not a container type.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "sent": "dbus_type_is_container_APIName return TRUE if type is a container", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "A \"container type\" can contain basic types, or nested container types.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "Tells you whether values of this type can change length if you set them to some other value.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_fixed", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "sent": "dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var": ["typecode"]}}, {"key": "dbus_type_is_valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "sent": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var": ["typecode"]}}, {"key": "dbus_type_is_valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "sent": "DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var": ["typecode"]}}, {"key": "dbus_type_is_valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "sent": "dbus_type_is_valid_APIName is safe with untrusted data.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var": ["typecode"]}}, {"key": "dbus_type_is_valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "sent": "dbus_type_is_valid_APIParam_1 is a potential type-code.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var": ["typecode"]}}, {"key": "dbus_type_is_valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "sent": "dbus_type_is_valid_APIName return TRUE if valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["int"], "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var": ["typecode"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "The slot must be initialized with -1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "The allocated slot is global, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "all DBusServer objects will have a slot with the given integer ID reserved.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "sent": "dbus_server_allocate_data_slot_APIName return FALSE on no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var": ["slot_p"]}}, {"key": "dbus_server_disconnect", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "sent": "Releases the server address and stops listening for new clients.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Releases the server address and stops listening for new clients.", "var": ["server"]}}, {"key": "dbus_server_disconnect", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "sent": "If called more than once, only the first call has an effect.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Releases the server address and stops listening for new clients.", "var": ["server"]}}, {"key": "dbus_server_disconnect", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "sent": "Does not modify the server reference count.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Releases the server address and stops listening for new clients.", "var": ["server"]}}, {"key": "dbus_server_disconnect", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "sent": "dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Releases the server address and stops listening for new clients.", "var": ["server"]}}, {"key": "dbus_server_free_data_slot", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "sent": "Deallocates a global ID for server data slots.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for server data slots.", "var": ["slot_p"]}}, {"key": "dbus_server_free_data_slot", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "sent": "dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for server data slots.", "var": ["slot_p"]}}, {"key": "dbus_server_free_data_slot", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "sent": "Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for server data slots.", "var": ["slot_p"]}}, {"key": "dbus_server_free_data_slot", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "sent": "dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for server data slots.", "var": ["slot_p"]}}, {"key": "dbus_server_get_address", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "sent": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_address", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "sent": "dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_address", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "sent": "dbus_server_get_address_APIName return the address or NULL if no memory", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_data", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "sent": "Retrieves data previously set with dbus_server_set_data_APIName .", "API_info": {"ret_type": "void *", "var_type": ["DBusServer *", "int"], "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var": ["server", "slot"]}}, {"key": "dbus_server_get_data", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "sent": "The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed).", "API_info": {"ret_type": "void *", "var_type": ["DBusServer *", "int"], "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var": ["server", "slot"]}}, {"key": "dbus_server_get_data", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "sent": "dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1.", "API_info": {"ret_type": "void *", "var_type": ["DBusServer *", "int"], "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var": ["server", "slot"]}}, {"key": "dbus_server_get_data", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "sent": "dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from.", "API_info": {"ret_type": "void *", "var_type": ["DBusServer *", "int"], "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var": ["server", "slot"]}}, {"key": "dbus_server_get_data", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "sent": "dbus_server_get_data_APIName return the data, or NULL if not found", "API_info": {"ret_type": "void *", "var_type": ["DBusServer *", "int"], "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var": ["server", "slot"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases).", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "This is an ID unique to each DBusServer .", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "Remember that a DBusServer represents only one mode of connecting, so e.g.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_id", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "sent": "dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "API_info": {"ret_type": "char *", "var_type": ["DBusServer *"], "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var": ["server"]}}, {"key": "dbus_server_get_is_connected", "paraph": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections. dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "sent": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *"], "desc": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "var": ["server"]}}, {"key": "dbus_server_get_is_connected", "paraph": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections. dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "sent": "dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *"], "desc": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "var": ["server"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "Otherwise returns a new DBusServer .", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName .", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "dbus_server_listen_APIParam_2 is location to store reason for failure.", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_listen", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "sent": "dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "API_info": {"ret_type": "DBusServer *", "var_type": ["const char *", "DBusError *"], "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_server_ref", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "sent": "Increments the reference count of a DBusServer .", "API_info": {"ret_type": "DBusServer *", "var_type": ["DBusServer *"], "desc": "Increments the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_ref", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "sent": "dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1.", "API_info": {"ret_type": "DBusServer *", "var_type": ["DBusServer *"], "desc": "Increments the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_ref", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "sent": "dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "API_info": {"ret_type": "DBusServer *", "var_type": ["DBusServer *"], "desc": "Increments the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_auth_mechanisms", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "sent": "dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "const char **"], "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var": ["server", "mechanisms"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_data", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "sent": "dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var": ["server", "slot", "data", "free_data_func"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "Otherwise, the connection will be unreferenced and closed.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "i.e.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_new_connection_function", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "sent": "dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"], "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var": ["server", "function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "These functions are responsible for making the application main loop aware of timeouts.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_set_watch_functions", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_server_unref", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "sent": "Decrements the reference count of a DBusServer .", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Decrements the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_unref", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "sent": "Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Decrements the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_unref", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "sent": "The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero.", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Decrements the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_server_unref", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "sent": "dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "API_info": {"ret_type": "void", "var_type": ["DBusServer *"], "desc": "Decrements the reference count of a DBusServer .", "var": ["server"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_bus_name", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "sent": "dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "dbus_validate_error_name_APIParam_1 is a potentially invalid.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_error_name", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "sent": "dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_interface", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "sent": "dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_member", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "sent": "dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var": ["name", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "Check an object dbus_validate_path_APIParam_1 for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_path", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "sent": "dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var": ["path", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "Check a string for validity.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "Strings on D-Bus must be valid UTF-8.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_validate_utf8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "sent": "dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusError *"], "desc": "Check a string for validity.", "var": ["alleged_utf8", "error"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "Adds a message filter.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "Filters are run in the order that they were added.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "The same handler can be added as a filter more than once, in which case it will be run more than once.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "Filters added during a filter callback will not be run on the message being processed.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "This is probably a feature, as filters could create arbitrary reentrancy.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "But kind of sucks if you are trying to filter METHOD_RETURN for some reason.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_add_filter", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "sent": "dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"], "desc": "Adds a message filter.", "var": ["connection", "function", "user_data", "free_data_function"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "The allocated slot is global, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "all DBusConnection objects will have a slot with the given integer ID reserved.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_allocate_data_slot", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "sent": "dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["dbus_int32_t *"], "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var": ["slot_p"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "If the queue is empty, returns NULL .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "If you need to keep the message, make a copy of it.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_borrow_message", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "sent": "dbus_connection_borrow_message_APIName return next message in the incoming queue", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var": ["connection"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "it will return FALSE for all types this implementation does not know, including invalid or reserved types.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_can_send_type", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "sent": "dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var": ["connection", "type"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "dbus_connection_close_APIName does not affect the connection reference count.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "You may not close a shared dbus_connection_close_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "These connections are owned by libdbus, and applications should only unref them, never close them.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "sent": "dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Processes any incoming data.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket).", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName .", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Processing has three steps.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Second, any filters registered with dbus_connection_add_filter_APIName are run.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "calling dbus_connection_dispatch_APIName recursively.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_dispatch", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "sent": "dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Processes any incoming data.", "var": ["connection"]}}, {"key": "dbus_connection_flush", "paraph": "Blocks until the outgoing message queue is empty. dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "sent": "Blocks until the outgoing message queue is empty.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Blocks until the outgoing message queue is empty.", "var": ["connection"]}}, {"key": "dbus_connection_flush", "paraph": "Blocks until the outgoing message queue is empty. dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "sent": "dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Blocks until the outgoing message queue is empty.", "var": ["connection"]}}, {"key": "dbus_connection_free_data_slot", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Deallocates a global ID for connection data slots.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for connection data slots.", "var": ["slot_p"]}}, {"key": "dbus_connection_free_data_slot", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot.", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for connection data slots.", "var": ["slot_p"]}}, {"key": "dbus_connection_free_data_slot", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for connection data slots.", "var": ["slot_p"]}}, {"key": "dbus_connection_free_data_slot", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "API_info": {"ret_type": "void", "var_type": ["dbus_int32_t *"], "desc": "Deallocates a global ID for connection data slots.", "var": ["slot_p"]}}, {"key": "dbus_connection_free_preallocated_send", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "sent": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"], "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var": ["connection", "preallocated"]}}, {"key": "dbus_connection_free_preallocated_send", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "sent": "Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"], "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var": ["connection", "preallocated"]}}, {"key": "dbus_connection_free_preallocated_send", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "sent": "dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"], "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var": ["connection", "preallocated"]}}, {"key": "dbus_connection_free_preallocated_send", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "sent": "dbus_connection_free_preallocated_send_APIParam_2 is the resources", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"], "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var": ["connection", "preallocated"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_adt_audit_session_data", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "sent": "dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"], "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var": ["connection", "data", "data_size"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "Retrieves data previously set with dbus_connection_set_data_APIName .", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed).", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions.", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "(See the note in docs for dbus_connection_set_watch_functions_APIName .)", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName .", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1.", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from.", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_data", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "sent": "dbus_connection_get_data_APIName return the data, or NULL if not found", "API_info": {"ret_type": "void *", "var_type": ["DBusConnection *", "dbus_int32_t"], "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var": ["connection", "slot"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "Gets the current state of the incoming message queue.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName .", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "When these bytes are parsed, they may not add up to an entire message.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1.", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_dispatch_status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "sent": "dbus_connection_get_dispatch_status_APIName return current dispatch status", "API_info": {"ret_type": "DBusDispatchStatus", "var_type": ["DBusConnection *"], "desc": "Gets the current state of the incoming message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "If it is authenticated as a specific user, then this returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "(Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .)", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "only allow the ANONYMOUS mechanism).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "sent": "dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_authenticated", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "sent": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_authenticated", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "sent": "(Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_authenticated", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "sent": "dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_is_connected", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "sent": "dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_size", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "sent": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_size", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "sent": "dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_size", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "sent": "dbus_connection_get_max_message_size_APIName return the max size of a single message", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "sent": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "sent": "dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_message_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "sent": "dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_size", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "sent": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_size", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "sent": "dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_size", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "sent": "dbus_connection_get_max_received_size_APIName return the max size of all live messages", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "sent": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "sent": "dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_max_received_unix_fds", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "sent": "dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var": ["connection"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_object_path_data", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "sent": "dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "void **"], "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var": ["connection", "path", "data_p"]}}, {"key": "dbus_connection_get_outgoing_size", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "sent": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_size", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "sent": "The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_size", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "sent": "dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_size", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "sent": "dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_unix_fds", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "sent": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_unix_fds", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "sent": "dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1.", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_outgoing_unix_fds", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "sent": "dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "API_info": {"ret_type": "long", "var_type": ["DBusConnection *"], "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "The only way to be sure the server ID is available is to wait for authentication to complete.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "In general, each mode of connecting to a given server will have its own ID.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus).", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "The D-Bus specification describes the server ID and other IDs in a bit more detail.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_server_id", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "sent": "dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *"], "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var": ["connection"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "Not all connections will have a socket.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_socket_APIName always returns specifically a socket file descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_socket_APIParam_2 is return location for the file descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_socket", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "This can be used for SELinux access control checks with getpeercon_APIName for example.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "Not all connections will have a file descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_unix_fd_APIName always fails on Windows.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_fd", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "sent": "dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int *"], "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var": ["connection", "fd"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_process_id", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "sent": "dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var": ["connection", "pid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "The message bus is a server and the apps connecting to the bus are clients.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "dbus_connection_get_unix_user_APIParam_2 is return location for the user ID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_unix_user", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "sent": "dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "unsigned long *"], "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var": ["connection", "uid"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "Returns TRUE if the ID is filled in.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "The message bus is a server and the apps connecting to the bus are clients.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\"", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_get_windows_user", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "sent": "dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "char **"], "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var": ["connection", "windows_sid_p"]}}, {"key": "dbus_connection_has_messages_to_send", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "sent": "Checks whether there are messages in the outgoing message queue.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Checks whether there are messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_has_messages_to_send", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "sent": "Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Checks whether there are messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_has_messages_to_send", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "sent": "dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Checks whether there are messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_has_messages_to_send", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "sent": "dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *"], "desc": "Checks whether there are messages in the outgoing message queue.", "var": ["connection"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_list_registered", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "sent": "dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "char ***"], "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var": ["connection", "parent_path", "child_entries"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName .", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Because this connection is shared, no user of the connection may call dbus_connection_close_APIName .", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "However, when you are done with the connection you should call dbus_connection_unref_APIName .", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_APIName return new connection, or NULL on failure", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "Unlike dbus_connection_open_APIName , always creates a new connection.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "This connection will not be saved or recycled by libdbus.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "(The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.)", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_open_private", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "sent": "dbus_connection_open_private_APIName return new connection, or NULL on failure", "API_info": {"ret_type": "DBusConnection *", "var_type": ["const char *", "DBusError *"], "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var": ["address", "error"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "Returns the first-received message from the incoming message queue, removing it from the queue.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "The caller owns a reference to dbus_connection_pop_message_APIParam_0.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "If the queue is empty, returns NULL .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "Instead, let the main loop invoke dbus_connection_dispatch_APIName .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "will all block while one of the others in the group is running.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_pop_message", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "sent": "dbus_connection_pop_message_APIName return next message in the incoming queue", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *"], "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var": ["connection"]}}, {"key": "dbus_connection_preallocate_send", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "sent": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "API_info": {"ret_type": "DBusPreallocatedSend *", "var_type": ["DBusConnection *"], "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var": ["connection"]}}, {"key": "dbus_connection_preallocate_send", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "sent": "Allows apps to create a future guarantee that they can send a message regardless of memory shortages.", "API_info": {"ret_type": "DBusPreallocatedSend *", "var_type": ["DBusConnection *"], "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var": ["connection"]}}, {"key": "dbus_connection_preallocate_send", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "sent": "dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for.", "API_info": {"ret_type": "DBusPreallocatedSend *", "var_type": ["DBusConnection *"], "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var": ["connection"]}}, {"key": "dbus_connection_preallocate_send", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "sent": "dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "API_info": {"ret_type": "DBusPreallocatedSend *", "var_type": ["DBusConnection *"], "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var": ["connection"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "See also dbus_connection_read_write_dispatch_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "The return value indicates whether reading or writing is still possible, i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "whether the dbus_connection_read_write_APIParam_1 is connected.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "Note that even after disconnection, messages may remain in the incoming queue that need to be processed.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "sent": "dbus_connection_read_write_APIName return TRUE if still connected", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "This is important because even after disconnecting, you want to process any messages you received prior to the disconnect.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_read_write_dispatch", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "sent": "dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "int"], "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var": ["connection", "timeout_milliseconds"]}}, {"key": "dbus_connection_ref", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "sent": "Increments the reference count of a DBusConnection .", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusConnection *"], "desc": "Increments the reference count of a DBusConnection .", "var": ["connection"]}}, {"key": "dbus_connection_ref", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "sent": "dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusConnection *"], "desc": "Increments the reference count of a DBusConnection .", "var": ["connection"]}}, {"key": "dbus_connection_ref", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "sent": "dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusConnection *"], "desc": "Increments the reference count of a DBusConnection .", "var": ["connection"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "Registers a fallback handler for a given subsection of the object hierarchy.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "You can use this to establish a default message handling policy for a whole \"subdirectory.\"", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "Use dbus_connection_try_register_fallback_APIName if this might be the case.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "dbus_connection_register_fallback_APIParam_3 is the virtual table.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "sent": "dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "Use dbus_connection_try_register_object_path_APIName if this might be the case.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "dbus_connection_register_object_path_APIParam_3 is the virtual table.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_register_object_path", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "sent": "dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"], "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "Removes a previously-added message filter.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance).", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "dbus_connection_remove_filter_APIParam_2 is the handler to remove.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_remove_filter", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "sent": "dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"], "desc": "Removes a previously-added message filter.", "var": ["connection", "function", "user_data"]}}, {"key": "dbus_connection_return_message", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_return_message", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_return_message", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_return_message", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "If the function fails due to lack of memory, it returns FALSE .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "sent": "dbus_connection_send_APIName return TRUE on success", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var": ["connection", "message", "serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIName cannot fail.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "It works identically to dbus_connection_send_APIName in other respects.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "Preallocated resources comes from dbus_connection_preallocate_send_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_preallocated", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "sent": "dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"], "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var": ["connection", "preallocated", "message", "client_serial"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "See dbus_connection_dispatch_APIName for details on when handlers are run.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "If -1 is passed for the timeout, a sane default timeout is used.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "-1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "sent": "dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"], "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var": ["connection", "message", "pending_return", "timeout_milliseconds"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "messages other than the reply are queued up but not processed.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED .", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "This means you can end up deadlocked if the application you are talking to needs you to reply to a method.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2.", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_send_with_reply_and_block", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "sent": "dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "API_info": {"ret_type": "DBusMessage *", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"], "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var": ["connection", "message", "timeout_milliseconds", "error"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "clients can connect anonymously.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ).", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "If anonymous connections are allowed, however, then any user identity is allowed.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_allow_anonymous", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "sent": "dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_change_sigpipe", "paraph": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN. dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "sent": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN.", "API_info": {"ret_type": "void", "var_type": ["dbus_bool_t"], "desc": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN.", "var": ["will_modify_sigpipe"]}}, {"key": "dbus_connection_set_change_sigpipe", "paraph": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN. dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "sent": "dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "API_info": {"ret_type": "void", "var_type": ["dbus_bool_t"], "desc": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN.", "var": ["will_modify_sigpipe"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "(See the note in docs for dbus_connection_set_watch_functions_APIName .)", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_data", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "sent": "dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"], "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var": ["connection", "slot", "data", "free_data_func"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_dispatch_status_function", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "sent": "dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"], "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_exit_on_disconnect", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "sent": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var": ["connection", "exit_on_disconnect"]}}, {"key": "dbus_connection_set_exit_on_disconnect", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "sent": "The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var": ["connection", "exit_on_disconnect"]}}, {"key": "dbus_connection_set_exit_on_disconnect", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "sent": "By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var": ["connection", "exit_on_disconnect"]}}, {"key": "dbus_connection_set_exit_on_disconnect", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "sent": "dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var": ["connection", "exit_on_disconnect"]}}, {"key": "dbus_connection_set_exit_on_disconnect", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "sent": "dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var": ["connection", "exit_on_disconnect"]}}, {"key": "dbus_connection_set_max_message_size", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "sent": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_message_size", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "sent": "Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_message_size", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "sent": "dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_message_size", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "sent": "dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_message_unix_fds", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "sent": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_message_unix_fds", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "sent": "Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_message_unix_fds", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "sent": "co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "Messages count toward the maximum until they are finalized.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "The semantics are not: if the next message would cause us to exceed the maximum, we do not read it.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "But this should be inconsequential.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_size", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "sent": "dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var": ["connection", "size"]}}, {"key": "dbus_connection_set_max_received_unix_fds", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "sent": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_received_unix_fds", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "sent": "Messages count toward the maximum until they are finalized.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_received_unix_fds", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "sent": "When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_received_unix_fds", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "sent": "The semantics are analogous to those of dbus_connection_set_max_received_size_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_max_received_unix_fds", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "sent": "co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "long"], "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var": ["connection", "n"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "However, the message bus wants to be able to route methods on that interface through the bus and to other applications.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "If a normal application sets this flag, it can break things badly.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "So do not set this unless you are the message bus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_route_peer_messages", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "sent": "dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "dbus_bool_t"], "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var": ["connection", "value"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "These functions are responsible for making the application main loop aware of timeouts.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "When using Qt, typically the DBusAddTimeoutFunction would create a QTimer.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "When using GLib, the DBusAddTimeoutFunction would call g_timeout_add.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "Call dbus_timeout_get_enabled_APIName to check this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "A disabled timeout should have no effect, and enabled timeout should be added to the main loop.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "Whenever a timeout is toggled, its interval may change.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "The timer interval may change whenever the timeout is added, removed, or toggled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_timeout_functions", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "Also, root is always allowed to connect.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "dbus_connection_set_unix_user_function_APIParam_2 is the predicate.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_unix_user_function", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "sent": "dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "a message has been queued for writing).", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "When using GLib, it would call g_main_context_wakeup_APIName.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_wakeup_main_function", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "sent": "dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"], "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var": ["connection", "wakeup_main_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Note that when a watch is added, it may not be enabled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Call dbus_watch_get_enabled_APIName to check this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "A disabled watch should have no effect, and enabled watch should be added to the main loop.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_watch_functions", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "sent": "dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"], "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "dbus_connection_set_windows_user_function_APIParam_2 is the predicate.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_set_windows_user_function", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "sent": "dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"], "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var": ["connection", "function", "data", "free_data_function"]}}, {"key": "dbus_connection_steal_borrowed_message", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_steal_borrowed_message", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_steal_borrowed_message", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_steal_borrowed_message", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "sent": "dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "DBusMessage *"], "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var": ["connection", "message"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "Registers a fallback handler for a given subsection of the object hierarchy.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "You can use this to establish a default message handling policy for a whole \"subdirectory.\"", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIParam_3 is the virtual table.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_fallback", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIParam_3 is the virtual table.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_try_register_object_path", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "sent": "dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"], "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var": ["connection", "path", "vtable", "user_data", "error"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "Most connections are shared.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unref", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "sent": "dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *"], "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var": ["connection"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "Can unregister both fallback paths and object paths.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_connection_unregister_object_path", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "sent": "dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var": ["connection", "path"]}}, {"key": "dbus_threads_init", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "sent": "Initializes threads, like dbus_threads_init_default_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusThreadFunctions *"], "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var": ["functions"]}}, {"key": "dbus_threads_init", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "sent": "This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusThreadFunctions *"], "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var": ["functions"]}}, {"key": "dbus_threads_init", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "sent": "dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusThreadFunctions *"], "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var": ["functions"]}}, {"key": "dbus_threads_init", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "sent": "dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const DBusThreadFunctions *"], "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var": ["functions"]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "Initializes threads.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "If it is called, D-Bus will do locking, at some cost in efficiency.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used).", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_threads_init_default", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "sent": "Returns TRUE on success, FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": [" void "], "desc": "Initializes threads.", "var": [" void "]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "The AddMatch method is fully documented in the D-Bus specification.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Rules are specified as a string of comma separated key/value pairs.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.).", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "It is important to note this because every time a message is received the application will be paged into memory to process it.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "This can cause performance problems such as draining batteries on embedded platforms.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "If you match message args ('arg0', 'arg1', and so forth) only string arguments will match.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "That is, arg0='5' means match the string \"5\" not the integer 5.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Currently there is no way to match against non-string arguments.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "A specialised form of wildcard matching on arguments is supported for path-like namespaces.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Matching on interface is tricky because method call messages only optionally specify the interface.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "This means match rules on method calls should not usually give an interface.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_add_match", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_add_match_APIParam_3 is location to store any errors", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "Connects to a bus daemon and registers the client with it.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "The caller of dbus_bus_get_APIName owns a reference to the bus.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "dbus_bus_get_APIName calls dbus_bus_register_APIName for you.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "sent": "dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it.", "var": ["type", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "For the session bus, this is useful as a way to uniquely identify each user session.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example).", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "See dbus_try_get_local_machine_id_APIName .", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2.", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_id", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "sent": "dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "API_info": {"ret_type": "char *", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var": ["connection", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "Unlike dbus_bus_get_APIName , always creates a new connection.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "This connection will not be saved or recycled by libdbus.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "See dbus_connection_open_private_APIName for more details on when to close and unref this connection.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIName will block until authentication and bus registration are complete.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned.", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_private", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "sent": "dbus_bus_get_private_APIName return a DBusConnection with new ref", "API_info": {"ret_type": "DBusConnection *", "var_type": ["DBusBusType", "DBusError *"], "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var": ["type", "error"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus.", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered.", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller.", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName .", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName .", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unique_name", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "sent": "dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "API_info": {"ret_type": "const char *", "var_type": ["DBusConnection *"], "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var": ["connection"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "Only works on UNIX; only works for connections on the same machine as the bus.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default).", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "So check for errors and do something sensible if they happen.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3.", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_get_unix_user", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "sent": "dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "API_info": {"ret_type": "unsigned long", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "Using this can easily result in a race condition, since an owner can appear or disappear after you call this.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "dbus_bus_name_has_owner_APIParam_3 is location to store any errors.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_name_has_owner", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "sent": "dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "Registers a dbus_bus_register_APIParam_1 with the bus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "This must be the first thing an application does when connecting to the message bus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "dbus_bus_register_APIName will block until registration is complete.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "dbus_bus_register_APIParam_2 is place to store errors.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_register", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "sent": "dbus_bus_register_APIName return TRUE on success", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "DBusError *"], "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var": ["connection", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "The \"ReleaseName\" method is canonically documented in the D-Bus specification.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_release_name", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "sent": "dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var": ["connection", "name", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "See detailed explanation in docs for dbus_bus_add_match_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_remove_match", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "sent": "dbus_bus_remove_match_APIParam_3 is location to store any errors", "API_info": {"ret_type": "void", "var_type": ["DBusConnection *", "const char *", "DBusError *"], "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var": ["connection", "rule", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "This method is fully documented in the D-Bus specification.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Only one owns it at a time - called the primary owner.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name).", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING .", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "the bus does not persistently associate it with the connection-name pair.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING .", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIName returns a result code.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "The possible result codes are as follows.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT .", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING .", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING .", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "(Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.)", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost).", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "If \u2013replace is given, ask to replace the old owner.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4.", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_request_name", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "sent": "dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "API_info": {"ret_type": "int", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"], "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var": ["connection", "name", "flags", "error"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "Can only be used if you registered with the bus manually (i.e.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "if you did not call dbus_bus_register_APIName ).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "Can only be called once per dbus_bus_set_unique_name_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "There really no point creating pain for yourself by doing things manually.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName .", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "dbus_bus_set_unique_name_APIParam_2 is the unique name.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_set_unique_name", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "sent": "dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *"], "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var": ["connection", "unique_name"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now).", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIParam_5 is location to store any errors.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_bus_start_service_by_name", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "sent": "dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"], "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var": ["connection", "name", "flags", "result", "error"]}}, {"key": "dbus_timeout_get_data", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "sent": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "API_info": {"ret_type": "void *", "var_type": ["DBusTimeout *"], "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_data", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "sent": "dbus_timeout_get_data_APIParam_1 is the DBusTimeout object.", "API_info": {"ret_type": "void *", "var_type": ["DBusTimeout *"], "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_data", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "sent": "dbus_timeout_get_data_APIName return previously-set data", "API_info": {"ret_type": "void *", "var_type": ["DBusTimeout *"], "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_enabled", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "sent": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_enabled", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "sent": "If not enabled, it should not be polled by the main loop.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_enabled", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "sent": "dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_enabled", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "sent": "dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_interval", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "sent": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "API_info": {"ret_type": "int", "var_type": ["DBusTimeout *"], "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_interval", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "sent": "The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once.", "API_info": {"ret_type": "int", "var_type": ["DBusTimeout *"], "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_interval", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "sent": "The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change.", "API_info": {"ret_type": "int", "var_type": ["DBusTimeout *"], "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_interval", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "sent": "dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object.", "API_info": {"ret_type": "int", "var_type": ["DBusTimeout *"], "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var": ["timeout"]}}, {"key": "dbus_timeout_get_interval", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "sent": "dbus_timeout_get_interval_APIName return the interval in milliseconds", "API_info": {"ret_type": "int", "var_type": ["DBusTimeout *"], "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_timeout_handle_APIParam_1 is the DBusTimeout object.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_handle", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusTimeout *"], "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var": ["timeout"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id.", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "dbus_timeout_set_data_APIParam_1 is the DBusTimeout object.", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_timeout_set_data", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "sent": "dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "API_info": {"ret_type": "void", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var": ["timeout", "data", "free_data_function"]}}, {"key": "dbus_address_entries_free", "paraph": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1. dbus_address_entries_free_APIParam_1 is the array", "sent": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "API_info": {"ret_type": "void", "var_type": ["DBusAddressEntry **"], "desc": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "var": ["entries"]}}, {"key": "dbus_address_entries_free", "paraph": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1. dbus_address_entries_free_APIParam_1 is the array", "sent": "dbus_address_entries_free_APIParam_1 is the array", "API_info": {"ret_type": "void", "var_type": ["DBusAddressEntry **"], "desc": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "var": ["entries"]}}, {"key": "dbus_address_entry_get_method", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "sent": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *"], "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var": ["entry"]}}, {"key": "dbus_address_entry_get_method", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "sent": "For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *"], "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var": ["entry"]}}, {"key": "dbus_address_entry_get_method", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "sent": "dbus_address_entry_get_method_APIName return a string describing the method.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *"], "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var": ["entry"]}}, {"key": "dbus_address_entry_get_method", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "sent": "This string must not be freed", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *"], "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var": ["entry"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value.", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_entry_get_value", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "sent": "This string must not be freed", "API_info": {"ret_type": "const char *", "var_type": ["DBusAddressEntry *", "const char *"], "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var": ["entry", "key"]}}, {"key": "dbus_address_escape_value", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "sent": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "API_info": {"ret_type": "char *", "var_type": ["const char *"], "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value"]}}, {"key": "dbus_address_escape_value", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "sent": "dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["const char *"], "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value"]}}, {"key": "dbus_address_escape_value", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "sent": "dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "API_info": {"ret_type": "char *", "var_type": ["const char *"], "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value"]}}, {"key": "dbus_address_unescape_value", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "sent": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "API_info": {"ret_type": "char *", "var_type": ["const char *", "DBusError *"], "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value", "error"]}}, {"key": "dbus_address_unescape_value", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "sent": "Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["const char *", "DBusError *"], "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value", "error"]}}, {"key": "dbus_address_unescape_value", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "sent": "dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1.", "API_info": {"ret_type": "char *", "var_type": ["const char *", "DBusError *"], "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value", "error"]}}, {"key": "dbus_address_unescape_value", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "sent": "dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails.", "API_info": {"ret_type": "char *", "var_type": ["const char *", "DBusError *"], "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value", "error"]}}, {"key": "dbus_address_unescape_value", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "sent": "dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "API_info": {"ret_type": "char *", "var_type": ["const char *", "DBusError *"], "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var": ["value", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "dbus_parse_address_APIParam_2 is return location to an array of entries.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "dbus_parse_address_APIParam_3 is return location for array length.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_parse_address", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "sent": "dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"], "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var": ["address", "entry_result", "array_len", "error"]}}, {"key": "dbus_watch_get_data", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "sent": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "API_info": {"ret_type": "void *", "var_type": ["DBusWatch *"], "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var": ["watch"]}}, {"key": "dbus_watch_get_data", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "sent": "dbus_watch_get_data_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "void *", "var_type": ["DBusWatch *"], "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var": ["watch"]}}, {"key": "dbus_watch_get_data", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "sent": "dbus_watch_get_data_APIName return previously-set data", "API_info": {"ret_type": "void *", "var_type": ["DBusWatch *"], "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var": ["watch"]}}, {"key": "dbus_watch_get_enabled", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "sent": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *"], "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var": ["watch"]}}, {"key": "dbus_watch_get_enabled", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "sent": "If not enabled, it should not be polled by the main loop.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *"], "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var": ["watch"]}}, {"key": "dbus_watch_get_enabled", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "sent": "dbus_watch_get_enabled_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *"], "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var": ["watch"]}}, {"key": "dbus_watch_get_enabled", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "sent": "dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *"], "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var": ["watch"]}}, {"key": "dbus_watch_get_fd", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "sent": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var": ["watch"]}}, {"key": "dbus_watch_get_fd", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "sent": "dbus_watch_get_fd_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var": ["watch"]}}, {"key": "dbus_watch_get_fd", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "sent": "dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var": ["watch"]}}, {"key": "dbus_watch_get_flags", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "sent": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusWatch *"], "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_flags", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "sent": "The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions.", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusWatch *"], "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_flags", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "sent": "dbus_watch_get_flags_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusWatch *"], "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_flags", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "sent": "dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "API_info": {"ret_type": "unsigned int", "var_type": ["DBusWatch *"], "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_socket", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "sent": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var": ["watch"]}}, {"key": "dbus_watch_get_socket", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "sent": "On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now).", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var": ["watch"]}}, {"key": "dbus_watch_get_socket", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "sent": "dbus_watch_get_socket_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var": ["watch"]}}, {"key": "dbus_watch_get_socket", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "sent": "dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch .", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "Always returns -1 on Windows.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_get_unix_fd", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "sent": "dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "API_info": {"ret_type": "int", "var_type": ["DBusWatch *"], "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var": ["watch"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "It is not allowed to reference a DBusWatch after it has been passed to remove_function.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_watch_handle_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values.", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_handle", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "sent": "dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "API_info": {"ret_type": "dbus_bool_t", "var_type": ["DBusWatch *", "unsigned int"], "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var": ["watch", "flags"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource.", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "dbus_watch_set_data_APIParam_1 is the DBusWatch object.", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2.", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}, {"key": "dbus_watch_set_data", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "sent": "dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "API_info": {"ret_type": "void", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"], "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var": ["watch", "data", "free_data_function"]}}]