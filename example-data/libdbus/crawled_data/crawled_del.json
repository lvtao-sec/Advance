[{"API_info": {"var": ["error"], "ret_type": "void", "desc": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "var_type": ["DBusError *"]}, "sent": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "paraph": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName . dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "key": "dbus_error_free"}, {"sent": "that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName", "cond": "null", "key": "dbus_message_iter_get_fixed_array", "prop": "dbus_message_iter_get_fixed_array_APIParam_1 is the iterator", "API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block"}, {"API_info": {"var": ["error"], "ret_type": "void", "desc": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName .", "var_type": ["DBusError *"]}, "sent": "dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "paraph": "Frees an dbus_error_free_APIParam_1 that been set (or just initialized), then reinitializes the dbus_error_free_APIParam_1 as in dbus_error_init_APIName . dbus_error_free_APIParam_1 is memory where the dbus_error_free_APIParam_1 is stored", "key": "dbus_error_free"}, {"API_info": {"var": ["error", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var_type": ["const DBusError *", "const char *"]}, "sent": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "key": "dbus_error_has_name"}, {"API_info": {"var": ["error", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var_type": ["const DBusError *", "const char *"]}, "sent": "dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1.", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "key": "dbus_error_has_name"}, {"API_info": {"var": ["error", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var_type": ["const DBusError *", "const char *"]}, "sent": "dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2.", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "key": "dbus_error_has_name"}, {"API_info": {"var": ["error", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2.", "var_type": ["const DBusError *", "const char *"]}, "sent": "dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "paraph": "Checks whether the dbus_error_has_name_APIParam_1 is set and has the given dbus_error_has_name_APIParam_2. dbus_error_has_name_APIParam_1 is the dbus_error_has_name_APIParam_1. dbus_error_has_name_APIParam_2 is the dbus_error_has_name_APIParam_2. dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred", "key": "dbus_error_has_name"}, {"API_info": {"var": ["error"], "ret_type": "void", "desc": "Initializes a DBusError structure.", "var_type": ["DBusError *"]}, "sent": "Initializes a DBusError structure.", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "key": "dbus_error_init"}, {"API_info": {"var": ["error"], "ret_type": "void", "desc": "Initializes a DBusError structure.", "var_type": ["DBusError *"]}, "sent": "dbus_error_init_APIParam_1 is the DBusError", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "key": "dbus_error_init"}, {"API_info": {"var": ["error"], "ret_type": "void", "desc": "Initializes a DBusError structure.", "var_type": ["DBusError *"]}, "sent": "Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point.", "paraph": "Initializes a DBusError structure. Does not allocate any memory; the dbus_error_init_APIParam_1 only needs to be freed if it is set at some point. dbus_error_init_APIParam_1 is the DBusError", "key": "dbus_error_init"}, {"API_info": {"var": ["error"], "ret_type": "dbus_bool_t", "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var_type": ["const DBusError *"]}, "sent": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "key": "dbus_error_is_set"}, {"API_info": {"var": ["error"], "ret_type": "dbus_bool_t", "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var_type": ["const DBusError *"]}, "sent": "dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object.", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "key": "dbus_error_is_set"}, {"API_info": {"var": ["error"], "ret_type": "dbus_bool_t", "desc": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set).", "var_type": ["const DBusError *"]}, "sent": "dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "paraph": "Checks whether an dbus_error_is_set_APIParam_1 occurred (the dbus_error_is_set_APIParam_1 is set). dbus_error_is_set_APIParam_1 is the dbus_error_is_set_APIParam_1 object. dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred", "key": "dbus_error_is_set"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "dbus_move_error_APIParam_1 is reinitialized to an empty error.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "dbus_move_error_APIParam_2 may not contain an existing error.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "If the destination is NULL , just frees and reinits the source error.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "dbus_move_error_APIParam_1 is the source error.", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["src", "dest"], "ret_type": "void", "desc": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2.", "var_type": ["DBusError *", "DBusError *"]}, "sent": "dbus_move_error_APIParam_2 is the destination error or NULL", "paraph": "Moves an error dbus_move_error_APIParam_1 into dbus_move_error_APIParam_2, freeing dbus_move_error_APIParam_1 and overwriting dbus_move_error_APIParam_2. Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized. dbus_move_error_APIParam_1 is reinitialized to an empty error. dbus_move_error_APIParam_2 may not contain an existing error. If the destination is NULL , just frees and reinits the source error. dbus_move_error_APIParam_1 is the source error. dbus_move_error_APIParam_2 is the destination error or NULL", "key": "dbus_move_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "Does nothing if dbus_set_error_APIParam_1 is NULL .", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "It will not hurt you.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2.", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "format", " ... "], "ret_type": "void", "desc": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *", " ... "]}, "sent": "dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "paraph": "Assigns an dbus_set_error_APIParam_1 dbus_set_error_APIParam_2 and message to a DBusError . Does nothing if dbus_set_error_APIParam_1 is NULL . The dbus_set_error_APIParam_3 may be NULL , which means a (pretty much useless) default message will be deduced from the dbus_set_error_APIParam_2. This is not a good idea, just go ahead and provide a useful dbus_set_error_APIParam_1 message. It will not hurt you. If no memory can be allocated for the dbus_set_error_APIParam_1 message, an out-of-memory dbus_set_error_APIParam_1 message will be set instead. dbus_set_error_APIParam_1 is the dbus_set_error_APIParam_1.or NULL. dbus_set_error_APIParam_2 is the dbus_set_error_APIParam_1 dbus_set_error_APIParam_2. dbus_set_error_APIParam_3 is printf-style dbus_set_error_APIParam_3 string", "key": "dbus_set_error"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "Does nothing if dbus_set_error_const_APIParam_1 is NULL .", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2.", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended.", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "You probably want dbus_set_error_APIName instead, in most cases.", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL.", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!).", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": " , you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed .", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["error", "name", "message"], "ret_type": "void", "desc": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError .", "var_type": ["DBusError *", "const char *", "const char *"]}, "sent": "dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "paraph": "Assigns an dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 to a DBusError . Does nothing if dbus_set_error_const_APIParam_1 is NULL . The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2. The default dbus_set_error_const_APIParam_3 will be totally useless, though, so using a NULL dbus_set_error_const_APIParam_3 is not recommended. Because dbus_set_error_const_APIName does not copy the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 or dbus_set_error_const_APIParam_3, you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed. You probably want dbus_set_error_APIName instead, in most cases. dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL. dbus_set_error_const_APIParam_2 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_2 (not copied!!!). dbus_set_error_const_APIParam_3 is the dbus_set_error_const_APIParam_1 dbus_set_error_const_APIParam_3 (not copied", "key": "dbus_set_error_const"}, {"API_info": {"var": ["memory"], "ret_type": "void", "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *"]}, "sent": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "key": "dbus_free"}, {"API_info": {"var": ["memory"], "ret_type": "void", "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *"]}, "sent": "If passed NULL , does nothing.", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "key": "dbus_free"}, {"API_info": {"var": ["memory"], "ret_type": "void", "desc": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *"]}, "sent": "dbus_free_APIParam_1 is block to be freed", "paraph": "Frees a block of dbus_free_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . If passed NULL , does nothing. dbus_free_APIParam_1 is block to be freed", "key": "dbus_free"}, {"API_info": {"var": ["str_array"], "ret_type": "void", "desc": "Frees a NULL -terminated array of strings.", "var_type": ["char **"]}, "sent": "Frees a NULL -terminated array of strings.", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "key": "dbus_free_string_array"}, {"API_info": {"var": ["str_array"], "ret_type": "void", "desc": "Frees a NULL -terminated array of strings.", "var_type": ["char **"]}, "sent": "If passed NULL , does nothing.", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "key": "dbus_free_string_array"}, {"API_info": {"var": ["str_array"], "ret_type": "void", "desc": "Frees a NULL -terminated array of strings.", "var_type": ["char **"]}, "sent": "dbus_free_string_array_APIParam_1 is the array to be freed", "paraph": "Frees a NULL -terminated array of strings. If passed NULL , does nothing. dbus_free_string_array_APIParam_1 is the array to be freed", "key": "dbus_free_string_array"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc_APIParam_0 must be released with dbus_free_APIName .", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "Returns NULL if the allocation fails.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "Free dbus_malloc_APIName memory with dbus_free_APIName only.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate.", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "paraph": "Allocates the given number of dbus_malloc_APIParam_1, as with standard malloc_APIName. Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc_APIParam_0 must be released with dbus_free_APIName . dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library. Free dbus_malloc_APIName memory with dbus_free_APIName only. dbus_malloc_APIParam_1 is number of dbus_malloc_APIParam_1 to allocate. dbus_malloc_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms.", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName .", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library.", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "Free it with dbus_free_APIName only.", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate.", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["bytes"], "ret_type": "DBUS_MALLOC void *", "desc": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName.", "var_type": ["size_t"]}, "sent": "dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "paraph": "Allocates the given number of dbus_malloc0_APIParam_1, as with standard malloc_APIName, but all dbus_malloc0_APIParam_1 are initialized to zero as with calloc_APIName. Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms. Returns NULL if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName . dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library. Free it with dbus_free_APIName only. dbus_malloc0_APIParam_1 is number of dbus_malloc0_APIParam_1 to allocate. dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails", "key": "dbus_malloc0"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms.", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "Returns NULL if the resize fails.", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "If the resize fails, the dbus_realloc_APIParam_1 is not freed.", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "dbus_realloc_APIParam_1 is block to be resized.", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block.", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": ["memory", "bytes"], "ret_type": "void *", "desc": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName .", "var_type": ["void *", "size_t"]}, "sent": "dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "paraph": "Resizes a block of dbus_realloc_APIParam_1 previously allocated by dbus_malloc_APIName or dbus_malloc0_APIName . Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms. Returns NULL if the resize fails. If the resize fails, the dbus_realloc_APIParam_1 is not freed. dbus_realloc_APIParam_1 is block to be resized. dbus_realloc_APIParam_2 is new size of the dbus_realloc_APIParam_1 block. dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails", "key": "dbus_realloc"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "It only frees libdbus-internal data structures.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName .", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName .", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "(Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.)", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName .", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again.", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "Obtains the machine UUID of the machine this process is running on.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName .", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "In the latter case, a warning is logged.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": [" void "], "ret_type": "void", "desc": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName .", "var_type": [" void "]}, "sent": "One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong , ", "paraph": "Frees all memory allocated internally by libdbus and reverses the effects of dbus_threads_init_APIName . libdbus keeps internal global variables, for example caches and thread locks, and it can be useful to free these internal data structures. dbus_shutdown_APIName does NOT free memory thatbe returned by dbus_shutdown_APIName to the application. It only frees libdbus-internal data structures. You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName . If a shared connection is open, calling dbus_shutdown_APIName will drain its queue of messages and disconnect it. In particular, this will result in processing of the special Disconnected signal, which may result in a call to _exit_APIName, unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour. You can not continue to use any D-Bus objects, such as connections, that were allocated prior to dbus_shutdown_APIName . You can, however, start over; call dbus_threads_init_APIName again, create new connections, and so forth. WARNING: dbus_shutdown_APIName is NOT thread safe, it must be called while NO other threads are using D-Bus. (Remember, you have to free all D-Bus objects and memory before you call dbus_shutdown_APIName , so no thread can be using libdbus.) The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers. dbus_shutdown_APIName may also be useful if you want to dlopen_APIName libdbus instead of linking to it, and want to be able to unload the library again. There is absolutely no requirement to call dbus_shutdown_APIName - in fact, most applications will not bother and should not feel guilty. You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName . One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong, since you do not know what the rest of the app is up to", "key": "dbus_shutdown"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName .", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "Gets the DYNAMICALLY LINKED version of libdbus.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": [" void "], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": [" void "]}, "sent": "dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly. In the latter case, a warning is logged. Other than its deficient error reporting, dbus_get_local_machine_id_APIName is the same as dbus_try_get_local_machine_id_APIName . Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_get_local_machine_id"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "In other words, you can get either the runtime or the compile-time version.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "Think carefully about which of these you want in a given case.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "dbus_get_version_APIParam_1 is pointer to return the major version, or NULL.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "The MINOR is an odd number for development releases and an even number for stable releases.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series.", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["major_version_p", "minor_version_p", "micro_version_p"], "ret_type": "void", "desc": "Gets the DYNAMICALLY LINKED version of libdbus.", "var_type": ["int *", "int *", "int *"]}, "sent": "dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "paraph": "Gets the DYNAMICALLY LINKED version of libdbus. Alternatively, there are macros #DBUS_MAJOR_VERSION, #DBUS_MINOR_VERSION, #DBUS_MICRO_VERSION, and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST. In other words, you can get either the runtime or the compile-time version. Think carefully about which of these you want in a given case. The libdbus full version number is \"MAJOR.MINOR.MICRO\" where the MINOR changes if API is added, and the MICRO changes with each release of a MAJOR.MINOR series. The MINOR is an odd number for development releases and an even number for stable releases. dbus_get_version_APIParam_1 is pointer to return the major version, or NULL. dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL. dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL", "key": "dbus_get_version"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "Wrapper for setenv_APIName.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "This is because we can not rely on internal implementation details of the underlying libc library.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "dbus_setenv_APIParam_1 is name of environment variable.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "dbus_setenv_APIName is not thread-safe ,  .", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset.", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["varname", "value"], "ret_type": "dbus_bool_t", "desc": "Wrapper for setenv_APIName.", "var_type": ["const char *", "const char *"]}, "sent": "dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "paraph": "Wrapper for setenv_APIName. If the dbus_setenv_APIParam_2 is NULL , unsets the environment variable. There is an unfixable memleak in that it is unsafe to free memory malloced for use with setenv. This is because we can not rely on internal implementation details of the underlying libc library. dbus_setenv_APIName is not thread-safe, because altering the environment in Unix is not thread-safe in general. dbus_setenv_APIParam_1 is name of environment variable. dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable, or NULL to unset. dbus_setenv_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_setenv"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "Obtains the machine UUID of the machine this process is running on.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName .", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves).", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "The machine ID can also be used to create unique per-machine instances.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "For example, you could use it in bus names or X selection names.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "The machine ID is preferred over the machine hostname ,  and may also change at runtime .", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated slot is global, i.e.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "all DBusPendingCall objects will have a slot with the given integer ID reserved.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusPendingCall . The allocated ID may then be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusPendingCall objects will have a slot with the given integer ID reserved. dbus_pending_call_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_pending_call_allocate_data_slot"}, {"API_info": {"var": ["error"], "ret_type": "char *", "desc": "Obtains the machine UUID of the machine this process is running on.", "var_type": ["DBusError *"]}, "sent": "The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance.", "paraph": "Obtains the machine UUID of the machine this process is running on. dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName . This UUID is guaranteed to remain the same until the next reboot (unless the sysadmin foolishly changes it and screws themselves). It will usually remain the same across reboots also, but hardware configuration changes or rebuilding the machine could break that. The idea is that two processes with the same machine ID should be able to use shared memory, UNIX domain sockets, process IDs, and other features of the OS that require both processes to be running on the same OS kernel instance. The machine ID can also be used to create unique per-machine instances. For example, you could use it in bus names or X selection names. The machine ID is preferred over the machine hostname, because the hostname is frequently set to \"localhost.localdomain\" and may also change at runtime. You can get the machine ID of a remote application by invoking the method GetMachineId from interface org.freedesktop.DBus.Peer. If the remote application has the same machine ID as the one returned by this function, then the remote application is on the same machine as your application. The UUID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. Returns a 32-byte-long hex-encoded UUID string, or NULL on failure", "key": "dbus_try_get_local_machine_id"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var_type": ["DBusPendingCall *"]}, "sent": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "key": "dbus_pending_call_block"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var_type": ["DBusPendingCall *"]}, "sent": "If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately.", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "key": "dbus_pending_call_block"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var_type": ["DBusPendingCall *"]}, "sent": "This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "key": "dbus_pending_call_block"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var_type": ["DBusPendingCall *"]}, "sent": "The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question.", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "key": "dbus_pending_call_block"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Block until the dbus_pending_call_block_APIParam_1 call is completed.", "var_type": ["DBusPendingCall *"]}, "sent": "Todo : when you start blocking , the timeout is reset , but it should really only use time remaining  .", "paraph": "Block until the dbus_pending_call_block_APIParam_1 call is completed. The blocking is as with dbus_connection_send_with_reply_and_block_APIName ; it does not enter the main loop or process other messages, it simply waits for the reply in question. If the dbus_pending_call_block_APIParam_1 call is already completed, dbus_pending_call_block_APIName returns immediately. Todo: when you start blocking, the timeout is reset, but it should really only use time remaining since the dbus_pending_call_block_APIParam_1 call was created. This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call", "key": "dbus_pending_call_block"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference.", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also.", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Deallocates a global ID for DBusPendingCall data slots.", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_pending_call_free_data_slot"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "If you cancel the call, no reply is received unless the the reply was already received before you canceled.", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored.", "var_type": ["DBusPendingCall *"]}, "sent": "Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received.", "paraph": "Cancels the dbus_pending_call_cancel_APIParam_1 call, such that any reply or error received will just be ignored. Drops the dbus library internal reference to the DBusPendingCall so will free the call if nobody else is holding a reference. However you usually get a reference from dbus_connection_send_with_reply_APIName so probably your app owns a ref also. Note that canceling a dbus_pending_call_cancel_APIParam_1 call will not simulate a timed-out call; if a call times out, then a timeout error reply is received. If you cancel the call, no reply is received unless the the reply was already received before you canceled. dbus_pending_call_cancel_APIParam_1 is the dbus_pending_call_cancel_APIParam_1 call", "key": "dbus_pending_call_cancel"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot.", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_pending_call_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_pending_call_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for DBusPendingCall data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "paraph": "Deallocates a global ID for DBusPendingCall data slots. dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusPendingCall objects will be freed when the DBusPendingCall is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_pending_call_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_pending_call_free_data_slot"}, {"API_info": {"var": ["pending"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var_type": ["DBusPendingCall *"]}, "sent": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "key": "dbus_pending_call_get_completed"}, {"API_info": {"var": ["pending"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call.", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "key": "dbus_pending_call_get_completed"}, {"API_info": {"var": ["pending"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "paraph": "Checks whether the dbus_pending_call_get_completed_APIParam_1 call has received a reply yet, or not. dbus_pending_call_get_completed_APIParam_1 is the dbus_pending_call_get_completed_APIParam_1 call. dbus_pending_call_get_completed_APIName return TRUE if a reply has been received", "key": "dbus_pending_call_get_completed"}, {"API_info": {"var": ["pending", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var_type": ["DBusPendingCall *", "dbus_int32_t"]}, "sent": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "key": "dbus_pending_call_get_data"}, {"API_info": {"var": ["pending", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var_type": ["DBusPendingCall *", "dbus_int32_t"]}, "sent": "The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed).", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "key": "dbus_pending_call_get_data"}, {"API_info": {"var": ["pending", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var_type": ["DBusPendingCall *", "dbus_int32_t"]}, "sent": "dbus_pending_call_get_data_APIParam_1 is the pending_call.", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "key": "dbus_pending_call_get_data"}, {"API_info": {"var": ["pending", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var_type": ["DBusPendingCall *", "dbus_int32_t"]}, "sent": "dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from.", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "key": "dbus_pending_call_get_data"}, {"API_info": {"var": ["pending", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_pending_call_set_data_APIName .", "var_type": ["DBusPendingCall *", "dbus_int32_t"]}, "sent": "dbus_pending_call_get_data_APIName return the data, or NULL if not found", "paraph": "Retrieves data previously set with dbus_pending_call_set_data_APIName . The dbus_pending_call_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_pending_call_get_data_APIParam_1 is the pending_call. dbus_pending_call_get_data_APIParam_2 is the dbus_pending_call_get_data_APIParam_2 to get data from. dbus_pending_call_get_data_APIName return the data, or NULL if not found", "key": "dbus_pending_call_get_data"}, {"API_info": {"var": ["pending"], "ret_type": "DBusPendingCall *", "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var_type": ["DBusPendingCall *"]}, "sent": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "key": "dbus_pending_call_ref"}, {"API_info": {"var": ["pending"], "ret_type": "DBusPendingCall *", "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object.", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "key": "dbus_pending_call_ref"}, {"API_info": {"var": ["pending"], "ret_type": "DBusPendingCall *", "desc": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "paraph": "Increments the reference count on a dbus_pending_call_ref_APIParam_1 call. dbus_pending_call_ref_APIParam_1 is the dbus_pending_call_ref_APIParam_1 call object. dbus_pending_call_ref_APIName return the dbus_pending_call_ref_APIParam_1 call object", "key": "dbus_pending_call_ref"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName .", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_data_APIParam_1 is the pending_call.", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number.", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store.", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3.", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized.", "var_type": ["DBusPendingCall *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "paraph": "Stores a pointer on a DBusPendingCall , along with an optional function to be used for freeing the dbus_pending_call_set_data_APIParam_3 when the dbus_pending_call_set_data_APIParam_3 is set again, or when the dbus_pending_call_set_data_APIParam_1 call is finalized. The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName . dbus_pending_call_set_data_APIParam_1 is the pending_call. dbus_pending_call_set_data_APIParam_2 is the dbus_pending_call_set_data_APIParam_2 number. dbus_pending_call_set_data_APIParam_3 is the dbus_pending_call_set_data_APIParam_3 to store. dbus_pending_call_set_data_APIParam_4 is finalizer function for the dbus_pending_call_set_data_APIParam_3. dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3", "key": "dbus_pending_call_set_data"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call.", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2.", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2.", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data.", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending", "function", "user_data", "free_user_data"], "ret_type": "dbus_bool_t", "desc": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out.", "var_type": ["DBusPendingCall *", "DBusPendingCallNotifyFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "paraph": "Sets a notification dbus_pending_call_set_notify_APIParam_2 to be called when the reply is received or the dbus_pending_call_set_notify_APIParam_1 call times out. dbus_pending_call_set_notify_APIParam_1 is the dbus_pending_call_set_notify_APIParam_1 call. dbus_pending_call_set_notify_APIParam_2 is notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_3 is data to pass to notifier dbus_pending_call_set_notify_APIParam_2. dbus_pending_call_set_notify_APIParam_4 is dbus_pending_call_set_notify_APIParam_2 to free the user data. dbus_pending_call_set_notify_APIName return FALSE if not enough memory", "key": "dbus_pending_call_set_notify"}, {"API_info": {"var": ["pending"], "ret_type": "DBusMessage *", "desc": "Gets the reply, or returns NULL if none has been received yet.", "var_type": ["DBusPendingCall *"]}, "sent": "Gets the reply, or returns NULL if none has been received yet.", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "key": "dbus_pending_call_steal_reply"}, {"API_info": {"var": ["pending"], "ret_type": "DBusMessage *", "desc": "Gets the reply, or returns NULL if none has been received yet.", "var_type": ["DBusPendingCall *"]}, "sent": "Ownership of the reply message passes to the caller.", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "key": "dbus_pending_call_steal_reply"}, {"API_info": {"var": ["pending"], "ret_type": "DBusMessage *", "desc": "Gets the reply, or returns NULL if none has been received yet.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call.", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "key": "dbus_pending_call_steal_reply"}, {"API_info": {"var": ["pending"], "ret_type": "DBusMessage *", "desc": "Gets the reply, or returns NULL if none has been received yet.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call ,  .", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "key": "dbus_pending_call_steal_reply"}, {"API_info": {"var": ["pending"], "ret_type": "DBusMessage *", "desc": "Gets the reply, or returns NULL if none has been received yet.", "var_type": ["DBusPendingCall *"]}, "sent": "dbus_pending_call_steal_reply_APIName return the reply message or NULL", "paraph": "Gets the reply, or returns NULL if none has been received yet. Ownership of the reply message passes to the caller. dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call, since the reply message is tranferred to the caller. dbus_pending_call_steal_reply_APIParam_1 is the dbus_pending_call_steal_reply_APIParam_1 call. dbus_pending_call_steal_reply_APIName return the reply message or NULL", "key": "dbus_pending_call_steal_reply"}, {"API_info": {"var": ["message"], "ret_type": "unsigned int", "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "key": "_dbus_message_get_n_unix_fds"}, {"API_info": {"var": ["pending"], "ret_type": "void", "desc": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "var_type": ["DBusPendingCall *"]}, "sent": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "paraph": "Decrements the reference count on a dbus_pending_call_unref_APIParam_1 call, freeing it if the count reaches 0. dbus_pending_call_unref_APIParam_1 is the dbus_pending_call_unref_APIParam_1 call object", "key": "dbus_pending_call_unref"}, {"API_info": {"var": ["message"], "ret_type": "unsigned int", "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "_dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1.", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "key": "_dbus_message_get_n_unix_fds"}, {"API_info": {"var": ["message"], "ret_type": "unsigned int", "desc": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "_dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "paraph": "Gets the number of unix fds attached to this _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIParam_1 is the _dbus_message_get_n_unix_fds_APIParam_1. _dbus_message_get_n_unix_fds_APIName return the number of file descriptors", "key": "_dbus_message_get_n_unix_fds"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated slot is global, i.e.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "all DBusMessage objects will have a slot with the given integer ID reserved.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusMessage . The allocated ID may then be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusMessage objects will have a slot with the given integer ID reserved. dbus_message_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_message_allocate_data_slot"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "The variable argument list should contain the type of each argument followed by the value to append.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors).", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "To append a basic type, specify its type code followed by the address of the value.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "If you need those you need to manually recurse into the array.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "Hence you may close the descriptor immediately after this call.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "For strings it works to write const char *array = \"Hello\" and then use &array though.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "If you do not do this then libdbus will not know to stop and will read invalid memory.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "dbus_message_append_args_APIName return TRUE on success", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over.", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree).", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "int", " ... "]}, "sent": "String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1.", "paraph": "Appends fields to a dbus_message_append_args_APIParam_1 given a variable argument list. The variable argument list should contain the type of each argument followed by the value to append. Appendable types are basic types, and arrays of fixed-length basic types (except arrays of Unix file descriptors). To append variable-length basic types, or any more complex value, you have to use an iterator rather than this function. To append a basic type, specify its type code followed by the address of the value. For example: To append an array of fixed-length basic types (except Unix file descriptors), pass in the DBUS_TYPE_ARRAY typecode, the element typecode, the address of the array pointer, and a 32-bit integer giving the number of elements in the array. So for example: dbus_message_append_args_APIName does not support arrays of Unix file descriptors. If you need those you need to manually recurse into the array. For Unix file descriptors dbus_message_append_args_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list. If you do not do this then libdbus will not know to stop and will read invalid memory. String/signature/path arrays should be passed in as \"const char*** address_of_array\" and \"int n_elements\" Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo: If this fails due to lack of memory, the dbus_message_append_args_APIParam_1 is hosed and you have to start over building the whole dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_1 is the dbus_message_append_args_APIParam_1. dbus_message_append_args_APIParam_2 is type of the first argument ... value of first argument, list of additional type-value pairs. dbus_message_append_args_APIName return TRUE on success", "key": "dbus_message_append_args"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1.", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "dbus_message_append_args_valist_APIParam_2 is type of first argument.", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs.", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "int", "va_list"]}, "sent": "dbus_message_append_args_valist_APIName return TRUE on success", "paraph": "Like dbus_message_append_args_APIName but takes a va_list for use by language bindings. Todo: for now, if dbus_message_append_args_valist_APIName fails due to OOM it will leave the dbus_message_append_args_valist_APIParam_1 half-written and you have to discard the dbus_message_append_args_valist_APIParam_1 and start over. See also dbus_message_append_args . dbus_message_append_args_valist_APIParam_1 is the dbus_message_append_args_valist_APIParam_1. dbus_message_append_args_valist_APIParam_2 is type of first argument. dbus_message_append_args_valist_APIParam_3 is value of first argument, then list of type/value pairs. dbus_message_append_args_valist_APIName return TRUE on success", "key": "dbus_message_append_args_valist"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var_type": ["DBusMessage *"]}, "sent": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "key": "dbus_message_contains_unix_fds"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1.", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "key": "dbus_message_contains_unix_fds"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "paraph": "Checks whether a dbus_message_contains_unix_fds_APIParam_1 contains unix fds. dbus_message_contains_unix_fds_APIParam_1 is the dbus_message_contains_unix_fds_APIParam_1. dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds", "key": "dbus_message_contains_unix_fds"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var_type": ["const DBusMessage *"]}, "sent": "dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1.", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "key": "dbus_message_copy"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var_type": ["const DBusMessage *"]}, "sent": "Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors.", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "key": "dbus_message_copy"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var_type": ["const DBusMessage *"]}, "sent": "dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "key": "dbus_message_copy"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage.", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1.", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "dbus_message_demarshal_APIParam_3 is the location to save errors to.", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["str", "len", "error"], "ret_type": "DBusMessage *", "desc": "Demarshal a D-Bus message from the format described in the D-Bus specification.", "var_type": ["const char *", "int", "DBusError *"]}, "sent": "dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "paraph": "Demarshal a D-Bus message from the format described in the D-Bus specification. Generally, dbus_message_demarshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_APIParam_1 is the marshalled DBusMessage. dbus_message_demarshal_APIParam_2 is the length of dbus_message_demarshal_APIParam_1. dbus_message_demarshal_APIParam_3 is the location to save errors to. dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3", "key": "dbus_message_demarshal"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled.", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1.", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "var_type": ["const DBusMessage *"]}, "sent": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked.", "paraph": "Creates a new dbus_message_copy_APIParam_1 that is an exact replica of the dbus_message_copy_APIParam_1 specified, except that its refcount is set to 1, its dbus_message_copy_APIParam_1 serial is reset to 0, and if the original dbus_message_copy_APIParam_1 was \"locked\" (in the outgoing dbus_message_copy_APIParam_1 queue and thus not modifiable) the new dbus_message_copy_APIParam_1 will not be locked. Todo: dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors. dbus_message_copy_APIParam_1 is the dbus_message_copy_APIParam_1. dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors (in case the dbus_message_copy_APIParam_1 to copy includes Unix file descriptors) can be allocated", "key": "dbus_message_copy"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "Otherwise returns the number of bytes to be demarshalled", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for message data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Deallocates a global ID for message data slots.", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_message_free_data_slot"}, {"API_info": {"var": ["buf", "len"], "ret_type": "int", "desc": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message.", "var_type": ["const char *", "int"]}, "sent": "dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled.", "paraph": "Returns the number of bytes required to be in the buffer to demarshal a D-Bus message. Generally, dbus_message_demarshal_bytes_needed_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_demarshal_bytes_needed_APIParam_1 is data to be marshalled. dbus_message_demarshal_bytes_needed_APIParam_2 is the length of dbus_message_demarshal_bytes_needed_APIParam_1. dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled. Otherwise returns the number of bytes to be demarshalled", "key": "dbus_message_demarshal_bytes_needed"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for message data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot.", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_message_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for message data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_message_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for message data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "paraph": "Deallocates a global ID for message data slots. dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusMessage objects will be freed when the message is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_message_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_message_free_data_slot"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set.", "var_type": ["DBusMessage *"]}, "sent": "Returns  has been set .", "paraph": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set. dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "key": "dbus_message_get_allow_interactive_authorization"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "paraph": "Returns whether the flag controlled by dbus_message_set_allow_interactive_authorization_APIName has been set. dbus_message_get_allow_interactive_authorization_APIParam_1 is the dbus_message_get_allow_interactive_authorization_APIParam_1", "key": "dbus_message_get_allow_interactive_authorization"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName .", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "To get a string array pass in \"char ***array_location\" and \"int *n_elements\".", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "If you need them without this flag set, make sure to unset it with fcntl_APIName.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "The list is terminated with DBUS_TYPE_INVALID .", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "They point into the DBusMessage .", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", " ... "], "ret_type": "dbus_bool_t", "desc": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list.", "var_type": ["DBusMessage *", "DBusError *", "int", " ... "]}, "sent": "dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs.", "paraph": "Gets arguments from a dbus_message_get_args_APIParam_1 given a variable argument list. The supported types include those supported by dbus_message_append_args_APIName ; that is, basic types and arrays of fixed-length basic types. The arguments are the same as they would be for dbus_message_iter_get_basic_APIName or dbus_message_iter_get_fixed_array_APIName . In addition to those types, arrays of string, object path, and signature are supported; but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references. To get a string array pass in \"char ***array_location\" and \"int *n_elements\". Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD. If you need to parse messages with arrays of Unix file descriptors you need to recurse into the array manually. Unix file descriptors that are read with dbus_message_get_args_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored. The list is terminated with DBUS_TYPE_INVALID . Except for string arrays, dbus_message_get_args_APIParam_0 values are constant; do not free them. They point into the DBusMessage . If the requested arguments are not present, or do not have the requested types, then an dbus_message_get_args_APIParam_2 will be set. If more arguments than requested are present, the requested argumentsbe returned by dbus_message_get_args_APIName and the extra arguments are ignored. Todo: support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1. dbus_message_get_args_APIParam_2 is dbus_message_get_args_APIParam_2 to be filled in on failure. dbus_message_get_args_APIParam_3 is the first argument type ... location for first argument value, then list of type-location pairs. dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set", "key": "dbus_message_get_args"}, {"API_info": {"var": ["message", "error", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"]}, "sent": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "key": "dbus_message_get_args_valist"}, {"API_info": {"var": ["message", "error", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"]}, "sent": "dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in.", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "key": "dbus_message_get_args_valist"}, {"API_info": {"var": ["message", "error", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"]}, "sent": "dbus_message_get_args_valist_APIParam_3 is type of the first argument.", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "key": "dbus_message_get_args_valist"}, {"API_info": {"var": ["message", "error", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"]}, "sent": "dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs.", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "key": "dbus_message_get_args_valist"}, {"API_info": {"var": ["message", "error", "first_arg_type", "var_args"], "ret_type": "dbus_bool_t", "desc": "Like dbus_message_get_args but takes a va_list for use by language bindings.", "var_type": ["DBusMessage *", "DBusError *", "int", "va_list"]}, "sent": "dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "paraph": "Like dbus_message_get_args but takes a va_list for use by language bindings. See also dbus_message_get_args dbus_message_get_args_valist_APIParam_1 is the dbus_message_get_args_valist_APIParam_1. dbus_message_get_args_valist_APIParam_2 is dbus_message_get_args_valist_APIParam_2 to be filled in. dbus_message_get_args_valist_APIParam_3 is type of the first argument. dbus_message_get_args_valist_APIParam_4 is return location for first argument, followed by list of type/location pairs. dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set", "key": "dbus_message_get_args_valist"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1.", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "key": "dbus_message_get_auto_start"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var_type": ["DBusMessage *"]}, "sent": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "key": "dbus_message_get_auto_start"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "paraph": "Returns TRUE if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started. dbus_message_get_auto_start_APIParam_1 is the dbus_message_get_auto_start_APIParam_1. dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start", "key": "dbus_message_get_auto_start"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_container_instance"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1.", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_container_instance"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified ,  .", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_container_instance"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "paraph": "Gets the container instance this dbus_message_get_container_instance_APIParam_1 was sent from, or NULL if none. dbus_message_get_container_instance_APIParam_0 becomes invalid if the dbus_message_get_container_instance_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_container_instance_APIParam_1 data. dbus_message_get_container_instance_APIParam_1 is the dbus_message_get_container_instance_APIParam_1. dbus_message_get_container_instance_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_container_instance"}, {"API_info": {"var": ["message", "slot"], "ret_type": "void*", "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var_type": ["DBusMessage *", "dbus_int32_t"]}, "sent": "Retrieves data previously set with dbus_message_set_data_APIName .", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "key": "dbus_message_get_data"}, {"API_info": {"var": ["message", "slot"], "ret_type": "void*", "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var_type": ["DBusMessage *", "dbus_int32_t"]}, "sent": "The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed).", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "key": "dbus_message_get_data"}, {"API_info": {"var": ["message", "slot"], "ret_type": "void*", "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var_type": ["DBusMessage *", "dbus_int32_t"]}, "sent": "dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1.", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "key": "dbus_message_get_data"}, {"API_info": {"var": ["message", "slot"], "ret_type": "void*", "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var_type": ["DBusMessage *", "dbus_int32_t"]}, "sent": "dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from.", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "key": "dbus_message_get_data"}, {"API_info": {"var": ["message", "slot"], "ret_type": "void*", "desc": "Retrieves data previously set with dbus_message_set_data_APIName .", "var_type": ["DBusMessage *", "dbus_int32_t"]}, "sent": "dbus_message_get_data_APIName return the data, or NULL if not found", "paraph": "Retrieves data previously set with dbus_message_set_data_APIName . The dbus_message_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_message_get_data_APIParam_1 is the dbus_message_get_data_APIParam_1. dbus_message_get_data_APIParam_2 is the dbus_message_get_data_APIParam_2 to get data from. dbus_message_get_data_APIName return the data, or NULL if not found", "key": "dbus_message_get_data"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var_type": ["DBusMessage *"]}, "sent": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "key": "dbus_message_get_destination"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1.", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "key": "dbus_message_get_destination"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified ,  .", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "key": "dbus_message_get_destination"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "paraph": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL if there is none set. dbus_message_get_destination_APIParam_0 becomes invalid if the dbus_message_get_destination_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_destination_APIParam_1 data. dbus_message_get_destination_APIParam_1 is the dbus_message_get_destination_APIParam_1. dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination (should not be freed) or NULL", "key": "dbus_message_get_destination"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "key": "dbus_message_get_error_name"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1.", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "key": "dbus_message_get_error_name"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified ,  .", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "key": "dbus_message_get_error_name"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "paraph": "Gets the error name (DBUS_MESSAGE_TYPE_ERROR only) or NULL if none. dbus_message_get_error_name_APIParam_0 becomes invalid if the dbus_message_get_error_name_APIParam_1 is modified, since the dbus_message_get_error_name_APIParam_1 points into the wire-marshaled dbus_message_get_error_name_APIParam_1 data. dbus_message_get_error_name_APIParam_1 is the dbus_message_get_error_name_APIParam_1. dbus_message_get_error_name_APIName return the error name (should not be freed) or NULL", "key": "dbus_message_get_error_name"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "The interface name is fully-qualified (namespaced).", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Returns NULL if none.", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1.", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified ,  .", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "paraph": "Gets the interface this dbus_message_get_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name is fully-qualified (namespaced). Returns NULL if none. dbus_message_get_interface_APIParam_0 becomes invalid if the dbus_message_get_interface_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_interface_APIParam_1 data. dbus_message_get_interface_APIParam_1 is the dbus_message_get_interface_APIParam_1. dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface (should not be freed) or NULL", "key": "dbus_message_get_interface"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "key": "dbus_message_get_member"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Returns NULL if none.", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "key": "dbus_message_get_member"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1.", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "key": "dbus_message_get_member"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified ,  .", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "key": "dbus_message_get_member"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "paraph": "Gets the interface member being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. dbus_message_get_member_APIParam_0 becomes invalid if the dbus_message_get_member_APIParam_1 is modified, since the dbus_message_get_member_APIParam_1 points into the wire-marshaled dbus_message_get_member_APIParam_1 data. dbus_message_get_member_APIParam_1 is the dbus_message_get_member_APIParam_1. dbus_message_get_member_APIName return the member name (should not be freed) or NULL", "key": "dbus_message_get_member"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var_type": ["DBusMessage *"]}, "sent": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "key": "dbus_message_get_no_reply"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1.", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "key": "dbus_message_get_no_reply"}, {"API_info": {"var": ["message"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "paraph": "Returns TRUE if the dbus_message_get_no_reply_APIParam_1 does not expect a reply. dbus_message_get_no_reply_APIParam_1 is the dbus_message_get_no_reply_APIParam_1. dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply", "key": "dbus_message_get_no_reply"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_path"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "Returns NULL if none.", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_path"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1.", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_path"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified ,  .", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_path"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_path_APIName return the path (should not be freed) or NULL", "paraph": "Gets the object path this dbus_message_get_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). Returns NULL if none. See also dbus_message_get_path_decomposed_APIName . dbus_message_get_path_APIParam_0 becomes invalid if the dbus_message_get_path_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_path_APIParam_1 data. dbus_message_get_path_APIParam_1 is the dbus_message_get_path_APIParam_1. dbus_message_get_path_APIName return the path (should not be freed) or NULL", "key": "dbus_message_get_path"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName .", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\".", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1.", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }.", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component).", "var_type": ["DBusMessage *", "char ***"]}, "sent": "dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists.", "paraph": "Gets the object dbus_message_get_path_decomposed_APIParam_2 this dbus_message_get_path_decomposed_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL) in a decomposed format (one array element per dbus_message_get_path_decomposed_APIParam_2 component). Free dbus_message_get_path_decomposed_APIParam_0 with dbus_free_string_array_APIName . An empty but non-NULL dbus_message_get_path_decomposed_APIParam_2 array means the dbus_message_get_path_decomposed_APIParam_2 \"/\". So the dbus_message_get_path_decomposed_APIParam_2 \"/foo/bar\" becomes { \"foo\", \"bar\", NULL } and the dbus_message_get_path_decomposed_APIParam_2 \"/\" becomes { NULL }. See also dbus_message_get_path_APIName . Todo: this could be optimized by using the len from the dbus_message_get_path_decomposed_APIParam_1 instead of calling strlen_APIName again dbus_message_get_path_decomposed_APIParam_1 is the dbus_message_get_path_decomposed_APIParam_1. dbus_message_get_path_decomposed_APIParam_2 is place to store allocated array of dbus_message_get_path_decomposed_APIParam_2 components; NULL set here if no dbus_message_get_path_decomposed_APIParam_2 field exists. dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array", "key": "dbus_message_get_path_decomposed"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1.", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "key": "dbus_message_get_reply_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var_type": ["DBusMessage *"]}, "sent": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "key": "dbus_message_get_reply_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_reply_serial_APIName return the reply serial", "paraph": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0 if none. dbus_message_get_reply_serial_APIParam_1 is the dbus_message_get_reply_serial_APIParam_1. dbus_message_get_reply_serial_APIName return the reply serial", "key": "dbus_message_get_reply_serial"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "The sender is filled in by the dbus_message_get_sender_APIParam_1 bus.", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name.", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "Connections may own multiple other bus names, but those are not found in the sender field.", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1.", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified ,  .", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_sender_APIName return the unique name of the sender or NULL", "paraph": "Gets the unique name of the connection which originated this dbus_message_get_sender_APIParam_1, or NULL if unknown or inapplicable. The sender is filled in by the dbus_message_get_sender_APIParam_1 bus. Note, dbus_message_get_sender_APIParam_0 sender is always the unique bus name. Connections may own multiple other bus names, but those are not found in the sender field. dbus_message_get_sender_APIParam_0 becomes invalid if the dbus_message_get_sender_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_sender_APIParam_1 data. dbus_message_get_sender_APIParam_1 is the dbus_message_get_sender_APIParam_1. dbus_message_get_sender_APIName return the unique name of the sender or NULL", "key": "dbus_message_get_sender"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "All messages received on a connection will have a serial provided by the remote application.", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1.", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1.", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you.", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "dbus_uint32_t", "desc": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_serial_APIName return the serial", "paraph": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 if none has been specified. The message serial number is provided by the application sending the dbus_message_get_serial_APIParam_1 and is used to identify replies to this dbus_message_get_serial_APIParam_1. All messages received on a connection will have a serial provided by the remote application. For messages you are sending, dbus_connection_send_APIName will assign a serial and return it to you. dbus_message_get_serial_APIParam_1 is the dbus_message_get_serial_APIParam_1. dbus_message_get_serial_APIName return the serial", "key": "dbus_message_get_serial"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "the arguments in the dbus_message_get_signature_APIParam_1 payload.", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "The signature is a string made up of type codes such as DBUS_TYPE_INT32 .", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ).", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method).", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1.", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified ,  .", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "const char *", "desc": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_signature_APIName return the type signature", "paraph": "Gets the type signature of the dbus_message_get_signature_APIParam_1, i.e. the arguments in the dbus_message_get_signature_APIParam_1 payload. The signature includes only \"in\" arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only \"out\" arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect (that is, it does not include the signature of the entire C++-style method). The signature is a string made up of type codes such as DBUS_TYPE_INT32 . The string is terminated with nul (nul is also the value of DBUS_TYPE_INVALID ). dbus_message_get_signature_APIParam_0 becomes invalid if the dbus_message_get_signature_APIParam_1 is modified, since it points into the wire-marshaled dbus_message_get_signature_APIParam_1 data. dbus_message_get_signature_APIParam_1 is the dbus_message_get_signature_APIParam_1. dbus_message_get_signature_APIName return the type signature", "key": "dbus_message_get_signature"}, {"API_info": {"var": ["message"], "ret_type": "int", "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Gets the type of a dbus_message_get_type_APIParam_1.", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "key": "dbus_message_get_type"}, {"API_info": {"var": ["message"], "ret_type": "int", "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "DBUS_MESSAGE_TYPE_INVALID will never be returned.", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "key": "dbus_message_get_type"}, {"API_info": {"var": ["message"], "ret_type": "int", "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1.", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "key": "dbus_message_get_type"}, {"API_info": {"var": ["message"], "ret_type": "int", "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type.", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "key": "dbus_message_get_type"}, {"API_info": {"var": ["message"], "ret_type": "int", "desc": "Gets the type of a dbus_message_get_type_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "paraph": "Gets the type of a dbus_message_get_type_APIParam_1. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type. DBUS_MESSAGE_TYPE_INVALID will never be returned. dbus_message_get_type_APIParam_1 is the dbus_message_get_type_APIParam_1. dbus_message_get_type_APIName return the type of the dbus_message_get_type_APIParam_1", "key": "dbus_message_get_type"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "key": "dbus_message_has_destination"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE .", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "key": "dbus_message_has_destination"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1.", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "key": "dbus_message_has_destination"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "key": "dbus_message_has_destination"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "paraph": "Checks whether the dbus_message_has_destination_APIParam_1 was sent to the given dbus_message_has_destination_APIParam_2. If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE . dbus_message_has_destination_APIParam_1 is the dbus_message_has_destination_APIParam_1. dbus_message_has_destination_APIParam_2 is the dbus_message_has_destination_APIParam_2 to check (must not be NULL ). dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2", "key": "dbus_message_has_destination"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "key": "dbus_message_has_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1.", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "key": "dbus_message_has_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_interface_APIParam_2 is the interface name.", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "key": "dbus_message_has_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_interface_APIParam_1 has an interface.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "paraph": "Checks if the dbus_message_has_interface_APIParam_1 has an interface. dbus_message_has_interface_APIParam_1 is the dbus_message_has_interface_APIParam_1. dbus_message_has_interface_APIParam_2 is the interface name. dbus_message_has_interface_APIName return TRUE if the interface field in the header matches", "key": "dbus_message_has_interface"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "key": "dbus_message_has_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1.", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "key": "dbus_message_has_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name.", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "key": "dbus_message_has_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "paraph": "Checks if the dbus_message_has_member_APIParam_1 has an interface dbus_message_has_member_APIParam_2. dbus_message_has_member_APIParam_1 is the dbus_message_has_member_APIParam_1. dbus_message_has_member_APIParam_2 is the dbus_message_has_member_APIParam_2 name. dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header", "key": "dbus_message_has_member"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "key": "dbus_message_has_path"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1.", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "key": "dbus_message_has_path"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal.", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "key": "dbus_message_has_path"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name.", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "key": "dbus_message_has_path"}, {"API_info": {"var": ["message", "path"], "ret_type": "dbus_bool_t", "desc": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "paraph": "Checks if the dbus_message_has_path_APIParam_1 has a particular object dbus_message_has_path_APIParam_2. The object dbus_message_has_path_APIParam_2 is the destination object for a method call or the emitting object for a signal. dbus_message_has_path_APIParam_1 is the dbus_message_has_path_APIParam_1. dbus_message_has_path_APIParam_2 is the dbus_message_has_path_APIParam_2 name. dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header", "key": "dbus_message_has_path"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE .", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender.", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "So you can not use dbus_message_has_sender_APIName to see  .", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender.", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1.", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "paraph": "Checks whether the dbus_message_has_sender_APIParam_1 has the given unique dbus_message_has_sender_APIParam_2 as its sender. If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE . Note that a peer application will always have the unique dbus_message_has_sender_APIParam_2 of the connection as the sender. So you can not use dbus_message_has_sender_APIName to see whether a sender owned a well-known dbus_message_has_sender_APIParam_2. Messages from the bus itself will have DBUS_SERVICE_DBUS as the sender. dbus_message_has_sender_APIParam_1 is the dbus_message_has_sender_APIParam_1. dbus_message_has_sender_APIParam_2 is the dbus_message_has_sender_APIParam_2 to check (must not be NULL ). dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender", "key": "dbus_message_has_sender"}, {"API_info": {"var": ["message", "signature"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1.", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "key": "dbus_message_has_signature"}, {"API_info": {"var": ["message", "signature"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks  for more details on what the dbus_message_has_signature_APIParam_2 looks like .", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "key": "dbus_message_has_signature"}, {"API_info": {"var": ["message", "signature"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_signature_APIParam_2 is typecode array.", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "key": "dbus_message_has_signature"}, {"API_info": {"var": ["message", "signature"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "paraph": "Checks whether the dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2; see dbus_message_get_signature_APIName for more details on what the dbus_message_has_signature_APIParam_2 looks like. dbus_message_has_signature_APIParam_1 is the dbus_message_has_signature_APIParam_1. dbus_message_has_signature_APIParam_2 is typecode array. dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2", "key": "dbus_message_has_signature"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "key": "dbus_message_is_error"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE .", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "key": "dbus_message_is_error"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1.", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "key": "dbus_message_is_error"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "key": "dbus_message_is_error"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "paraph": "Checks whether the dbus_message_is_error_APIParam_1 is an error reply with the given error name. If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE . dbus_message_is_error_APIParam_1 is the dbus_message_is_error_APIParam_1. dbus_message_is_error_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error", "key": "dbus_message_is_error"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE .", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "If the interface field is missing, then it will be assumed equal to the provided interface.", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name.", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1.", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "method"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "paraph": "Checks whether the dbus_message_is_method_call_APIParam_1 is a dbus_message_is_method_call_APIParam_3 call with the given interface and member fields. If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE . If the interface field is missing, then it will be assumed equal to the provided interface. The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name. dbus_message_is_method_call_APIParam_1 is the dbus_message_is_method_call_APIParam_1. dbus_message_is_method_call_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_method_call_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call", "key": "dbus_message_is_method_call"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1.", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE .", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ).", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["message", "iface", "signal_name"], "ret_type": "dbus_bool_t", "desc": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "paraph": "Checks whether the dbus_message_is_signal_APIParam_1 is a signal with the given interface and member fields. If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE . dbus_message_is_signal_APIParam_1 is the dbus_message_is_signal_APIParam_1. dbus_message_is_signal_APIParam_2 is the name to check (must not be NULL ). dbus_message_is_signal_APIParam_3 is the name to check (must not be NULL ). dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal", "key": "dbus_message_is_signal"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Once this returns, the message is hosed and you have to start over building the whole message.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_abandon_container_APIParam_1 is the append iterator.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "This should only be used to abandon creation of a message when you have open containers.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. This should only be used to abandon creation of a message when you have open containers. dbus_message_iter_abandon_container_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Once this returns, the message is hosed and you have to start over building the whole message.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "The basic types are the non-container types such as integer and string.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "So for string, const char**.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "For integer, dbus_int32_t*.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "Hence you may close the descriptor immediately after this call.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "dbus_message_iter_append_basic_APIParam_1 is the append iterator.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator.", "paraph": "Abandons creation of a contained-typed value and frees resources created by dbus_message_iter_open_container_APIName . Once this returns, the message is hosed and you have to start over building the whole message. Unlike dbus_message_iter_abandon_container_APIName , it is valid to call dbus_message_iter_abandon_container_if_open_APIName on an iterator that was initialized with DBUS_MESSAGE_ITER_INIT_CLOSED , or an iterator that was already closed or abandoned. However, it is not valid to call dbus_message_iter_abandon_container_if_open_APIName on uninitialized memory. This is intended to be used in error cleanup code paths, similar to this pattern: DBusMessageIter outer = DBUS_MESSAGE_ITER_INIT_CLOSED; DBusMessageIter inner = DBUS_MESSAGE_ITER_INIT_CLOSED; dbus_bool_t result = FALSE; if (!dbus_message_iter_open_container (iter, ..., &outer)) goto out; if (!dbus_message_iter_open_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_append_basic (&inner, ...)) goto out; if (!dbus_message_iter_close_container (&outer, ..., &inner)) goto out; if (!dbus_message_iter_close_container (iter, ..., &outer)) goto out; result = TRUE; out: dbus_message_iter_abandon_container_if_open_APIName (&outer, &inner); dbus_message_iter_abandon_container_if_open_APIName (iter, &outer); return result; dbus_message_iter_abandon_container_if_open_APIParam_1 is the append iterator. dbus_message_iter_abandon_container_if_open_APIParam_2 is sub-iterator to close", "key": "dbus_message_iter_abandon_container_if_open"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3.", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "type", "value"], "ret_type": "dbus_bool_t", "desc": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message.", "var_type": ["DBusMessageIter *", "int", "const void *"]}, "sent": "dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "paraph": "Appends a basic-typed dbus_message_iter_append_basic_APIParam_3 to the message. The basic types are the non-container types such as integer and string. The \"value\" argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3. So for string, const char**. For integer, dbus_int32_t*. For Unix file descriptors dbus_message_iter_append_basic_APIName will internally duplicate the descriptor you passed in. Hence you may close the descriptor immediately after this call. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_basic_APIParam_1 is the append iterator. dbus_message_iter_append_basic_APIParam_2 is the dbus_message_iter_append_basic_APIParam_2 of the. dbus_message_iter_append_basic_APIParam_3 is dbus_message_iter_append_basic_APIParam_3 the address of the dbus_message_iter_append_basic_APIParam_3. dbus_message_iter_append_basic_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_basic"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "Appends a block of fixed-length values to an array.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "The fixed-length types are all basic types that are not string-like.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "So int32, double, bool, etc.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "(Unix file descriptors however are not supported.)", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "The \"value\" argument should be the address of the array.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "For strings it works to write const char *array = \"Hello\" and then use &array though.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "So for integer, \"dbus_int32_t**\" is expected for example.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable.", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated.", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName .", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName .", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "element_type", "value", "n_elements"], "ret_type": "dbus_bool_t", "desc": "Appends a block of fixed-length values to an array.", "var_type": ["DBusMessageIter *", "int", "const void *", "int"]}, "sent": "Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree).", "paraph": "Appends a block of fixed-length values to an array. The fixed-length types are all basic types that are not string-like. So int32, double, bool, etc. (Unix file descriptors however are not supported.) You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function. You may call dbus_message_iter_append_fixed_array_APIName multiple times (and intermixed with calls to dbus_message_iter_append_basic_APIName ) for the same array. The \"value\" argument should be the address of the array. So for integer, \"dbus_int32_t**\" is expected for example. Warning in C, given \"int array[]\", \"&array == array\" (the comp.lang.c FAQ says otherwise, but gcc and the FAQ do not agree). So if you are using an array instead of a pointer you have to create a pointer variable, assign the array to it, then take the address of the pointer variable. For strings it works to write const char *array = \"Hello\" and then use &array though. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_append_fixed_array_APIParam_1 is the append iterator. dbus_message_iter_append_fixed_array_APIParam_2 is the type of the array elements. dbus_message_iter_append_fixed_array_APIParam_3 is the address of the array. dbus_message_iter_append_fixed_array_APIParam_4 is the number of elements to append. dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory", "key": "dbus_message_iter_append_fixed_array"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_close_container_APIParam_1 is the append iterator.", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_close_container_APIParam_2 is sub-iterator to close.", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "dbus_bool_t", "desc": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName .", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_close_container_APIName return FALSE if not enough memory", "paraph": "Closes a container-typed value appended to the message; may write out more information to the message known only after the entire container is written, and may free resources created by dbus_message_iter_open_container_APIName . Even if dbus_message_iter_close_container_APIName fails due to lack of memory, the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated. It must not be closed again with this function, or abandoned with dbus_message_iter_abandon_container_APIName . However, it remains valid to call dbus_message_iter_abandon_container_if_open_APIName . Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. dbus_message_iter_close_container_APIParam_1 is the append iterator. dbus_message_iter_close_container_APIParam_2 is sub-iterator to close. dbus_message_iter_close_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_close_container"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the argument type of the argument that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "Returns the argument type of the argument that the message iterator points to.", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "key": "dbus_message_iter_get_arg_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the argument type of the argument that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "If the iterator is at the end of the message, returns DBUS_TYPE_INVALID .", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "key": "dbus_message_iter_get_arg_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the argument type of the argument that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_arg_type_APIName return the argument type", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "key": "dbus_message_iter_get_arg_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the argument type of the argument that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1.", "paraph": "Returns the argument type of the argument that the message iterator points to. If the iterator is at the end of the message, returns DBUS_TYPE_INVALID . You can thus write a loop as follows: dbus_message_iter_get_arg_type_APIParam_1 is the message dbus_message_iter_get_arg_type_APIParam_1. dbus_message_iter_get_arg_type_APIName return the argument type", "key": "dbus_message_iter_get_arg_type"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "Returns the number of bytes in the array as marshaled in the wire protocol.", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "The iterator must currently be inside an array-typed value.", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid.", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "Use dbus_message_iter_get_element_count_APIName instead.", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "Why would you want to know how many bytes are in the array as marshaled in the wire protocol?", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_array_len_APIParam_1 is the iterator.", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter"], "ret_type": "DBUS_DEPRECATED int", "desc": "Returns the number of bytes in the array as marshaled in the wire protocol.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "paraph": "Returns the number of bytes in the array as marshaled in the wire protocol. The iterator must currently be inside an array-typed value. dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid. Why would you want to know how many bytes are in the array as marshaled in the wire protocol? Use dbus_message_iter_get_element_count_APIName instead. dbus_message_iter_get_array_len_APIParam_1 is the iterator. dbus_message_iter_get_array_len_APIName return the number of bytes in the array", "key": "dbus_message_iter_get_array_len"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "Basic types are the non-containers such as integer and string.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\".", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "This call duplicates Unix file descriptors when reading them.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "It is your job to close them when you do not need them anymore.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "If you need them without this flag set, make sure to unset it with fcntl_APIName.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName .", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName .", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "dbus_message_iter_get_basic_APIParam_1 is the iterator.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something.", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "Returns the number of elements in the array-typed value pointed to by the iterator.", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "key": "dbus_message_iter_get_element_count"}, {"API_info": {"var": ["iter", "value"], "ret_type": "void", "desc": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator.", "var_type": ["DBusMessageIter *", "void *"]}, "sent": "All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.)", "paraph": "Reads a basic-typed dbus_message_iter_get_basic_APIParam_2 from the message iterator. Basic types are the non-containers such as integer and string. The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0. So for int32 it should be a \"dbus_int32_t*\" and for string a \"const char**\". dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed. This call duplicates Unix file descriptors when reading them. It is your job to close them when you do not need them anymore. Unix file descriptors that are read with dbus_message_iter_get_basic_APIName will have the FD_CLOEXEC flag set. If you need them without this flag set, make sure to unset it with fcntl_APIName. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting, or you'll crash when you try to use an integer as a string or something. To read any container type (array, struct, dict) you will need to recurse into the container with dbus_message_iter_recurse_APIName . If the container is an array of fixed-length values (except Unix file descriptors), you can get all the array elements at once with dbus_message_iter_get_fixed_array_APIName . Otherwise, you have to iterate over the container contents one dbus_message_iter_get_basic_APIParam_2 at a time. All basic-typed values are guaranteed to fit in a DBusBasicValue , so in versions of libdbus that have that type, you can write code like this: (All D-Bus basic types are either numeric and 8 bytes or smaller, or behave like a string; so in older versions of libdbus, DBusBasicValue can be replaced with union { char *string; unsigned char bytes[8]; }, for instance.) dbus_message_iter_get_basic_APIParam_1 is the iterator. dbus_message_iter_get_basic_APIParam_2 is location to store the dbus_message_iter_get_basic_APIParam_2", "key": "dbus_message_iter_get_basic"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_element_count_APIParam_1 is the iterator.", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "key": "dbus_message_iter_get_element_count"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_element_count_APIName return the number of elements in the array", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "key": "dbus_message_iter_get_element_count"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the element type of the array that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "Returns the element type of the array that the message iterator points to.", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "key": "dbus_message_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the element type of the array that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1.", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "key": "dbus_message_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the element type of the array that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "Note that you need to check that the iterator points to an array prior to using this function.", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "key": "dbus_message_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the number of elements in the array-typed value pointed to by the iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it.", "paraph": "Returns the number of elements in the array-typed value pointed to by the iterator. Note that dbus_message_iter_get_element_count_APIName is O(1) for arrays of fixed-size types but O(n) for arrays of variable-length types such as strings, so it may be a bad idea to use it. dbus_message_iter_get_element_count_APIParam_1 is the iterator. dbus_message_iter_get_element_count_APIName return the number of elements in the array", "key": "dbus_message_iter_get_element_count"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the element type of the array that the message iterator points to.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_element_type_APIName return the array element type", "paraph": "Returns the element type of the array that the message iterator points to. Note that you need to check that the iterator points to an array prior to using this function. dbus_message_iter_get_element_type_APIParam_1 is the message dbus_message_iter_get_element_type_APIParam_1. dbus_message_iter_get_element_type_APIName return the array element type", "key": "dbus_message_iter_get_element_type"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "Reads a block of fixed-length values from the message iterator.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "Fixed-length values are those basic types that are not string-like, such as integers, bool, double.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ).", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "There is one exception here :  .", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "(However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.)", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "dbus_message_iter_get_fixed_array_APIParam_1 is the iterator.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block.", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": "dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter", "value", "n_elements"], "ret_type": "void", "desc": "Reads a block of fixed-length values from the message iterator.", "var_type": ["DBusMessageIter *", "void *", "int *"]}, "sent": " ; it is much preferred over walking the entire array with an iterator .", "paraph": "Reads a block of fixed-length values from the message iterator. Fixed-length values are those basic types that are not string-like, such as integers, bool, double. dbus_message_iter_get_fixed_array_APIParam_0 will be from the current position in the array until the end of the array. There is one exception here: although DBUS_TYPE_UNIX_FD is considered a 'fixed' type arrays of this type may not be read with this function. The message dbus_message_iter_get_fixed_array_APIParam_1 should be \"in\" the array (that is, you recurse into the array, and then you call dbus_message_iter_get_fixed_array_APIName on the \"sub-iterator\" created by dbus_message_iter_recurse_APIName ). The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0. So for int32 it should be a \"const dbus_int32_t**\" dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed. dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type. If an array elements are not fixed in size, you have to recurse into the array with dbus_message_iter_recurse_APIName and read the elements one by one. Because the array is not copied, dbus_message_iter_get_fixed_array_APIName runs in constant time and is fast; it is much preferred over walking the entire array with an iterator. (However, you can always use dbus_message_iter_recurse_APIName , even for fixed-length types; dbus_message_iter_get_fixed_array_APIName is just an optimization.) dbus_message_iter_get_fixed_array_APIParam_1 is the iterator. dbus_message_iter_get_fixed_array_APIParam_2 is location to store the block. dbus_message_iter_get_fixed_array_APIParam_3 is number of elements in the block", "key": "dbus_message_iter_get_fixed_array"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the current signature of a message iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "Returns the current signature of a message iterator.", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "key": "dbus_message_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the current signature of a message iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName .", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "key": "dbus_message_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the current signature of a message iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_signature_APIParam_1 is the message iterator.", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "key": "dbus_message_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the current signature of a message iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value.", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "key": "dbus_message_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the current signature of a message iterator.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "paraph": "Returns the current signature of a message iterator. This is useful primarily for dealing with variants; one can recurse into a variant and determine the signature of the variant value. dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName . dbus_message_iter_get_signature_APIParam_1 is the message iterator. dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory", "key": "dbus_message_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Checks if an iterator has any more fields.", "var_type": ["DBusMessageIter *"]}, "sent": "Checks if an iterator has any more fields.", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "key": "dbus_message_iter_has_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Checks if an iterator has any more fields.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1.", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "key": "dbus_message_iter_has_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Checks if an iterator has any more fields.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "paraph": "Checks if an iterator has any more fields. dbus_message_iter_has_next_APIParam_1 is the message dbus_message_iter_has_next_APIParam_1. dbus_message_iter_has_next_APIName return TRUE if there are more fields following", "key": "dbus_message_iter_has_next"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "When possible, dbus_message_get_args_APIName is much more convenient.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "Some types of argument can only be read with DBusMessageIter however.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "dbus_bool_t", "desc": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName.", "paraph": "Initializes a DBusMessageIter for reading the arguments of the dbus_message_iter_init_APIParam_1 passed in. When possible, dbus_message_get_args_APIName is much more convenient. Some types of argument can only be read with DBusMessageIter however. The easiest way to iterate is like this: DBusMessageIter contains no allocated memory; it need not be freed, and can be copied by assignment or memcpy_APIName. dbus_message_iter_init_APIParam_1 is the dbus_message_iter_init_APIParam_1. dbus_message_iter_init_APIParam_2 is pointer to an iterator to initialize. dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments", "key": "dbus_message_iter_init"}, {"API_info": {"var": ["message", "iter"], "ret_type": "void", "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "key": "dbus_message_iter_init_append"}, {"API_info": {"var": ["message", "iter"], "ret_type": "void", "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1.", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "key": "dbus_message_iter_init_append"}, {"API_info": {"var": ["message", "iter"], "ret_type": "void", "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "key": "dbus_message_iter_init_append"}, {"API_info": {"var": ["iter"], "ret_type": "void", "desc": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "var_type": ["DBusMessageIter *"]}, "sent": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "paraph": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED . The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "key": "dbus_message_iter_init_closed"}, {"API_info": {"var": ["message", "iter"], "ret_type": "void", "desc": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1.", "var_type": ["DBusMessage *", "DBusMessageIter *"]}, "sent": "Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1.", "paraph": "Initializes a DBusMessageIter for appending arguments to the end of a dbus_message_iter_init_append_APIParam_1. Todo: If appending any of the arguments fails due to lack of memory, the dbus_message_iter_init_append_APIParam_1 is hosed and you have to start over building the whole dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_1 is the dbus_message_iter_init_append_APIParam_1. dbus_message_iter_init_append_APIParam_2 is pointer to an iterator to initialize", "key": "dbus_message_iter_init_append"}, {"API_info": {"var": ["iter"], "ret_type": "void", "desc": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED .", "var_type": ["DBusMessageIter *"]}, "sent": "The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "paraph": "Initialize dbus_message_iter_init_closed_APIParam_1 as if with DBUS_MESSAGE_ITER_INIT_CLOSED . The only valid operation for such an iterator is dbus_message_iter_abandon_container_if_open_APIName , which does nothing", "key": "dbus_message_iter_init_closed"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Moves the iterator to the next field, if any.", "var_type": ["DBusMessageIter *"]}, "sent": "Moves the iterator to the next field, if any.", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "key": "dbus_message_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Moves the iterator to the next field, if any.", "var_type": ["DBusMessageIter *"]}, "sent": "If there no next field, returns FALSE .", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "key": "dbus_message_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Moves the iterator to the next field, if any.", "var_type": ["DBusMessageIter *"]}, "sent": "If the iterator moves forward, returns TRUE .", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "key": "dbus_message_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Moves the iterator to the next field, if any.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1.", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "key": "dbus_message_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Moves the iterator to the next field, if any.", "var_type": ["DBusMessageIter *"]}, "sent": "dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "paraph": "Moves the iterator to the next field, if any. If there no next field, returns FALSE . If the iterator moves forward, returns TRUE . dbus_message_iter_next_APIParam_1 is the message dbus_message_iter_next_APIParam_1. dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field", "key": "dbus_message_iter_next"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "Appends a container-typed value to the message.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "Container types are for example struct, variant, and array.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName .", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName .", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName .", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_open_container_APIParam_1 is the append iterator.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize.", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "type", "contained_signature", "sub"], "ret_type": "dbus_bool_t", "desc": "Appends a container-typed value to the message.", "var_type": ["DBusMessageIter *", "int", "const char *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_open_container_APIName return FALSE if not enough memory", "paraph": "Appends a container-typed value to the message. On success, you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator, and then call dbus_message_iter_close_container_APIName . Container types are for example struct, variant, and array. For variants, the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant. For structs and dict entries, dbus_message_iter_open_container_APIParam_3 should be NULL ; it will be set to whatever types you write into the struct. For arrays, dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements. Todo: If this fails due to lack of memory, the message is hosed and you have to start over building the whole message. If dbus_message_iter_open_container_APIName fails, the sub-iterator remains invalid, and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName . However, after dbus_message_iter_open_container_APIName has either succeeded or failed, it is valid to call dbus_message_iter_abandon_container_if_open_APIName . dbus_message_iter_open_container_APIParam_1 is the append iterator. dbus_message_iter_open_container_APIParam_2 is the dbus_message_iter_open_container_APIParam_2 of the value. dbus_message_iter_open_container_APIParam_3 is the dbus_message_iter_open_container_APIParam_2 of container contents. dbus_message_iter_open_container_APIParam_4 is sub-iterator to initialize. dbus_message_iter_open_container_APIName return FALSE if not enough memory", "key": "dbus_message_iter_open_container"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "There no array of int32 to recurse into.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Note that this recurses into a value, not a type, so you can only recurse if the value exists.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_recurse_APIParam_1 is the message iterator.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Locks a dbus_message_lock_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Locks a dbus_message_lock_APIParam_1.", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "key": "dbus_message_lock"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Locks a dbus_message_lock_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us.", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "key": "dbus_message_lock"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Locks a dbus_message_lock_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol.", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "key": "dbus_message_lock"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Locks a dbus_message_lock_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "key": "dbus_message_lock"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Locks a dbus_message_lock_APIParam_1.", "var_type": ["DBusMessage *"]}, "sent": "Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked.", "paraph": "Locks a dbus_message_lock_APIParam_1. Allows checking that applications do not keep a reference to a dbus_message_lock_APIParam_1 in the outgoing queue and change it underneath us. Messages are locked when they enter the outgoing queue (dbus_connection_send_message_APIName), and the library complains if the dbus_message_lock_APIParam_1 is modified while locked. dbus_message_lock_APIName may also called externally, for applications wrapping D-Bus in another protocol. dbus_message_lock_APIParam_1 is the dbus_message_lock_APIParam_1 to lock", "key": "dbus_message_lock"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol.", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "dbus_message_marshal_APIParam_1 is the DBusMessage.", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["iter", "sub"], "ret_type": "void", "desc": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container.", "var_type": ["DBusMessageIter *", "DBusMessageIter *"]}, "sent": "The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further.", "paraph": "Recurses into a container value when reading values from a message, initializing a sub-iterator to use for traversing the child values of the container. Note that this recurses into a value, not a type, so you can only recurse if the value exists. The main implication of this is that if you have for example an empty array of array of int32, you can recurse into the outermost array, but it will have no values, so you will not be able to recurse further. There no array of int32 to recurse into. If a container is an array of fixed-length types (except Unix file descriptors), it is much more efficient to use dbus_message_iter_get_fixed_array_APIName to get the whole array in one shot, rather than individually walking over the array elements. Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into. Results of dbus_message_iter_recurse_APIName are undefined if there is no container to recurse into at the current iterator position. dbus_message_iter_recurse_APIParam_1 is the message iterator. dbus_message_iter_recurse_APIParam_2 is the sub-iterator to initialize", "key": "dbus_message_iter_recurse"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "dbus_message_marshal_APIParam_2 is the location to save the marshalled form to.", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to.", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["msg", "marshalled_data_p", "len_p"], "ret_type": "dbus_bool_t", "desc": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification.", "var_type": ["DBusMessage *", "char **", "int *"]}, "sent": "dbus_message_marshal_APIName return FALSE if there was not enough memory", "paraph": "Turn a DBusMessage into the marshalled form as described in the D-Bus specification. Generally, dbus_message_marshal_APIName is only useful for encapsulating D-Bus messages in a different protocol. dbus_message_marshal_APIParam_1 is the DBusMessage. dbus_message_marshal_APIParam_2 is the location to save the marshalled form to. dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to. dbus_message_marshal_APIName return FALSE if there was not enough memory", "key": "dbus_message_marshal"}, {"API_info": {"var": ["message_type"], "ret_type": "DBusMessage *", "desc": "Constructs a new message of the given message type.", "var_type": ["int"]}, "sent": "Constructs a new message of the given message type.", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "key": "dbus_message_new"}, {"API_info": {"var": ["message_type"], "ret_type": "DBusMessage *", "desc": "Constructs a new message of the given message type.", "var_type": ["int"]}, "sent": "Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth.", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "key": "dbus_message_new"}, {"API_info": {"var": ["message_type"], "ret_type": "DBusMessage *", "desc": "Constructs a new message of the given message type.", "var_type": ["int"]}, "sent": "Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead.", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "key": "dbus_message_new"}, {"API_info": {"var": ["message_type"], "ret_type": "DBusMessage *", "desc": "Constructs a new message of the given message type.", "var_type": ["int"]}, "sent": "dbus_message_new_APIParam_1 is type of message.", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "key": "dbus_message_new"}, {"API_info": {"var": ["message_type"], "ret_type": "DBusMessage *", "desc": "Constructs a new message of the given message type.", "var_type": ["int"]}, "sent": "dbus_message_new_APIName return new message or NULL if no memory", "paraph": "Constructs a new message of the given message type. Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_SIGNAL , and so forth. Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead. dbus_message_new_APIParam_1 is type of message. dbus_message_new_APIName return new message or NULL if no memory", "key": "dbus_message_new"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "Creates a new message that is an error reply to another message.", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "Error replies are most common in response to method calls, but can be returned in reply to any message.", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "The error name must be a valid error name according to the syntax given in the D-Bus specification.", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "If you do not want to make up an error name just use DBUS_ERROR_FAILED .", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_new_error_APIParam_1 is the message we're replying to.", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_new_error_APIParam_2 is the error name.", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message).", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_message"], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message.", "var_type": ["DBusMessage *", "const char *", "const char *"]}, "sent": "dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "paraph": "Creates a new message that is an error reply to another message. Error replies are most common in response to method calls, but can be returned in reply to any message. The error name must be a valid error name according to the syntax given in the D-Bus specification. If you do not want to make up an error name just use DBUS_ERROR_FAILED . dbus_message_new_error_APIParam_1 is the message we're replying to. dbus_message_new_error_APIParam_2 is the error name. dbus_message_new_error_APIParam_3 is the error message string (or NULL for none, but please give a message). dbus_message_new_error_APIName return a new error message object, free with dbus_message_unref_APIName", "key": "dbus_message_new_error"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting.", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message.", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "dbus_message_new_error_printf_APIParam_2 is the error name.", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "dbus_message_new_error_printf_APIName return a new error message", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["reply_to", "error_name", "error_format", " ... "], "ret_type": "DBusMessage *", "desc": "Creates a new message that is an error reply to another message, allowing you to use printf formatting.", "var_type": ["DBusMessage *", "const char *", "const char *", " ... "]}, "sent": "dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments.", "paraph": "Creates a new message that is an error reply to another message, allowing you to use printf formatting. See dbus_message_new_error_APIName for details - dbus_message_new_error_printf_APIName is the same aside from the printf formatting. Todo: add _DBUS_GNUC_PRINTF to this (requires moving _DBUS_GNUC_PRINTF to public header, see DBUS_DEPRECATED for an example) dbus_message_new_error_printf_APIParam_1 is the original message. dbus_message_new_error_printf_APIParam_2 is the error name. dbus_message_new_error_printf_APIParam_3 is the error message format as with printf ... format string arguments. dbus_message_new_error_printf_APIName return a new error message", "key": "dbus_message_new_error_printf"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "Returns NULL if memory can not be allocated for the message.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL .", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus).", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification).", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_method_call_APIParam_3 is interface to invoke.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke.", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["destination", "path", "iface", "method"], "ret_type": "DBusMessage *", "desc": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object.", "var_type": ["const char *", "const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "paraph": "Constructs a new message to invoke a dbus_message_new_method_call_APIParam_4 on a remote object. Returns NULL if memory can not be allocated for the message. The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set; this is appropriate when using D-Bus in a peer-to-peer context (no message bus). The interface may be NULL , which means that if multiple methods with the given name exist it is undefined which one will be invoked. The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL . Destination, dbus_message_new_method_call_APIParam_2, interface, and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters (see the D-Bus specification). dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL. dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to. dbus_message_new_method_call_APIParam_3 is interface to invoke. dbus_message_new_method_call_APIParam_4 is on, or NULL dbus_message_new_method_call_APIParam_4 method to invoke. dbus_message_new_method_call_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_call"}, {"API_info": {"var": ["method_call"], "ret_type": "DBusMessage *", "desc": "Constructs a message that is a reply to a method call.", "var_type": ["DBusMessage *"]}, "sent": "Constructs a message that is a reply to a method call.", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_return"}, {"API_info": {"var": ["method_call"], "ret_type": "DBusMessage *", "desc": "Constructs a message that is a reply to a method call.", "var_type": ["DBusMessage *"]}, "sent": "Returns NULL if memory can not be allocated for the message.", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_return"}, {"API_info": {"var": ["method_call"], "ret_type": "DBusMessage *", "desc": "Constructs a message that is a reply to a method call.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_new_method_return_APIParam_1 is the message being replied to.", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_return"}, {"API_info": {"var": ["method_call"], "ret_type": "DBusMessage *", "desc": "Constructs a message that is a reply to a method call.", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "paraph": "Constructs a message that is a reply to a method call. Returns NULL if memory can not be allocated for the message. dbus_message_new_method_return_APIParam_1 is the message being replied to. dbus_message_new_method_return_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_method_return"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "Constructs a new message representing a signal emission.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "Returns NULL if memory can not be allocated for the message.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields).", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal.", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["path", "iface", "name"], "ret_type": "DBusMessage *", "desc": "Constructs a new message representing a signal emission.", "var_type": ["const char *", "const char *", "const char *"]}, "sent": "dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "paraph": "Constructs a new message representing a signal emission. Returns NULL if memory can not be allocated for the message. A signal is identified by its originating object dbus_message_new_signal_APIParam_1, interface, and the dbus_message_new_signal_APIParam_3 of the signal. Path, interface, and signal dbus_message_new_signal_APIParam_3 must all be valid (the D-Bus specification defines the syntax of these fields). dbus_message_new_signal_APIParam_1 is the dbus_message_new_signal_APIParam_1 to the object emitting the signal. dbus_message_new_signal_APIParam_2 is the interface the signal is emitted from. dbus_message_new_signal_APIParam_3 is dbus_message_new_signal_APIParam_3 of the signal. dbus_message_new_signal_APIName return a new DBusMessage , free with dbus_message_unref_APIName", "key": "dbus_message_new_signal"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Increments the reference count of a DBusMessage .", "var_type": ["DBusMessage *"]}, "sent": "Increments the reference count of a DBusMessage .", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "key": "dbus_message_ref"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Increments the reference count of a DBusMessage .", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1.", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "key": "dbus_message_ref"}, {"API_info": {"var": ["message"], "ret_type": "DBusMessage *", "desc": "Increments the reference count of a DBusMessage .", "var_type": ["DBusMessage *"]}, "sent": "dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "paraph": "Increments the reference count of a DBusMessage . dbus_message_ref_APIParam_1 is the dbus_message_ref_APIParam_1. dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref", "key": "dbus_message_ref"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION .", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set.", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1.", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used.", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly.", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "allow"], "ret_type": "void", "desc": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "paraph": "Sets a flag indicating that the caller of the method is prepared to wait for interactive authorization to take place (for instance via Polkit) before the actual method is processed. The flag is FALSE by default; that is, by default the other end is expected to make any authorization decisions non-interactively and promptly. It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that authorization failed, but could have succeeded if this flag had been used. For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set. On the protocol level this toggles DBUS_HEADER_FLAG_ALLOW_INTERACTIVE_AUTHORIZATION . dbus_message_set_allow_interactive_authorization_APIParam_1 is the dbus_message_set_allow_interactive_authorization_APIParam_1. dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE if interactive authorization is acceptable", "key": "dbus_message_set_allow_interactive_authorization"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "In case of failure, the reply will be an error.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "The flag is set to TRUE by default, i.e.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "auto starting is the default.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1.", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "auto_start"], "ret_type": "void", "desc": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "paraph": "Sets a flag indicating that an owner for the destination name will be automatically started before the dbus_message_set_auto_start_APIParam_1 is delivered. When this flag is set, the dbus_message_set_auto_start_APIParam_1 is held until a name owner finishes starting up, or fails to start up. In case of failure, the reply will be an error. The flag is set to TRUE by default, i.e. auto starting is the default. On the protocol level this toggles DBUS_HEADER_FLAG_NO_AUTO_START dbus_message_set_auto_start_APIParam_1 is the dbus_message_set_auto_start_APIParam_1. dbus_message_set_auto_start_APIParam_2 is TRUE if auto-starting is desired", "key": "dbus_message_set_auto_start"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "key": "dbus_message_set_container_instance"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1.", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "key": "dbus_message_set_container_instance"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The path must contain only valid characters for an object path as defined in the D-Bus specification.", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "key": "dbus_message_set_container_instance"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset.", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "key": "dbus_message_set_container_instance"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_container_instance_APIName return FALSE if not enough memory", "paraph": "Sets the container instance this dbus_message_set_container_instance_APIParam_1 was sent from. The path must contain only valid characters for an object path as defined in the D-Bus specification. dbus_message_set_container_instance_APIParam_1 is the dbus_message_set_container_instance_APIParam_1. dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset. dbus_message_set_container_instance_APIName return FALSE if not enough memory", "key": "dbus_message_set_container_instance"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName .", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1.", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number.", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store.", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3.", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized.", "var_type": ["DBusMessage *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "paraph": "Stores a pointer on a DBusMessage , along with an optional function to be used for freeing the dbus_message_set_data_APIParam_3 when the dbus_message_set_data_APIParam_3 is set again, or when the dbus_message_set_data_APIParam_1 is finalized. The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName . dbus_message_set_data_APIParam_1 is the dbus_message_set_data_APIParam_1. dbus_message_set_data_APIParam_2 is the dbus_message_set_data_APIParam_2 number. dbus_message_set_data_APIParam_3 is the dbus_message_set_data_APIParam_3 to store. dbus_message_set_data_APIParam_4 is finalizer function for the dbus_message_set_data_APIParam_3. dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3", "key": "dbus_message_set_data"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the message dbus_message_set_destination_APIParam_2.", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification.", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1.", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset.", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_destination_APIName return FALSE if not enough memory", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The name is fully-qualified (namespaced).", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "destination"], "ret_type": "dbus_bool_t", "desc": "Sets the message dbus_message_set_destination_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance.", "paraph": "Sets the message dbus_message_set_destination_APIParam_2. The dbus_message_set_destination_APIParam_2 is the name of another connection on the bus and may be either the unique name assigned by the bus to each connection, or a well-known name specified in advance. The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_destination_APIParam_1 is the dbus_message_set_destination_APIParam_1. dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset. dbus_message_set_destination_APIName return FALSE if not enough memory", "key": "dbus_message_set_destination"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1.", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The error name must contain only valid characters as defined in the D-Bus specification.", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_error_name_APIParam_2 is the name or NULL to unset.", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "error_name"], "ret_type": "dbus_bool_t", "desc": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_error_name_APIName return FALSE if not enough memory", "paraph": "Sets the name of the error (DBUS_MESSAGE_TYPE_ERROR). The name is fully-qualified (namespaced). The error name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_error_name_APIParam_1 is the dbus_message_set_error_name_APIParam_1. dbus_message_set_error_name_APIParam_2 is the name or NULL to unset. dbus_message_set_error_name_APIName return FALSE if not enough memory", "key": "dbus_message_set_error_name"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "key": "dbus_message_set_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The interface name must contain only valid characters as defined in the D-Bus specification.", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "key": "dbus_message_set_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1.", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "key": "dbus_message_set_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_interface_APIParam_2 is the interface or NULL to unset.", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "key": "dbus_message_set_interface"}, {"API_info": {"var": ["message", "iface"], "ret_type": "dbus_bool_t", "desc": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_interface_APIName return FALSE if not enough memory", "paraph": "Sets the interface this dbus_message_set_interface_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the interface a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The interface name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_interface_APIParam_1 is the dbus_message_set_interface_APIParam_1. dbus_message_set_interface_APIParam_2 is the interface or NULL to unset. dbus_message_set_interface_APIName return FALSE if not enough memory", "key": "dbus_message_set_interface"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "key": "dbus_message_set_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification.", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "key": "dbus_message_set_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1.", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "key": "dbus_message_set_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset.", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "key": "dbus_message_set_member"}, {"API_info": {"var": ["message", "member"], "ret_type": "dbus_bool_t", "desc": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_member_APIName return FALSE if not enough memory", "paraph": "Sets the interface dbus_message_set_member_APIParam_2 being invoked (DBUS_MESSAGE_TYPE_METHOD_CALL) or emitted (DBUS_MESSAGE_TYPE_SIGNAL). The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification. dbus_message_set_member_APIParam_1 is the dbus_message_set_member_APIParam_1. dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset. dbus_message_set_member_APIName return FALSE if not enough memory", "key": "dbus_message_set_member"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it.", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "If this flag is set , there is no way to know  .", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1.", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "The flag is FALSE by default, that is by default the other end is required to reply.", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The path must contain only valid characters as defined in the D-Bus specification.", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "key": "dbus_message_set_path"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1.", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "key": "dbus_message_set_path"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "key": "dbus_message_set_path"}, {"API_info": {"var": ["message", "no_reply"], "ret_type": "void", "desc": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "var_type": ["DBusMessage *", "dbus_bool_t"]}, "sent": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies.", "paraph": "Sets a flag indicating that the dbus_message_set_no_reply_APIParam_1 does not want a reply; if this flag is set, the other end of the connection may (but is not required to) optimize by not sending method return or error replies. If this flag is set, there is no way to know whether the dbus_message_set_no_reply_APIParam_1 successfully arrived at the remote end. Normally you know a dbus_message_set_no_reply_APIParam_1 was received when you receive the reply to it. The flag is FALSE by default, that is by default the other end is required to reply. On the protocol level this toggles DBUS_HEADER_FLAG_NO_REPLY_EXPECTED dbus_message_set_no_reply_APIParam_1 is the dbus_message_set_no_reply_APIParam_1. dbus_message_set_no_reply_APIParam_2 is TRUE if no reply is desired", "key": "dbus_message_set_no_reply"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_path_APIParam_2 is the path or NULL to unset.", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "key": "dbus_message_set_path"}, {"API_info": {"var": ["message", "object_path"], "ret_type": "dbus_bool_t", "desc": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL).", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_path_APIName return FALSE if not enough memory", "paraph": "Sets the object path this dbus_message_set_path_APIParam_1 is being sent to (for DBUS_MESSAGE_TYPE_METHOD_CALL) or the one a signal is being emitted from (for DBUS_MESSAGE_TYPE_SIGNAL). The path must contain only valid characters as defined in the D-Bus specification. dbus_message_set_path_APIParam_1 is the dbus_message_set_path_APIParam_1. dbus_message_set_path_APIParam_2 is the path or NULL to unset. dbus_message_set_path_APIName return FALSE if not enough memory", "key": "dbus_message_set_path"}, {"API_info": {"var": ["message", "reply_serial"], "ret_type": "dbus_bool_t", "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "key": "dbus_message_set_reply_serial"}, {"API_info": {"var": ["message", "reply_serial"], "ret_type": "dbus_bool_t", "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1.", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "key": "dbus_message_set_reply_serial"}, {"API_info": {"var": ["message", "reply_serial"], "ret_type": "dbus_bool_t", "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to.", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "key": "dbus_message_set_reply_serial"}, {"API_info": {"var": ["message", "reply_serial"], "ret_type": "dbus_bool_t", "desc": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to).", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "paraph": "Sets the reply serial of a dbus_message_set_reply_serial_APIParam_1 (the serial of the dbus_message_set_reply_serial_APIParam_1 this is a reply to). dbus_message_set_reply_serial_APIParam_1 is the dbus_message_set_reply_serial_APIParam_1. dbus_message_set_reply_serial_APIParam_2 is the serial we're replying to. dbus_message_set_reply_serial_APIName return FALSE if not enough memory", "key": "dbus_message_set_reply_serial"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "Usually you do not want to call this.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset.", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "sender"], "ret_type": "dbus_bool_t", "desc": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2.", "var_type": ["DBusMessage *", "const char *"]}, "sent": "dbus_message_set_sender_APIName return FALSE if not enough memory", "paraph": "Sets the dbus_message_set_sender_APIParam_1 dbus_message_set_sender_APIParam_2. The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification. Usually you do not want to call this. The dbus_message_set_sender_APIParam_1 bus daemon will call it to set the origin of each dbus_message_set_sender_APIParam_1. If you are not implementing a dbus_message_set_sender_APIParam_1 bus daemon you should not need to set the dbus_message_set_sender_APIParam_2. dbus_message_set_sender_APIParam_1 is the dbus_message_set_sender_APIParam_1. dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset. dbus_message_set_sender_APIName return FALSE if not enough memory", "key": "dbus_message_set_sender"}, {"API_info": {"var": ["message", "serial"], "ret_type": "void", "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "key": "dbus_message_set_serial"}, {"API_info": {"var": ["message", "serial"], "ret_type": "void", "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "This can only be done once on a dbus_message_set_serial_APIParam_1.", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "key": "dbus_message_set_serial"}, {"API_info": {"var": ["message", "serial"], "ret_type": "void", "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1.", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "key": "dbus_message_set_serial"}, {"API_info": {"var": ["message", "serial"], "ret_type": "void", "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "key": "dbus_message_set_serial"}, {"API_info": {"var": ["type_str"], "ret_type": "int", "desc": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "var_type": ["const char *"]}, "sent": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "paraph": "Utility function to convert a machine-readable (not translated) string into a D-Bus message type", "key": "dbus_message_type_from_string"}, {"API_info": {"var": ["message", "serial"], "ret_type": "void", "desc": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1.", "var_type": ["DBusMessage *", "dbus_uint32_t"]}, "sent": "DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection .", "paraph": "Sets the dbus_message_set_serial_APIParam_2 number of a dbus_message_set_serial_APIParam_1. This can only be done once on a dbus_message_set_serial_APIParam_1. DBusConnection will automatically set the dbus_message_set_serial_APIParam_2 to an appropriate value when the dbus_message_set_serial_APIParam_1 is sent; dbus_message_set_serial_APIName is only needed when encapsulating messages in another protocol, or otherwise bypassing DBusConnection . dbus_message_set_serial_APIParam_1 is the dbus_message_set_serial_APIParam_1. dbus_message_set_serial_APIParam_2 is the dbus_message_set_serial_APIParam_2", "key": "dbus_message_set_serial"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["message"], "ret_type": "void", "desc": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "var_type": ["DBusMessage *"]}, "sent": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "paraph": "Decrements the reference count of a DBusMessage , freeing the dbus_message_unref_APIParam_1 if the count reaches 0. dbus_message_unref_APIParam_1 is the dbus_message_unref_APIParam_1 See also dbus_message_ref", "key": "dbus_message_unref"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR .", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "The return value indicates  .", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from.", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["type"], "ret_type": "const char*", "desc": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "var_type": ["int"]}, "sent": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "paraph": "Utility function to convert a D-Bus message dbus_message_type_to_string_APIParam_1 into a machine-readable string (not translated", "key": "dbus_message_type_to_string"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set.", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "Returns the current type pointed to by the iterator.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["error", "message"], "ret_type": "dbus_bool_t", "desc": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2.", "var_type": ["DBusError *", "DBusMessage *"]}, "sent": "The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string.", "paraph": "Sets a DBusError based on the contents of the given dbus_set_error_from_message_APIParam_2. The dbus_set_error_from_message_APIParam_1 is only set if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2, as in DBUS_MESSAGE_TYPE_ERROR . The name of the dbus_set_error_from_message_APIParam_1 is set to the name of the dbus_set_error_from_message_APIParam_2, and the dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2 is set to the first argument if the argument exists and is a string. The return value indicates whether the dbus_set_error_from_message_APIParam_1 was set (the dbus_set_error_from_message_APIParam_1 is set if and only if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 message). So you can check for an dbus_set_error_from_message_APIParam_1 reply and convert it to DBusError in one go: dbus_set_error_from_message_APIParam_1 is the dbus_set_error_from_message_APIParam_1 to set. dbus_set_error_from_message_APIParam_2 is the dbus_set_error_from_message_APIParam_2 to set it from. dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR", "key": "dbus_set_error_from_message"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "If the iterator is pointing at a type code such as ', then the iterator will be returned directly.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "DBUS_TYPE_STRUCT, not '('.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_current_type_APIName return current type (e.g.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator.", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "key": "dbus_signature_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var_type": ["const DBusSignatureIter *"]}, "sent": "Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY .", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "key": "dbus_signature_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var_type": ["const DBusSignatureIter *"]}, "sent": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "key": "dbus_signature_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_element_type_APIName return current array element type", "paraph": "Convenience function for returning the element type of an array; dbus_signature_iter_get_element_type_APIName allows you to avoid initializing a sub-iterator and getting its current type. Undefined behavior results if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY . dbus_signature_iter_get_element_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_element_type_APIName return current array element type", "key": "dbus_signature_iter_get_element_type"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "Returns the signature of the single complete type starting at the given iterator.", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator.", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned.", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory.", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "Should be freed with dbus_free_APIName", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["iter", "signature"], "ret_type": "void", "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var_type": ["DBusSignatureIter *", "const char *"]}, "sent": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "key": "dbus_signature_iter_init"}, {"API_info": {"var": ["iter", "signature"], "ret_type": "void", "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var_type": ["DBusSignatureIter *", "const char *"]}, "sent": "dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize.", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "key": "dbus_signature_iter_init"}, {"API_info": {"var": ["iter", "signature"], "ret_type": "void", "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var_type": ["DBusSignatureIter *", "const char *"]}, "sent": "dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "key": "dbus_signature_iter_init"}, {"API_info": {"var": ["iter", "signature"], "ret_type": "void", "desc": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2.", "var_type": ["DBusSignatureIter *", "const char *"]}, "sent": "dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function.", "paraph": "Initializes a DBusSignatureIter for reading a type dbus_signature_iter_init_APIParam_2. dbus_signature_iter_init_APIName is not safe to use on invalid signatures; be sure to validate potentially invalid signatures with dbus_signature_validate before using this function. dbus_signature_iter_init_APIParam_1 is pointer to an iterator to initialize. dbus_signature_iter_init_APIParam_2 is the type dbus_signature_iter_init_APIParam_2", "key": "dbus_signature_iter_init"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "Skip to the next value on this \"level\".", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "e.g.", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "the next field in a struct, the next value in an array.", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "Returns FALSE at the end of the current container.", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "dbus_signature_iter_next_APIParam_1 is the iterator.", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter"], "ret_type": "dbus_bool_t", "desc": "Skip to the next value on this \"level\".", "var_type": ["DBusSignatureIter *"]}, "sent": "dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "paraph": "Skip to the next value on this \"level\". e.g. the next field in a struct, the next value in an array. Returns FALSE at the end of the current container. dbus_signature_iter_next_APIParam_1 is the iterator. dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level", "key": "dbus_signature_iter_next"}, {"API_info": {"var": ["iter", "subiter"], "ret_type": "void", "desc": "Initialize a new iterator pointing to the first type in the current container.", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"]}, "sent": "Initialize a new iterator pointing to the first type in the current container.", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "key": "dbus_signature_iter_recurse"}, {"API_info": {"var": ["iter", "subiter"], "ret_type": "void", "desc": "Initialize a new iterator pointing to the first type in the current container.", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"]}, "sent": "if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ).", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "key": "dbus_signature_iter_recurse"}, {"API_info": {"var": ["iter", "subiter"], "ret_type": "void", "desc": "Initialize a new iterator pointing to the first type in the current container.", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"]}, "sent": "dbus_signature_iter_recurse_APIParam_1 is the current interator.", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "key": "dbus_signature_iter_recurse"}, {"API_info": {"var": ["iter", "subiter"], "ret_type": "void", "desc": "Initialize a new iterator pointing to the first type in the current container.", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"]}, "sent": "dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "key": "dbus_signature_iter_recurse"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check a type dbus_signature_validate_APIParam_1 for validity.", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "key": "dbus_signature_validate"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1.", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "key": "dbus_signature_validate"}, {"API_info": {"var": ["iter"], "ret_type": "char *", "desc": "Returns the signature of the single complete type starting at the given iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned.", "paraph": "Returns the signature of the single complete type starting at the given iterator. For example, if the iterator is pointing at the start of \"(ii)ii\" (which is \"a struct of two ints, followed by an int, followed by an int\"), then \"(ii)\" would be returned. If the iterator is pointing at one of the \"i\" then just that \"i\" would be returned. dbus_signature_iter_get_signature_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_signature_APIName return current signature; or NULL if no memory. Should be freed with dbus_free_APIName", "key": "dbus_signature_iter_get_signature"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message.", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "key": "dbus_signature_validate"}, {"API_info": {"var": ["iter", "subiter"], "ret_type": "void", "desc": "Initialize a new iterator pointing to the first type in the current container.", "var_type": ["const DBusSignatureIter *", "DBusSignatureIter *"]}, "sent": "The results are undefined when calling this if the current type is a non-container (i.e.", "paraph": "Initialize a new iterator pointing to the first type in the current container. The results are undefined when calling this if the current type is a non-container (i.e. if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName ). dbus_signature_iter_recurse_APIParam_1 is the current interator. dbus_signature_iter_recurse_APIParam_2 is an iterator to initialize pointing to the first child", "key": "dbus_signature_iter_recurse"}, {"API_info": {"var": ["iter"], "ret_type": "int", "desc": "Returns the current type pointed to by the iterator.", "var_type": ["const DBusSignatureIter *"]}, "sent": "However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g.", "paraph": "Returns the current type pointed to by the iterator. If the iterator is pointing at a type code such as ', then the iterator will be returned directly. However, when the parser encounters a container type start character such as '(' for a structure, the corresponding type for the container will be returned, e.g. DBUS_TYPE_STRUCT, not '('. In this case, you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type. dbus_signature_iter_get_current_type_APIParam_1 is pointer to an iterator. dbus_signature_iter_get_current_type_APIName return current type (e.g. DBUS_TYPE_STRING , DBUS_TYPE_ARRAY", "key": "dbus_signature_iter_get_current_type"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return.", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "key": "dbus_signature_validate"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check a type dbus_signature_validate_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "paraph": "Check a type dbus_signature_validate_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError*, if you do not care about having an dbus_signature_validate_APIParam_2 name and message. dbus_signature_validate_APIParam_1 is a potentially invalid type dbus_signature_validate_APIParam_1. dbus_signature_validate_APIParam_2 is dbus_signature_validate_APIParam_2 return. dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set", "key": "dbus_signature_validate"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1.", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return.", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "`` One complete type '' means a single basic type , array , struct , or dictionary ,  .", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "DBUS_TYPE_INVALID is not a basic type.", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "So all numbers and strings are basic types and structs, arrays, and variants are not basic types.", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "dbus_type_is_basic_APIName return TRUE if type is basic", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "var_type": ["int"]}, "sent": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values.", "paraph": "A \"basic type\" is a somewhat arbitrary concept, but the intent is to include those types that are fully-specified by a single dbus_type_is_basic_APIParam_1, with no additional type information or nested values. So all numbers and strings are basic types and structs, arrays, and variants are not basic types. DBUS_TYPE_INVALID is not a basic type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_basic_APIName return TRUE if type is basic", "key": "dbus_type_is_basic"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "A \"container type\" can contain basic types, or nested container types.", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["signature", "error"], "ret_type": "dbus_bool_t", "desc": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type.", "var_type": ["const char *", "DBusError *"]}, "sent": "More than one complete type would mean for example \"ii\" or two integers in sequence.", "paraph": "Check that a type dbus_signature_validate_single_APIParam_1 is both valid and contains exactly one complete type. \"One complete type\" means a single basic type, array, struct, or dictionary, though the struct or array may be arbitrarily recursive and complex. More than one complete type would mean for example \"ii\" or two integers in sequence. dbus_signature_validate_single_APIParam_1 is a potentially invalid type dbus_signature_validate_single_APIParam_1. dbus_signature_validate_single_APIParam_2 is dbus_signature_validate_single_APIParam_2 return. dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type", "key": "dbus_signature_validate_single"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "DBUS_TYPE_INVALID is not a container type.", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "A \"container type\" can contain basic types, or nested container types.", "var_type": ["int"]}, "sent": "dbus_type_is_container_APIName return TRUE if type is a container", "paraph": "A \"container type\" can contain basic types, or nested container types. DBUS_TYPE_INVALID is not a container type. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_container_APIName return TRUE if type is a container", "key": "dbus_type_is_container"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "Tells you whether values of this type can change length if you set them to some other value.", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "dbus_type_is_fixed_APIName is useful to determine  .", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function.", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function.", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName .", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID.", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Tells you whether values of this type can change length if you set them to some other value.", "var_type": ["int"]}, "sent": "For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor.", "paraph": "Tells you whether values of this type can change length if you set them to some other value. For this purpose, you assume that the first byte of the old and new value would be in the same location, so alignment padding is not a factor. dbus_type_is_fixed_APIName is useful to determine whether dbus_message_iter_get_fixed_array_APIName may be used. Some structs are fixed-size (if they contain only fixed-size types) but struct is not considered a fixed type for purposes of this function. It is an error to pass an invalid type-code, other than DBUS_TYPE_INVALID, to this function. The valid type-codes are defined by dbus-protocol.h and can be checked with dbus_type_is_valid_APIName . dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID. dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths", "key": "dbus_type_is_fixed"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var_type": ["int"]}, "sent": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "key": "dbus_type_is_valid"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var_type": ["int"]}, "sent": "dbus_type_is_valid_APIName is safe with untrusted data.", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "key": "dbus_type_is_valid"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var_type": ["int"]}, "sent": "DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either.", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "key": "dbus_type_is_valid"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var_type": ["int"]}, "sent": "dbus_type_is_valid_APIParam_1 is a potential type-code.", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "key": "dbus_type_is_valid"}, {"API_info": {"var": ["typecode"], "ret_type": "dbus_bool_t", "desc": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1.", "var_type": ["int"]}, "sent": "dbus_type_is_valid_APIName return TRUE if valid", "paraph": "Return TRUE if the argument is a valid dbus_type_is_valid_APIParam_1. DBUS_TYPE_INVALID surprisingly enough is not considered valid, and random unknown bytes are not either. dbus_type_is_valid_APIName is safe with untrusted data. dbus_type_is_valid_APIParam_1 is a potential type-code. dbus_type_is_valid_APIName return TRUE if valid", "key": "dbus_type_is_valid"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "The slot must be initialized with -1.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated slot is global, i.e.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "all DBusServer objects will have a slot with the given integer ID reserved.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusServer .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_server_allocate_data_slot_APIName return FALSE on no memory", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusServer . The allocated ID may then be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName . The slot must be initialized with -1. If a nonnegative slot is passed in, the refcount is incremented on that slot, rather than creating a new slot. The allocated slot is global, i.e. all DBusServer objects will have a slot with the given integer ID reserved. dbus_server_allocate_data_slot_APIParam_1 is address of global variable storing the slot ID. dbus_server_allocate_data_slot_APIName return FALSE on no memory", "key": "dbus_server_allocate_data_slot"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Releases the server address and stops listening for new clients.", "var_type": ["DBusServer *"]}, "sent": "Releases the server address and stops listening for new clients.", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "key": "dbus_server_disconnect"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Releases the server address and stops listening for new clients.", "var_type": ["DBusServer *"]}, "sent": "If called more than once, only the first call has an effect.", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "key": "dbus_server_disconnect"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Releases the server address and stops listening for new clients.", "var_type": ["DBusServer *"]}, "sent": "Does not modify the server reference count.", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "key": "dbus_server_disconnect"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Releases the server address and stops listening for new clients.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "paraph": "Releases the server address and stops listening for new clients. If called more than once, only the first call has an effect. Does not modify the server reference count. dbus_server_disconnect_APIParam_1 is the dbus_server_disconnect_APIParam_1", "key": "dbus_server_disconnect"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for server data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Deallocates a global ID for server data slots.", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "key": "dbus_server_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for server data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot.", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "key": "dbus_server_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for server data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "key": "dbus_server_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for server data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "paraph": "Deallocates a global ID for server data slots. dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusServer objects will be freed when the server is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). dbus_server_free_data_slot_APIParam_1 is address of the slot to deallocate", "key": "dbus_server_free_data_slot"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1.", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "key": "dbus_server_get_address"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "key": "dbus_server_get_address"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_get_address_APIName return the address or NULL if no memory", "paraph": "Returns the address of the dbus_server_get_address_APIParam_1, as a newly-allocated string which must be freed by the caller. dbus_server_get_address_APIParam_1 is the dbus_server_get_address_APIParam_1. dbus_server_get_address_APIName return the address or NULL if no memory", "key": "dbus_server_get_address"}, {"API_info": {"var": ["server", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var_type": ["DBusServer *", "int"]}, "sent": "Retrieves data previously set with dbus_server_set_data_APIName .", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "key": "dbus_server_get_data"}, {"API_info": {"var": ["server", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var_type": ["DBusServer *", "int"]}, "sent": "The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed).", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "key": "dbus_server_get_data"}, {"API_info": {"var": ["server", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var_type": ["DBusServer *", "int"]}, "sent": "dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1.", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "key": "dbus_server_get_data"}, {"API_info": {"var": ["server", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var_type": ["DBusServer *", "int"]}, "sent": "dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from.", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "key": "dbus_server_get_data"}, {"API_info": {"var": ["server", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_server_set_data_APIName .", "var_type": ["DBusServer *", "int"]}, "sent": "dbus_server_get_data_APIName return the data, or NULL if not found", "paraph": "Retrieves data previously set with dbus_server_set_data_APIName . The dbus_server_get_data_APIParam_2 must still be allocated (must not have been freed). dbus_server_get_data_APIParam_1 is the dbus_server_get_data_APIParam_1. dbus_server_get_data_APIParam_2 is the dbus_server_get_data_APIParam_2 to get data from. dbus_server_get_data_APIName return the data, or NULL if not found", "key": "dbus_server_get_data"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases).", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "This is an ID unique to each DBusServer .", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "Remember that a DBusServer represents only one mode of connecting, so e.g.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification.", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "char *", "desc": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "paraph": "Returns the unique ID of the dbus_server_get_id_APIParam_1, as a newly-allocated string which must be freed by the caller. This ID is normally used by clients to tell when two DBusConnection would be equivalent (because the dbus_server_get_id_APIParam_1 address passed to dbus_connection_open_APIName will have the same guid in the two cases). dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection. This is an ID unique to each DBusServer . Remember that a DBusServer represents only one mode of connecting, so e.g. a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID. The ID is not a UUID in the sense of RFC4122; the details are explained in the D-Bus specification. dbus_server_get_id_APIParam_1 is the dbus_server_get_id_APIParam_1. dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory", "key": "dbus_server_get_id"}, {"API_info": {"var": ["server"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "var_type": ["DBusServer *"]}, "sent": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "paraph": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections. dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "key": "dbus_server_get_is_connected"}, {"API_info": {"var": ["server"], "ret_type": "dbus_bool_t", "desc": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections.", "var_type": ["DBusServer *"]}, "sent": "dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "paraph": "Returns TRUE if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections. dbus_server_get_is_connected_APIParam_1 is the dbus_server_get_is_connected_APIParam_1", "key": "dbus_server_get_is_connected"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Otherwise returns a new DBusServer .", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName .", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_server_listen_APIParam_2 is location to store reason for failure.", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusServer *", "desc": "Listens for new connections on the given dbus_server_listen_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "paraph": "Listens for new connections on the given dbus_server_listen_APIParam_1. If there are multiple semicolon-separated dbus_server_listen_APIParam_1 entries in the dbus_server_listen_APIParam_1, tries each one and listens on the first one that works. Returns NULL and sets dbus_server_listen_APIParam_2 if listening fails for any reason. Otherwise returns a new DBusServer . dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional. To free the server, applications must call first dbus_server_disconnect_APIName and then dbus_server_unref_APIName . dbus_server_listen_APIParam_1 is the dbus_server_listen_APIParam_1 of this server. dbus_server_listen_APIParam_2 is location to store reason for failure. dbus_server_listen_APIName return a new DBusServer , or NULL on failure", "key": "dbus_server_listen"}, {"API_info": {"var": ["server"], "ret_type": "DBusServer *", "desc": "Increments the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "Increments the reference count of a DBusServer .", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "key": "dbus_server_ref"}, {"API_info": {"var": ["server"], "ret_type": "DBusServer *", "desc": "Increments the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1.", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "key": "dbus_server_ref"}, {"API_info": {"var": ["server"], "ret_type": "DBusServer *", "desc": "Increments the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "paraph": "Increments the reference count of a DBusServer . dbus_server_ref_APIParam_1 is the dbus_server_ref_APIParam_1. dbus_server_ref_APIName return the dbus_server_ref_APIParam_1", "key": "dbus_server_ref"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called.", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior).", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2.", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1.", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2.", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "mechanisms"], "ret_type": "dbus_bool_t", "desc": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names.", "var_type": ["DBusServer *", "const char **"]}, "sent": "dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "paraph": "Sets the authentication dbus_server_set_auth_mechanisms_APIParam_2 that this dbus_server_set_auth_mechanisms_APIParam_1 offers to clients, as a NULL -terminated array of mechanism names. dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called. Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2 (this is the default behavior). The D-Bus specification describes some of the supported dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIParam_1 is the dbus_server_set_auth_mechanisms_APIParam_1. dbus_server_set_auth_mechanisms_APIParam_2 is NULL -terminated array of dbus_server_set_auth_mechanisms_APIParam_2. dbus_server_set_auth_mechanisms_APIName return FALSE if no memory", "key": "dbus_server_set_auth_mechanisms"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName .", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1.", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number.", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store.", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3.", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized.", "var_type": ["DBusServer *", "int", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "paraph": "Stores a pointer on a DBusServer , along with an optional function to be used for freeing the dbus_server_set_data_APIParam_3 when the dbus_server_set_data_APIParam_3 is set again, or when the dbus_server_set_data_APIParam_1 is finalized. The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName . dbus_server_set_data_APIParam_1 is the dbus_server_set_data_APIParam_1. dbus_server_set_data_APIParam_2 is the dbus_server_set_data_APIParam_2 number. dbus_server_set_data_APIParam_3 is the dbus_server_set_data_APIParam_3 to store. dbus_server_set_data_APIParam_4 is finalizer function for the dbus_server_set_data_APIParam_3. dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3", "key": "dbus_server_set_data"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "Otherwise, the connection will be unreferenced and closed.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "i.e.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler.", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections.", "var_type": ["DBusServer *", "DBusNewConnectionFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "paraph": "Sets a dbus_server_set_new_connection_function_APIParam_2 to be used for handling new connections. The given dbus_server_set_new_connection_function_APIParam_2 is passed each new connection as the connection is created. If the new connection dbus_server_set_new_connection_function_APIParam_2 increments the connection reference count, the connection will stay alive. Otherwise, the connection will be unreferenced and closed. The new connection dbus_server_set_new_connection_function_APIParam_2 may also close the connection itself, which is considered good form if the connection is not wanted. The connection here is private in the sense of dbus_connection_open_private_APIName , so if the new connection dbus_server_set_new_connection_function_APIParam_2 keeps a reference it must arrange for the connection to be closed. i.e. libdbus does not own this connection once the new connection dbus_server_set_new_connection_function_APIParam_2 takes a reference. dbus_server_set_new_connection_function_APIParam_1 is the dbus_server_set_new_connection_function_APIParam_1. dbus_server_set_new_connection_function_APIParam_2 is a dbus_server_set_new_connection_function_APIParam_2 to handle new connections. dbus_server_set_new_connection_function_APIParam_3 is dbus_server_set_new_connection_function_APIParam_3 to pass to the new connection handler. dbus_server_set_new_connection_function_APIParam_4 is dbus_server_set_new_connection_function_APIParam_2 to free the dbus_server_set_new_connection_function_APIParam_3", "key": "dbus_server_set_new_connection_function"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "These functions are responsible for making the application main loop aware of timeouts.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5.", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "paraph": "Sets the timeout functions for the dbus_server_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. dbus_server_set_timeout_functions_APIName behaves exactly like dbus_connection_set_timeout_functions_APIName ; see the documentation for that routine. dbus_server_set_timeout_functions_APIParam_1 is the dbus_server_set_timeout_functions_APIParam_1. dbus_server_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_server_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_server_set_timeout_functions_APIParam_4 is function to notify when the timeout is enabled/disabled. dbus_server_set_timeout_functions_APIParam_5 is dbus_server_set_timeout_functions_APIParam_5 to pass to dbus_server_set_timeout_functions_APIParam_2 and dbus_server_set_timeout_functions_APIParam_3. dbus_server_set_timeout_functions_APIParam_6 is function to be called to free the dbus_server_set_timeout_functions_APIParam_5. dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_timeout_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5.", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1.", "var_type": ["DBusServer *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "paraph": "Sets the watch functions for the dbus_server_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events. dbus_server_set_watch_functions_APIName behaves exactly like dbus_connection_set_watch_functions_APIName ; see the documentation for that routine. dbus_server_set_watch_functions_APIParam_1 is the dbus_server_set_watch_functions_APIParam_1. dbus_server_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_server_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_server_set_watch_functions_APIParam_4 is function to notify when the watch is enabled/disabled. dbus_server_set_watch_functions_APIParam_5 is dbus_server_set_watch_functions_APIParam_5 to pass to dbus_server_set_watch_functions_APIParam_2 and dbus_server_set_watch_functions_APIParam_3. dbus_server_set_watch_functions_APIParam_6 is function to be called to free the dbus_server_set_watch_functions_APIParam_5. dbus_server_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_server_set_watch_functions"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Decrements the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "Decrements the reference count of a DBusServer .", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "key": "dbus_server_unref"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Decrements the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero.", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "key": "dbus_server_unref"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Decrements the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero.", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "key": "dbus_server_unref"}, {"API_info": {"var": ["server"], "ret_type": "void", "desc": "Decrements the reference count of a DBusServer .", "var_type": ["DBusServer *"]}, "sent": "dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "paraph": "Decrements the reference count of a DBusServer . Finalizes the dbus_server_unref_APIParam_1 if the reference count reaches zero. The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero. dbus_server_unref_APIParam_1 is the dbus_server_unref_APIParam_1", "key": "dbus_server_unref"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL.", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return.", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message.", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_error_name_APIParam_1 is a potentially invalid.", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message.", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return.", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a bus dbus_validate_bus_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_bus_name_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check a bus dbus_validate_bus_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message. dbus_validate_bus_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1, which must not be NULL. dbus_validate_bus_name_APIParam_2 is dbus_validate_bus_name_APIParam_2 return. dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid", "key": "dbus_validate_bus_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL.", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return.", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message.", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_error_name_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message. dbus_validate_error_name_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_error_name_APIParam_1 is a potentially invalid. dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return. dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid", "key": "dbus_validate_error_name"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL.", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message.", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return.", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check an object dbus_validate_path_APIParam_1 for validity.", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check an interface dbus_validate_interface_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_interface_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check an interface dbus_validate_interface_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message. dbus_validate_interface_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1, which must not be NULL. dbus_validate_interface_APIParam_2 is dbus_validate_interface_APIParam_2 return. dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid", "key": "dbus_validate_interface"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL.", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return.", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message.", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Check a string for validity.", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Strings on D-Bus must be valid UTF-8.", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["name", "error"], "ret_type": "dbus_bool_t", "desc": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_member_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check a member (method/signal) dbus_validate_member_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message. dbus_validate_member_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1, which must not be NULL. dbus_validate_member_APIParam_2 is dbus_validate_member_APIParam_2 return. dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid", "key": "dbus_validate_member"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL.", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return.", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message.", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "Adds a message filter.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "Filters are run in the order that they were added.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName .", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["path", "error"], "ret_type": "dbus_bool_t", "desc": "Check an object dbus_validate_path_APIParam_1 for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_path_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check an object dbus_validate_path_APIParam_1 for validity. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_path_APIParam_2 name and message. dbus_validate_path_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1, which must not be NULL. dbus_validate_path_APIParam_2 is dbus_validate_path_APIParam_2 return. dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid", "key": "dbus_validate_path"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "Filters added during a filter callback will not be run on the message being processed.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "The same handler can be added as a filter more than once, in which case it will be run more than once.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "This is probably a feature, as filters could create arbitrary reentrancy.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "But kind of sucks if you are trying to filter METHOD_RETURN for some reason.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "Todo : we do not run filters on messages while blocking without entering the main loop ,  .", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["alleged_utf8", "error"], "ret_type": "dbus_bool_t", "desc": "Check a string for validity.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_validate_utf8_APIName is suitable for validating C strings , but is not suitable for validating untrusted data from a network unless the string length is also checked ,  .", "paraph": "Check a string for validity. Strings on D-Bus must be valid UTF-8. Remember that NULL can always be passed instead of a DBusError *, if you do not care about having an dbus_validate_utf8_APIParam_2 name and message. dbus_validate_utf8_APIName is suitable for validating C strings, but is not suitable for validating untrusted data from a network unless the string length is also checked, since it assumes that the string ends at the first zero byte according to normal C conventions. dbus_validate_utf8_APIParam_1 is a string to be checked, which must not be NULL. dbus_validate_utf8_APIParam_2 is dbus_validate_utf8_APIParam_2 return. dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8", "key": "dbus_validate_utf8"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data.", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["connection", "function", "user_data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Adds a message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "paraph": "Adds a message filter. Filters are handlers that are run on all incoming messages, prior to the objects registered with dbus_connection_register_object_path_APIName . Filters are run in the order that they were added. The same handler can be added as a filter more than once, in which case it will be run more than once. Filters added during a filter callback will not be run on the message being processed. Todo: we do not run filters on messages while blocking without entering the main loop, since filters are run as part of dbus_connection_dispatch_APIName . This is probably a feature, as filters could create arbitrary reentrancy. But kind of sucks if you are trying to filter METHOD_RETURN for some reason. dbus_connection_add_filter_APIParam_1 is the dbus_connection_add_filter_APIParam_1. dbus_connection_add_filter_APIParam_2 is dbus_connection_add_filter_APIParam_2 to handle messages. dbus_connection_add_filter_APIParam_3 is user data to pass to the dbus_connection_add_filter_APIParam_2. dbus_connection_add_filter_APIParam_4 is dbus_connection_add_filter_APIParam_2 to use for freeing user data. dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory", "key": "dbus_connection_add_filter"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName .", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "The passed-in slot must be initialized to -1, and is filled in with the slot ID.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "The allocated slot is global, i.e.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "all DBusConnection objects will have a slot with the given integer ID reserved.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot.", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "dbus_bool_t", "desc": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection .", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "paraph": "Allocates an integer ID to be used for storing application-specific data on any DBusConnection . The allocated ID may then be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName . The passed-in slot must be initialized to -1, and is filled in with the slot ID. If the passed-in slot is not -1, it is assumed to be already allocated, and its refcount is incremented. The allocated slot is global, i.e. all DBusConnection objects will have a slot with the given integer ID reserved. dbus_connection_allocate_data_slot_APIParam_1 is address of a global variable storing the slot. dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory", "key": "dbus_connection_allocate_data_slot"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "If the queue is empty, returns NULL .", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName .", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "If you need to keep the message, make a copy of it.", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName .", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it.", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1.", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_borrow_message_APIName return next message in the incoming queue", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, leaving it in the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time.", "paraph": "Returns the first-received message from the incoming message queue, leaving it in the queue. If the queue is empty, returns NULL . The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName . No one can get at the message while its borrowed, so return it as quickly as possible and do not keep a reference to it after returning it. If you need to keep the message, make a copy of it. dbus_connection_dispatch_APIName will block if called while a borrowed message is outstanding; only one piece of code can be playing with the incoming queue at a time. dbus_connection_borrow_message_APIName will block if called during a dbus_connection_dispatch_APIName . dbus_connection_borrow_message_APIParam_1 is the dbus_connection_borrow_message_APIParam_1. dbus_connection_borrow_message_APIName return next message in the incoming queue", "key": "dbus_connection_borrow_message"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "it will return FALSE for all types this implementation does not know, including invalid or reserved types.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check.", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection", "type"], "ret_type": "dbus_bool_t", "desc": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1.", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "paraph": "Tests whether a certain dbus_connection_can_send_type_APIParam_2 can be send via the dbus_connection_can_send_type_APIParam_1. This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD. The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this. dbus_connection_can_send_type_APIName can be used to do runtime checking for types that might be unknown to the specific D-Bus client implementation version, i.e. it will return FALSE for all types this implementation does not know, including invalid or reserved types. dbus_connection_can_send_type_APIParam_1 is the dbus_connection_can_send_type_APIParam_1. dbus_connection_can_send_type_APIParam_2 is the dbus_connection_can_send_type_APIParam_2 to check. dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1", "key": "dbus_connection_can_send_type"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_close_APIName does not affect the connection reference count.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "You may not close a shared dbus_connection_close_APIParam_1.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "These connections are owned by libdbus, and applications should only unref them, never close them.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Applications can know it is safe to unref these connections  as the dbus_connection_close_APIParam_1 is open .", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Processes any incoming data.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received.", "var_type": ["DBusConnection *"]}, "sent": "The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected.", "paraph": "Closes a private dbus_connection_close_APIParam_1, so no further data can be sent or received. This disconnects the transport (such as a socket) underlying the dbus_connection_close_APIParam_1. Attempts to send messages after closing a dbus_connection_close_APIParam_1 are safe, but will result in error replies generated locally in libdbus. dbus_connection_close_APIName does not affect the connection reference count. it is safe to close a dbus_connection_close_APIParam_1 more than once; all calls after the first do nothing. it is impossible to \"reopen\" a dbus_connection_close_APIParam_1, a new dbus_connection_close_APIParam_1 must be created. dbus_connection_close_APIName may result in a call to the DBusDispatchStatusFunction set with dbus_connection_set_dispatch_status_function_APIName , as the disconnect message it generates needs to be dispatched. If a dbus_connection_close_APIParam_1 is dropped by the remote application, it will close itself. You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1. If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1, the results are undefined; it is a bug in your program and libdbus will try to print a warning. You may not close a shared dbus_connection_close_APIParam_1. Connections created with dbus_connection_open_APIName or dbus_bus_get_APIName are shared. These connections are owned by libdbus, and applications should only unref them, never close them. Applications can know it is safe to unref these connections because libdbus will be holding a reference as long as the dbus_connection_close_APIParam_1 is open. Thus, either the dbus_connection_close_APIParam_1 is closed and it is OK to drop the last reference, or the dbus_connection_close_APIParam_1 is open and the app knows it does not have the last reference. Connections created with dbus_connection_open_private_APIName or dbus_bus_get_private_APIName are not kept track of or referenced by libdbus. The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference, if the dbus_connection_close_APIParam_1 is not already disconnected. dbus_connection_close_APIParam_1 is the private (unshared) dbus_connection_close_APIParam_1 to close", "key": "dbus_connection_close"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket).", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName .", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Processing has three steps.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Second, any filters registered with dbus_connection_add_filter_APIName are run.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "First , any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName  .", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "calling dbus_connection_dispatch_APIName recursively.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Processes any incoming data.", "var_type": ["DBusConnection *"]}, "sent": "If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application.", "paraph": "Processes any incoming data. If there incoming raw data that has not yet been parsed, it is parsed, which may or may not result in adding messages to the incoming queue. The incoming data buffer is filled when the dbus_connection_dispatch_APIParam_1 reads from its underlying transport (such as a socket). Reading usually happens in dbus_watch_handle_APIName or dbus_connection_read_write_APIName . If there are complete messages in the incoming queue, dbus_connection_dispatch_APIName removes one message from the queue and processes it. Processing has three steps. First, any method replies are passed to DBusPendingCall or dbus_connection_send_with_reply_and_block_APIName in order to complete the pending method call. Second, any filters registered with dbus_connection_add_filter_APIName are run. If any filter returns DBUS_HANDLER_RESULT_HANDLED then processing stops after that filter. Third, if the message is a method call it is forwarded to any registered object path handlers added with dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . A single call to dbus_connection_dispatch_APIName will process at most one message; it will not clear the entire message queue. Be careful about calling dbus_connection_dispatch_APIName from inside a message handler, i.e. calling dbus_connection_dispatch_APIName recursively. If threads have been initialized with a recursive mutex function, then this will not deadlock; however, it can certainly confuse your application. Todo: some FIXME in here about handling DBUS_HANDLER_RESULT_NEED_MEMORY dbus_connection_dispatch_APIParam_1 is the dbus_connection_dispatch_APIParam_1. dbus_connection_dispatch_APIName dispatch status, see dbus_connection_get_dispatch_status_APIName", "key": "dbus_connection_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Blocks until the outgoing message queue is empty.", "var_type": ["DBusConnection *"]}, "sent": "Blocks until the outgoing message queue is empty.", "paraph": "Blocks until the outgoing message queue is empty. dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "key": "dbus_connection_flush"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Blocks until the outgoing message queue is empty.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "paraph": "Blocks until the outgoing message queue is empty. dbus_connection_flush_APIParam_1 is the dbus_connection_flush_APIParam_1", "key": "dbus_connection_flush"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for connection data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Deallocates a global ID for connection data slots.", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_connection_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for connection data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot.", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_connection_free_data_slot"}, {"API_info": {"var": ["connection", "preallocated"], "ret_type": "void", "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"]}, "sent": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "key": "dbus_connection_free_preallocated_send"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for connection data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot).", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_connection_free_data_slot"}, {"API_info": {"var": ["slot_p"], "ret_type": "void", "desc": "Deallocates a global ID for connection data slots.", "var_type": ["dbus_int32_t *"]}, "sent": "When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "paraph": "Deallocates a global ID for connection data slots. dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot. Existing data stored on existing DBusConnection objects will be freed when the connection is finalized, but may not be retrieved (and may only be replaced if someone else reallocates the slot). When the refcount on the passed-in slot reaches 0, it is set to -1. dbus_connection_free_data_slot_APIParam_1 is address storing the slot to deallocate", "key": "dbus_connection_free_data_slot"}, {"API_info": {"var": ["connection", "preallocated"], "ret_type": "void", "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"]}, "sent": "dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1.", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "key": "dbus_connection_free_preallocated_send"}, {"API_info": {"var": ["connection", "preallocated"], "ret_type": "void", "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"]}, "sent": "Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message.", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "key": "dbus_connection_free_preallocated_send"}, {"API_info": {"var": ["connection", "preallocated"], "ret_type": "void", "desc": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName .", "var_type": ["DBusConnection *", "DBusPreallocatedSend *"]}, "sent": "dbus_connection_free_preallocated_send_APIParam_2 is the resources", "paraph": "Frees dbus_connection_free_preallocated_send_APIParam_2 message-sending resources from dbus_connection_preallocate_send_APIName . Should only be called if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message. dbus_connection_free_preallocated_send_APIParam_1 is the dbus_connection_free_preallocated_send_APIParam_1. dbus_connection_free_preallocated_send_APIParam_2 is the resources", "key": "dbus_connection_free_preallocated_send"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2.", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "data", "data_size"], "ret_type": "dbus_bool_t", "desc": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any.", "var_type": ["DBusConnection *", "void **", "dbus_int32_t *"]}, "sent": "dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "paraph": "Gets the ADT audit dbus_connection_get_adt_audit_session_data_APIParam_2 of the dbus_connection_get_adt_audit_session_data_APIParam_1 if any. Returns TRUE if the structure pointerbe returned by dbus_connection_get_adt_audit_session_data_APIName. Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_1 is the dbus_connection_get_adt_audit_session_data_APIParam_1. dbus_connection_get_adt_audit_session_data_APIParam_2 is return location for audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIParam_3 is return location for length of audit dbus_connection_get_adt_audit_session_data_APIParam_2. dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer", "key": "dbus_connection_get_adt_audit_session_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "Retrieves data previously set with dbus_connection_set_data_APIName .", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed).", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "(See the note in docs for dbus_connection_set_watch_functions_APIName .)", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions.", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1.", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from.", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "dbus_connection_get_data_APIName return the data, or NULL if not found", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "Gets the current state of the incoming message queue.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection", "slot"], "ret_type": "void *", "desc": "Retrieves data previously set with dbus_connection_set_data_APIName .", "var_type": ["DBusConnection *", "dbus_int32_t"]}, "sent": "A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName .", "paraph": "Retrieves data previously set with dbus_connection_set_data_APIName . The dbus_connection_get_data_APIParam_2 must still be allocated (must not have been freed). Note dbus_connection_get_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_get_data_APIParam_1 while invoking dbus_connection_get_data_APIName , or the dbus_connection_get_data_APIParam_1 could be finalized during dbus_connection_get_data_APIName . dbus_connection_get_data_APIParam_1 is the dbus_connection_get_data_APIParam_1. dbus_connection_get_data_APIParam_2 is the dbus_connection_get_data_APIParam_2 to get data from. dbus_connection_get_data_APIName return the data, or NULL if not found", "key": "dbus_connection_get_data"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName .", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "When these bytes are parsed, they may not add up to an entire message.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1.", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_dispatch_status_APIName return current dispatch status", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "DBusDispatchStatus", "desc": "Gets the current state of the incoming message queue.", "var_type": ["DBusConnection *"]}, "sent": "In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1 ,  .", "paraph": "Gets the current state of the incoming message queue. DBUS_DISPATCH_DATA_REMAINS indicates that the message queue may contain messages. DBUS_DISPATCH_COMPLETE indicates that the incoming queue is empty. DBUS_DISPATCH_NEED_MEMORY indicates that there could be data, but we can not know for sure without more memory. To process the incoming message queue, use dbus_connection_dispatch_APIName or (in rare cases) dbus_connection_pop_message_APIName . Note, DBUS_DISPATCH_DATA_REMAINS really means that either we have messages in the queue, or we have raw bytes buffered up that need to be parsed. When these bytes are parsed, they may not add up to an entire message. Thus, it is possible to see a status of DBUS_DISPATCH_DATA_REMAINS but not have a message yet. In particular this happens on initial dbus_connection_get_dispatch_status_APIParam_1, because all sorts of authentication protocol stuff has to be parsed before the first message arrives. dbus_connection_get_dispatch_status_APIParam_1 is the dbus_connection_get_dispatch_status_APIParam_1. dbus_connection_get_dispatch_status_APIName return current dispatch status", "key": "dbus_connection_get_dispatch_status"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "(Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .)", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "If it is authenticated as a specific user, then this returns FALSE .", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE .", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "only allow the ANONYMOUS mechanism).", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as.", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1.", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var_type": ["DBusConnection *"]}, "sent": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "key": "dbus_connection_get_is_authenticated"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var_type": ["DBusConnection *"]}, "sent": "(Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1.", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "key": "dbus_connection_get_is_authenticated"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "paraph": "Gets whether the dbus_connection_get_is_authenticated_APIParam_1 was authenticated. (Note that if the dbus_connection_get_is_authenticated_APIParam_1 was authenticated then disconnected, dbus_connection_get_is_authenticated_APIName still returns TRUE ) dbus_connection_get_is_authenticated_APIParam_1 is the dbus_connection_get_is_authenticated_APIParam_1. dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated", "key": "dbus_connection_get_is_authenticated"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous.", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not.", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName .", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1.", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "paraph": "Gets whether the dbus_connection_get_is_connected_APIParam_1 is currently open. A dbus_connection_get_is_connected_APIParam_1 may become disconnected when the remote application closes its end, or exits; a dbus_connection_get_is_connected_APIParam_1 may also be disconnected with dbus_connection_close_APIName . There are not separate states for \"closed\" and \"disconnected,\" the two terms are synonymous. dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not. dbus_connection_get_is_connected_APIParam_1 is the dbus_connection_get_is_connected_APIParam_1. dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive", "key": "dbus_connection_get_is_connected"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "key": "dbus_connection_get_max_message_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1.", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "key": "dbus_connection_get_max_message_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_message_size_APIName return the max size of a single message", "paraph": "Gets the value set by dbus_connection_set_max_message_size_APIName . dbus_connection_get_max_message_size_APIParam_1 is the dbus_connection_get_max_message_size_APIParam_1. dbus_connection_get_max_message_size_APIName return the max size of a single message", "key": "dbus_connection_get_max_message_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "key": "dbus_connection_get_max_message_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1.", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "key": "dbus_connection_get_max_message_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user.", "var_type": ["DBusConnection *"]}, "sent": "If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e.", "paraph": "Gets whether the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated as a specific user. If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE . If it is authenticated as a specific user, then this returns FALSE . (Note that if the dbus_connection_get_is_anonymous_APIParam_1 was authenticated as anonymous then disconnected, dbus_connection_get_is_anonymous_APIName still returns TRUE .) If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous, you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as. If you want to prevent non-anonymous authorization, use dbus_server_set_auth_mechanisms_APIName to remove the mechanisms that allow proving user identity (i.e. only allow the ANONYMOUS mechanism). dbus_connection_get_is_anonymous_APIParam_1 is the dbus_connection_get_is_anonymous_APIParam_1. dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous", "key": "dbus_connection_get_is_anonymous"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "paraph": "Gets the value set by dbus_connection_set_max_message_unix_fds_APIName . dbus_connection_get_max_message_unix_fds_APIParam_1 is the dbus_connection_get_max_message_unix_fds_APIParam_1. dbus_connection_get_max_message_unix_fds_APIName return the max numer of unix fds of a single message", "key": "dbus_connection_get_max_message_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "key": "dbus_connection_get_max_received_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1.", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "key": "dbus_connection_get_max_received_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_size_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_received_size_APIName return the max size of all live messages", "paraph": "Gets the value set by dbus_connection_set_max_received_size_APIName . dbus_connection_get_max_received_size_APIParam_1 is the dbus_connection_get_max_received_size_APIParam_1. dbus_connection_get_max_received_size_APIName return the max size of all live messages", "key": "dbus_connection_get_max_received_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "key": "dbus_connection_get_max_received_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1.", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "key": "dbus_connection_get_max_received_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "paraph": "Gets the value set by dbus_connection_set_max_received_unix_fds_APIName . dbus_connection_get_max_received_unix_fds_APIParam_1 is the dbus_connection_get_max_received_unix_fds_APIParam_1. dbus_connection_get_max_received_unix_fds_APIName return the max unix fds of all live messages", "key": "dbus_connection_get_max_received_unix_fds"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1.", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL .", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with.", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL.", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection", "path", "data_p"], "ret_type": "dbus_bool_t", "desc": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName .", "var_type": ["DBusConnection *", "const char *", "void **"]}, "sent": "dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "paraph": "Gets the user data passed to dbus_connection_register_object_path_APIName or dbus_connection_register_fallback_APIName . If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2, the data is filled in with NULL . dbus_connection_get_object_path_data_APIParam_1 is the dbus_connection_get_object_path_data_APIParam_1. dbus_connection_get_object_path_data_APIParam_2 is the dbus_connection_get_object_path_data_APIParam_2 you registered with. dbus_connection_get_object_path_data_APIParam_3 is location to store the user data, or NULL. dbus_connection_get_object_path_data_APIName return FALSE if not enough memory", "key": "dbus_connection_get_object_path_data"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "key": "dbus_connection_get_outgoing_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1.", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "key": "dbus_connection_get_outgoing_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "key": "dbus_connection_get_outgoing_size"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1.", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "key": "dbus_connection_get_outgoing_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "key": "dbus_connection_get_outgoing_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate number of uni fds of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "paraph": "Gets the approximate number of uni fds of all messages in the outgoing message queue. dbus_connection_get_outgoing_unix_fds_APIParam_1 is the dbus_connection_get_outgoing_unix_fds_APIParam_1. dbus_connection_get_outgoing_unix_fds_APIName return the number of unix fds that have been queued up but not sent", "key": "dbus_connection_get_outgoing_unix_fds"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "The only way to be sure the server ID is available is to wait for authentication to complete.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "In general, each mode of connecting to a given server will have its own ID.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "long", "desc": "Gets the approximate size in bytes of all messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead.", "paraph": "Gets the approximate size in bytes of all messages in the outgoing message queue. The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature, as optimizations may choose to tell small white lies to avoid performance overhead. dbus_connection_get_outgoing_size_APIParam_1 is the dbus_connection_get_outgoing_size_APIParam_1. dbus_connection_get_outgoing_size_APIName return the number of bytes that have been queued up but not sent", "key": "dbus_connection_get_outgoing_size"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus).", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "The D-Bus specification describes the server ID and other IDs in a bit more detail.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end.", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection"], "ret_type": "char *", "desc": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "paraph": "Gets the ID of the server address we are authenticated to, if this dbus_connection_get_server_id_APIParam_1 is on the client side. If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side. If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet, the ID may be available if it was included in the server address, but may not be available. The only way to be sure the server ID is available is to wait for authentication to complete. In general, each mode of connecting to a given server will have its own ID. So for example, if the session bus daemon is listening on UNIX domain sockets and on TCP, then each of those modalities will have its own server ID. If you want an ID that identifies an entire session bus, look at dbus_bus_get_id_APIName instead (which is just a convenience wrapper around the org.freedesktop.DBus.GetId method invoked on the bus). You can also get a machine ID; see dbus_try_get_local_machine_id_APIName to get the machine you are on. There is not a convenience wrapper, but you can invoke org.freedesktop.DBus.Peer.GetMachineId on any peer to get the machine ID on the other end. The D-Bus specification describes the server ID and other IDs in a bit more detail. dbus_connection_get_server_id_APIParam_1 is the dbus_connection_get_server_id_APIParam_1. dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side", "key": "dbus_connection_get_server_id"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "Not all connections will have a socket.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "i.e.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_socket_APIName always returns specifically a socket file descriptor.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "If the dbus_connection_get_socket_APIParam_1 is not socket-based , dbus_connection_get_socket_APIName will return FALSE ,  .", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_socket_APIParam_2 is return location for the file descriptor.", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "paraph": "Gets the underlying Windows or UNIX socket file descriptor of the dbus_connection_get_socket_APIParam_1, if any. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a socket. So for adding descriptors to the main loop, use dbus_watch_get_socket_APIName and so forth. If the dbus_connection_get_socket_APIParam_1 is not socket-based, dbus_connection_get_socket_APIName will return FALSE, even if the dbus_connection_get_socket_APIParam_1 does have a file descriptor of some kind. i.e. dbus_connection_get_socket_APIName always returns specifically a socket file descriptor. dbus_connection_get_socket_APIParam_1 is the dbus_connection_get_socket_APIParam_1. dbus_connection_get_socket_APIParam_2 is return location for the file descriptor. dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained", "key": "dbus_connection_get_socket"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "This can be used for SELinux access control checks with getpeercon_APIName for example.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "Not all connections will have a file descriptor.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_unix_fd_APIName always fails on Windows.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor.", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "fd"], "ret_type": "dbus_bool_t", "desc": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any.", "var_type": ["DBusConnection *", "int *"]}, "sent": "dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "paraph": "Get the UNIX file descriptor of the dbus_connection_get_unix_fd_APIParam_1, if any. This can be used for SELinux access control checks with getpeercon_APIName for example. DO NOT read or write to the file descriptor, or try to select_APIName on it; use DBusWatch for main loop integration. Not all connections will have a file descriptor. So for adding descriptors to the main loop, use dbus_watch_get_unix_fd_APIName and so forth. If the dbus_connection_get_unix_fd_APIParam_1 is socket-based, you can also use dbus_connection_get_socket_APIName , which will work on Windows too. dbus_connection_get_unix_fd_APIName always fails on Windows. Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket, but that is not guaranteed. dbus_connection_get_unix_fd_APIParam_1 is the dbus_connection_get_unix_fd_APIParam_1. dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor. dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained", "key": "dbus_connection_get_unix_fd"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in.", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1.", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1.", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID.", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "pid"], "ret_type": "dbus_bool_t", "desc": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "paraph": "Gets the process ID of the dbus_connection_get_unix_process_id_APIParam_1 if any. Returns TRUE if the dbus_connection_get_unix_process_id_APIParam_2 is filled in. Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_1 is the dbus_connection_get_unix_process_id_APIParam_1. dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID. dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID", "key": "dbus_connection_get_unix_process_id"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "Always returns FALSE on non-UNIX platforms for now ,  .", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "The message bus is a server and the apps connecting to the bus are clients.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "The UID is only read by servers from clients ; clients can not usually get the UID of servers ,  .", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_user_APIParam_2 is return location for the user ID.", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName .", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "uid"], "ret_type": "dbus_bool_t", "desc": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "unsigned long *"]}, "sent": "dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "paraph": "Gets the UNIX user ID of the dbus_connection_get_unix_user_APIParam_1 if known. Returns TRUE if the dbus_connection_get_unix_user_APIParam_2 is filled in. Always returns FALSE on non-UNIX platforms for now, though in theory someone could hook Windows to NIS or something. Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1. The UID is only read by servers from clients; clients can not usually get the UID of servers, because servers do not authenticate to clients. dbus_connection_get_unix_user_APIParam_0 is the UID the dbus_connection_get_unix_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 though if you like; this is done with dbus_bus_get_unix_user_APIName . dbus_connection_get_unix_user_APIParam_1 is the dbus_connection_get_unix_user_APIParam_1. dbus_connection_get_unix_user_APIParam_2 is return location for the user ID. dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID", "key": "dbus_connection_get_unix_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "Returns TRUE if the ID is filled in.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "Always returns FALSE on non-Windows platforms for now ,  .", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName .", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "The message bus is a server and the apps connecting to the bus are clients.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "The user is only read by servers from clients ; clients can not usually get the user of servers ,  .", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway  .", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory.", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Checks whether there are messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "Checks whether there are messages in the outgoing message queue.", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "key": "dbus_connection_has_messages_to_send"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "Todo : We would like to be able to say `` You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1  like ; this is done with dbus_bus_get_windows_user_APIName . ''", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Checks whether there are messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1.", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "key": "dbus_connection_has_messages_to_send"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Checks whether there are messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket).", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "key": "dbus_connection_has_messages_to_send"}, {"API_info": {"var": ["connection"], "ret_type": "dbus_bool_t", "desc": "Checks whether there are messages in the outgoing message queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "paraph": "Checks whether there are messages in the outgoing message queue. Use dbus_connection_flush_APIName to block until all outgoing messages have been written to the underlying transport (such as a socket). dbus_connection_has_messages_to_send_APIParam_1 is the dbus_connection_has_messages_to_send_APIParam_1. dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty", "key": "dbus_connection_has_messages_to_send"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "The return value indicates  ; if it is available but we do not have the memory to copy it , then the return value is TRUE and NULL is given as the SID .", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName .", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1.", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of.", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children.", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["connection", "parent_path", "child_entries"], "ret_type": "dbus_bool_t", "desc": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "char ***"]}, "sent": "dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "paraph": "Lists the registered fallback handlers and object path handlers at the given dbus_connection_list_registered_APIParam_2. dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName . dbus_connection_list_registered_APIParam_1 is the dbus_connection_list_registered_APIParam_1. dbus_connection_list_registered_APIParam_2 is the path to list the child handlers of. dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children. dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries", "key": "dbus_connection_list_registered"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["connection", "windows_sid_p"], "ret_type": "dbus_bool_t", "desc": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known.", "var_type": ["DBusConnection *", "char **"]}, "sent": "dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "paraph": "Gets the Windows user SID of the dbus_connection_get_windows_user_APIParam_1 if known. Returns TRUE if the ID is filled in. Always returns FALSE on non-Windows platforms for now, though in theory someone could hook UNIX to Active Directory or something. Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1. The user is only read by servers from clients; clients can not usually get the user of servers, because servers do not authenticate to clients. dbus_connection_get_windows_user_APIParam_0 is the user the dbus_connection_get_windows_user_APIParam_1 authenticated as. The message bus is a server and the apps connecting to the bus are clients. dbus_connection_get_windows_user_APIParam_0 has to be freed with dbus_free_APIName . The return value indicates whether the user SID is available; if it is available but we do not have the memory to copy it, then the return value is TRUE and NULL is given as the SID. Todo: We would like to be able to say \"You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 though if you like; this is done with dbus_bus_get_windows_user_APIName.\" But this has to be implemented in bus/driver.c and dbus/dbus-bus.c , and is pointless anyway since on Windows we only use the session bus for now. dbus_connection_get_windows_user_APIParam_1 is the dbus_connection_get_windows_user_APIParam_1. dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory. dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory", "key": "dbus_connection_get_windows_user"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName .", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": " , no user of the connection may call dbus_connection_close_APIName .", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "However, when you are done with the connection you should call dbus_connection_unref_APIName .", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server.", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Gets a connection to a remote dbus_connection_open_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_APIName return new connection, or NULL on failure", "paraph": "Gets a connection to a remote dbus_connection_open_APIParam_1. If a connection to the given dbus_connection_open_APIParam_1 already exists, returns the existing connection with its reference count incremented. Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server. Use dbus_connection_open_private_APIName to get a dedicated connection not shared with other callers of dbus_connection_open_APIName . If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter. Pass NULL for the dbus_connection_open_APIParam_2 parameter if you are not interested in the reason for failure. Because this connection is shared, no user of the connection may call dbus_connection_close_APIName . However, when you are done with the connection you should call dbus_connection_unref_APIName . Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_APIParam_1 is the dbus_connection_open_APIParam_1. dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned. dbus_connection_open_APIName return new connection, or NULL on failure", "key": "dbus_connection_open"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Unlike dbus_connection_open_APIName , always creates a new connection.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "This connection will not be saved or recycled by libdbus.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "(The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.)", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_connection_open_private_APIName return new connection, or NULL on failure", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["address", "error"], "ret_type": "DBusConnection *", "desc": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1.", "var_type": ["const char *", "DBusError *"]}, "sent": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server.", "paraph": "Opens a new, dedicated connection to a remote dbus_connection_open_private_APIParam_1. Unlike dbus_connection_open_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter. Pass NULL for the dbus_connection_open_private_APIParam_2 parameter if you are not interested in the reason for failure. When you are done with this connection, you must dbus_connection_close_APIName to disconnect it, and dbus_connection_unref_APIName to free the connection object. (The dbus_connection_close_APIName can be skipped if the connection is already known to be disconnected, for example if you are inside a handler for the Disconnected signal.) Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason; connections are expensive enough that it is wasteful to create lots of connections to the same server. dbus_connection_open_private_APIParam_1 is the dbus_connection_open_private_APIParam_1. dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned. dbus_connection_open_private_APIName return new connection, or NULL on failure", "key": "dbus_connection_open_private"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "The caller owns a reference to dbus_connection_pop_message_APIParam_0.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "Returns the first-received message from the incoming message queue, removing it from the queue.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "If the queue is empty, returns NULL .", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "Instead, let the main loop invoke dbus_connection_dispatch_APIName .", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "will all block while one of the others in the group is running.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc.", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusMessage *", "desc": "Returns the first-received message from the incoming message queue, removing it from the queue.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_pop_message_APIName return next message in the incoming queue", "paraph": "Returns the first-received message from the incoming message queue, removing it from the queue. The caller owns a reference to dbus_connection_pop_message_APIParam_0. If the queue is empty, returns NULL . dbus_connection_pop_message_APIName bypasses any message handlers that are registered, and so using it is usually wrong. Instead, let the main loop invoke dbus_connection_dispatch_APIName . Popping messages manually is only useful in very simple programs that do not share a DBusConnection with any libraries or other modules. There is a lock that covers all ways of accessing the incoming message queue, so dbus_connection_dispatch_APIName , dbus_connection_pop_message_APIName , dbus_connection_borrow_message_APIName , etc. will all block while one of the others in the group is running. dbus_connection_pop_message_APIParam_1 is the dbus_connection_pop_message_APIParam_1. dbus_connection_pop_message_APIName return next message in the incoming queue", "key": "dbus_connection_pop_message"}, {"API_info": {"var": ["connection"], "ret_type": "DBusPreallocatedSend *", "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var_type": ["DBusConnection *"]}, "sent": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "key": "dbus_connection_preallocate_send"}, {"API_info": {"var": ["connection"], "ret_type": "DBusPreallocatedSend *", "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for.", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "key": "dbus_connection_preallocate_send"}, {"API_info": {"var": ["connection"], "ret_type": "DBusPreallocatedSend *", "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var_type": ["DBusConnection *"]}, "sent": "Allows apps to create a future guarantee that they can send a message regardless of memory shortages.", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "key": "dbus_connection_preallocate_send"}, {"API_info": {"var": ["connection"], "ret_type": "DBusPreallocatedSend *", "desc": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "paraph": "Preallocates resources needed to send a message, allowing the message to be sent without the possibility of memory allocation failure. Allows apps to create a future guarantee that they can send a message regardless of memory shortages. dbus_connection_preallocate_send_APIParam_1 is the dbus_connection_preallocate_send_APIParam_1 we're preallocating for. dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL", "key": "dbus_connection_preallocate_send"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE .", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "The return value indicates  , i.e.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "whether the dbus_connection_read_write_APIParam_1 is connected.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE .", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "Note that even after disconnection, messages may remain in the incoming queue that need to be processed.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite.", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_APIName return TRUE if still connected", "paraph": "dbus_connection_read_write_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . See also dbus_connection_read_write_dispatch_APIName . As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, then read or write, then return TRUE . If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE . The return value indicates whether reading or writing is still possible, i.e. whether the dbus_connection_read_write_APIParam_1 is connected. Note that even after disconnection, messages may remain in the incoming queue that need to be processed. dbus_connection_read_write_dispatch_APIName dispatches incoming messages for you; with dbus_connection_read_write_APIName you have to arrange to drain the incoming queue yourself. dbus_connection_read_write_APIParam_1 is the dbus_connection_read_write_APIParam_1. dbus_connection_read_write_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_APIName return TRUE if still connected", "key": "dbus_connection_read_write"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "The return value indicates  .", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "This is important  .", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages.", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout .", "var_type": ["DBusConnection *", "int"]}, "sent": "dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "paraph": "dbus_connection_read_write_dispatch_APIName is intended for use with applications that do not want to write a main loop and deal with DBusWatch and DBusTimeout . An example usage would be: In this usage you would normally have set up a filter function to look at each message as it is dispatched. The loop terminates when the last message from the dbus_connection_read_write_dispatch_APIParam_1 (the disconnected signal) is processed. If there are messages to dispatch, dbus_connection_read_write_dispatch_APIName will dbus_connection_dispatch_APIName once, and return. If there are no messages to dispatch, dbus_connection_read_write_dispatch_APIName will block until it can read or write, then read or write, then return. The way to think of dbus_connection_read_write_dispatch_APIName is that it either makes some sort of progress, or it blocks. Note that, while it is blocked on I/O, it cannot be interrupted (even by other threads), which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just react to received messages. The return value indicates whether the disconnect message has been processed, NOT whether the dbus_connection_read_write_dispatch_APIParam_1 is connected. This is important because even after disconnecting, you want to process any messages you received prior to the disconnect. dbus_connection_read_write_dispatch_APIParam_1 is the dbus_connection_read_write_dispatch_APIParam_1. dbus_connection_read_write_dispatch_APIParam_2 is max time to block or -1 for infinite. dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed", "key": "dbus_connection_read_write_dispatch"}, {"API_info": {"var": ["connection"], "ret_type": "DBusConnection *", "desc": "Increments the reference count of a DBusConnection .", "var_type": ["DBusConnection *"]}, "sent": "Increments the reference count of a DBusConnection .", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "key": "dbus_connection_ref"}, {"API_info": {"var": ["connection"], "ret_type": "DBusConnection *", "desc": "Increments the reference count of a DBusConnection .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1.", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "key": "dbus_connection_ref"}, {"API_info": {"var": ["connection"], "ret_type": "DBusConnection *", "desc": "Increments the reference count of a DBusConnection .", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "paraph": "Increments the reference count of a DBusConnection . dbus_connection_ref_APIParam_1 is the dbus_connection_ref_APIParam_1. dbus_connection_ref_APIName return the dbus_connection_ref_APIParam_1", "key": "dbus_connection_ref"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "Registers a fallback handler for a given subsection of the object hierarchy.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "You can use this to establish a default message handling policy for a whole \"subdirectory.\"", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "Use dbus_connection_try_register_fallback_APIName if this might be the case.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_fallback_APIParam_3 is the virtual table.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" It is a bug to call dbus_connection_register_fallback_APIName for object paths which already have a handler. Use dbus_connection_try_register_fallback_APIName if this might be the case. dbus_connection_register_fallback_APIParam_1 is the dbus_connection_register_fallback_APIParam_1. dbus_connection_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_register_fallback_APIParam_2 elements. dbus_connection_register_fallback_APIParam_3 is the virtual table. dbus_connection_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_register_fallback_APIParam_3. dbus_connection_register_fallback_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) occured", "key": "dbus_connection_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "Use dbus_connection_try_register_object_path_APIName if this might be the case.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_object_path_APIParam_3 is the virtual table.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "Removes a previously-added message filter.", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *"]}, "sent": "dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements.", "paraph": "Registers a handler for a given dbus_connection_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_register_object_path_APIParam_2. It is a bug to call dbus_connection_register_object_path_APIName for object paths which already have a handler. Use dbus_connection_try_register_object_path_APIName if this might be the case. dbus_connection_register_object_path_APIParam_1 is the dbus_connection_register_object_path_APIParam_1. dbus_connection_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_register_object_path_APIParam_2 elements. dbus_connection_register_object_path_APIParam_3 is the virtual table. dbus_connection_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_register_object_path_APIParam_3. dbus_connection_register_object_path_APIName return FALSE if an error ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) ocurred", "key": "dbus_connection_register_object_path"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1.", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter.", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance).", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "dbus_connection_remove_filter_APIParam_2 is the handler to remove.", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "function", "user_data"], "ret_type": "void", "desc": "Removes a previously-added message filter.", "var_type": ["DBusConnection *", "DBusHandleMessageFunction", "void *"]}, "sent": "dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "paraph": "Removes a previously-added message filter. It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter. If the given handler was added more than once, only one instance of it will be removed (the most recently-added instance). dbus_connection_remove_filter_APIParam_1 is the dbus_connection_remove_filter_APIParam_1. dbus_connection_remove_filter_APIParam_2 is the handler to remove. dbus_connection_remove_filter_APIParam_3 is user data for the handler to remove", "key": "dbus_connection_remove_filter"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_return_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL .", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_return_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1.", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_return_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "paraph": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName . Only called if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non- NULL . dbus_connection_return_message_APIParam_1 is the dbus_connection_return_message_APIParam_1. dbus_connection_return_message_APIParam_2 is the dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_return_message"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": " , no error will be returned .", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "If the function fails due to lack of memory, it returns FALSE .", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_APIName return TRUE on success", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "The function will never fail for other reasons ;  , you can queue an outgoing dbus_connection_send_APIParam_2 ,  .", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "message", "serial"], "ret_type": "dbus_bool_t", "desc": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue.", "var_type": ["DBusConnection *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care.", "paraph": "Adds a dbus_connection_send_APIParam_2 to the outgoing dbus_connection_send_APIParam_2 queue. Does not block to write the dbus_connection_send_APIParam_2 to the network; that happens asynchronously. To force the dbus_connection_send_APIParam_2 to be written, call dbus_connection_flush_APIName however it is not necessary to call dbus_connection_flush_APIName by hand; the dbus_connection_send_APIParam_2 will be sent the next time the main loop is run. dbus_connection_flush_APIName should only be used, for example, if the application was expected to exit before running the main loop. Because this only queues the dbus_connection_send_APIParam_2, the only reason it can fail is lack of memory. Even if the dbus_connection_send_APIParam_1 is disconnected, no error will be returned. If the function fails due to lack of memory, it returns FALSE . The function will never fail for other reasons; even if the dbus_connection_send_APIParam_1 is disconnected, you can queue an outgoing dbus_connection_send_APIParam_2, though obviously it will not be sent. The dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3 is used by the remote application to send a reply; see dbus_message_get_serial_APIName or the D-Bus specification. dbus_message_unref_APIName can be called as soon as this method returns as the dbus_connection_send_APIParam_2 queue will hold its own ref until the dbus_connection_send_APIParam_2 is sent. dbus_connection_send_APIParam_1 is the dbus_connection_send_APIParam_1. dbus_connection_send_APIParam_2 is the dbus_connection_send_APIParam_2 to write. dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care. dbus_connection_send_APIName return TRUE on success", "key": "dbus_connection_send"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIName cannot fail.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "It works identically to dbus_connection_send_APIName in other respects.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "Preallocated resources comes from dbus_connection_preallocate_send_APIName .", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send.", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "preallocated", "message", "client_serial"], "ret_type": "void", "desc": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources.", "var_type": ["DBusConnection *", "DBusPreallocatedSend *", "DBusMessage *", "dbus_uint32_t *"]}, "sent": "dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "paraph": "Sends a dbus_connection_send_preallocated_APIParam_3 using dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIName cannot fail. It works identically to dbus_connection_send_APIName in other respects. Preallocated resources comes from dbus_connection_preallocate_send_APIName . dbus_connection_send_preallocated_APIName \"consumes\" the dbus_connection_send_preallocated_APIParam_2 resources, they need not be freed separately. dbus_connection_send_preallocated_APIParam_1 is the dbus_connection_send_preallocated_APIParam_1. dbus_connection_send_preallocated_APIParam_2 is the dbus_connection_send_preallocated_APIParam_2 resources. dbus_connection_send_preallocated_APIParam_3 is the dbus_connection_send_preallocated_APIParam_3 to send. dbus_connection_send_preallocated_APIParam_4 is return location for client serial assigned to the dbus_connection_send_preallocated_APIParam_3", "key": "dbus_connection_send_preallocated"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "See dbus_connection_dispatch_APIName for details on when handlers are run.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName .", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName .", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "If -1 is passed for the timeout, a sane default timeout is used.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "-1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "messages other than the reply are queued up but not processed.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "pending_return", "timeout_milliseconds"], "ret_type": "dbus_bool_t", "desc": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2.", "var_type": ["DBusConnection *", "DBusMessage *", "DBusPendingCall **", "int"]}, "sent": "dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them.", "paraph": "Queues a dbus_connection_send_with_reply_APIParam_2 to send, as with dbus_connection_send_APIName , but also returns a DBusPendingCall used to receive a reply to the dbus_connection_send_with_reply_APIParam_2. If no reply is received in the given dbus_connection_send_with_reply_APIParam_4, dbus_connection_send_with_reply_APIName expires the pending reply and generates a synthetic error reply (generated in-process, not by the remote application) indicating that a timeout occurred. A DBusPendingCall will see a reply dbus_connection_send_with_reply_APIParam_2 before any filters or registered object path handlers. See dbus_connection_dispatch_APIName for details on when handlers are run. A DBusPendingCall will always see exactly one reply dbus_connection_send_with_reply_APIParam_2, unless it is cancelled with dbus_pending_call_cancel_APIName . If NULL is passed for the dbus_connection_send_with_reply_APIParam_3, the DBusPendingCall will still be generated internally, and used to track the dbus_connection_send_with_reply_APIParam_2 reply timeout. This means a timeout error will occur if no reply arrives, unlike with dbus_connection_send_APIName . If -1 is passed for the timeout, a sane default timeout is used. -1 is typically the best value for the timeout for this reason, unless you want a very short or very long timeout. If DBUS_TIMEOUT_INFINITE is passed for the timeout, no timeout will be set and the call will block forever. Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them, the DBusPendingCall will be set to NULL , so be careful with this. dbus_connection_send_with_reply_APIParam_1 is the dbus_connection_send_with_reply_APIParam_1. dbus_connection_send_with_reply_APIParam_2 is the dbus_connection_send_with_reply_APIParam_2 to send. dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them. dbus_connection_send_with_reply_APIParam_4 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise", "key": "dbus_connection_send_with_reply"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY .", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED .", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "This means you can end up deadlocked if the application you are talking to needs you to reply to a method.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout.", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "message", "timeout_milliseconds", "error"], "ret_type": "DBusMessage *", "desc": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply.", "var_type": ["DBusConnection *", "DBusMessage *", "int", "DBusError *"]}, "sent": "dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "paraph": "Sends a dbus_connection_send_with_reply_and_block_APIParam_2 and blocks a certain time period while waiting for a reply. dbus_connection_send_with_reply_and_block_APIName does not reenter the main loop, i.e. messages other than the reply are queued up but not processed. dbus_connection_send_with_reply_and_block_APIName is used to invoke method calls on a remote object. If a normal reply is received, itbe returned by dbus_connection_send_with_reply_and_block_APIName, and removed from the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. If it is not received, NULLbe returned by dbus_connection_send_with_reply_and_block_APIName and the dbus_connection_send_with_reply_and_block_APIParam_4 is set to DBUS_ERROR_NO_REPLY . If an dbus_connection_send_with_reply_and_block_APIParam_4 reply is received, it is converted to a DBusError and returned as an dbus_connection_send_with_reply_and_block_APIParam_4, then the reply dbus_connection_send_with_reply_and_block_APIParam_2 is deleted and NULLbe returned by dbus_connection_send_with_reply_and_block_APIName. If something else goes wrong, result is set to whatever is appropriate, such as DBUS_ERROR_NO_MEMORY or DBUS_ERROR_DISCONNECTED . Warning While dbus_connection_send_with_reply_and_block_APIName blocks the calling thread will not be processing the incoming dbus_connection_send_with_reply_and_block_APIParam_2 queue. This means you can end up deadlocked if the application you are talking to needs you to reply to a method. To solve this, either avoid the situation, block in a separate thread from the main connection-dispatching thread, or use dbus_pending_call_set_notify_APIName to avoid blocking. dbus_connection_send_with_reply_and_block_APIParam_1 is the dbus_connection_send_with_reply_and_block_APIParam_1. dbus_connection_send_with_reply_and_block_APIParam_2 is the dbus_connection_send_with_reply_and_block_APIParam_2 to send. dbus_connection_send_with_reply_and_block_APIParam_3 is timeout in milliseconds, -1 (or DBUS_TIMEOUT_USE_DEFAULT ) for default or DBUS_TIMEOUT_INFINITE for no timeout. dbus_connection_send_with_reply_and_block_APIParam_4 is return location for dbus_connection_send_with_reply_and_block_APIParam_4 dbus_connection_send_with_reply_and_block_APIParam_2. dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails", "key": "dbus_connection_send_with_reply_and_block"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "clients can connect anonymously.", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ).", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "If set to TRUE , then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed ", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "If anonymous connections are allowed, however, then any user identity is allowed.", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1.", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work.", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName .", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["will_modify_sigpipe"], "ret_type": "void", "desc": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN.", "var_type": ["dbus_bool_t"]}, "sent": "dbus_connection_set_change_sigpipe_APIName sets a global flag for  .", "paraph": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN. dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "key": "dbus_connection_set_change_sigpipe"}, {"API_info": {"var": ["will_modify_sigpipe"], "ret_type": "void", "desc": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN.", "var_type": ["dbus_bool_t"]}, "sent": "dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "paraph": "dbus_connection_set_change_sigpipe_APIName sets a global flag for whether dbus_connection_new_APIName will set SIGPIPE behavior to SIG_IGN. dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN", "key": "dbus_connection_set_change_sigpipe"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName .", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "(See the note in docs for dbus_connection_set_watch_functions_APIName .)", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3.", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName .", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "slot", "data", "free_data_func"], "ret_type": "dbus_bool_t", "desc": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized.", "var_type": ["DBusConnection *", "dbus_int32_t", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "paraph": "Stores a pointer on a DBusConnection , along with an optional function to be used for freeing the dbus_connection_set_data_APIParam_3 when the dbus_connection_set_data_APIParam_3 is set again, or when the dbus_connection_set_data_APIParam_1 is finalized. The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName . Note dbus_connection_set_data_APIName does not take the main thread lock on DBusConnection , which allows it to be used from inside watch and timeout functions. (See the note in docs for dbus_connection_set_watch_functions_APIName .) A side effect of this is that you need to know there a reference held on the dbus_connection_set_data_APIParam_1 while invoking dbus_connection_set_data_APIName , or the dbus_connection_set_data_APIParam_1 could be finalized during dbus_connection_set_data_APIName . dbus_connection_set_data_APIParam_1 is the dbus_connection_set_data_APIParam_1. dbus_connection_set_data_APIParam_2 is the dbus_connection_set_data_APIParam_2 number. dbus_connection_set_data_APIParam_3 is the dbus_connection_set_data_APIParam_3 to store. dbus_connection_set_data_APIParam_4 is finalizer function for the dbus_connection_set_data_APIParam_3. dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3", "key": "dbus_connection_set_data"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction .", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process.", "paraph": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1 when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction . If set to TRUE (the default is FALSE ), then the dbus_connection_set_allow_anonymous_APIParam_1 can proceed even if the client does not authenticate as some user identity, i.e. clients can connect anonymously. This setting interacts with the available authorization mechanisms (see dbus_server_set_auth_mechanisms_APIName ). Namely, an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work. This setting also changes the default rule for connections authorized as a user; normally, if a dbus_connection_set_allow_anonymous_APIParam_1 authorizes as a user identity, it is permitted if the user identity is root or the user identity matches the user identity of the server process. If anonymous connections are allowed, however, then any user identity is allowed. You can override the rules for connections authorized as a user identity with dbus_connection_set_unix_user_function_APIName and dbus_connection_set_windows_user_function_APIName . dbus_connection_set_allow_anonymous_APIParam_1 is the dbus_connection_set_allow_anonymous_APIParam_1. dbus_connection_set_allow_anonymous_APIParam_2 is whether to allow authentication as an anonymous user", "key": "dbus_connection_set_allow_anonymous"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes.", "var_type": ["DBusConnection *", "DBusDispatchStatusFunction", "void *", "DBusFreeFunction"]}, "sent": "If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called.", "paraph": "Set a dbus_connection_set_dispatch_status_function_APIParam_2 to be invoked when the dispatch status changes. If the dispatch status is DBUS_DISPATCH_DATA_REMAINS , then dbus_connection_dispatch_APIName needs to be called to process incoming messages. However, dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction. Indeed, almost any reentrancy in dbus_connection_set_dispatch_status_function_APIName is a bad idea. Instead, the DBusDispatchStatusFunction should simply save an indication that messages should be dispatched later, when the main loop is re-entered. If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2, you have to be sure to dispatch on every iteration of your main loop, especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called. dbus_connection_set_dispatch_status_function_APIParam_1 is the dbus_connection_set_dispatch_status_function_APIParam_1. dbus_connection_set_dispatch_status_function_APIParam_2 is dbus_connection_set_dispatch_status_function_APIParam_2 to call on dispatch status changes. dbus_connection_set_dispatch_status_function_APIParam_3 is dbus_connection_set_dispatch_status_function_APIParam_3 for dbus_connection_set_dispatch_status_function_APIParam_2. dbus_connection_set_dispatch_status_function_APIParam_4 is free the dbus_connection_set_dispatch_status_function_APIParam_2 dbus_connection_set_dispatch_status_function_APIParam_3", "key": "dbus_connection_set_dispatch_status_function"}, {"API_info": {"var": ["connection", "exit_on_disconnect"], "ret_type": "void", "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "key": "dbus_connection_set_exit_on_disconnect"}, {"API_info": {"var": ["connection", "exit_on_disconnect"], "ret_type": "void", "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1.", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "key": "dbus_connection_set_exit_on_disconnect"}, {"API_info": {"var": ["connection", "exit_on_disconnect"], "ret_type": "void", "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function.", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "key": "dbus_connection_set_exit_on_disconnect"}, {"API_info": {"var": ["connection", "exit_on_disconnect"], "ret_type": "void", "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default.", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "key": "dbus_connection_set_exit_on_disconnect"}, {"API_info": {"var": ["connection", "exit_on_disconnect"], "ret_type": "void", "desc": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "paraph": "Set whether _exit_APIName should be called when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal. The call to _exit_APIName comes after any handlers for the disconnect signal run; handlers can cancel the exit by calling this function. By default, dbus_connection_set_exit_on_disconnect_APIParam_2 is FALSE ; but for message bus connections returned from dbus_bus_get_APIName it will be toggled on by default. dbus_connection_set_exit_on_disconnect_APIParam_1 is the dbus_connection_set_exit_on_disconnect_APIParam_1. dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE if _exit_APIName should be called after a disconnect signal", "key": "dbus_connection_set_exit_on_disconnect"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "key": "dbus_connection_set_max_message_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1.", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "key": "dbus_connection_set_max_message_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection.", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "key": "dbus_connection_set_max_message_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "paraph": "Specifies the maximum dbus_connection_set_max_message_size_APIParam_2 message this dbus_connection_set_max_message_size_APIParam_1 is allowed to receive. Larger messages will result in disconnecting the dbus_connection_set_max_message_size_APIParam_1. dbus_connection_set_max_message_size_APIParam_1 is a DBusConnection. dbus_connection_set_max_message_size_APIParam_2 is maximum message dbus_connection_set_max_message_size_APIParam_2 the dbus_connection_set_max_message_size_APIParam_1 can receive, in bytes", "key": "dbus_connection_set_max_message_size"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "key": "dbus_connection_set_max_message_unix_fds"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1.", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "key": "dbus_connection_set_max_message_unix_fds"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive.", "var_type": ["DBusConnection *", "long"]}, "sent": "co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "paraph": "Specifies the maximum number of unix fds a message on this dbus_connection_set_max_message_unix_fds_APIParam_1 is allowed to receive. Messages with more unix fds will result in disconnecting the dbus_connection_set_max_message_unix_fds_APIParam_1. co. dbus_connection_set_max_message_unix_fds_APIParam_2 isnection is a DBusConnection dbus_connection_set_max_message_unix_fds_APIParam_2 maximum message unix fds the dbus_connection_set_max_message_unix_fds_APIParam_1 can receive", "key": "dbus_connection_set_max_message_unix_fds"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Messages count toward the maximum until they are finalized.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "The semantics are not: if the next message would cause us to exceed the maximum, we do not read it.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "But this should be inconsequential.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Messages count toward the maximum until they are finalized.", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_unix_fds"}, {"API_info": {"var": ["connection", "size"], "ret_type": "void", "desc": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount.", "paraph": "Sets the maximum total number of bytes that can be used for all messages received on this dbus_connection_set_max_received_size_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_size_APIParam_1 will not read more data until some messages are finalized. The semantics of the maximum are: if outstanding messages are already above the maximum, additional messages will not be read. The semantics are not: if the next message would cause us to exceed the maximum, we do not read it. The reason is that we do not know the dbus_connection_set_max_received_size_APIParam_2 of a message until after we read it. Thus, the max live messages dbus_connection_set_max_received_size_APIParam_2 can actually be exceeded by up to the maximum dbus_connection_set_max_received_size_APIParam_2 of a single message. Also, if we read say 1024 bytes off the wire in a single read_APIName, and that contains a half-dozen small messages, we may exceed the dbus_connection_set_max_received_size_APIParam_2 max by that amount. But this should be inconsequential. This does imply that we can not call read_APIName with a buffer larger than we're willing to exceed this limit by. dbus_connection_set_max_received_size_APIParam_1 is the dbus_connection_set_max_received_size_APIParam_1. dbus_connection_set_max_received_size_APIParam_2 is the maximum dbus_connection_set_max_received_size_APIParam_2 in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_size"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_unix_fds"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "The semantics are analogous to those of dbus_connection_set_max_received_size_APIName .", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_unix_fds"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized.", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_unix_fds"}, {"API_info": {"var": ["connection", "n"], "ret_type": "void", "desc": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1.", "var_type": ["DBusConnection *", "long"]}, "sent": "co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "paraph": "Sets the maximum total number of unix fds that can be used for all messages received on this dbus_connection_set_max_received_unix_fds_APIParam_1. Messages count toward the maximum until they are finalized. When the maximum is reached, the dbus_connection_set_max_received_unix_fds_APIParam_1 will not read more data until some messages are finalized. The semantics are analogous to those of dbus_connection_set_max_received_size_APIName . co. dbus_connection_set_max_received_unix_fds_APIParam_2 isnection is the dbus_connection_set_max_received_unix_fds_APIParam_1 dbus_connection_set_max_received_unix_fds_APIParam_2 the maximum size in bytes of all outstanding messages", "key": "dbus_connection_set_max_received_unix_fds"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "If a normal application sets this flag, it can break things badly.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "However, the message bus wants to be able to route methods on that interface through the bus and to other applications.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "So do not set this unless you are the message bus.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1.", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "value"], "ret_type": "void", "desc": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface.", "var_type": ["DBusConnection *", "dbus_bool_t"]}, "sent": "dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "paraph": "Normally DBusConnection automatically handles all messages to the org.freedesktop.DBus.Peer interface. However, the message bus wants to be able to route methods on that interface through the bus and to other applications. If routing peer messages is enabled, then messages with the org.freedesktop.DBus.Peer interface that also have a bus destination name set will not be automatically handled by the DBusConnection and instead will be dispatched normally to the application. If a normal application sets this flag, it can break things badly. So do not set this unless you are the message bus. dbus_connection_set_route_peer_messages_APIParam_1 is the dbus_connection_set_route_peer_messages_APIParam_1. dbus_connection_set_route_peer_messages_APIParam_2 is TRUE to pass through org.freedesktop.DBus.Peer messages with a bus name set", "key": "dbus_connection_set_route_peer_messages"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "These functions are responsible for making the application main loop aware of timeouts.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "When using Qt, typically the DBusAddTimeoutFunction would create a QTimer.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "When using GLib, the DBusAddTimeoutFunction would call g_timeout_add.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Call dbus_timeout_get_enabled_APIName to check this.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "A disabled timeout should have no effect, and enabled timeout should be added to the main loop.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "This feature is used instead of simply adding/removing the timeout  .", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Whenever a timeout is toggled, its interval may change.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName .", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The timer interval may change whenever the timeout is added, removed, or toggled.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5.", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddTimeoutFunction", "DBusRemoveTimeoutFunction", "DBusTimeoutToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "paraph": "Sets the timeout functions for the dbus_connection_set_timeout_functions_APIParam_1. These functions are responsible for making the application main loop aware of timeouts. When using Qt, typically the DBusAddTimeoutFunction would create a QTimer. When using GLib, the DBusAddTimeoutFunction would call g_timeout_add. The DBusTimeoutToggledFunction notifies the application that the timeout has been enabled or disabled. Call dbus_timeout_get_enabled_APIName to check this. A disabled timeout should have no effect, and enabled timeout should be added to the main loop. This feature is used instead of simply adding/removing the timeout because enabling/disabling can be done without memory allocation. With Qt, QTimer::start_APIName and QTimer::stop_APIName can be used to enable and disable. The toggled function may be NULL if a main loop re-queries dbus_timeout_get_enabled_APIName every time anyway. Whenever a timeout is toggled, its interval may change. The DBusTimeout can be queried for the timer interval using dbus_timeout_get_interval_APIName . dbus_timeout_handle_APIName should be called repeatedly, each time the interval elapses, starting after it has elapsed once. The timeout stops firing when it is removed with the given dbus_connection_set_timeout_functions_APIParam_3. The timer interval may change whenever the timeout is added, removed, or toggled. Note The thread lock on DBusConnection is held while timeout functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/thread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_timeout_functions_APIParam_1 is the dbus_connection_set_timeout_functions_APIParam_1. dbus_connection_set_timeout_functions_APIParam_2 is function to add a timeout. dbus_connection_set_timeout_functions_APIParam_3 is function to remove a timeout. dbus_connection_set_timeout_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_timeout_functions_APIParam_5 is dbus_connection_set_timeout_functions_APIParam_5 to pass to dbus_connection_set_timeout_functions_APIParam_2 and dbus_connection_set_timeout_functions_APIParam_3. dbus_connection_set_timeout_functions_APIParam_6 is function to be called to free the dbus_connection_set_timeout_functions_APIParam_5. dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_timeout_functions"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine  .", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "Also, root is always allowed to connect.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_unix_user_function_APIParam_2 is the predicate.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate.", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "a message has been queued for writing).", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowUnixUserFunction", "void *", "DBusFreeFunction"]}, "sent": "However , the dbus_connection_set_unix_user_function_APIParam_2 will never be called ,  protocols would allow authenticating as a UNIX user on Windows .", "paraph": "Sets a predicate dbus_connection_set_unix_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_unix_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_unix_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected. If the dbus_connection_set_unix_user_function_APIParam_2 is set to NULL (as it is by default), then only the same UID as the server process will be allowed to connect. Also, root is always allowed to connect. On Windows, the dbus_connection_set_unix_user_function_APIParam_2 will be set and its dbus_connection_set_unix_user_function_APIParam_4 will be invoked when the dbus_connection_set_unix_user_function_APIParam_1 is freed or a new dbus_connection_set_unix_user_function_APIParam_2 is set. However, the dbus_connection_set_unix_user_function_APIParam_2 will never be called, because there are no UNIX user ids to pass to it, or at least none of the existing auth protocols would allow authenticating as a UNIX user on Windows. dbus_connection_set_unix_user_function_APIParam_1 is the dbus_connection_set_unix_user_function_APIParam_1. dbus_connection_set_unix_user_function_APIParam_2 is the predicate. dbus_connection_set_unix_user_function_APIParam_3 is dbus_connection_set_unix_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_unix_user_function_APIParam_4 is dbus_connection_set_unix_user_function_APIParam_2 to free the dbus_connection_set_unix_user_function_APIParam_3", "key": "dbus_connection_set_unix_user_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "When using GLib, it would call g_main_context_wakeup_APIName.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2.", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "wakeup_main_function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1.", "var_type": ["DBusConnection *", "DBusWakeupMainFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "paraph": "Sets the mainloop wakeup function for the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIName is responsible for waking up the main loop (if its sleeping in another thread) when some some change has happened to the dbus_connection_set_wakeup_main_function_APIParam_1 that the mainloop needs to reconsider (e.g. a message has been queued for writing). When using Qt, this typically results in a call to QEventLoop::wakeUp_APIName. When using GLib, it would call g_main_context_wakeup_APIName. dbus_connection_set_wakeup_main_function_APIParam_1 is the dbus_connection_set_wakeup_main_function_APIParam_1. dbus_connection_set_wakeup_main_function_APIParam_2 is function to wake up the mainloop. dbus_connection_set_wakeup_main_function_APIParam_3 is dbus_connection_set_wakeup_main_function_APIParam_3 to pass dbus_connection_set_wakeup_main_function_APIParam_2. dbus_connection_set_wakeup_main_function_APIParam_4 is function to be called to free the dbus_connection_set_wakeup_main_function_APIParam_3", "key": "dbus_connection_set_wakeup_main_function"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Note that when a watch is added, it may not be enabled.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Call dbus_watch_get_enabled_APIName to check this.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "A disabled watch should have no effect, and enabled watch should be added to the main loop.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "This feature is used instead of simply adding/removing the watch  .", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName .", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "i.e.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5.", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "add_function", "remove_function", "toggled_function", "data", "free_data_function"], "ret_type": "dbus_bool_t", "desc": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1.", "var_type": ["DBusConnection *", "DBusAddWatchFunction", "DBusRemoveWatchFunction", "DBusWatchToggledFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "paraph": "Sets the watch functions for the dbus_connection_set_watch_functions_APIParam_1. These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events, using select_APIName or poll_APIName. When using Qt, typically the DBusAddWatchFunction would create a QSocketNotifier. When using GLib, the DBusAddWatchFunction could call g_io_add_watch_APIName, or could be used as part of a more elaborate GSource. Note that when a watch is added, it may not be enabled. The DBusWatchToggledFunction notifies the application that the watch has been enabled or disabled. Call dbus_watch_get_enabled_APIName to check this. A disabled watch should have no effect, and enabled watch should be added to the main loop. This feature is used instead of simply adding/removing the watch because enabling/disabling can be done without memory allocation. The toggled function may be NULL if a main loop re-queries dbus_watch_get_enabled_APIName every time anyway. The DBusWatch can be queried for the file descriptor to watch using dbus_watch_get_unix_fd_APIName or dbus_watch_get_socket_APIName , and for the events to watch for using dbus_watch_get_flags_APIName . The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a watch for hangups, errors, and other exceptional conditions. Once a file descriptor becomes readable or writable, or an exception occurs, dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet. It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3. If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2. If so, the dbus_connection_set_watch_functions_APIParam_2 may have been called successfully one or more times, but the dbus_connection_set_watch_functions_APIParam_3 will also have been called to remove any successful adds. i.e. if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called. Note The thread lock on DBusConnection is held while watch functions are invoked, so inside these functions you may not invoke any methods on DBusConnection or it will deadlock. See the comments in the code or http://lists.freedesktop.org/archives/dbus/2007-July/tread.html#8144 if you encounter this issue and want to attempt writing a patch. dbus_connection_set_watch_functions_APIParam_1 is the dbus_connection_set_watch_functions_APIParam_1. dbus_connection_set_watch_functions_APIParam_2 is function to begin monitoring a new descriptor. dbus_connection_set_watch_functions_APIParam_3 is function to stop monitoring a descriptor. dbus_connection_set_watch_functions_APIParam_4 is function to notify of enable/disable. dbus_connection_set_watch_functions_APIParam_5 is dbus_connection_set_watch_functions_APIParam_5 to pass to dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3. dbus_connection_set_watch_functions_APIParam_6 is function to be called to free the dbus_connection_set_watch_functions_APIParam_5. dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory", "key": "dbus_connection_set_watch_functions"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine  .", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_windows_user_function_APIParam_2 is the predicate.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "However , the dbus_connection_set_windows_user_function_APIParam_2 will never be called ,  .", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected.", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "function", "data", "free_data_function"], "ret_type": "void", "desc": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect.", "var_type": ["DBusConnection *", "DBusAllowWindowsUserFunction", "void *", "DBusFreeFunction"]}, "sent": "dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "paraph": "Sets a predicate dbus_connection_set_windows_user_function_APIParam_2 used to determine whether a given user ID is allowed to connect. When an incoming dbus_connection_set_windows_user_function_APIParam_1 has authenticated with a particular user ID, dbus_connection_set_windows_user_function_APIName is called; if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected. If the dbus_connection_set_windows_user_function_APIParam_2 is set to NULL (as it is by default), then only the same user owning the server process will be allowed to connect. On UNIX, the dbus_connection_set_windows_user_function_APIParam_2 will be set and its dbus_connection_set_windows_user_function_APIParam_4 will be invoked when the dbus_connection_set_windows_user_function_APIParam_1 is freed or a new dbus_connection_set_windows_user_function_APIParam_2 is set. However, the dbus_connection_set_windows_user_function_APIParam_2 will never be called, because there is no way right now to authenticate as a Windows user on UNIX. dbus_connection_set_windows_user_function_APIParam_1 is the dbus_connection_set_windows_user_function_APIParam_1. dbus_connection_set_windows_user_function_APIParam_2 is the predicate. dbus_connection_set_windows_user_function_APIParam_3 is dbus_connection_set_windows_user_function_APIParam_3 to pass to the predicate. dbus_connection_set_windows_user_function_APIParam_4 is dbus_connection_set_windows_user_function_APIParam_2 to free the dbus_connection_set_windows_user_function_APIParam_3", "key": "dbus_connection_set_windows_user_function"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_steal_borrowed_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName .", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_steal_borrowed_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1.", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_steal_borrowed_message"}, {"API_info": {"var": ["connection", "message"], "ret_type": "void", "desc": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName .", "var_type": ["DBusConnection *", "DBusMessage *"]}, "sent": "dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "paraph": "Used to keep a dbus_connection_steal_borrowed_message_APIParam_2 after peeking at a dbus_connection_steal_borrowed_message_APIParam_2 using dbus_connection_borrow_message_APIName . Before using this function, see the caveats/warnings in the documentation for dbus_connection_pop_message_APIName . dbus_connection_steal_borrowed_message_APIParam_1 is the dbus_connection_steal_borrowed_message_APIParam_1. dbus_connection_steal_borrowed_message_APIParam_2 is the dbus_connection_steal_borrowed_message_APIParam_2 from dbus_connection_borrow_message_APIName", "key": "dbus_connection_steal_borrowed_message"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "Registers a fallback handler for a given subsection of the object hierarchy.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "You can use this to establish a default message handling policy for a whole \"subdirectory.\"", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIParam_3 is the virtual table.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a fallback handler for a given subsection of the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements.", "paraph": "Registers a fallback handler for a given subsection of the object hierarchy. The given dbus_connection_try_register_fallback_APIParam_3 handles messages at or below the given dbus_connection_try_register_fallback_APIParam_2. You can use this to establish a default message handling policy for a whole \"subdirectory.\" dbus_connection_try_register_fallback_APIParam_1 is the dbus_connection_try_register_fallback_APIParam_1. dbus_connection_try_register_fallback_APIParam_2 is a '/' delimited string of dbus_connection_try_register_fallback_APIParam_2 elements. dbus_connection_try_register_fallback_APIParam_3 is the virtual table. dbus_connection_try_register_fallback_APIParam_4 is data to pass to functions in the dbus_connection_try_register_fallback_APIParam_3. dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned. dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_fallback"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIParam_3 is the virtual table.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned.", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection", "path", "vtable", "user_data", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy.", "var_type": ["DBusConnection *", "const char *", "const DBusObjectPathVTable *", "void *", "DBusError *"]}, "sent": "dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "paraph": "Registers a handler for a given dbus_connection_try_register_object_path_APIParam_2 in the object hierarchy. The given dbus_connection_try_register_object_path_APIParam_3 handles messages sent to exactly the given dbus_connection_try_register_object_path_APIParam_2. dbus_connection_try_register_object_path_APIParam_1 is the dbus_connection_try_register_object_path_APIParam_1. dbus_connection_try_register_object_path_APIParam_2 is a '/' delimited string of dbus_connection_try_register_object_path_APIParam_2 elements. dbus_connection_try_register_object_path_APIParam_3 is the virtual table. dbus_connection_try_register_object_path_APIParam_4 is data to pass to functions in the dbus_connection_try_register_object_path_APIParam_3. dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned. dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5 ( DBUS_ERROR_NO_MEMORY or DBUS_ERROR_OBJECT_PATH_IN_USE ) is reported", "key": "dbus_connection_try_register_object_path"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "Most connections are shared.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName .", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Can unregister both fallback paths and object paths.", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered.", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1.", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["connection"], "ret_type": "void", "desc": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero.", "var_type": ["DBusConnection *"]}, "sent": "For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference.", "paraph": "Decrements the reference count of a DBusConnection , and finalizes it if the count reaches zero. Note: it is a bug to drop the last reference to a dbus_connection_unref_APIParam_1 that is still connected. For shared connections, libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected, so you can know that either you do not have the last reference, or it is OK to drop the last reference. Most connections are shared. dbus_connection_open_APIName and dbus_bus_get_APIName return shared connections. For private connections, the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference. Private connections come from dbus_connection_open_private_APIName or dbus_bus_get_private_APIName . dbus_connection_unref_APIParam_1 is the dbus_connection_unref_APIParam_1", "key": "dbus_connection_unref"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["functions"], "ret_type": "dbus_bool_t", "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var_type": ["const DBusThreadFunctions *"]}, "sent": "Initializes threads, like dbus_threads_init_default_APIName .", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "key": "dbus_threads_init"}, {"API_info": {"var": ["connection", "path"], "ret_type": "dbus_bool_t", "desc": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements.", "paraph": "Unregisters the handler registered with exactly the given dbus_connection_unregister_object_path_APIParam_2. it is a bug to call dbus_connection_unregister_object_path_APIName for a dbus_connection_unregister_object_path_APIParam_2 that is not registered. Can unregister both fallback paths and object paths. dbus_connection_unregister_object_path_APIParam_1 is the dbus_connection_unregister_object_path_APIParam_1. dbus_connection_unregister_object_path_APIParam_2 is a '/' delimited string of dbus_connection_unregister_object_path_APIParam_2 elements. dbus_connection_unregister_object_path_APIName return FALSE if not enough memory", "key": "dbus_connection_unregister_object_path"}, {"API_info": {"var": ["functions"], "ret_type": "dbus_bool_t", "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var_type": ["const DBusThreadFunctions *"]}, "sent": "dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads.", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "key": "dbus_threads_init"}, {"API_info": {"var": ["functions"], "ret_type": "dbus_bool_t", "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var_type": ["const DBusThreadFunctions *"]}, "sent": "This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName .", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "key": "dbus_threads_init"}, {"API_info": {"var": ["functions"], "ret_type": "dbus_bool_t", "desc": "Initializes threads, like dbus_threads_init_default_APIName .", "var_type": ["const DBusThreadFunctions *"]}, "sent": "dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "paraph": "Initializes threads, like dbus_threads_init_default_APIName . This version previously allowed user-specified threading primitives, but since D-Bus 1.6 it ignores them and behaves exactly like dbus_threads_init_default_APIName . dbus_threads_init_APIParam_1 is ignored, formerly dbus_threads_init_APIParam_1 for using threads. dbus_threads_init_APIName return TRUE on success, FALSE if no memory", "key": "dbus_threads_init"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "Initializes threads.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "If it is called, D-Bus will do locking, at some cost in efficiency.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used).", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "Returns TRUE on success, FALSE if not enough memory", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": [" void "], "ret_type": "dbus_bool_t", "desc": "Initializes threads.", "var_type": [" void "]}, "sent": "As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers.", "paraph": "Initializes threads. If dbus_threads_init_default_APIName is not called, the D-Bus library will not lock any data structures. If it is called, D-Bus will do locking, at some cost in efficiency. Since D-Bus 1.7 it is safe to call dbus_threads_init_default_APIName from any thread, any number of times (but it must be called before any other libdbus API is used). In D-Bus 1.6 or older, dbus_threads_init_default_APIName must be called in the main thread before any other thread starts. As a result, it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin, unless the library or plugin imposes a similar requirement on its callers. dbus_shutdown_APIName reverses the effects of dbus_threads_init_default_APIName when it resets all global state in libdbus. Returns TRUE on success, FALSE if not enough memory", "key": "dbus_threads_init_default"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "This is generally acceptable ,  .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "The AddMatch method is fully documented in the D-Bus specification.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Rules are specified as a string of comma separated key/value pairs.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Normal API conventions would have the function return a boolean value indicating  , but that would require blocking always to determine the return value .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "This can cause performance problems such as draining batteries on embedded platforms.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "It is important to note this  .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you match message args ('arg0', 'arg1', and so forth) only string arguments will match.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "That is, arg0='5' means match the string \"5\" not the integer 5.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Currently there is no way to match against non-string arguments.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "A specialised form of wildcard matching on arguments is supported for path-like namespaces.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Matching on interface is tricky  .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "This means match rules on method calls should not usually give an interface.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_add_match_APIParam_3 is location to store any errors", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "Connects to a bus daemon and registers the client with it.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Both of these maximums are much higher than you are likely to need , they only exist  .", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "The caller of dbus_bus_get_APIName owns a reference to the bus.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.).", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_APIName calls dbus_bus_register_APIName for you.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned.", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it.", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "paraph": "Connects to a bus daemon and registers the client with it. If a connection to the bus already exists, then that connectionbe returned by dbus_bus_get_APIName. The caller of dbus_bus_get_APIName owns a reference to the bus. The caller may NOT call dbus_connection_close_APIName on this connection; see dbus_connection_open_APIName and dbus_connection_close_APIName for details on that. If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_APIName calls dbus_bus_register_APIName for you. If returning a newly-created connection, dbus_bus_get_APIName will block until authentication and bus registration are complete. dbus_bus_get_APIParam_1 is bus dbus_bus_get_APIParam_1. dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned. dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2", "key": "dbus_bus_get"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "For the session bus, this is useful as a way to uniquely identify each user session.", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "See dbus_try_get_local_machine_id_APIName .", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1.", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2.", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "Unlike dbus_bus_get_APIName , always creates a new connection.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "This connection will not be saved or recycled by libdbus.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "For the system bus , probably the bus ID is not useful ; instead , use the machine ID  and may be persistent beyond a single bus instance .", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "See dbus_connection_open_private_APIName for more details on when to close and unref this connection.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIName will block until authentication and bus registration are complete.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIName return a DBusConnection with new ref", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["type", "error"], "ret_type": "DBusConnection *", "desc": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName .", "var_type": ["DBusBusType", "DBusError *"]}, "sent": "dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned.", "paraph": "Connects to a bus daemon and registers the client with it as with dbus_bus_register_APIName . Unlike dbus_bus_get_APIName , always creates a new connection. This connection will not be saved or recycled by libdbus. Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference. See dbus_connection_open_private_APIName for more details on when to close and unref this connection. dbus_bus_get_private_APIName calls dbus_connection_set_exit_on_disconnect_APIName on the new connection, so the application will exit if the connection closes. You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection. dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you. dbus_bus_get_private_APIName will block until authentication and bus registration are complete. dbus_bus_get_private_APIParam_1 is bus dbus_bus_get_private_APIParam_1. dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned. dbus_bus_get_private_APIName return a DBusConnection with new ref", "key": "dbus_bus_get_private"}, {"API_info": {"var": ["connection", "error"], "ret_type": "char *", "desc": "Asks the bus to return its globally unique ID, as described in the D-Bus specification.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "In addition to an ID for each bus and an ID for each machine , there is an ID for each address that the bus is listening on ; that can be retrieved with dbus_connection_get_server_id_APIName ,  .", "paraph": "Asks the bus to return its globally unique ID, as described in the D-Bus specification. For the session bus, this is useful as a way to uniquely identify each user session. For the system bus, probably the bus ID is not useful; instead, use the machine ID since it is accessible without necessarily connecting to the bus and may be persistent beyond a single bus instance (across reboots for example). See dbus_try_get_local_machine_id_APIName . In addition to an ID for each bus and an ID for each machine, there is an ID for each address that the bus is listening on; that can be retrieved with dbus_connection_get_server_id_APIName , though it is probably not very useful. dbus_bus_get_id_APIParam_1 is the dbus_bus_get_id_APIParam_1. dbus_bus_get_id_APIParam_2 is location to store the dbus_bus_get_id_APIParam_2. dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set", "key": "dbus_bus_get_id"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus.", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered.", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller.", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1.", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName .", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName .", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection"], "ret_type": "const char *", "desc": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus.", "var_type": ["DBusConnection *"]}, "sent": "dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "paraph": "Gets the unique name of the dbus_bus_get_unique_name_APIParam_1 as assigned by the message bus. Only possible after the dbus_bus_get_unique_name_APIParam_1 has been registered with the message bus. All connections returned by dbus_bus_get_APIName or dbus_bus_get_private_APIName have been successfully registered. The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed, and should not be freed by the caller. Other than dbus_bus_get_APIName , there are two ways to set the unique name; one is dbus_bus_register_APIName , the other is dbus_bus_set_unique_name_APIName . You are responsible for calling dbus_bus_set_unique_name_APIName if you register by hand instead of using dbus_bus_register_APIName . dbus_bus_get_unique_name_APIParam_1 is the dbus_bus_get_unique_name_APIParam_1. dbus_bus_get_unique_name_APIName return the unique name or NULL on error", "key": "dbus_bus_get_unique_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Only works on UNIX; only works for connections on the same machine as the bus.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you are not on the same machine as the bus , then calling this is probably a bad idea ,  .", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other.", "paraph": "Adds a match dbus_bus_add_match_APIParam_2 to match messages going through the message bus. The \"rule\" argument is the string form of a match dbus_bus_add_match_APIParam_2. If you pass NULL for the dbus_bus_add_match_APIParam_3, dbus_bus_add_match_APIName will not block; the match thus will not be added until you flush the dbus_bus_add_match_APIParam_1, and if there an dbus_bus_add_match_APIParam_3 adding the match you will not find out about it. This is generally acceptable, since the possible errors (including a lack of resources in the bus, the dbus_bus_add_match_APIParam_1 having exceeded its quota of active match rules, or the match dbus_bus_add_match_APIParam_2 being unparseable) are generally unrecoverable. If you pass non- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply. This may be useful when using match dbus_bus_add_match_APIParam_2 keys introduced in recent versions of D-Bus, like 'arg0namespace', to allow the application to fall back to less efficient match rules supported by older versions of the daemon if the running version is not new enough; or when using user-supplied rules rather than rules hard-coded at compile time. Normal API conventions would have the function return a boolean value indicating whether the dbus_bus_add_match_APIParam_3 was set, but that would require blocking always to determine the return value. The AddMatch method is fully documented in the D-Bus specification. For quick reference, the format of the match rules is discussed here, but the specification is the canonical version of this information. Rules are specified as a string of comma separated key/value pairs. An example is \"type=ignal',sender='org.freedesktop.DBus', interface='org.freedesktop.DBus',member='Foo', path='/bar/foo',destination=':452345.34'\" Possible keys you can match on are type, sender, interface, member, path, destination and numbered keys to match message args (keys are 'arg0', 'arg1', etc.). Omitting a key from the dbus_bus_add_match_APIParam_2 indicates a wildcard match. For instance omitting the member from a match dbus_bus_add_match_APIParam_2 but adding a sender would let all messages from that sender through regardless of the member. Matches are inclusive not exclusive so as long as one dbus_bus_add_match_APIParam_2 matches the message will get through. It is important to note this because every time a message is received the application will be paged into memory to process it. This can cause performance problems such as draining batteries on embedded platforms. If you match message args ('arg0', 'arg1', and so forth) only string arguments will match. That is, arg0='5' means match the string \"5\" not the integer 5. Currently there is no way to match against non-string arguments. A specialised form of wildcard matching on arguments is supported for path-like namespaces. If your argument match has a 'path' suffix (eg: \"arg0path='/some/path/'\") then it is considered a match if the argument exactly matches the given string or if one of them ends in a '/' and is a prefix of the other. Matching on interface is tricky because method call messages only optionally specify the interface. If a message omits the interface, then it will NOT match if the dbus_bus_add_match_APIParam_2 specifies an interface name. This means match rules on method calls should not usually give an interface. However, signal messages are required to include the interface so when matching signals usually you should specify the interface in the match dbus_bus_add_match_APIParam_2. For security reasons, you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER . Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes. Both of these maximums are much higher than you are likely to need, they only exist because the D-Bus bus daemon has fixed limits on all resource usage. dbus_bus_add_match_APIParam_1 is dbus_bus_add_match_APIParam_1 to the message bus. dbus_bus_add_match_APIParam_2 is textual form of match dbus_bus_add_match_APIParam_2. dbus_bus_add_match_APIParam_3 is location to store any errors", "key": "dbus_bus_add_match"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "So check for errors and do something sensible if they happen.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "For the system message bus you are guaranteed to be on the same machine  .", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID.", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "unsigned long", "desc": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "paraph": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any. Only works on UNIX; only works for connections on the same machine as the bus. If you are not on the same machine as the bus, then calling this is probably a bad idea, since the UID will mean little to your application. For the system message bus you are guaranteed to be on the same machine since it only listens on a UNIX domain socket (at least, as shipped by default). dbus_bus_get_unix_user_APIName only works for connections that authenticated as a UNIX user, right now that includes all bus connections, but it is very possible to have connections with no associated UID. So check for errors and do something sensible if they happen. dbus_bus_get_unix_user_APIName will always return an dbus_bus_get_unix_user_APIParam_3 on Windows. dbus_bus_get_unix_user_APIParam_1 is the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_2 is a dbus_bus_get_unix_user_APIParam_2 owned by the dbus_bus_get_unix_user_APIParam_1. dbus_bus_get_unix_user_APIParam_3 is location to store the dbus_bus_get_unix_user_APIParam_3. dbus_bus_get_unix_user_APIName return the unix user id, or ((unsigned)-1) if dbus_bus_get_unix_user_APIParam_3 is set", "key": "dbus_bus_get_unix_user"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Asks the bus  .", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1.", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2.", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Using this can easily result in a race condition ,  .", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_name_has_owner_APIParam_3 is location to store any errors.", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "Registers a dbus_bus_register_APIParam_1 with the bus.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "This must be the first thing an application does when connecting to the message bus.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "dbus_bool_t", "desc": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner.", "paraph": "Asks the bus whether a certain dbus_bus_name_has_owner_APIParam_2 has an owner. Using this can easily result in a race condition, since an owner can appear or disappear after you call this. If you want to request a dbus_bus_name_has_owner_APIParam_2, just request it; if you want to avoid replacing a current owner, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner. dbus_bus_name_has_owner_APIParam_1 is the dbus_bus_name_has_owner_APIParam_1. dbus_bus_name_has_owner_APIParam_2 is the dbus_bus_name_has_owner_APIParam_2. dbus_bus_name_has_owner_APIParam_3 is location to store any errors. dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3", "key": "dbus_bus_name_has_owner"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName .", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_register_APIName will block until registration is complete.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType .", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_register_APIParam_2 is place to store errors.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "dbus_bus_register_APIName return TRUE on success", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "The \"ReleaseName\" method is canonically documented in the D-Bus specification.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages.", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue.", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "error"], "ret_type": "dbus_bool_t", "desc": "Registers a dbus_bus_register_APIParam_1 with the bus.", "var_type": ["DBusConnection *", "DBusError *"]}, "sent": "For shared connections in a multithreaded application , you can not really make the registration calls yourself ,  , and the bus will kick you off if you send two registration messages .", "paraph": "Registers a dbus_bus_register_APIParam_1 with the bus. This must be the first thing an application does when connecting to the message bus. If registration succeeds, the unique name will be set, and can be obtained using dbus_bus_get_unique_name_APIName . dbus_bus_register_APIName will block until registration is complete. If the dbus_bus_register_APIParam_1 has already registered with the bus (determined by checking whether dbus_bus_get_unique_name_APIName returns a non- NULL value), then dbus_bus_register_APIName does nothing. If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName will be called for you. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain. Using dbus_bus_register_APIName manually is only useful if you have your own custom message bus not found in DBusBusType . If you open a bus dbus_bus_register_APIParam_1 with dbus_connection_open_APIName or dbus_connection_open_private_APIName you will have to dbus_bus_register_APIName yourself, or make the appropriate registration method calls yourself. If you send the method calls yourself, call dbus_bus_set_unique_name_APIName with the unique bus name you get from the bus. For shared connections (created with dbus_connection_open_APIName ) in a multithreaded application, you can not really make the registration calls yourself, because you do not know whether some other thread is also registering, and the bus will kick you off if you send two registration messages. If you use dbus_bus_register_APIName however, there is a lock that keeps both apps from registering at the same time. The rule in a multithreaded app, then, is that dbus_bus_register_APIName must be used to register, or you need to have your own locks that all threads in the app will respect. In a single-threaded application you can register by hand instead of using dbus_bus_register_APIName , as long as you check dbus_bus_get_unique_name_APIName to see if a unique name has already been stored by another thread before you send the registration messages. dbus_bus_register_APIParam_1 is the dbus_bus_register_APIParam_1. dbus_bus_register_APIParam_2 is place to store errors. dbus_bus_register_APIName return TRUE on success", "key": "dbus_bus_register"}, {"API_info": {"var": ["connection", "name", "error"], "ret_type": "int", "desc": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus.", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "paraph": "Asks the bus to unassign the given dbus_bus_release_name_APIParam_2 from this dbus_bus_release_name_APIParam_1 by invoking the ReleaseName method on the bus. The \"ReleaseName\" method is canonically documented in the D-Bus specification. Possible results are: DBUS_RELEASE_NAME_REPLY_RELEASED which means you owned the dbus_bus_release_name_APIParam_2 or were in the queue to own it, and and now you do not own it and are not in the queue. DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it. DBUS_RELEASE_NAME_REPLY_NON_EXISTENT which means nobody owned the dbus_bus_release_name_APIParam_2. dbus_bus_release_name_APIParam_1 is the dbus_bus_release_name_APIParam_1. dbus_bus_release_name_APIParam_2 is the dbus_bus_release_name_APIParam_2 to remove. dbus_bus_release_name_APIParam_3 is location to store the dbus_bus_release_name_APIParam_3. dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set", "key": "dbus_bus_release_name"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2.", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will.", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "See detailed explanation in docs for dbus_bus_add_match_APIName .", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus.", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName .", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2.", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "rule", "error"], "ret_type": "void", "desc": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed).", "var_type": ["DBusConnection *", "const char *", "DBusError *"]}, "sent": "dbus_bus_remove_match_APIParam_3 is location to store any errors", "paraph": "Removes a previously-added match dbus_bus_remove_match_APIParam_2 \"by value\" (the most recently-added identical dbus_bus_remove_match_APIParam_2 gets removed). The \"rule\" argument is the string form of a match dbus_bus_remove_match_APIParam_2. The bus compares match rules semantically, not textually, so whitespace and ordering do not have to be identical to the dbus_bus_remove_match_APIParam_2 you passed to dbus_bus_add_match_APIName . If you pass NULL for the dbus_bus_remove_match_APIParam_3, dbus_bus_remove_match_APIName will not block; otherwise it will. See detailed explanation in docs for dbus_bus_add_match_APIName . dbus_bus_remove_match_APIParam_1 is dbus_bus_remove_match_APIParam_1 to the message bus. dbus_bus_remove_match_APIParam_2 is textual form of match dbus_bus_remove_match_APIParam_2. dbus_bus_remove_match_APIParam_3 is location to store any errors", "key": "dbus_bus_remove_match"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "This method is fully documented in the D-Bus specification.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Only one owns it at a time - called the primary owner.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name).", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "These properties are stored  and does not become the primary owner .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "the bus does not persistently associate it with the connection-name pair.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIName returns a result code.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "The possible result codes are as follows.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "(Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.)", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over or be queued up according to  .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT .", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost).", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "If \u2013replace is given, ask to replace the old owner.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4.", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "name", "flags", "error"], "ret_type": "int", "desc": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus.", "var_type": ["DBusConnection *", "const char *", "unsigned int", "DBusError *"]}, "sent": "dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "paraph": "Asks the bus to assign the given dbus_bus_request_name_APIParam_2 to this dbus_bus_request_name_APIParam_1 by invoking the RequestName method on the bus. This method is fully documented in the D-Bus specification. For quick reference, the dbus_bus_request_name_APIParam_3 and result codes are discussed here, but the specification is the canonical version of this information. First you should know that for each bus dbus_bus_request_name_APIParam_2, the bus stores a queue of connections that would like to own it. Only one owns it at a time - called the primary owner. If the primary owner releases the dbus_bus_request_name_APIParam_2 or disconnects, then the next owner in the queue atomically takes over. So for example if you have an application org.freedesktop.TextEditor and multiple instances of it can be run, you can have all of them sitting in the queue. The first one to start up will receive messages sent to org.freedesktop.TextEditor, but if that one exits another will become the primary owner and receive messages. The queue means you do not need to manually watch for the current owner to disappear and then request the dbus_bus_request_name_APIParam_2 again. When requesting a dbus_bus_request_name_APIParam_2, you can specify several dbus_bus_request_name_APIParam_3. DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE are properties stored by the bus for this dbus_bus_request_name_APIParam_1 with respect to each requested bus dbus_bus_request_name_APIParam_2. These properties are stored even if the dbus_bus_request_name_APIParam_1 is queued and does not become the primary owner. You can update these dbus_bus_request_name_APIParam_3 by calling RequestName again (even if you already own the name). DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_NAME_FLAG_DO_NOT_QUEUE means that if you are not the primary owner, you do not want to be queued up - you only care about being the primary owner. Unlike the other two dbus_bus_request_name_APIParam_3, DBUS_NAME_FLAG_REPLACE_EXISTING is a property of the individual RequestName call, i.e. the bus does not persistently associate it with the connection-name pair. If a RequestName call includes the DBUS_NAME_FLAG_REPLACE_EXISTING flag, and the current primary owner has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, then the current primary owner will be kicked off. If no dbus_bus_request_name_APIParam_3 are given, an application will receive the requested dbus_bus_request_name_APIParam_2 only if the dbus_bus_request_name_APIParam_2 is currently unowned; and it will NOT give up the dbus_bus_request_name_APIParam_2 if another application asks to take it over using DBUS_NAME_FLAG_REPLACE_EXISTING . dbus_bus_request_name_APIName returns a result code. The possible result codes are as follows. DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner, and the caller is now the primary owner; or that the dbus_bus_request_name_APIParam_2 had an owner, and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT . DBUS_REQUEST_NAME_REPLY_IN_QUEUE happens only if the caller does NOT specify DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . In this case the caller ends up in a queue to own the dbus_bus_request_name_APIParam_2 after the current owner gives it up. DBUS_REQUEST_NAME_REPLY_EXISTS happens if the dbus_bus_request_name_APIParam_2 has an owner already and the caller specifies DBUS_NAME_FLAG_DO_NOT_QUEUE and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING . DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER happens if an application requests a dbus_bus_request_name_APIParam_2 it already owns. (Re-requesting a dbus_bus_request_name_APIParam_2 is useful if you want to change the DBUS_NAME_FLAG_ALLOW_REPLACEMENT or DBUS_NAME_FLAG_DO_NOT_QUEUE settings.) When a service represents an application, say \"text editor,\" then it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started. Then any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over (last-started-wins) or be queued up (first-started-wins) according to whether DBUS_NAME_FLAG_ALLOW_REPLACEMENT was given. Conventionally, single-instance applications often offer a command line option called \u2013replace which means to replace the current instance. To implement this, always set DBUS_NAME_FLAG_ALLOW_REPLACEMENT when you request your application bus dbus_bus_request_name_APIParam_2. When you lose ownership of your bus dbus_bus_request_name_APIParam_2, you need to exit. Look for the signal \"NameLost\" from DBUS_SERVICE_DBUS and DBUS_INTERFACE_DBUS (the signal first argument is the bus dbus_bus_request_name_APIParam_2 that was lost). If starting up without \u2013replace, do not specify DBUS_NAME_FLAG_REPLACE_EXISTING , and exit if you fail to become the bus dbus_bus_request_name_APIParam_2 owner. If \u2013replace is given, ask to replace the old owner. dbus_bus_request_name_APIParam_1 is the dbus_bus_request_name_APIParam_1. dbus_bus_request_name_APIParam_2 is the dbus_bus_request_name_APIParam_2 to request. dbus_bus_request_name_APIParam_3 is dbus_bus_request_name_APIParam_3. dbus_bus_request_name_APIParam_4 is location to store the dbus_bus_request_name_APIParam_4. dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set", "key": "dbus_bus_request_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "if you did not call dbus_bus_register_APIName ).", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Can only be called once per dbus_bus_set_unique_name_APIParam_1.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName .", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Can only be used if you registered with the bus manually (i.e.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "There really no point creating pain for yourself by doing things manually.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections in a multithreaded application ,  .", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName .", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_bus_set_unique_name_APIParam_2 is the unique name.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections.", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "unique_name"], "ret_type": "dbus_bool_t", "desc": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus.", "var_type": ["DBusConnection *", "const char *"]}, "sent": "dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "paraph": "Sets the unique name of the dbus_bus_set_unique_name_APIParam_1, as assigned by the message bus. Can only be used if you registered with the bus manually (i.e. if you did not call dbus_bus_register_APIName ). Can only be called once per dbus_bus_set_unique_name_APIParam_1. After the unique name is set, you can get it with dbus_bus_get_unique_name_APIName . The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself. One (probably unusual) reason to do that might be to do the bus registration call asynchronously instead of synchronously. Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function. There really no point creating pain for yourself by doing things manually. it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections (created by dbus_connection_open_APIName ) in a multithreaded application, because only one registration attempt can be sent to the bus. If two threads are both sending the registration message, there is no mechanism in libdbus itself to avoid sending it twice. Thus, you need a way to coordinate which thread sends the registration attempt; which also means you know which thread will call dbus_bus_set_unique_name_APIName . If you do not know about all threads in the app (for example, if some libraries you are using might start libdbus-using threads), then you need to avoid using dbus_bus_set_unique_name_APIName on shared connections. dbus_bus_set_unique_name_APIParam_1 is the dbus_bus_set_unique_name_APIParam_1. dbus_bus_set_unique_name_APIParam_2 is the unique name. dbus_bus_set_unique_name_APIName return FALSE if not enough memory", "key": "dbus_bus_set_unique_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now).", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIParam_5 is location to store any errors.", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["connection", "name", "flags", "result", "error"], "ret_type": "dbus_bool_t", "desc": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2.", "var_type": ["DBusConnection *", "const char *", "dbus_uint32_t", "dbus_uint32_t *", "DBusError *"]}, "sent": "dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "paraph": "Starts a service that will request ownership of the given dbus_bus_start_service_by_name_APIParam_2. dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING if successful. Pass NULL if you do not care about the dbus_bus_start_service_by_name_APIParam_4. The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion, currently you should specify 0. it is often easier to avoid explicitly starting services, and just send a method call to the service bus dbus_bus_start_service_by_name_APIParam_2 instead. Method calls start a service to handle them by default unless you call dbus_message_set_auto_start_APIName to disable this behavior. dbus_bus_start_service_by_name_APIParam_1 is the dbus_bus_start_service_by_name_APIParam_1. dbus_bus_start_service_by_name_APIParam_2 is the dbus_bus_start_service_by_name_APIParam_2 we want the new service to request. dbus_bus_start_service_by_name_APIParam_3 is the dbus_bus_start_service_by_name_APIParam_3 (should always be 0 for now). dbus_bus_start_service_by_name_APIParam_4 is a place to store the dbus_bus_start_service_by_name_APIParam_4 or NULL. dbus_bus_start_service_by_name_APIParam_5 is location to store any errors. dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not", "key": "dbus_bus_start_service_by_name"}, {"API_info": {"var": ["timeout"], "ret_type": "void *", "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var_type": ["DBusTimeout *"]}, "sent": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "key": "dbus_timeout_get_data"}, {"API_info": {"var": ["timeout"], "ret_type": "void *", "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_data_APIParam_1 is the DBusTimeout object.", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "key": "dbus_timeout_get_data"}, {"API_info": {"var": ["timeout"], "ret_type": "void *", "desc": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_data_APIName return previously-set data", "paraph": "Gets data previously set with dbus_timeout_set_data_APIName or NULL if none. dbus_timeout_get_data_APIParam_1 is the DBusTimeout object. dbus_timeout_get_data_APIName return previously-set data", "key": "dbus_timeout_get_data"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusTimeout *"]}, "sent": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "key": "dbus_timeout_get_enabled"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusTimeout *"]}, "sent": "If not enabled, it should not be polled by the main loop.", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "key": "dbus_timeout_get_enabled"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object.", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "key": "dbus_timeout_get_enabled"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "paraph": "Returns whether a dbus_timeout_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_timeout_get_enabled_APIParam_1 is the DBusTimeout object. dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled", "key": "dbus_timeout_get_enabled"}, {"API_info": {"var": ["timeout"], "ret_type": "int", "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var_type": ["DBusTimeout *"]}, "sent": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "key": "dbus_timeout_get_interval"}, {"API_info": {"var": ["timeout"], "ret_type": "int", "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var_type": ["DBusTimeout *"]}, "sent": "The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once.", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "key": "dbus_timeout_get_interval"}, {"API_info": {"var": ["timeout"], "ret_type": "int", "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object.", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "key": "dbus_timeout_get_interval"}, {"API_info": {"var": ["timeout"], "ret_type": "int", "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_get_interval_APIName return the interval in milliseconds", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "key": "dbus_timeout_get_interval"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout"], "ret_type": "int", "desc": "Gets the dbus_timeout_get_interval_APIParam_1 interval.", "var_type": ["DBusTimeout *"]}, "sent": "The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change.", "paraph": "Gets the dbus_timeout_get_interval_APIParam_1 interval. The dbus_timeout_handle_APIName should be called each time this interval elapses, starting after The dbus_timeout_handle_APIName elapses once. The interval may change during the life of the dbus_timeout_get_interval_APIParam_1; if so, the dbus_timeout_get_interval_APIParam_1 will be disabled and re-enabled (calling the \"timeout toggled function\") to notify you of the change. dbus_timeout_get_interval_APIParam_1 is the DBusTimeout object. dbus_timeout_get_interval_APIName return the interval in milliseconds", "key": "dbus_timeout_get_interval"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs.", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1.", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_handle_APIParam_1 is the DBusTimeout object.", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2.", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["timeout"], "ret_type": "dbus_bool_t", "desc": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1.", "var_type": ["DBusTimeout *"]}, "sent": "Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted.", "paraph": "Calls the dbus_timeout_handle_APIParam_1 handler for this dbus_timeout_handle_APIParam_1. dbus_timeout_handle_APIName should be called when the dbus_timeout_handle_APIParam_1 occurs. If dbus_timeout_handle_APIName returns FALSE , then there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1. Typically just letting the dbus_timeout_handle_APIParam_1 fire again next time it naturally times out is an adequate response to that problem, but you could try to do more if you wanted. dbus_timeout_handle_APIParam_1 is the DBusTimeout object. dbus_timeout_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_timeout_handle"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "dbus_timeout_set_data_APIParam_1 is the DBusTimeout object.", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2.", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id.", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["timeout", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName .", "var_type": ["DBusTimeout *", "void *", "DBusFreeFunction"]}, "sent": "dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "paraph": "Sets dbus_timeout_set_data_APIParam_2 which can be retrieved with dbus_timeout_get_data_APIName . Intended for use by the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction to store the DBusAddTimeoutFunction and DBusRemoveTimeoutFunction own dbus_timeout_set_data_APIParam_2. For example with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id. dbus_timeout_set_data_APIParam_1 is the DBusTimeout object. dbus_timeout_set_data_APIParam_2 is the dbus_timeout_set_data_APIParam_2. dbus_timeout_set_data_APIParam_3 is function to be called to free the dbus_timeout_set_data_APIParam_2", "key": "dbus_timeout_set_data"}, {"API_info": {"var": ["entries"], "ret_type": "void", "desc": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "var_type": ["DBusAddressEntry **"]}, "sent": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "paraph": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1. dbus_address_entries_free_APIParam_1 is the array", "key": "dbus_address_entries_free"}, {"API_info": {"var": ["entries"], "ret_type": "void", "desc": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1.", "var_type": ["DBusAddressEntry **"]}, "sent": "dbus_address_entries_free_APIParam_1 is the array", "paraph": "Frees a NULL -terminated array of address dbus_address_entries_free_APIParam_1. dbus_address_entries_free_APIParam_1 is the array", "key": "dbus_address_entries_free"}, {"API_info": {"var": ["entry"], "ret_type": "const char *", "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var_type": ["DBusAddressEntry *"]}, "sent": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "key": "dbus_address_entry_get_method"}, {"API_info": {"var": ["entry"], "ret_type": "const char *", "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var_type": ["DBusAddressEntry *"]}, "sent": "dbus_address_entry_get_method_APIName return a string describing the method.", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "key": "dbus_address_entry_get_method"}, {"API_info": {"var": ["entry"], "ret_type": "const char *", "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var_type": ["DBusAddressEntry *"]}, "sent": "This string must not be freed", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "key": "dbus_address_entry_get_method"}, {"API_info": {"var": ["entry"], "ret_type": "const char *", "desc": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1.", "var_type": ["DBusAddressEntry *"]}, "sent": "For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1.", "paraph": "Returns the method string of an address dbus_address_entry_get_method_APIParam_1. For example, given the address dbus_address_entry_get_method_APIParam_1 \"tcp:host=example.com\" it would return the string \"tcp\" dbus_address_entry_get_method_APIParam_1 is the dbus_address_entry_get_method_APIParam_1. dbus_address_entry_get_method_APIName return a string describing the method. This string must not be freed", "key": "dbus_address_entry_get_method"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1.", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2.", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value.", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "This string must not be freed", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["value"], "ret_type": "char *", "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *"]}, "sent": "dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1.", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_escape_value"}, {"API_info": {"var": ["value"], "ret_type": "char *", "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *"]}, "sent": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_escape_value"}, {"API_info": {"var": ["value"], "ret_type": "char *", "desc": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *"]}, "sent": "dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "paraph": "Escapes the given string as a dbus_address_escape_value_APIParam_1 in a key=value pair for a D-Bus address. dbus_address_escape_value_APIParam_1 is the unescaped dbus_address_escape_value_APIParam_1. dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_escape_value"}, {"API_info": {"var": ["entry", "key"], "ret_type": "const char *", "desc": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1.", "var_type": ["DBusAddressEntry *", "const char *"]}, "sent": "For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped.", "paraph": "Returns a value from a dbus_address_entry_get_value_APIParam_2 of an dbus_address_entry_get_value_APIParam_1. For example, given the address \"tcp:host=example.com,port=8073\" if you asked for the dbus_address_entry_get_value_APIParam_2 \"host\" you would get the value \"example.com\" dbus_address_entry_get_value_APIParam_0 value is already unescaped. dbus_address_entry_get_value_APIParam_1 is the dbus_address_entry_get_value_APIParam_1. dbus_address_entry_get_value_APIParam_2 is the dbus_address_entry_get_value_APIParam_2. dbus_address_entry_get_value_APIName return the dbus_address_entry_get_value_APIParam_2 value. This string must not be freed", "key": "dbus_address_entry_get_value"}, {"API_info": {"var": ["value", "error"], "ret_type": "char *", "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *", "DBusError *"]}, "sent": "Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1.", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_unescape_value"}, {"API_info": {"var": ["value", "error"], "ret_type": "char *", "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *", "DBusError *"]}, "sent": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_unescape_value"}, {"API_info": {"var": ["value", "error"], "ret_type": "char *", "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1.", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_unescape_value"}, {"API_info": {"var": ["value", "error"], "ret_type": "char *", "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails.", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_unescape_value"}, {"API_info": {"var": ["value", "error"], "ret_type": "char *", "desc": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address.", "var_type": ["const char *", "DBusError *"]}, "sent": "dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "paraph": "Unescapes the given string as a dbus_address_unescape_value_APIParam_1 in a key=value pair for a D-Bus address. Note that dbus_address_entry_get_value_APIName returns an already-unescaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_1 is the escaped dbus_address_unescape_value_APIParam_1. dbus_address_unescape_value_APIParam_2 is dbus_address_unescape_value_APIParam_2 to set if the unescaping fails. dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory", "key": "dbus_address_unescape_value"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "dbus_parse_address_APIParam_2 is return location to an array of entries.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "dbus_parse_address_APIParam_3 is return location for array length.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["address", "entry_result", "array_len", "error"], "ret_type": "dbus_bool_t", "desc": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "var_type": ["const char *", "DBusAddressEntry ***", "int *", "DBusError *"]}, "sent": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format.", "paraph": "Parses an dbus_parse_address_APIParam_1 string of the form: method:key=value,key=value;method:key=value See the D-Bus specification for complete docs on the format. When connecting to an dbus_parse_address_APIParam_1, the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first. dbus_parse_address_APIParam_1 is the dbus_parse_address_APIParam_1. dbus_parse_address_APIParam_2 is return location to an array of entries. dbus_parse_address_APIParam_3 is return location for array length. dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned. dbus_parse_address_APIName return TRUE on success, FALSE otherwise", "key": "dbus_parse_address"}, {"API_info": {"var": ["watch"], "ret_type": "void *", "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var_type": ["DBusWatch *"]}, "sent": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "key": "dbus_watch_get_data"}, {"API_info": {"var": ["watch"], "ret_type": "void *", "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_data_APIParam_1 is the DBusWatch object.", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "key": "dbus_watch_get_data"}, {"API_info": {"var": ["watch"], "ret_type": "void *", "desc": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_data_APIName return previously-set data", "paraph": "Gets data previously set with dbus_watch_set_data_APIName or NULL if none. dbus_watch_get_data_APIParam_1 is the DBusWatch object. dbus_watch_get_data_APIName return previously-set data", "key": "dbus_watch_get_data"}, {"API_info": {"var": ["watch"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusWatch *"]}, "sent": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "key": "dbus_watch_get_enabled"}, {"API_info": {"var": ["watch"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusWatch *"]}, "sent": "If not enabled, it should not be polled by the main loop.", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "key": "dbus_watch_get_enabled"}, {"API_info": {"var": ["watch"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_enabled_APIParam_1 is the DBusWatch object.", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "key": "dbus_watch_get_enabled"}, {"API_info": {"var": ["watch"], "ret_type": "dbus_bool_t", "desc": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "paraph": "Returns whether a dbus_watch_get_enabled_APIParam_1 is enabled or not. If not enabled, it should not be polled by the main loop. dbus_watch_get_enabled_APIParam_1 is the DBusWatch object. dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled", "key": "dbus_watch_get_enabled"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var_type": ["DBusWatch *"]}, "sent": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "key": "dbus_watch_get_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_fd_APIParam_1 is the DBusWatch object.", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "key": "dbus_watch_get_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Deprecated former name of dbus_watch_get_unix_fd_APIName .", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "paraph": "Deprecated former name of dbus_watch_get_unix_fd_APIName . dbus_watch_get_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_fd_APIName return the file descriptor to dbus_watch_get_fd_APIParam_1", "key": "dbus_watch_get_fd"}, {"API_info": {"var": ["watch"], "ret_type": "unsigned int", "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var_type": ["DBusWatch *"]}, "sent": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "key": "dbus_watch_get_flags"}, {"API_info": {"var": ["watch"], "ret_type": "unsigned int", "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_flags_APIParam_1 is the DBusWatch object.", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "key": "dbus_watch_get_flags"}, {"API_info": {"var": ["watch"], "ret_type": "unsigned int", "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "key": "dbus_watch_get_flags"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var_type": ["DBusWatch *"]}, "sent": "On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now).", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "key": "dbus_watch_get_socket"}, {"API_info": {"var": ["watch"], "ret_type": "unsigned int", "desc": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor.", "var_type": ["DBusWatch *"]}, "sent": "The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions.", "paraph": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor. The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR; all watches implicitly include a dbus_watch_get_flags_APIParam_1 for hangups, errors, and other exceptional conditions. dbus_watch_get_flags_APIParam_1 is the DBusWatch object. dbus_watch_get_flags_APIName return the conditions to dbus_watch_get_flags_APIParam_1", "key": "dbus_watch_get_flags"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_socket_APIParam_1 is the DBusWatch object.", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "key": "dbus_watch_get_socket"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var_type": ["DBusWatch *"]}, "sent": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "key": "dbus_watch_get_socket"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "paraph": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred. On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket (assuming the transport is socket-based, as it always is for now). dbus_watch_get_socket_APIParam_1 is the DBusWatch object. dbus_watch_get_socket_APIName return the socket to dbus_watch_get_socket_APIParam_1", "key": "dbus_watch_get_socket"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "Always returns -1 on Windows.", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "On UNIX this is preferred to dbus_watch_get_socket_APIName  .", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1.", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object.", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch"], "ret_type": "int", "desc": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor.", "var_type": ["DBusWatch *"]}, "sent": "dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "paraph": "Returns a UNIX file descriptor to be watched, which may be a pipe, socket, or other type of descriptor. On UNIX this is preferred to dbus_watch_get_socket_APIName since it works with more kinds of DBusWatch . Always returns -1 on Windows. On Windows you use dbus_watch_get_socket_APIName to get a Winsock socket to dbus_watch_get_unix_fd_APIParam_1. dbus_watch_get_unix_fd_APIParam_1 is the DBusWatch object. dbus_watch_get_unix_fd_APIName return the file descriptor to dbus_watch_get_unix_fd_APIParam_1", "key": "dbus_watch_get_unix_fd"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "It is not allowed to reference a DBusWatch after it has been passed to remove_function.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "dbus_watch_handle_APIParam_1 is the DBusWatch object.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen.", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "flags"], "ret_type": "dbus_bool_t", "desc": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup.", "var_type": ["DBusWatch *", "unsigned int"]}, "sent": "dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "paraph": "Called to notify the D-Bus library when a previously-added dbus_watch_handle_APIParam_1 is ready for reading or writing, or has an exception such as a hangup. If dbus_watch_handle_APIName returns FALSE , then the file descriptor may still be ready for reading or writing, but more memory is needed in order to do the reading or writing. If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen. dbus_watch_handle_APIName cannot be called during the DBusAddWatchFunction, as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet. It is not allowed to reference a DBusWatch after it has been passed to remove_function. dbus_watch_handle_APIParam_1 is the DBusWatch object. dbus_watch_handle_APIParam_2 is the poll condition using DBusWatchFlags values. dbus_watch_handle_APIName return FALSE if there wasn't enough memory", "key": "dbus_watch_handle"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2.", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource.", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "dbus_watch_set_data_APIParam_1 is the DBusWatch object.", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2.", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}, {"API_info": {"var": ["watch", "data", "free_data_function"], "ret_type": "void", "desc": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName .", "var_type": ["DBusWatch *", "void *", "DBusFreeFunction"]}, "sent": "dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "paraph": "Sets dbus_watch_set_data_APIParam_2 which can be retrieved with dbus_watch_get_data_APIName . Intended for use by the DBusAddWatchFunction and DBusRemoveWatchFunction to store their own dbus_watch_set_data_APIParam_2. For example with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource. dbus_watch_set_data_APIParam_1 is the DBusWatch object. dbus_watch_set_data_APIParam_2 is the dbus_watch_set_data_APIParam_2. dbus_watch_set_data_APIParam_3 is function to be called to free the dbus_watch_set_data_APIParam_2", "key": "dbus_watch_set_data"}]