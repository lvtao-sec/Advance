[{"cond": "null", "prop": "that is , you recurse into the array , and you call dbus_message_iter_get_fixed_array_APIName on the `` sub-iterator '' created by dbus_message_iter_recurse_APIName"}, {"cond": "null", "prop": "dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred"}, {"cond": "null", "prop": "dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred"}, {"cond": "null", "prop": "dbus_pending_call_get_completed_APIName return TRUE if a reply has been received"}, {"cond": "null", "prop": "dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3"}, {"cond": "null", "prop": "dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds"}, {"cond": "null", "prop": "dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled"}, {"cond": "null", "prop": "dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set"}, {"cond": "null", "prop": "dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set"}, {"cond": "null", "prop": "dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start"}, {"cond": "null", "prop": "dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply"}, {"cond": "null", "prop": "dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array"}, {"cond": "null", "prop": "dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2"}, {"cond": "null", "prop": "dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header"}, {"cond": "null", "prop": "dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header"}, {"cond": "null", "prop": "dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender"}, {"cond": "null", "prop": "dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2"}, {"cond": "null", "prop": "dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error"}, {"cond": "null", "prop": "dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call"}, {"cond": "null", "prop": "dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal"}, {"cond": "null", "prop": "dbus_message_iter_has_next_APIName return TRUE if there are more fields following"}, {"cond": "null", "prop": "dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments"}, {"cond": "null", "prop": "dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field"}, {"cond": "null", "prop": "dbus_message_marshal_APIName return FALSE if there was not enough memory"}, {"cond": "null", "prop": "dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3"}, {"cond": "null", "prop": "dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR"}, {"cond": "null", "prop": "dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level"}, {"cond": "null", "prop": "dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set"}, {"cond": "null", "prop": "dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type"}, {"cond": "null", "prop": "dbus_type_is_basic_APIName return TRUE if type is basic"}, {"cond": "null", "prop": "dbus_type_is_container_APIName return TRUE if type is a container"}, {"cond": "null", "prop": "dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths"}, {"cond": "null", "prop": "dbus_server_set_auth_mechanisms_APIName return FALSE if no memory"}, {"cond": "null", "prop": "dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3"}, {"cond": "null", "prop": "dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid"}, {"cond": "null", "prop": "dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid"}, {"cond": "null", "prop": "dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid"}, {"cond": "null", "prop": "dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid"}, {"cond": "null", "prop": "dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid"}, {"cond": "null", "prop": "dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8"}, {"cond": "null", "prop": "dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1"}, {"cond": "null", "prop": "dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer"}, {"cond": "null", "prop": "dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous"}, {"cond": "null", "prop": "dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated"}, {"cond": "null", "prop": "dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive"}, {"cond": "null", "prop": "dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained"}, {"cond": "null", "prop": "dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained"}, {"cond": "null", "prop": "dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID"}, {"cond": "null", "prop": "dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID"}, {"cond": "null", "prop": "dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty"}, {"cond": "null", "prop": "dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries"}, {"cond": "null", "prop": "dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory"}, {"cond": "null", "prop": "dbus_connection_read_write_APIName return TRUE if still connected"}, {"cond": "null", "prop": "dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed"}, {"cond": "null", "prop": "dbus_connection_register_fallback_APIName return FALSE if an error  occured"}, {"cond": "null", "prop": "dbus_connection_register_object_path_APIName return FALSE if an error  ocurred"}, {"cond": "null", "prop": "dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3"}, {"cond": "null", "prop": "dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5  is reported"}, {"cond": "null", "prop": "dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5  is reported"}, {"cond": "null", "prop": "dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3"}, {"cond": "null", "prop": "dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not"}, {"cond": "null", "prop": "dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled"}, {"cond": "null", "prop": "dbus_timeout_handle_APIName return FALSE if there wasn't enough memory"}, {"cond": "null", "prop": "dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled"}, {"cond": "null", "prop": "dbus_watch_handle_APIName return FALSE if there wasn't enough memory"}, {"cond": "null", "prop": "Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized"}, {"cond": "null", "prop": "dbus_move_error_APIParam_2 may not contain an existing error"}, {"cond": "if it is set at some point", "prop": "the dbus_error_init_APIParam_1 only needs to be freed"}, {"cond": "null", "prop": "dbus_move_error_APIParam_1 is the source error"}, {"cond": "null", "prop": "dbus_move_error_APIParam_2 is the destination error or NULL"}, {"cond": "null", "prop": "The dbus_set_error_APIParam_3 may be NULL , which means a default message will be deduced from the dbus_set_error_APIParam_2"}, {"cond": "null", "prop": "It will not hurt you"}, {"cond": "null", "prop": "The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2"}, {"cond": "null", "prop": "The default dbus_set_error_const_APIParam_3 will be totally useless , though , so using a NULL dbus_set_error_const_APIParam_3 is not recommended"}, {"cond": "null", "prop": "dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL"}, {"cond": "null", "prop": "You probably want dbus_set_error_APIName instead , in most cases"}, {"cond": "null", "prop": "you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed"}, {"cond": "null", "prop": "Frees a NULL - terminated array of strings"}, {"cond": "If passed", "prop": "NULL , does nothing"}, {"cond": "If passed", "prop": "NULL , does nothing"}, {"cond": "If passed", "prop": "NULL , does nothing"}, {"cond": "If passed", "prop": "NULL , does nothing"}, {"cond": "null", "prop": "Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms"}, {"cond": "null", "prop": "Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms"}, {"cond": "null", "prop": "dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library"}, {"cond": "null", "prop": "dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library"}, {"cond": "null", "prop": "dbus_malloc_APIParam_0 must be released with dbus_free_APIName"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if the allocation fails", "prop": "Returns NULL"}, {"cond": "if the allocation fails.dbus_malloc0_APIParam_0 must be released with dbus_free_APIName", "prop": "Returns NULL"}, {"cond": "if the resize fails", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if none", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "if memory can not be allocated for the message", "prop": "Returns NULL"}, {"cond": "null", "prop": "Free it with dbus_free_APIName only"}, {"cond": "null", "prop": "dbus_malloc_APIName return allocated memory, or NULL if the allocation fails"}, {"cond": "null", "prop": "dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails"}, {"cond": "null", "prop": "Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms"}, {"cond": "null", "prop": "dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails"}, {"cond": "null", "prop": "You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName"}, {"cond": "null", "prop": "You can not continue to use any D-Bus objects , such as connections , that were allocated prior to dbus_shutdown_APIName"}, {"cond": "null", "prop": "The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers"}, {"cond": "null", "prop": "There is absolutely no requirement to call dbus_shutdown_APIName - in fact , most applications will not bother and should not feel guilty"}, {"cond": "while NO other threads are using D-Bus", "prop": "dbus_shutdown_APIName is NOT thread safe , it must be called"}, {"cond": "null", "prop": "You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName"}, {"cond": "null", "prop": "dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName"}, {"cond": "null", "prop": "dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName"}, {"cond": "null", "prop": "dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName"}, {"cond": "null", "prop": "this will result in processing of the special Disconnected signal , which may result in a call to _exit_APIName , unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour"}, {"cond": "null", "prop": "One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong"}, {"cond": "null", "prop": "Returns a 32-byte-long hex-encoded UUID string , or NULL on failure"}, {"cond": "null", "prop": "Returns a 32-byte-long hex-encoded UUID string , or NULL on failure"}, {"cond": "null", "prop": "Returns a 32-byte-long hex-encoded UUID string , or NULL on failure"}, {"cond": "null", "prop": "Returns a 32-byte-long hex-encoded UUID string , or NULL on failure"}, {"cond": "null", "prop": "dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly"}, {"cond": "null", "prop": "dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3"}, {"cond": "null", "prop": "dbus_get_version_APIParam_1 is pointer to return the major version, or NULL"}, {"cond": "null", "prop": "Alternatively , there are macros #DBUS_MAJOR_VERSION , #DBUS_MINOR_VERSION , #DBUS_MICRO_VERSION , and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST"}, {"cond": "null", "prop": "dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL"}, {"cond": "null", "prop": "The MINOR is an odd number for development releases and an even number for stable releases"}, {"cond": "null", "prop": "dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL"}, {"cond": "null", "prop": "This is because we can not rely on internal implementation details of the underlying libc library"}, {"cond": "null", "prop": "dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable , or NULL to unset"}, {"cond": "null", "prop": "dbus_setenv_APIName return TRUE on success, FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory"}, {"cond": "null", "prop": "The machine ID can also be used to create unique per-machine instances"}, {"cond": "null", "prop": "The machine ID is preferred over the machine hostname , and may also change at runtime"}, {"cond": "null", "prop": "The UUID is not a UUID in the sense of RFC4122"}, {"cond": "null", "prop": "The allocated ID may be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName"}, {"cond": "null", "prop": "The allocated ID may be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName"}, {"cond": "null", "prop": "The allocated ID may be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName"}, {"cond": "null", "prop": "The allocated ID may be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "The passed-in slot must be initialized to -1 , and is filled in with the slot ID"}, {"cond": "null", "prop": "If the remote application has the same machine ID as the one returned by this function, the remote application is on the same machine as your application"}, {"cond": "null", "prop": "all DBusPendingCall objects will have a slot with the given integer ID reserved"}, {"cond": "null", "prop": "all DBusMessage objects will have a slot with the given integer ID reserved"}, {"cond": "null", "prop": "all DBusServer objects will have a slot with the given integer ID reserved"}, {"cond": "null", "prop": "all DBusConnection objects will have a slot with the given integer ID reserved"}, {"cond": "null", "prop": "dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_server_set_watch_functions_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory"}, {"cond": "null", "prop": "Block until the dbus_pending_call_block_APIParam_1 call is completed"}, {"cond": "null", "prop": "This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call"}, {"cond": "null", "prop": "but it should really only use time remaining"}, {"cond": "null", "prop": "dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot"}, {"cond": "null", "prop": "dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot"}, {"cond": "null", "prop": "dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot"}, {"cond": "null", "prop": "dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot"}, {"cond": "null", "prop": "The idea is that two processes with the same machine ID should be able to use shared memory , UNIX domain sockets , process IDs , and other features of the OS that require both processes to be running on the same OS kernel instance"}, {"cond": "null", "prop": "The dbus_pending_call_get_data_APIParam_2 must still be allocated"}, {"cond": "null", "prop": "The dbus_message_get_data_APIParam_2 must still be allocated"}, {"cond": "null", "prop": "The dbus_server_get_data_APIParam_2 must still be allocated"}, {"cond": "null", "prop": "The dbus_connection_get_data_APIParam_2 must still be allocated"}, {"cond": "null", "prop": "dbus_pending_call_get_data_APIName return the data, or NULL if not found"}, {"cond": "null", "prop": "dbus_message_get_data_APIName return the data, or NULL if not found"}, {"cond": "null", "prop": "dbus_server_get_data_APIName return the data, or NULL if not found"}, {"cond": "null", "prop": "dbus_connection_get_data_APIName return the data, or NULL if not found"}, {"cond": "null", "prop": "The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName"}, {"cond": "null", "prop": "The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName"}, {"cond": "null", "prop": "The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName"}, {"cond": "null", "prop": "The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName"}, {"cond": "null", "prop": "dbus_pending_call_set_notify_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_iter_append_basic_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_iter_close_container_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_iter_open_container_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_container_instance_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_destination_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_error_name_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_interface_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_member_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_path_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_reply_serial_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_message_set_sender_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_connection_get_object_path_data_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_connection_unregister_object_path_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "dbus_bus_set_unique_name_APIName return FALSE if not enough memory"}, {"cond": "null", "prop": "Gets the reply, or returns NULL if none has been received yet"}, {"cond": "null", "prop": "dbus_pending_call_steal_reply_APIName return the reply message or NULL"}, {"cond": "null", "prop": "dbus_message_new_APIName return new message or NULL if no memory"}, {"cond": "null", "prop": "dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call"}, {"cond": "null", "prop": "The variable argument list should contain the type of each argument followed by the value to append"}, {"cond": "null", "prop": "dbus_message_append_args_APIName does not support arrays of Unix file descriptors"}, {"cond": "If you need those", "prop": "you need to manually recurse into the array"}, {"cond": "null", "prop": "The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list"}, {"cond": "null", "prop": "dbus_message_append_args_APIName return TRUE on success"}, {"cond": "null", "prop": "dbus_message_append_args_valist_APIName return TRUE on success"}, {"cond": "null", "prop": "dbus_connection_send_APIName return TRUE on success"}, {"cond": "null", "prop": "dbus_bus_register_APIName return TRUE on success"}, {"cond": "If you do not do this libdbus", "prop": "will not know to stop and will read invalid memory"}, {"cond": "null", "prop": "support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo"}, {"cond": "null", "prop": "String/signature/path arrays should be passed in as `` const char *** address_of_array '' and `` int n_elements '' Todo"}, {"cond": "null", "prop": "and you have to start over building the whole dbus_message_append_args_APIParam_1"}, {"cond": "null", "prop": "and you have to start over building the whole dbus_message_iter_init_append_APIParam_1"}, {"cond": "null", "prop": "dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors"}, {"cond": "null", "prop": "dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors  can be allocated"}, {"cond": "null", "prop": "dbus_message_demarshal_APIParam_3 is the location to save errors to"}, {"cond": "null", "prop": "The supported types include those supported by dbus_message_append_args_APIName"}, {"cond": "null", "prop": "Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD"}, {"cond": "null", "prop": "The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored"}, {"cond": "If you need them without this flag set", "prop": "make sure to unset it with fcntl_APIName"}, {"cond": "If you need them without this flag set", "prop": "make sure to unset it with fcntl_APIName"}, {"cond": "If you need them without this flag set", "prop": "make sure to unset it with fcntl_APIName"}, {"cond": "If you need them without this flag set", "prop": "make sure to unset it with fcntl_APIName"}, {"cond": "If you need to parse messages with arrays of Unix file descriptors", "prop": "you need to recurse into the array manually"}, {"cond": "null", "prop": "In addition to those types , arrays of string , object path , and signature are supported"}, {"cond": "null", "prop": "support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1"}, {"cond": "null", "prop": "but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references"}, {"cond": "null", "prop": "dbus_message_get_container_instance_APIName return the path  or NULL"}, {"cond": "null", "prop": "dbus_message_get_path_APIName return the path  or NULL"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "if the argument is a valid dbus_type_is_valid_APIParam_1", "prop": "Return TRUE"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_auto_start_APIParam_1 will cause an owner for destination name to be auto-started", "prop": "Returns TRUE"}, {"cond": "if the dbus_message_get_no_reply_APIParam_1 does not expect a reply", "prop": "Returns TRUE"}, {"cond": "if the dbus_server_get_is_connected_APIParam_1 is still listening for new connections", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_process_id_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the dbus_connection_get_unix_user_APIParam_2 is filled in", "prop": "Returns TRUE"}, {"cond": "if the ID is filled in", "prop": "Returns TRUE"}, {"cond": "null", "prop": "dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination  or NULL"}, {"cond": "if there is none set", "prop": "Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL"}, {"cond": "null", "prop": "dbus_message_get_error_name_APIName return the error name  or NULL"}, {"cond": "if none", "prop": "Gets the error name or NULL"}, {"cond": "null", "prop": "dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface  or NULL"}, {"cond": "null", "prop": "dbus_message_get_member_APIName return the member name  or NULL"}, {"cond": "if no dbus_message_get_path_decomposed_APIParam_2 field exists", "prop": "NULL set here"}, {"cond": "if none", "prop": "Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0"}, {"cond": "null", "prop": "dbus_message_get_reply_serial_APIName return the reply serial"}, {"cond": "null", "prop": "dbus_message_get_serial_APIName return the serial"}, {"cond": "null", "prop": "dbus_bus_get_private_APIName return a DBusConnection with new ref"}, {"cond": "null", "prop": "So the dbus_message_get_path_decomposed_APIParam_2 '' / foo/bar '' becomes -LCB- `` foo '' , `` bar '' , NULL -RCB- and the dbus_message_get_path_decomposed_APIParam_2 '' / '' becomes -LCB- NULL -RCB-"}, {"cond": "null", "prop": "Note , dbus_message_get_sender_APIParam_0 sender is always the unique bus name"}, {"cond": "null", "prop": "Connections may own multiple other bus names , but those are not found in the sender field"}, {"cond": "null", "prop": "dbus_message_get_sender_APIName return the unique name of the sender or NULL"}, {"cond": "if none", "prop": "Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 has been specified"}, {"cond": "null", "prop": "The signature includes only `` in '' arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only `` out '' arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect"}, {"cond": "null", "prop": "DBUS_MESSAGE_TYPE_INVALID will never be returned"}, {"cond": "null", "prop": "If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE"}, {"cond": "null", "prop": "Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type"}, {"cond": "null", "prop": "If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE"}, {"cond": "null", "prop": "So you can not use dbus_message_has_sender_APIName to see"}, {"cond": "null", "prop": "If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE"}, {"cond": "null", "prop": "If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE"}, {"cond": "null", "prop": "If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE"}, {"cond": "null", "prop": "The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name"}, {"cond": "If the interface field is missing", "prop": "it will be assumed equal to the provided interface"}, {"cond": "when you have open containers", "prop": "This should only be used to abandon creation of a message"}, {"cond": "null", "prop": "The `` value '' argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3"}, {"cond": "null", "prop": "dbus_bool_t result = FALSE"}, {"cond": "null", "prop": "result = TRUE"}, {"cond": "null", "prop": "return result"}, {"cond": "null", "prop": "You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function"}, {"cond": "null", "prop": "You may call dbus_message_iter_append_fixed_array_APIName multiple times for the same array"}, {"cond": "null", "prop": "The `` value '' argument should be the address of the array"}, {"cond": "null", "prop": "It must not be closed again with this function , or abandoned with dbus_message_iter_abandon_container_APIName"}, {"cond": "Even if dbus_message_iter_close_container_APIName fails due to lack of memory", "prop": "the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated"}, {"cond": "null", "prop": "If the iterator is at the end of the message, returns DBUS_TYPE_INVALID"}, {"cond": "null", "prop": "You can thus write a loop as follows"}, {"cond": "null", "prop": "The iterator must currently be inside an array-typed value"}, {"cond": "null", "prop": "dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid"}, {"cond": "null", "prop": "Use dbus_message_iter_get_element_count_APIName instead"}, {"cond": "null", "prop": "Why would you want to know how many bytes are in the array as marshaled in the wire protocol ?"}, {"cond": "null", "prop": "The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0"}, {"cond": "null", "prop": "The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0"}, {"cond": "null", "prop": "dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed"}, {"cond": "null", "prop": "So for int32 it should be a `` dbus_int32_t * '' and for string a `` const char ** ''"}, {"cond": "null", "prop": "To read any container type you will need to recurse into the container with dbus_message_iter_recurse_APIName"}, {"cond": "when you do not need them anymore", "prop": "It is your job to close them"}, {"cond": "when you try to use an integer as a string or something", "prop": "you 'll crash"}, {"cond": "null", "prop": "Note that you need to check that the iterator points to an array prior to using this function"}, {"cond": "null", "prop": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting , or"}, {"cond": "null", "prop": "Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into"}, {"cond": "null", "prop": "The message dbus_message_iter_get_fixed_array_APIParam_1 should be `` in '' the array"}, {"cond": "null", "prop": "dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type"}, {"cond": "if the application was expected to exit before running the main loop", "prop": "dbus_connection_flush_APIName should only be used"}, {"cond": "null", "prop": "So for int32 it should be a `` const dbus_int32_t ** '' dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed"}, {"cond": "null", "prop": "dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory"}, {"cond": "null", "prop": "Some types of argument can only be read with DBusMessageIter however"}, {"cond": "null", "prop": "it need not be freed , and can be copied by assignment or memcpy_APIName"}, {"cond": "null", "prop": "If there no next field, returns FALSE"}, {"cond": "null", "prop": "If the iterator moves forward, returns TRUE"}, {"cond": "null", "prop": "On success , you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator , and call dbus_message_iter_close_container_APIName"}, {"cond": "null", "prop": "For variants , the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant"}, {"cond": "null", "prop": "For arrays , dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements"}, {"cond": "null", "prop": "For structs and dict entries , dbus_message_iter_open_container_APIParam_3 should be NULL"}, {"cond": "null", "prop": "However , after dbus_message_iter_open_container_APIName has either succeeded or failed , it is valid to call dbus_message_iter_abandon_container_if_open_APIName"}, {"cond": "If dbus_message_iter_open_container_APIName fails", "prop": "the sub-iterator remains invalid , and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName"}, {"cond": "if the value exists", "prop": "you can only recurse"}, {"cond": "null", "prop": "dbus_message_lock_APIName may also called externally , for applications wrapping D-Bus in another protocol"}, {"cond": "if there is no container to recurse into at the current iterator position", "prop": "Results of dbus_message_iter_recurse_APIName are undefined"}, {"cond": "null", "prop": "dbus_message_marshal_APIParam_2 is the location to save the marshalled form to"}, {"cond": "null", "prop": "dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to"}, {"cond": "null", "prop": "Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead"}, {"cond": "null", "prop": "The error name must be a valid error name according to the syntax given in the D-Bus specification"}, {"cond": "If you do not want to make up an error name", "prop": "just use DBUS_ERROR_FAILED"}, {"cond": "null", "prop": "dbus_message_new_error_printf_APIName return a new error message"}, {"cond": "null", "prop": "The main implication of this is that , but it will have no values , so you will not be able to recurse further"}, {"cond": "null", "prop": "The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL"}, {"cond": "null", "prop": "The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set"}, {"cond": "null", "prop": "Destination , dbus_message_new_method_call_APIParam_2 , interface , and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters"}, {"cond": "null", "prop": "dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL"}, {"cond": "null", "prop": "dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to"}, {"cond": "null", "prop": "dbus_message_new_method_call_APIParam_4 is on , or NULL dbus_message_new_method_call_APIParam_4 method to invoke"}, {"cond": "null", "prop": "The interface may be NULL , which"}, {"cond": "null", "prop": "Path , interface , and signal dbus_message_new_signal_APIParam_3 must all be valid"}, {"cond": "null", "prop": "dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref"}, {"cond": "null", "prop": "For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set"}, {"cond": "if interactive authorization is acceptable", "prop": "dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE"}, {"cond": "if auto-starting is desired", "prop": "dbus_message_set_auto_start_APIParam_2 is TRUE"}, {"cond": "if no reply is desired", "prop": "dbus_message_set_no_reply_APIParam_2 is TRUE"}, {"cond": "if _exit_APIName should be called after a disconnect signal", "prop": "dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE"}, {"cond": "null", "prop": "It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that"}, {"cond": "null", "prop": "dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset"}, {"cond": "null", "prop": "dbus_message_set_path_APIParam_2 is the path or NULL to unset"}, {"cond": "null", "prop": "The path must contain only valid characters for an object path as defined in the D-Bus specification"}, {"cond": "null", "prop": "The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification"}, {"cond": "null", "prop": "The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification"}, {"cond": "null", "prop": "dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset"}, {"cond": "null", "prop": "The error name must contain only valid characters as defined in the D-Bus specification"}, {"cond": "null", "prop": "dbus_message_set_error_name_APIParam_2 is the name or NULL to unset"}, {"cond": "null", "prop": "The interface name must contain only valid characters as defined in the D-Bus specification"}, {"cond": "null", "prop": "dbus_message_set_interface_APIParam_2 is the interface or NULL to unset"}, {"cond": "null", "prop": "dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset"}, {"cond": "null", "prop": "dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset"}, {"cond": "null", "prop": "The path must contain only valid characters as defined in the D-Bus specification"}, {"cond": "null", "prop": "The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification"}, {"cond": "null", "prop": "Usually you do not want to call this"}, {"cond": "null", "prop": "This can only be done once on a dbus_message_set_serial_APIParam_1"}, {"cond": "If you are not implementing a dbus_message_set_sender_APIParam_1 bus", "prop": "daemon you should not need to set the dbus_message_set_sender_APIParam_2"}, {"cond": "when encapsulating messages in another protocol , or otherwise bypassing DBusConnection", "prop": "dbus_message_set_serial_APIName is only needed"}, {"cond": "if the dbus_set_error_from_message_APIParam_2 is an dbus_set_error_from_message_APIParam_1 dbus_set_error_from_message_APIParam_2", "prop": "The dbus_set_error_from_message_APIParam_1 is only set , as in DBUS_MESSAGE_TYPE_ERROR"}, {"cond": "null", "prop": "DBUS_TYPE_STRUCT , not ' -LRB- '"}, {"cond": "null", "prop": "If the iterator is pointing at a type code such as ', the iterator will be returned directly"}, {"cond": "null", "prop": "you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type"}, {"cond": "null", "prop": "Returns the signature of the single complete type starting at the given iterator"}, {"cond": "null", "prop": "If the iterator is pointing at one of the \"i\" just that \"i\" would be returned"}, {"cond": "if you invoke dbus_signature_iter_get_element_type_APIName when the current type of the iterator is not DBUS_TYPE_ARRAY", "prop": "Undefined behavior results"}, {"cond": "null", "prop": "Should be freed with dbus_free_APIName"}, {"cond": "null", "prop": "dbus_signature_iter_init_APIName is not safe to use on invalid signatures"}, {"cond": "null", "prop": "be sure to validate potentially invalid signatures with dbus_signature_validate before using this function"}, {"cond": "null", "prop": "Returns FALSE at the end of the current container"}, {"cond": "null", "prop": "if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName )"}, {"cond": "null", "prop": "if the iterator is pointing at the start of \"ii\" , \"\" would be returned"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_signature_validate_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_bus_name_APIParam_2 dbus_validate_bus_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_error_name_APIParam_2 dbus_validate_error_name_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_interface_APIParam_2 dbus_validate_interface_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_member_APIParam_2 dbus_validate_member_APIParam_1 and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_path_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "if you do not care about having an dbus_validate_utf8_APIParam_2 name and message", "prop": "NULL can always be passed instead of a DBusError *"}, {"cond": "when calling this", "prop": "The results are undefined if the current type is a non-container -LRB- i.e"}, {"cond": "If you dbus_connection_unref_APIName for the last time without closing the dbus_connection_close_APIParam_1", "prop": "the results are undefined"}, {"cond": "null", "prop": "DBUS_TYPE_INVALID is not a basic type"}, {"cond": "null", "prop": "dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID"}, {"cond": "null", "prop": "dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID"}, {"cond": "null", "prop": "dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function"}, {"cond": "null", "prop": "DBUS_TYPE_INVALID is not a container type"}, {"cond": "null", "prop": "dbus_type_is_valid_APIName is safe with untrusted data"}, {"cond": "null", "prop": "DBUS_TYPE_INVALID surprisingly enough is not considered valid , and random unknown bytes are not either"}, {"cond": "null", "prop": "dbus_type_is_valid_APIName return TRUE if valid"}, {"cond": "null", "prop": "For this purpose , you assume that the first byte of the old and new value would be in the same location , so alignment padding is not a factor"}, {"cond": "null", "prop": "The slot must be initialized with -1"}, {"cond": "null", "prop": "dbus_server_allocate_data_slot_APIName return FALSE on no memory"}, {"cond": "If called more than once", "prop": "only the first call has an effect"}, {"cond": "null", "prop": "dbus_server_get_address_APIName return the address or NULL if no memory"}, {"cond": "null", "prop": "Returns the address of the dbus_server_get_address_APIParam_1 , as a newly-allocated string which must be freed by the caller"}, {"cond": "null", "prop": "Returns the unique ID of the dbus_server_get_id_APIParam_1 , as a newly-allocated string which must be freed by the caller"}, {"cond": "null", "prop": "This is an ID unique to each DBusServer"}, {"cond": "null", "prop": "dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection"}, {"cond": "null", "prop": "Remember that a DBusServer represents only one mode of connecting , so e.g"}, {"cond": "null", "prop": "dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory"}, {"cond": "null", "prop": "The ID is not a UUID in the sense of RFC4122"}, {"cond": "null", "prop": "a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID"}, {"cond": "null", "prop": "Otherwise returns a new DBusServer"}, {"cond": "null", "prop": "dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional"}, {"cond": "null", "prop": "To free the server , applications must call first dbus_server_disconnect_APIName and dbus_server_unref_APIName"}, {"cond": "if listening fails for any reason", "prop": "Returns NULL and sets dbus_server_listen_APIParam_2"}, {"cond": "null", "prop": "dbus_server_listen_APIName return a new DBusServer , or NULL on failure"}, {"cond": "null", "prop": "dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called"}, {"cond": "null", "prop": "Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of timeouts"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of timeouts"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of timeouts"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of timeouts"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events"}, {"cond": "null", "prop": "The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero"}, {"cond": "null", "prop": "dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1 , which must not be NULL"}, {"cond": "null", "prop": "dbus_validate_error_name_APIParam_1 is a potentially invalid"}, {"cond": "null", "prop": "dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return"}, {"cond": "null", "prop": "dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1 , which must not be NULL"}, {"cond": "null", "prop": "dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1 , which must not be NULL"}, {"cond": "null", "prop": "dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1 , which must not be NULL"}, {"cond": "null", "prop": "Strings on D-Bus must be valid UTF-8"}, {"cond": "null", "prop": "dbus_validate_utf8_APIParam_1 is a string to be checked , which must not be NULL"}, {"cond": "null", "prop": "This is probably a feature , as filters could create arbitrary reentrancy"}, {"cond": "null", "prop": "If the queue is empty, returns NULL"}, {"cond": "null", "prop": "If the queue is empty, returns NULL"}, {"cond": "null", "prop": "If the queue is empty, returns NULL"}, {"cond": "null", "prop": "If the queue is empty, returns NULL"}, {"cond": "null", "prop": "The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName"}, {"cond": "null", "prop": "This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD"}, {"cond": "null", "prop": "The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this"}, {"cond": "null", "prop": "it will return FALSE for all types this implementation does not know, including invalid or reserved types"}, {"cond": "null", "prop": "all calls after the first do nothing"}, {"cond": "null", "prop": "it is safe to close a dbus_connection_close_APIParam_1 more than once"}, {"cond": "null", "prop": "You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1"}, {"cond": "null", "prop": "You may not close a shared dbus_connection_close_APIParam_1"}, {"cond": "null", "prop": "it is impossible to `` reopen '' a dbus_connection_close_APIParam_1 , a new dbus_connection_close_APIParam_1 must be created"}, {"cond": "null", "prop": "These connections are owned by libdbus , and applications should only unref them , never close them"}, {"cond": "null", "prop": "Applications can know it is safe to unref these connections as the dbus_connection_close_APIParam_1 is open"}, {"cond": "if the dbus_connection_close_APIParam_1 is not already disconnected", "prop": "The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference"}, {"cond": "If threads have been initialized with a recursive mutex function", "prop": "this will not deadlock"}, {"cond": "null", "prop": "Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1"}, {"cond": "null", "prop": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1"}, {"cond": "null", "prop": "Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1"}, {"cond": "null", "prop": "Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1"}, {"cond": "if the dbus_connection_free_preallocated_send_APIParam_2 resources are not used to send a message", "prop": "Should only be called"}, {"cond": "null", "prop": "DBUS_DISPATCH_NEED_MEMORY indicates that there could be data , but we can not know for sure without more memory"}, {"cond": "while invoking dbus_connection_get_data_APIName", "prop": "you need to know there a reference held on the dbus_connection_get_data_APIParam_1"}, {"cond": "while invoking dbus_connection_set_data_APIName", "prop": "you need to know there a reference held on the dbus_connection_set_data_APIParam_1"}, {"cond": "When these bytes are parsed", "prop": "they may not add up to an entire message"}, {"cond": "null", "prop": "If it is authenticated as a specific user, this returns FALSE"}, {"cond": "null", "prop": "If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE"}, {"cond": "If the dbus_connection_get_is_anonymous_APIParam_1 is not anonymous", "prop": "you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as"}, {"cond": "null", "prop": "dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not"}, {"cond": "If nothing was registered at this dbus_connection_get_object_path_data_APIParam_2", "prop": "the data is filled in with NULL"}, {"cond": "null", "prop": "The only way to be sure the server ID is available is to wait for authentication to complete"}, {"cond": "null", "prop": "If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side"}, {"cond": "null", "prop": "dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side"}, {"cond": "null", "prop": "The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature , as optimizations may choose to tell small white lies to avoid performance overhead"}, {"cond": "If a client-side dbus_connection_get_server_id_APIParam_1 is not authenticated yet", "prop": "the ID may be available if it was included in the server address , but may not be available"}, {"cond": "null", "prop": "If the dbus_connection_get_socket_APIParam_1 is not socket-based , dbus_connection_get_socket_APIName will return FALSE"}, {"cond": "null", "prop": "dbus_connection_get_socket_APIParam_2 is return location for the file descriptor"}, {"cond": "null", "prop": "dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor"}, {"cond": "null", "prop": "dbus_connection_get_unix_fd_APIName always fails on Windows"}, {"cond": "null", "prop": "Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket , but that is not guaranteed"}, {"cond": "If the dbus_connection_get_unix_fd_APIParam_1 is socket-based", "prop": "you can also use dbus_connection_get_socket_APIName , which will work on Windows too"}, {"cond": "null", "prop": "dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID"}, {"cond": "null", "prop": "Always returns FALSE on non-UNIX platforms for now"}, {"cond": "null", "prop": "Always returns FALSE on non-Windows platforms for now"}, {"cond": "null", "prop": "clients can not usually get the UID of servers"}, {"cond": "null", "prop": "You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 like"}, {"cond": "null", "prop": "clients can not usually get the user of servers"}, {"cond": "null", "prop": "dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory"}, {"cond": "null", "prop": "We would like to be able to say `` You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 like"}, {"cond": "null", "prop": "if it is available but we do not have the memory to copy it , the return value is TRUE and NULL is given as the SID"}, {"cond": "null", "prop": "dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName"}, {"cond": "null", "prop": "dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children"}, {"cond": "null", "prop": "Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server"}, {"cond": "null", "prop": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter"}, {"cond": "null", "prop": "If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter"}, {"cond": "null", "prop": "dbus_connection_open_APIName return new connection, or NULL on failure"}, {"cond": "null", "prop": "dbus_connection_open_private_APIName return new connection, or NULL on failure"}, {"cond": "null", "prop": "dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned"}, {"cond": "null", "prop": "dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned"}, {"cond": "null", "prop": "dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned"}, {"cond": "null", "prop": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason"}, {"cond": "null", "prop": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason"}, {"cond": "null", "prop": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason"}, {"cond": "null", "prop": "Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason"}, {"cond": "if you are not interested in the reason for failure", "prop": "Pass NULL for the dbus_connection_open_APIParam_2 parameter"}, {"cond": "if you are not interested in the reason for failure", "prop": "Pass NULL for the dbus_connection_open_private_APIParam_2 parameter"}, {"cond": "when you are done with the connection", "prop": "However , you should call dbus_connection_unref_APIName"}, {"cond": "null", "prop": "This connection will not be saved or recycled by libdbus"}, {"cond": "null", "prop": "This connection will not be saved or recycled by libdbus"}, {"cond": "null", "prop": "This connection will not be saved or recycled by libdbus"}, {"cond": "null", "prop": "This connection will not be saved or recycled by libdbus"}, {"cond": "null", "prop": "Instead , let the main loop invoke dbus_connection_dispatch_APIName"}, {"cond": "When you are done with this connection", "prop": "you must dbus_connection_close_APIName to disconnect it , and dbus_connection_unref_APIName to free the connection object"}, {"cond": "null", "prop": "dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL"}, {"cond": "null", "prop": "If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE"}, {"cond": "null", "prop": "As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, read or write, return TRUE"}, {"cond": "null", "prop": "Note that even after disconnection , messages may remain in the incoming queue that need to be processed"}, {"cond": "null", "prop": "This is important"}, {"cond": "while it is blocked on I/O", "prop": "it can not be interrupted , which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just"}, {"cond": "null", "prop": "It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter"}, {"cond": "null", "prop": "dbus_connection_remove_filter_APIParam_2 is the handler to remove"}, {"cond": "null", "prop": "Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName"}, {"cond": "If the given handler was added more than once", "prop": "only one instance of it will be removed"}, {"cond": "if dbus_connection_return_message_APIParam_2 from dbus_connection_borrow_message_APIName was non - NULL", "prop": "Only called"}, {"cond": "null", "prop": "no error will be returned"}, {"cond": "null", "prop": "If the function fails due to lack of memory, it returns FALSE"}, {"cond": "null", "prop": "Because this only queues the dbus_connection_send_APIParam_2 , the only reason it can fail is lack of memory"}, {"cond": "null", "prop": "The function will never fail for other reasons"}, {"cond": "null", "prop": "dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care"}, {"cond": "null", "prop": "dbus_connection_send_preallocated_APIName can not fail"}, {"cond": "null", "prop": "dbus_connection_send_preallocated_APIName `` consumes '' the dbus_connection_send_preallocated_APIParam_2 resources , they need not be freed separately"}, {"cond": "if no reply arrives", "prop": "a timeout error will occur , unlike with dbus_connection_send_APIName"}, {"cond": "null", "prop": "dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise"}, {"cond": "null", "prop": "-1 is typically the best value for the timeout , unless you want a very short or very long timeout"}, {"cond": "null", "prop": "dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them"}, {"cond": "Warning if the dbus_connection_send_with_reply_APIParam_1 is disconnected or you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them", "prop": "the DBusPendingCall will be set to NULL , so be careful with this"}, {"cond": "null", "prop": "dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails"}, {"cond": "when the dbus_connection_set_allow_anonymous_APIParam_1 is first seen in the DBusNewConnectionFunction", "prop": "dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1"}, {"cond": "null", "prop": "Namely , an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work"}, {"cond": "null", "prop": "dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN"}, {"cond": "null", "prop": "However , dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction"}, {"cond": "If the dispatch status is DBUS_DISPATCH_DATA_REMAINS", "prop": "dbus_connection_dispatch_APIName needs to be called to process incoming messages"}, {"cond": "when the main loop is re-entered", "prop": "messages should be dispatched later"}, {"cond": "null", "prop": "The call to _exit_APIName comes after any handlers for the disconnect signal run"}, {"cond": "null", "prop": "Instead , the DBusDispatchStatusFunction should simply save an indication that"}, {"cond": "when the dbus_connection_set_exit_on_disconnect_APIParam_1 receives a disconnect signal", "prop": "_exit_APIName should be called"}, {"cond": "when the dbus_timeout_handle_APIParam_1 occurs", "prop": "dbus_timeout_handle_APIName should be called"}, {"cond": "If you do not set a dispatch status dbus_connection_set_dispatch_status_function_APIParam_2", "prop": "you have to be sure to dispatch on every iteration of your main loop , especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called"}, {"cond": "null", "prop": "The semantics of the maximum are"}, {"cond": "null", "prop": "The semantics are not"}, {"cond": "null", "prop": "But this should be inconsequential"}, {"cond": "null", "prop": "This does imply that we can not call read_APIName with a buffer larger than we 're willing to exceed this limit by"}, {"cond": "null", "prop": "However , the message bus wants to be able to route methods on that interface through the bus and to other applications"}, {"cond": "If a normal application sets this flag", "prop": "it can break things badly"}, {"cond": "null", "prop": "A disabled timeout should have no effect , and enabled timeout should be added to the main loop"}, {"cond": "null", "prop": "This feature is used instead of simply adding/removing the timeout"}, {"cond": "null", "prop": "dbus_timeout_handle_APIName should be called repeatedly , each time the interval elapses , starting after it has elapsed once"}, {"cond": "null", "prop": "so inside these functions you may not invoke any methods on DBusConnection or it will deadlock"}, {"cond": "null", "prop": "so inside these functions you may not invoke any methods on DBusConnection or it will deadlock"}, {"cond": "null", "prop": "so inside these functions you may not invoke any methods on DBusConnection or it will deadlock"}, {"cond": "null", "prop": "so inside these functions you may not invoke any methods on DBusConnection or it will deadlock"}, {"cond": "null", "prop": "if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected"}, {"cond": "null", "prop": "if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected"}, {"cond": "When using Qt", "prop": "this typically results in a call to QEventLoop::wakeUp_APIName"}, {"cond": "null", "prop": "it may not be enabled"}, {"cond": "null", "prop": "This feature is used instead of simply adding/removing the watch"}, {"cond": "null", "prop": "These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events , using select_APIName or poll_APIName"}, {"cond": "null", "prop": "A disabled watch should have no effect , and enabled watch should be added to the main loop"}, {"cond": "null", "prop": "It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3"}, {"cond": "null", "prop": "It is not allowed to reference a DBusWatch after it has been passed to remove_function"}, {"cond": "null", "prop": "The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR"}, {"cond": "null", "prop": "If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2"}, {"cond": "null", "prop": "Once a file descriptor becomes readable or writable , or an exception occurs , dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition"}, {"cond": "during the DBusAddWatchFunction", "prop": "dbus_watch_handle_APIName can not be called , as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet"}, {"cond": "null", "prop": "if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called"}, {"cond": "null", "prop": "dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned"}, {"cond": "null", "prop": "dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned"}, {"cond": "null", "prop": "dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned"}, {"cond": "null", "prop": "dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned"}, {"cond": "null", "prop": "For private connections , the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference"}, {"cond": "null", "prop": "dbus_threads_init_APIName return TRUE on success, FALSE if no memory"}, {"cond": "null", "prop": "In D-Bus 1.6 or older , dbus_threads_init_default_APIName must be called in the main thread before any other thread starts"}, {"cond": "null", "prop": "For shared connections , libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected , so you can know that either you do not have the last reference , or it is OK to drop the last reference"}, {"cond": "null", "prop": "This is generally acceptable"}, {"cond": "if not", "prop": "Returns TRUE on success , FALSE enough memory"}, {"cond": "null", "prop": "Normal API conventions would have the function return a boolean value indicating  , but that would require blocking always to determine the return value"}, {"cond": "null", "prop": "As a result , it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin , unless the library or plugin imposes a similar requirement on its callers"}, {"cond": "If you pass non", "prop": "- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply"}, {"cond": "null", "prop": "This can cause performance problems such as draining batteries on embedded platforms"}, {"cond": "null", "prop": "It is important to note this"}, {"cond": "null", "prop": "That is , arg0 = ' 5 ' means match the string `` 5 '' not the integer 5"}, {"cond": "null", "prop": "A specialised form of wildcard matching on arguments is supported for path-like namespaces"}, {"cond": "if there an dbus_bus_add_match_APIParam_3 adding the match", "prop": "you will not find out about it"}, {"cond": "null", "prop": "This means match rules on method calls should not usually give an interface"}, {"cond": "null", "prop": "For security reasons , you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER"}, {"cond": "null", "prop": "Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes"}, {"cond": "null", "prop": "Both of these maximums are much higher than you are likely to need , they only exist"}, {"cond": "null", "prop": "The caller may NOT call dbus_connection_close_APIName on this connection"}, {"cond": "null", "prop": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection"}, {"cond": "null", "prop": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection"}, {"cond": "null", "prop": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection"}, {"cond": "null", "prop": "You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection"}, {"cond": "null", "prop": "dbus_bus_get_APIName calls dbus_bus_register_APIName for you"}, {"cond": "null", "prop": "dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you"}, {"cond": "null", "prop": "If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes"}, {"cond": "null", "prop": "dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2"}, {"cond": "null", "prop": "Asks the bus to return its globally unique ID, as described in the D-Bus specification"}, {"cond": "null", "prop": "dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set"}, {"cond": "null", "prop": "For the system bus , probably the bus ID is not useful"}, {"cond": "null", "prop": "instead , use the machine ID and may be persistent beyond a single bus instance"}, {"cond": "null", "prop": "Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference"}, {"cond": "if the connection closes", "prop": "the application will exit"}, {"cond": "null", "prop": "The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed , and should not be freed by the caller"}, {"cond": "null", "prop": "In addition to an ID for each bus and an ID for each machine , there is an ID for each address that the bus is listening on"}, {"cond": "null", "prop": "dbus_bus_get_unique_name_APIName return the unique name or NULL on error"}, {"cond": "if you register by hand", "prop": "calling dbus_bus_set_unique_name_APIName instead of using dbus_bus_register_APIName"}, {"cond": "null", "prop": "You are responsible for"}, {"cond": "null", "prop": "Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any"}, {"cond": "null", "prop": "dbus_bus_get_unix_user_APIName return the unix user id, or -1) if dbus_bus_get_unix_user_APIParam_3 is set"}, {"cond": "null", "prop": "This must be the first thing"}, {"cond": "null", "prop": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain"}, {"cond": "If you use dbus_bus_get_APIName or dbus_bus_get_private_APIName dbus_bus_register_APIName", "prop": "will be called for you"}, {"cond": "if you want to avoid replacing a current owner", "prop": "do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner"}, {"cond": "if you have your own custom message bus not found in DBusBusType", "prop": "Using dbus_bus_register_APIName manually is only useful"}, {"cond": "null", "prop": "DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it"}, {"cond": "null", "prop": "The rule in a multithreaded app , , is that dbus_bus_register_APIName must be used to register , or you need to have your own locks that all threads in the app will respect"}, {"cond": "null", "prop": "dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set"}, {"cond": "null", "prop": "dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set"}, {"cond": "null", "prop": "For shared connections in a multithreaded application , you can not really make the registration calls yourself , , and"}, {"cond": "null", "prop": "First you should know that for each bus dbus_bus_request_name_APIParam_2 , the bus stores a queue of connections that would like to own it"}, {"cond": "null", "prop": "The queue means you do not need to manually watch for the current owner to disappear and request the dbus_bus_request_name_APIParam_2 again"}, {"cond": "When requesting a dbus_bus_request_name_APIParam_2", "prop": "you can specify several dbus_bus_request_name_APIParam_3"}, {"cond": "null", "prop": "DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING"}, {"cond": "null", "prop": "dbus_bus_request_name_APIName returns a result code"}, {"cond": "if you are not the primary owner", "prop": "you do not want to be queued up"}, {"cond": "null", "prop": "DBUS_NAME_FLAG_DO_NOT_QUEUE means that - you only care about being the primary owner"}, {"cond": "null", "prop": "any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over or be queued up according to"}, {"cond": "null", "prop": "DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner , and the caller is now the primary owner"}, {"cond": "null", "prop": "and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING"}, {"cond": "null", "prop": "or that the dbus_bus_request_name_APIParam_2 had an owner , and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT"}, {"cond": "When you lose ownership of your bus dbus_bus_request_name_APIParam_2", "prop": "you need to exit"}, {"cond": "null", "prop": "and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING"}, {"cond": "null", "prop": "Can only be called once per dbus_bus_set_unique_name_APIParam_1"}, {"cond": "When a service represents an application", "prop": "say `` text editor , '' it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started"}, {"cond": "null", "prop": "The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself"}, {"cond": "null", "prop": "Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function"}, {"cond": "null", "prop": "it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections in a multithreaded application"}, {"cond": "null", "prop": "Thus , you need a way to coordinate which thread sends the registration attempt"}, {"cond": "if you registered with the bus manually -LRB- i.e", "prop": "Can only be used"}, {"cond": "If two threads are both sending the registration message", "prop": "there is no mechanism in libdbus itself to avoid sending it twice"}, {"cond": "If you do not know about all threads in the app", "prop": "you need to avoid using dbus_bus_set_unique_name_APIName on shared connections"}, {"cond": "if successful", "prop": "dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING"}, {"cond": "null", "prop": "The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion , currently you should specify 0"}, {"cond": "null", "prop": "The dbus_timeout_handle_APIName should be called each time this interval elapses , starting after The dbus_timeout_handle_APIName elapses once"}, {"cond": "If not enabled", "prop": "it should not be polled by the main loop"}, {"cond": "If not enabled", "prop": "it should not be polled by the main loop"}, {"cond": "If not enabled", "prop": "it should not be polled by the main loop"}, {"cond": "If not enabled", "prop": "it should not be polled by the main loop"}, {"cond": "null", "prop": "If dbus_timeout_handle_APIName returns FALSE , there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1"}, {"cond": "null", "prop": "with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id"}, {"cond": "null", "prop": "This string must not be freed"}, {"cond": "null", "prop": "This string must not be freed"}, {"cond": "null", "prop": "This string must not be freed"}, {"cond": "null", "prop": "This string must not be freed"}, {"cond": "null", "prop": "dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory"}, {"cond": "null", "prop": "dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory"}, {"cond": "if you asked for the dbus_address_entry_get_value_APIParam_2 `` host '' you would get the value `` example.com '' dbus_address_entry_get_value_APIParam_0 value is already unescaped", "prop": "host = example.com , port = 8073 ''"}, {"cond": "null", "prop": "dbus_parse_address_APIName return TRUE on success, FALSE otherwise"}, {"cond": "When connecting to an dbus_parse_address_APIParam_1", "prop": "the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first"}, {"cond": "null", "prop": "Deprecated former name of dbus_watch_get_unix_fd_APIName"}, {"cond": "null", "prop": "Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor"}, {"cond": "null", "prop": "On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket"}, {"cond": "null", "prop": "The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR"}, {"cond": "null", "prop": "Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred"}, {"cond": "null", "prop": "Always returns -1 on Windows"}, {"cond": "null", "prop": "If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen"}, {"cond": "during the DBusAddWatchFunction", "prop": "dbus_watch_handle_APIName can not be called , as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet"}, {"cond": "null", "prop": "with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource"}]