that is , you recurse into the array , and you call dbus_message_iter_get_fixed_array_APIName on the `` sub-iterator '' created by dbus_message_iter_recurse_APIName
dbus_error_has_name_APIName return TRUE if the given named dbus_error_has_name_APIParam_1 occurred
dbus_error_is_set_APIName return TRUE if an dbus_error_is_set_APIParam_1 occurred
dbus_pending_call_get_completed_APIName return TRUE if a reply has been received
dbus_pending_call_set_data_APIName return TRUE if there was enough memory to store the dbus_pending_call_set_data_APIParam_3
dbus_message_contains_unix_fds_APIName return TRUE if the dbus_message_contains_unix_fds_APIParam_1 contains unix fds
dbus_message_demarshal_bytes_needed_APIName return -1 if there was no valid data to be demarshalled, 0 if there wasn't enough data to determine how much should be demarshalled
dbus_message_get_args_APIName return FALSE if the dbus_message_get_args_APIParam_2 was set
dbus_message_get_args_valist_APIName return FALSE if dbus_message_get_args_valist_APIParam_2 was set
dbus_message_get_auto_start_APIName return TRUE if the dbus_message_get_auto_start_APIParam_1 will use auto-start
dbus_message_get_no_reply_APIName return TRUE if the dbus_message_get_no_reply_APIParam_1 sender is not waiting for a reply
dbus_message_get_path_decomposed_APIName return FALSE if no memory to allocate the array
dbus_message_has_destination_APIName return TRUE if the dbus_message_has_destination_APIParam_1 has the given destination dbus_message_has_destination_APIParam_2
dbus_message_has_member_APIName return TRUE if there is a dbus_message_has_member_APIParam_2 field in the header
dbus_message_has_path_APIName return TRUE if there is a dbus_message_has_path_APIParam_2 field in the header
dbus_message_has_sender_APIName return TRUE if the dbus_message_has_sender_APIParam_1 has the given sender
dbus_message_has_signature_APIName return TRUE if dbus_message_has_signature_APIParam_1 has the given dbus_message_has_signature_APIParam_2
dbus_message_is_error_APIName return TRUE if the dbus_message_is_error_APIParam_1 is the specified error
dbus_message_is_method_call_APIName return TRUE if the dbus_message_is_method_call_APIParam_1 is the specified dbus_message_is_method_call_APIParam_3 call
dbus_message_is_signal_APIName return TRUE if the dbus_message_is_signal_APIParam_1 is the specified signal
dbus_message_iter_has_next_APIName return TRUE if there are more fields following
dbus_message_iter_init_APIName return FALSE if the dbus_message_iter_init_APIParam_1 has no arguments
dbus_message_iter_next_APIName return TRUE if the iterator was moved to the next field
dbus_message_marshal_APIName return FALSE if there was not enough memory
dbus_message_set_data_APIName return TRUE if there was enough memory to store the dbus_message_set_data_APIParam_3
dbus_set_error_from_message_APIName return TRUE if the dbus_set_error_from_message_APIParam_2 had type DBUS_MESSAGE_TYPE_ERROR
dbus_signature_iter_next_APIName return FALSE if nothing more to read at or below this level
dbus_signature_validate_APIName return TRUE if dbus_signature_validate_APIParam_1 is valid or FALSE if an dbus_signature_validate_APIParam_2 is set
dbus_signature_validate_single_APIName return TRUE if dbus_signature_validate_single_APIParam_1 is valid and has exactly one complete type
dbus_type_is_basic_APIName return TRUE if type is basic
dbus_type_is_container_APIName return TRUE if type is a container
dbus_type_is_fixed_APIName return FALSE if the type can occupy different lengths
dbus_server_set_auth_mechanisms_APIName return FALSE if no memory
dbus_server_set_data_APIName return TRUE if there was enough memory to store the dbus_server_set_data_APIParam_3
dbus_validate_bus_name_APIName return TRUE if dbus_validate_bus_name_APIParam_1 is valid
dbus_validate_error_name_APIName return TRUE if dbus_validate_error_name_APIParam_1 is valid
dbus_validate_interface_APIName return TRUE if dbus_validate_interface_APIParam_1 is valid
dbus_validate_member_APIName return TRUE if dbus_validate_member_APIParam_1 is valid
dbus_validate_path_APIName return TRUE if dbus_validate_path_APIParam_1 is valid
dbus_validate_utf8_APIName return TRUE if dbus_validate_utf8_APIParam_1 is valid UTF-8
dbus_connection_can_send_type_APIName return TRUE if the dbus_connection_can_send_type_APIParam_2 may be send via the dbus_connection_can_send_type_APIParam_1
dbus_connection_get_adt_audit_session_data_APIName return TRUE if audit dbus_connection_get_adt_audit_session_data_APIParam_2 is filled in with a valid ucred pointer
dbus_connection_get_is_anonymous_APIName return TRUE if not authenticated or authenticated as anonymous
dbus_connection_get_is_authenticated_APIName return TRUE if the dbus_connection_get_is_authenticated_APIParam_1 was ever authenticated
dbus_connection_get_is_connected_APIName return TRUE if the dbus_connection_get_is_connected_APIParam_1 is still alive
dbus_connection_get_socket_APIName return TRUE if dbus_connection_get_socket_APIParam_2 is successfully obtained
dbus_connection_get_unix_fd_APIName return TRUE if dbus_connection_get_unix_fd_APIParam_2 is successfully obtained
dbus_connection_get_unix_process_id_APIName return TRUE if uid is filled in with a valid process ID
dbus_connection_get_unix_user_APIName return TRUE if dbus_connection_get_unix_user_APIParam_2 is filled in with a valid user ID
dbus_connection_has_messages_to_send_APIName return TRUE if the outgoing queue is non-empty
dbus_connection_list_registered_APIName return FALSE if no memory to allocate the child entries
dbus_connection_get_windows_user_APIName return TRUE if user is available (returned value may be NULL anyway if no memory
dbus_connection_read_write_APIName return TRUE if still connected
dbus_connection_read_write_dispatch_APIName return TRUE if the disconnect message has not been processed
dbus_connection_register_fallback_APIName return FALSE if an error  occured
dbus_connection_register_object_path_APIName return FALSE if an error  ocurred
dbus_connection_set_data_APIName return TRUE if there was enough memory to store the dbus_connection_set_data_APIParam_3
dbus_connection_try_register_fallback_APIName return FALSE if an dbus_connection_try_register_fallback_APIParam_5  is reported
dbus_connection_try_register_object_path_APIName return FALSE if an dbus_connection_try_register_object_path_APIParam_5  is reported
dbus_bus_name_has_owner_APIName return TRUE if the dbus_bus_name_has_owner_APIParam_2 exists, FALSE if not or on dbus_bus_name_has_owner_APIParam_3
dbus_bus_start_service_by_name_APIName return TRUE if the activation succeeded, FALSE if not
dbus_timeout_get_enabled_APIName return TRUE if the dbus_timeout_get_enabled_APIParam_1 is enabled
dbus_timeout_handle_APIName return FALSE if there wasn't enough memory
dbus_watch_get_enabled_APIName return TRUE if the dbus_watch_get_enabled_APIParam_1 is enabled
dbus_watch_handle_APIName return FALSE if there wasn't enough memory
Both dbus_move_error_APIParam_1 and dbus_move_error_APIParam_2 must be initialized
dbus_move_error_APIParam_2 may not contain an existing error
the dbus_error_init_APIParam_1 only needs to be freed
dbus_move_error_APIParam_1 is the source error
dbus_move_error_APIParam_2 is the destination error or NULL
The dbus_set_error_APIParam_3 may be NULL , which means a default message will be deduced from the dbus_set_error_APIParam_2
It will not hurt you
The dbus_set_error_const_APIParam_3 may be NULL , which means a default dbus_set_error_const_APIParam_3 will be deduced from the dbus_set_error_const_APIParam_2
The default dbus_set_error_const_APIParam_3 will be totally useless , though , so using a NULL dbus_set_error_const_APIParam_3 is not recommended
dbus_set_error_const_APIParam_1 is the dbus_set_error_const_APIParam_1 or NULL
You probably want dbus_set_error_APIName instead , in most cases
you must ensure the dbus_set_error_const_APIParam_2 and dbus_set_error_const_APIParam_3 are global data that will not be freed
Frees a NULL - terminated array of strings
NULL , does nothing
NULL , does nothing
NULL , does nothing
NULL , does nothing
Guaranteed to return NULL if dbus_malloc_APIParam_1 is zero on all platforms
Guaranteed to return NULL if dbus_malloc0_APIParam_1 is zero on all platforms
dbus_malloc_APIName memory is NOT safe to free with regular free_APIName from the C library
dbus_malloc0_APIName memory is NOT safe to free with regular free_APIName from the C library
dbus_malloc_APIParam_0 must be released with dbus_free_APIName
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Returns NULL
Free it with dbus_free_APIName only
dbus_malloc_APIName return allocated memory, or NULL if the allocation fails
dbus_malloc0_APIName return allocated memory, or NULL if the allocation fails
Guaranteed to free the dbus_realloc_APIParam_1 and return NULL if dbus_realloc_APIParam_2 is zero on all platforms
dbus_realloc_APIName return allocated dbus_realloc_APIParam_1, or NULL if the resize fails
You MUST free all memory and release all reference counts returned to you by libdbus prior to calling dbus_shutdown_APIName
You can not continue to use any D-Bus objects , such as connections , that were allocated prior to dbus_shutdown_APIName
The purpose of dbus_shutdown_APIName is to allow applications to get clean output from memory leak checkers
There is absolutely no requirement to call dbus_shutdown_APIName - in fact , most applications will not bother and should not feel guilty
dbus_shutdown_APIName is NOT thread safe , it must be called
You have to know that nobody is using libdbus in your application process before you can call dbus_shutdown_APIName
dbus_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName
dbus_try_get_local_machine_id_APIParam_0 must be freed with dbus_free_APIName
dbus_message_iter_get_signature_APIParam_0 must be freed with dbus_free_APIName
this will result in processing of the special Disconnected signal , which may result in a call to _exit_APIName , unless you have used dbus_connection_set_exit_on_disconnect_APIName to disable that behaviour
One implication of this is that calling dbus_shutdown_APIName from a library is almost certainly wrong
Returns a 32-byte-long hex-encoded UUID string , or NULL on failure
Returns a 32-byte-long hex-encoded UUID string , or NULL on failure
Returns a 32-byte-long hex-encoded UUID string , or NULL on failure
Returns a 32-byte-long hex-encoded UUID string , or NULL on failure
dbus_get_local_machine_id_APIName returns NULL if there was not enough memory to read the UUID, or if the UUID could not be read because the D-Bus library was installed incorrectly
dbus_message_demarshal_APIName return NULL if there was an dbus_message_demarshal_APIParam_3
dbus_get_version_APIParam_1 is pointer to return the major version, or NULL
Alternatively , there are macros #DBUS_MAJOR_VERSION , #DBUS_MINOR_VERSION , #DBUS_MICRO_VERSION , and #DBUS_VERSION which allow you to test the VERSION YOU ARE COMPILED AGAINST
dbus_get_version_APIParam_2 is pointer to return the minor version, or NULL
The MINOR is an odd number for development releases and an even number for stable releases
dbus_get_version_APIParam_3 is pointer to return the micro version, or NULL
This is because we can not rely on internal implementation details of the underlying libc library
dbus_setenv_APIParam_2 is dbus_setenv_APIParam_2 of environment variable , or NULL to unset
dbus_setenv_APIName return TRUE on success, FALSE if not enough memory
dbus_connection_add_filter_APIName return TRUE on success, FALSE if not enough memory
The machine ID can also be used to create unique per-machine instances
The machine ID is preferred over the machine hostname , and may also change at runtime
The UUID is not a UUID in the sense of RFC4122
The allocated ID may be used with dbus_pending_call_set_data_APIName and dbus_pending_call_get_data_APIName
The allocated ID may be used with dbus_message_set_data_APIName and dbus_message_get_data_APIName
The allocated ID may be used with dbus_server_set_data_APIName and dbus_server_get_data_APIName
The allocated ID may be used with dbus_connection_set_data_APIName and dbus_connection_get_data_APIName
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
The passed-in slot must be initialized to -1 , and is filled in with the slot ID
If the remote application has the same machine ID as the one returned by this function, the remote application is on the same machine as your application
all DBusPendingCall objects will have a slot with the given integer ID reserved
all DBusMessage objects will have a slot with the given integer ID reserved
all DBusServer objects will have a slot with the given integer ID reserved
all DBusConnection objects will have a slot with the given integer ID reserved
dbus_pending_call_allocate_data_slot_APIName return FALSE on failure (no memory
dbus_message_allocate_data_slot_APIName return FALSE on failure (no memory
dbus_server_set_timeout_functions_APIName return FALSE on failure (no memory
dbus_server_set_watch_functions_APIName return FALSE on failure (no memory
dbus_connection_allocate_data_slot_APIName return FALSE on failure (no memory
dbus_connection_set_timeout_functions_APIName return FALSE on failure (no memory
dbus_connection_set_watch_functions_APIName return FALSE on failure (no memory
Block until the dbus_pending_call_block_APIParam_1 call is completed
This requires storing timestamps instead of intervals in the timeout dbus_pending_call_block_APIParam_1 is the dbus_pending_call_block_APIParam_1 call
but it should really only use time remaining
dbus_pending_call_get_data_APIName and dbus_pending_call_set_data_APIName may no longer be used with this slot
dbus_message_get_data_APIName and dbus_message_set_data_APIName may no longer be used with this slot
dbus_server_get_data_APIName and dbus_server_set_data_APIName may no longer be used with this slot
dbus_connection_get_data_APIName and dbus_connection_set_data_APIName may no longer be used with this slot
The idea is that two processes with the same machine ID should be able to use shared memory , UNIX domain sockets , process IDs , and other features of the OS that require both processes to be running on the same OS kernel instance
The dbus_pending_call_get_data_APIParam_2 must still be allocated
The dbus_message_get_data_APIParam_2 must still be allocated
The dbus_server_get_data_APIParam_2 must still be allocated
The dbus_connection_get_data_APIParam_2 must still be allocated
dbus_pending_call_get_data_APIName return the data, or NULL if not found
dbus_message_get_data_APIName return the data, or NULL if not found
dbus_server_get_data_APIName return the data, or NULL if not found
dbus_connection_get_data_APIName return the data, or NULL if not found
The dbus_pending_call_set_data_APIParam_2 number must have been allocated with dbus_pending_call_allocate_data_slot_APIName
The dbus_message_set_data_APIParam_2 number must have been allocated with dbus_message_allocate_data_slot_APIName
The dbus_server_set_data_APIParam_2 number must have been allocated with dbus_server_allocate_data_slot_APIName
The dbus_connection_set_data_APIParam_2 number must have been allocated with dbus_connection_allocate_data_slot_APIName
dbus_pending_call_set_notify_APIName return FALSE if not enough memory
dbus_message_iter_append_basic_APIName return FALSE if not enough memory
dbus_message_iter_append_fixed_array_APIName return FALSE if not enough memory
dbus_message_iter_close_container_APIName return FALSE if not enough memory
dbus_message_iter_open_container_APIName return FALSE if not enough memory
dbus_message_set_container_instance_APIName return FALSE if not enough memory
dbus_message_set_destination_APIName return FALSE if not enough memory
dbus_message_set_error_name_APIName return FALSE if not enough memory
dbus_message_set_interface_APIName return FALSE if not enough memory
dbus_message_set_member_APIName return FALSE if not enough memory
dbus_message_set_path_APIName return FALSE if not enough memory
dbus_message_set_reply_serial_APIName return FALSE if not enough memory
dbus_message_set_sender_APIName return FALSE if not enough memory
dbus_connection_get_object_path_data_APIName return FALSE if not enough memory
dbus_connection_unregister_object_path_APIName return FALSE if not enough memory
dbus_bus_set_unique_name_APIName return FALSE if not enough memory
Gets the reply, or returns NULL if none has been received yet
dbus_pending_call_steal_reply_APIName return the reply message or NULL
dbus_message_new_APIName return new message or NULL if no memory
dbus_pending_call_steal_reply_APIName can only be called once per dbus_pending_call_steal_reply_APIParam_1 call
The variable argument list should contain the type of each argument followed by the value to append
dbus_message_append_args_APIName does not support arrays of Unix file descriptors
you need to manually recurse into the array
The last argument to dbus_message_append_args_APIName must be DBUS_TYPE_INVALID , marking the end of the argument list
dbus_message_append_args_APIName return TRUE on success
dbus_message_append_args_valist_APIName return TRUE on success
dbus_connection_send_APIName return TRUE on success
dbus_bus_register_APIName return TRUE on success
will not know to stop and will read invalid memory
support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays Todo
String/signature/path arrays should be passed in as `` const char *** address_of_array '' and `` int n_elements '' Todo
and you have to start over building the whole dbus_message_append_args_APIParam_1
and you have to start over building the whole dbus_message_iter_init_append_APIParam_1
dbus_message_copy_APIName can not be used in programs that try to recover from OOM errors
dbus_message_copy_APIName return the new dbus_message_copy_APIParam_1.or NULL if not enough memory or Unix file descriptors  can be allocated
dbus_message_demarshal_APIParam_3 is the location to save errors to
The supported types include those supported by dbus_message_append_args_APIName
Similar to dbus_message_get_fixed_array_APIName dbus_message_get_args_APIName does not support arrays of type DBUS_TYPE_UNIX_FD
The variable argument list should contain the type of the argument followed by a pointer to where the value should be stored
make sure to unset it with fcntl_APIName
make sure to unset it with fcntl_APIName
make sure to unset it with fcntl_APIName
make sure to unset it with fcntl_APIName
you need to recurse into the array manually
In addition to those types , arrays of string , object path , and signature are supported
support DBUS_TYPE_STRUCT and DBUS_TYPE_VARIANT and complex arrays dbus_message_get_args_APIParam_1 is the dbus_message_get_args_APIParam_1
but thesebe returned by dbus_message_get_args_APIName as allocated memory and must be freed with dbus_free_string_array_APIName , while the other typesbe returned by dbus_message_get_args_APIName as const references
dbus_message_get_container_instance_APIName return the path  or NULL
dbus_message_get_path_APIName return the path  or NULL
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Return TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
Returns TRUE
dbus_message_get_destination_APIName return the dbus_message_get_destination_APIParam_1 destination  or NULL
Gets the destination of a dbus_message_get_destination_APIParam_1 or NULL
dbus_message_get_error_name_APIName return the error name  or NULL
Gets the error name or NULL
dbus_message_get_interface_APIName return the dbus_message_get_interface_APIParam_1 interface  or NULL
dbus_message_get_member_APIName return the member name  or NULL
NULL set here
Returns the serial that the dbus_message_get_reply_serial_APIParam_1 is a reply to or 0
dbus_message_get_reply_serial_APIName return the reply serial
dbus_message_get_serial_APIName return the serial
dbus_bus_get_private_APIName return a DBusConnection with new ref
So the dbus_message_get_path_decomposed_APIParam_2 '' / foo/bar '' becomes -LCB- `` foo '' , `` bar '' , NULL -RCB- and the dbus_message_get_path_decomposed_APIParam_2 '' / '' becomes -LCB- NULL -RCB-
Note , dbus_message_get_sender_APIParam_0 sender is always the unique bus name
Connections may own multiple other bus names , but those are not found in the sender field
dbus_message_get_sender_APIName return the unique name of the sender or NULL
Returns the serial of a dbus_message_get_serial_APIParam_1 or 0 has been specified
The signature includes only `` in '' arguments for DBUS_MESSAGE_TYPE_METHOD_CALL and only `` out '' arguments for DBUS_MESSAGE_TYPE_METHOD_RETURN , so is slightly different from what you might expect
DBUS_MESSAGE_TYPE_INVALID will never be returned
If the dbus_message_has_destination_APIParam_1 has no destination specified or has a different destination, returns FALSE
Types include DBUS_MESSAGE_TYPE_METHOD_CALL , DBUS_MESSAGE_TYPE_METHOD_RETURN , DBUS_MESSAGE_TYPE_ERROR , DBUS_MESSAGE_TYPE_SIGNAL , but other types are allowed and all code must silently ignore messages of unknown type
If the dbus_message_has_sender_APIParam_1 has no sender specified or has a different sender, returns FALSE
So you can not use dbus_message_has_sender_APIName to see
If the dbus_message_is_error_APIParam_1 is not DBUS_MESSAGE_TYPE_ERROR , or has a different name, returns FALSE
If the dbus_message_is_method_call_APIParam_1 is not DBUS_MESSAGE_TYPE_METHOD_CALL , or has a different interface or member field, returns FALSE
If the dbus_message_is_signal_APIParam_1 is not DBUS_MESSAGE_TYPE_SIGNAL , or has a different interface or member field, returns FALSE
The D-Bus protocol allows dbus_message_is_method_call_APIParam_3 callers to leave out the interface name
it will be assumed equal to the provided interface
This should only be used to abandon creation of a message
The `` value '' argument should be the address of a basic-typed dbus_message_iter_append_basic_APIParam_3
dbus_bool_t result = FALSE
result = TRUE
return result
You must call dbus_message_iter_open_container_APIName to open an array of values before calling this function
You may call dbus_message_iter_append_fixed_array_APIName multiple times for the same array
The `` value '' argument should be the address of the array
It must not be closed again with this function , or abandoned with dbus_message_iter_abandon_container_APIName
the sub-iterator dbus_message_iter_close_container_APIParam_2 has been closed and invalidated
If the iterator is at the end of the message, returns DBUS_TYPE_INVALID
You can thus write a loop as follows
The iterator must currently be inside an array-typed value
dbus_message_iter_get_array_len_APIName is deprecated on the grounds that it is stupid
Use dbus_message_iter_get_element_count_APIName instead
Why would you want to know how many bytes are in the array as marshaled in the wire protocol ?
The dbus_message_iter_get_basic_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_basic_APIParam_0
The dbus_message_iter_get_fixed_array_APIParam_2 argument should be the address of a location to store dbus_message_iter_get_fixed_array_APIParam_0
dbus_message_iter_get_basic_APIParam_0 is by reference and should not be freed
So for int32 it should be a `` dbus_int32_t * '' and for string a `` const char ** ''
To read any container type you will need to recurse into the container with dbus_message_iter_recurse_APIName
It is your job to close them
you 'll crash
Note that you need to check that the iterator points to an array prior to using this function
Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting , or
Be sure you have somehow checked that dbus_message_iter_get_arg_type_APIName matches the type you are expecting to recurse into
The message dbus_message_iter_get_fixed_array_APIParam_1 should be `` in '' the array
dbus_message_iter_get_fixed_array_APIName should only be used if dbus_type_is_fixed_APIName returns TRUE for the element type
dbus_connection_flush_APIName should only be used
So for int32 it should be a `` const dbus_int32_t ** '' dbus_message_iter_get_fixed_array_APIParam_0 dbus_message_iter_get_fixed_array_APIParam_2 is by reference and should not be freed
dbus_message_iter_get_signature_APIName return the contained signature, or NULL if out of memory
Some types of argument can only be read with DBusMessageIter however
it need not be freed , and can be copied by assignment or memcpy_APIName
If there no next field, returns FALSE
If the iterator moves forward, returns TRUE
On success , you are required to append the contents of the container using dbus_message_iter_open_container_APIParam_0 sub-iterator , and call dbus_message_iter_close_container_APIName
For variants , the dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the single value inside the variant
For arrays , dbus_message_iter_open_container_APIParam_3 should be the dbus_message_iter_open_container_APIParam_2 of the array elements
For structs and dict entries , dbus_message_iter_open_container_APIParam_3 should be NULL
However , after dbus_message_iter_open_container_APIName has either succeeded or failed , it is valid to call dbus_message_iter_abandon_container_if_open_APIName
the sub-iterator remains invalid , and must not be closed with dbus_message_iter_close_container_APIName or abandoned with dbus_message_iter_abandon_container_APIName
you can only recurse
dbus_message_lock_APIName may also called externally , for applications wrapping D-Bus in another protocol
Results of dbus_message_iter_recurse_APIName are undefined
dbus_message_marshal_APIParam_2 is the location to save the marshalled form to
dbus_message_marshal_APIParam_3 is the location to save the length of the marshalled form to
Usually you want to use dbus_message_new_method_call_APIName , dbus_message_new_method_return_APIName , dbus_message_new_signal_APIName , or dbus_message_new_error_APIName instead
The error name must be a valid error name according to the syntax given in the D-Bus specification
just use DBUS_ERROR_FAILED
dbus_message_new_error_printf_APIName return a new error message
The main implication of this is that , but it will have no values , so you will not be able to recurse further
The dbus_message_new_method_call_APIParam_2 and dbus_message_new_method_call_APIParam_4 names may not be NULL
The dbus_message_new_method_call_APIParam_1 may be NULL in which case no dbus_message_new_method_call_APIParam_1 is set
Destination , dbus_message_new_method_call_APIParam_2 , interface , and dbus_message_new_method_call_APIParam_4 name can not contain any invalid characters
dbus_message_new_method_call_APIParam_1 is name that the message should be sent to or NULL
dbus_message_new_method_call_APIParam_2 is object dbus_message_new_method_call_APIParam_2 the message should be sent to
dbus_message_new_method_call_APIParam_4 is on , or NULL dbus_message_new_method_call_APIParam_4 method to invoke
The interface may be NULL , which
Path , interface , and signal dbus_message_new_signal_APIParam_3 must all be valid
dbus_message_ref_APIName return the dbus_message_ref_APIParam_1 See also dbus_message_unref
For messages whose type is not DBUS_MESSAGE_TYPE_METHOD_CALL , this flag is meaningless and should not be set
dbus_message_set_allow_interactive_authorization_APIParam_2 is TRUE
dbus_message_set_auto_start_APIParam_2 is TRUE
dbus_message_set_no_reply_APIParam_2 is TRUE
dbus_connection_set_exit_on_disconnect_APIParam_2 is TRUE
It may use the error DBUS_ERROR_INTERACTIVE_AUTHORIZATION_REQUIRED to signal that
dbus_message_set_container_instance_APIParam_2 is the path or NULL to unset
dbus_message_set_path_APIParam_2 is the path or NULL to unset
The path must contain only valid characters for an object path as defined in the D-Bus specification
The dbus_message_set_destination_APIParam_2 name must contain only valid characters as defined in the D-Bus specification
The dbus_message_set_member_APIParam_2 name must contain only valid characters as defined in the D-Bus specification
dbus_message_set_destination_APIParam_2 is the dbus_message_set_destination_APIParam_2 name or NULL to unset
The error name must contain only valid characters as defined in the D-Bus specification
dbus_message_set_error_name_APIParam_2 is the name or NULL to unset
The interface name must contain only valid characters as defined in the D-Bus specification
dbus_message_set_interface_APIParam_2 is the interface or NULL to unset
dbus_message_set_member_APIParam_2 is the dbus_message_set_member_APIParam_2 or NULL to unset
dbus_message_set_sender_APIParam_2 is the dbus_message_set_sender_APIParam_2 or NULL to unset
The path must contain only valid characters as defined in the D-Bus specification
The dbus_message_set_sender_APIParam_2 must be a valid bus name as defined in the D-Bus specification
Usually you do not want to call this
This can only be done once on a dbus_message_set_serial_APIParam_1
daemon you should not need to set the dbus_message_set_sender_APIParam_2
dbus_message_set_serial_APIName is only needed
The dbus_set_error_from_message_APIParam_1 is only set , as in DBUS_MESSAGE_TYPE_ERROR
DBUS_TYPE_STRUCT , not ' -LRB- '
If the iterator is pointing at a type code such as ', the iterator will be returned directly
you should initialize a sub-iterator with dbus_signature_iter_recurse_APIName to parse the container type
Returns the signature of the single complete type starting at the given iterator
If the iterator is pointing at one of the "i" just that "i" would be returned
Undefined behavior results
Should be freed with dbus_free_APIName
dbus_signature_iter_init_APIName is not safe to use on invalid signatures
be sure to validate potentially invalid signatures with dbus_signature_validate before using this function
Returns FALSE at the end of the current container
if dbus_type_is_container_APIName returns FALSE for the result of dbus_signature_iter_get_current_type_APIName )
if the iterator is pointing at the start of "ii" , "" would be returned
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
NULL can always be passed instead of a DBusError *
The results are undefined if the current type is a non-container -LRB- i.e
the results are undefined
DBUS_TYPE_INVALID is not a basic type
dbus_type_is_basic_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID
dbus_type_is_container_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID
dbus_type_is_fixed_APIParam_1 is either a valid type-code or DBUS_TYPE_INVALID
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
It is an error to pass an invalid type-code , other than DBUS_TYPE_INVALID , to this function
DBUS_TYPE_INVALID is not a container type
dbus_type_is_valid_APIName is safe with untrusted data
DBUS_TYPE_INVALID surprisingly enough is not considered valid , and random unknown bytes are not either
dbus_type_is_valid_APIName return TRUE if valid
For this purpose , you assume that the first byte of the old and new value would be in the same location , so alignment padding is not a factor
The slot must be initialized with -1
dbus_server_allocate_data_slot_APIName return FALSE on no memory
only the first call has an effect
dbus_server_get_address_APIName return the address or NULL if no memory
Returns the address of the dbus_server_get_address_APIParam_1 , as a newly-allocated string which must be freed by the caller
Returns the unique ID of the dbus_server_get_id_APIParam_1 , as a newly-allocated string which must be freed by the caller
This is an ID unique to each DBusServer
dbus_connection_open_APIName can re-use an existing connection with the same ID instead of opening a new connection
Remember that a DBusServer represents only one mode of connecting , so e.g
dbus_server_get_id_APIName return the id of the dbus_server_get_id_APIParam_1 or NULL if no memory
The ID is not a UUID in the sense of RFC4122
a bus daemon can listen on multiple addresses which will mean it has multiple DBusServer each with their own ID
Otherwise returns a new DBusServer
dbus_server_set_new_connection_function_APIName , dbus_server_set_watch_functions_APIName , and dbus_server_set_timeout_functions_APIName should be called immediately to render the server fully functional
To free the server , applications must call first dbus_server_disconnect_APIName and dbus_server_unref_APIName
Returns NULL and sets dbus_server_listen_APIParam_2
dbus_server_listen_APIName return a new DBusServer , or NULL on failure
dbus_server_set_auth_mechanisms_APIName only affects connections created after it is called
Pass NULL instead of an array to use all available dbus_server_set_auth_mechanisms_APIParam_2
These functions are responsible for making the application main loop aware of timeouts
These functions are responsible for making the application main loop aware of timeouts
These functions are responsible for making the application main loop aware of timeouts
These functions are responsible for making the application main loop aware of timeouts
These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events
The dbus_server_unref_APIParam_1 must be disconnected before the refcount reaches zero
dbus_validate_bus_name_APIParam_1 is a potentially invalid bus dbus_validate_bus_name_APIParam_1 , which must not be NULL
dbus_validate_error_name_APIParam_1 is a potentially invalid
dbus_validate_error_name_APIParam_2 is dbus_validate_error_name_APIParam_1, which must not be NULL dbus_validate_error_name_APIParam_2 error return
dbus_validate_interface_APIParam_1 is a potentially invalid interface dbus_validate_interface_APIParam_1 , which must not be NULL
dbus_validate_member_APIParam_1 is a potentially invalid member dbus_validate_member_APIParam_1 , which must not be NULL
dbus_validate_path_APIParam_1 is a potentially invalid object dbus_validate_path_APIParam_1 , which must not be NULL
Strings on D-Bus must be valid UTF-8
dbus_validate_utf8_APIParam_1 is a string to be checked , which must not be NULL
This is probably a feature , as filters could create arbitrary reentrancy
If the queue is empty, returns NULL
If the queue is empty, returns NULL
If the queue is empty, returns NULL
If the queue is empty, returns NULL
The caller does not own a reference to dbus_connection_borrow_message_APIParam_0, and must either return it using dbus_connection_return_message_APIName or keep it after calling dbus_connection_steal_borrowed_message_APIName
This will always return TRUE for all types, with the exception of DBUS_TYPE_UNIX_FD
The function will return TRUE for DBUS_TYPE_UNIX_FD only on systems that know Unix file descriptors and can send them via the chosen transport and when the remote side supports this
it will return FALSE for all types this implementation does not know, including invalid or reserved types
all calls after the first do nothing
it is safe to close a dbus_connection_close_APIParam_1 more than once
You must close a dbus_connection_close_APIParam_1 prior to releasing the last reference to the dbus_connection_close_APIParam_1
You may not close a shared dbus_connection_close_APIParam_1
it is impossible to `` reopen '' a dbus_connection_close_APIParam_1 , a new dbus_connection_close_APIParam_1 must be created
These connections are owned by libdbus , and applications should only unref them , never close them
Applications can know it is safe to unref these connections as the dbus_connection_close_APIParam_1 is open
The creator of these connections is responsible for calling dbus_connection_close_APIName prior to releasing the last reference
this will not deadlock
Always returns FALSE prior to authenticating the dbus_connection_get_adt_audit_session_data_APIParam_1
Always returns FALSE prior to authenticating the dbus_connection_get_unix_process_id_APIParam_1
Always returns FALSE prior to authenticating the dbus_connection_get_unix_user_APIParam_1
Always returns FALSE prior to authenticating the dbus_connection_get_windows_user_APIParam_1
Should only be called
DBUS_DISPATCH_NEED_MEMORY indicates that there could be data , but we can not know for sure without more memory
you need to know there a reference held on the dbus_connection_get_data_APIParam_1
you need to know there a reference held on the dbus_connection_set_data_APIParam_1
they may not add up to an entire message
If it is authenticated as a specific user, this returns FALSE
If the dbus_connection_get_is_anonymous_APIParam_1 is not authenticated, dbus_connection_get_is_anonymous_APIName returns TRUE , and if it is authenticated but as an anonymous user, it returns TRUE
you can use dbus_connection_get_unix_user_APIName and dbus_connection_get_windows_user_APIName to see who it is authorized as
dbus_connection_get_is_connected_APIName should really be called get_is_open_APIName but for historical reasons is not
the data is filled in with NULL
The only way to be sure the server ID is available is to wait for authentication to complete
If the dbus_connection_get_server_id_APIParam_1 is on the server side, this will always return NULL - use dbus_server_get_id_APIName to get the ID of your own server, if you are the server side
dbus_connection_get_server_id_APIName return the server ID or NULL if no memory or the dbus_connection_get_server_id_APIParam_1 is server-side
The size is approximate in that you should not use it to decide how many bytes to read off the network or anything of that nature , as optimizations may choose to tell small white lies to avoid performance overhead
the ID may be available if it was included in the server address , but may not be available
If the dbus_connection_get_socket_APIParam_1 is not socket-based , dbus_connection_get_socket_APIName will return FALSE
dbus_connection_get_socket_APIParam_2 is return location for the file descriptor
dbus_connection_get_unix_fd_APIParam_2 is return location for the file descriptor
dbus_connection_get_unix_fd_APIName always fails on Windows
Right now dbus_connection_get_unix_fd_APIParam_0 is always a socket , but that is not guaranteed
you can also use dbus_connection_get_socket_APIName , which will work on Windows too
dbus_connection_get_unix_process_id_APIParam_2 is return location for the process ID
Always returns FALSE on non-UNIX platforms for now
Always returns FALSE on non-Windows platforms for now
clients can not usually get the UID of servers
You can ask the bus to tell you the UID of another dbus_connection_get_unix_user_APIParam_1 like
clients can not usually get the user of servers
dbus_connection_get_windows_user_APIParam_2 is return location for an allocated copy of the user ID, or NULL if no memory
We would like to be able to say `` You can ask the bus to tell you the user of another dbus_connection_get_windows_user_APIParam_1 like
if it is available but we do not have the memory to copy it , the return value is TRUE and NULL is given as the SID
dbus_connection_list_registered_APIParam_0 should be freed with dbus_free_string_array_APIName
dbus_connection_list_registered_APIParam_3 is returns NULL -terminated array of children
Otherwise, returns a new connection and saves the new connection for possible re-use if a future call to dbus_connection_open_APIName asks to connect to the same server
If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_APIParam_2 parameter
If the open fails, the function returns NULL , and provides a reason for the failure in the dbus_connection_open_private_APIParam_2 parameter
dbus_connection_open_APIName return new connection, or NULL on failure
dbus_connection_open_private_APIName return new connection, or NULL on failure
dbus_connection_open_APIParam_2 is dbus_connection_open_APIParam_1 where an dbus_connection_open_APIParam_2 can be returned
dbus_connection_open_private_APIParam_2 is dbus_connection_open_private_APIParam_1 where an dbus_connection_open_private_APIParam_2 can be returned
dbus_parse_address_APIParam_4 is dbus_parse_address_APIParam_1 where an dbus_parse_address_APIParam_4 can be returned
Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason
Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason
Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason
Note Prefer dbus_connection_open_APIName to dbus_connection_open_private_APIName unless you have good reason
Pass NULL for the dbus_connection_open_APIParam_2 parameter
Pass NULL for the dbus_connection_open_private_APIParam_2 parameter
However , you should call dbus_connection_unref_APIName
This connection will not be saved or recycled by libdbus
This connection will not be saved or recycled by libdbus
This connection will not be saved or recycled by libdbus
This connection will not be saved or recycled by libdbus
Instead , let the main loop invoke dbus_connection_dispatch_APIName
you must dbus_connection_close_APIName to disconnect it , and dbus_connection_unref_APIName to free the connection object
dbus_connection_preallocate_send_APIName return the preallocated resources, or NULL
If the dbus_connection_read_write_APIParam_1 is closed, the function returns FALSE
As long as the dbus_connection_read_write_APIParam_1 is open, dbus_connection_read_write_APIName will block until it can read or write, read or write, return TRUE
Note that even after disconnection , messages may remain in the incoming queue that need to be processed
This is important
it can not be interrupted , which makes dbus_connection_read_write_dispatch_APIName unsuitable for applications that do more than just
It is a programming error to call dbus_connection_remove_filter_APIName for a handler that has not been added as a filter
dbus_connection_remove_filter_APIParam_2 is the handler to remove
Used to return a dbus_connection_return_message_APIParam_2 after peeking at a dbus_connection_return_message_APIParam_2 using dbus_connection_borrow_message_APIName
only one instance of it will be removed
Only called
no error will be returned
If the function fails due to lack of memory, it returns FALSE
Because this only queues the dbus_connection_send_APIParam_2 , the only reason it can fail is lack of memory
The function will never fail for other reasons
dbus_connection_send_APIParam_3 is return location for dbus_connection_send_APIParam_2 dbus_connection_send_APIParam_3, or NULL if you do not care
dbus_connection_send_preallocated_APIName can not fail
dbus_connection_send_preallocated_APIName `` consumes '' the dbus_connection_send_preallocated_APIParam_2 resources , they need not be freed separately
a timeout error will occur , unlike with dbus_connection_send_APIName
dbus_connection_send_with_reply_APIName return FALSE if no memory, TRUE otherwise
-1 is typically the best value for the timeout , unless you want a very short or very long timeout
dbus_connection_send_with_reply_APIParam_3 is return location for a DBusPendingCall object, or NULL if dbus_connection_send_with_reply_APIParam_1 is disconnected or when you try to send Unix file descriptors on a dbus_connection_send_with_reply_APIParam_1 that does not support them
the DBusPendingCall will be set to NULL , so be careful with this
dbus_connection_send_with_reply_and_block_APIName return the dbus_connection_send_with_reply_and_block_APIParam_2 that is the reply or NULL with an dbus_connection_send_with_reply_and_block_APIParam_4 code if the function fails
dbus_connection_set_allow_anonymous_APIName must be called on the server side of a dbus_connection_set_allow_anonymous_APIParam_1
Namely , an auth mechanism such as ANONYMOUS that supports anonymous auth must be included in the list of available mechanisms for anonymous login to work
dbus_connection_set_change_sigpipe_APIParam_1 is TRUE to allow sigpipe to be set to SIG_IGN
However , dbus_connection_dispatch_APIName MUST NOT BE CALLED from inside the DBusDispatchStatusFunction
dbus_connection_dispatch_APIName needs to be called to process incoming messages
messages should be dispatched later
The call to _exit_APIName comes after any handlers for the disconnect signal run
Instead , the DBusDispatchStatusFunction should simply save an indication that
_exit_APIName should be called
dbus_timeout_handle_APIName should be called
you have to be sure to dispatch on every iteration of your main loop , especially if dbus_watch_handle_APIName or dbus_timeout_handle_APIName were called
The semantics of the maximum are
The semantics are not
But this should be inconsequential
This does imply that we can not call read_APIName with a buffer larger than we 're willing to exceed this limit by
However , the message bus wants to be able to route methods on that interface through the bus and to other applications
it can break things badly
A disabled timeout should have no effect , and enabled timeout should be added to the main loop
This feature is used instead of simply adding/removing the timeout
dbus_timeout_handle_APIName should be called repeatedly , each time the interval elapses , starting after it has elapsed once
so inside these functions you may not invoke any methods on DBusConnection or it will deadlock
so inside these functions you may not invoke any methods on DBusConnection or it will deadlock
so inside these functions you may not invoke any methods on DBusConnection or it will deadlock
so inside these functions you may not invoke any methods on DBusConnection or it will deadlock
if it returns TRUE , the dbus_connection_set_unix_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_unix_user_function_APIParam_1 is disconnected
if it returns TRUE , the dbus_connection_set_windows_user_function_APIParam_1 is allowed to proceed, otherwise the dbus_connection_set_windows_user_function_APIParam_1 is disconnected
this typically results in a call to QEventLoop::wakeUp_APIName
it may not be enabled
This feature is used instead of simply adding/removing the watch
These functions are responsible for making the application main loop aware of file descriptors that need to be monitored for events , using select_APIName or poll_APIName
A disabled watch should have no effect , and enabled watch should be added to the main loop
It is not allowed to reference a DBusWatch after it has been passed to dbus_connection_set_watch_functions_APIParam_3
It is not allowed to reference a DBusWatch after it has been passed to remove_function
The flags returned by dbus_watch_get_flags_APIName will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR
If FALSEbe returned by dbus_connection_set_watch_functions_APIName due to lack of memory, the failure may be due to a FALSE return from the new dbus_connection_set_watch_functions_APIParam_2
Once a file descriptor becomes readable or writable , or an exception occurs , dbus_watch_handle_APIName should be called to notify the dbus_connection_set_watch_functions_APIParam_1 of the file descriptor condition
dbus_watch_handle_APIName can not be called , as the dbus_connection_set_watch_functions_APIParam_1 will not be ready to handle that watch yet
if FALSEbe returned by dbus_connection_set_watch_functions_APIName the net result should be that dbus_connection_set_watch_functions_APIName has no effect, but the dbus_connection_set_watch_functions_APIParam_2 and dbus_connection_set_watch_functions_APIParam_3 may have been called
dbus_connection_try_register_fallback_APIParam_5 is address where an dbus_connection_try_register_fallback_APIParam_5 can be returned
dbus_connection_try_register_object_path_APIParam_5 is address where an dbus_connection_try_register_object_path_APIParam_5 can be returned
dbus_bus_get_APIParam_2 is address where an dbus_bus_get_APIParam_2 can be returned
dbus_bus_get_private_APIParam_2 is address where an dbus_bus_get_private_APIParam_2 can be returned
For private connections , the creator of the dbus_connection_unref_APIParam_1 must arrange for dbus_connection_close_APIName to be called prior to dropping the last reference
dbus_threads_init_APIName return TRUE on success, FALSE if no memory
In D-Bus 1.6 or older , dbus_threads_init_default_APIName must be called in the main thread before any other thread starts
For shared connections , libdbus will own a reference as long as the dbus_connection_unref_APIParam_1 is connected , so you can know that either you do not have the last reference , or it is OK to drop the last reference
This is generally acceptable
Returns TRUE on success , FALSE enough memory
Normal API conventions would have the function return a boolean value indicating  , but that would require blocking always to determine the return value
As a result , it is not sufficient to call dbus_threads_init_default_APIName in a library or plugin , unless the library or plugin imposes a similar requirement on its callers
- NULL for the dbus_bus_add_match_APIParam_3 dbus_bus_add_match_APIName will block until it gets a reply
This can cause performance problems such as draining batteries on embedded platforms
It is important to note this
That is , arg0 = ' 5 ' means match the string `` 5 '' not the integer 5
A specialised form of wildcard matching on arguments is supported for path-like namespaces
you will not find out about it
This means match rules on method calls should not usually give an interface
For security reasons , you can match arguments only up to DBUS_MAXIMUM_MATCH_RULE_ARG_NUMBER
Match rules have a maximum length of DBUS_MAXIMUM_MATCH_RULE_LENGTH bytes
Both of these maximums are much higher than you are likely to need , they only exist
The caller may NOT call dbus_connection_close_APIName on this connection
You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection
You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection
You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection
You can undo this by calling dbus_connection_set_exit_on_disconnect_APIName yourself after you get the connection
dbus_bus_get_APIName calls dbus_bus_register_APIName for you
dbus_bus_get_private_APIName calls dbus_bus_register_APIName for you
If dbus_bus_get_APIName obtains a new connection object never before returned from dbus_bus_get_APIName , it will call dbus_connection_set_exit_on_disconnect_APIName , so the application will exit if the connection closes
dbus_bus_get_APIName return a DBusConnection with new ref or NULL on dbus_bus_get_APIParam_2
Asks the bus to return its globally unique ID, as described in the D-Bus specification
dbus_bus_get_id_APIName return the bus ID or NULL if dbus_bus_get_id_APIParam_2 is set
For the system bus , probably the bus ID is not useful
instead , use the machine ID and may be persistent beyond a single bus instance
Caller owns a reference to the bus and must either close it or know it to be closed prior to releasing this reference
the application will exit
The name remains valid until the dbus_bus_get_unique_name_APIParam_1 is freed , and should not be freed by the caller
In addition to an ID for each bus and an ID for each machine , there is an ID for each address that the bus is listening on
dbus_bus_get_unique_name_APIName return the unique name or NULL on error
calling dbus_bus_set_unique_name_APIName instead of using dbus_bus_register_APIName
You are responsible for
Asks the bus to return the UID the named dbus_bus_get_unix_user_APIParam_1 authenticated as, if any
dbus_bus_get_unix_user_APIName return the unix user id, or -1) if dbus_bus_get_unix_user_APIParam_3 is set
This must be the first thing
Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName instead of dbus_bus_register_APIName and save yourself some pain
will be called for you
do not specify DBUS_NAME_FLAG_REPLACE_EXISTING and you will get an dbus_bus_name_has_owner_APIParam_3 if there already an owner
Using dbus_bus_register_APIName manually is only useful
DBUS_RELEASE_NAME_REPLY_NOT_OWNER which means someone else owns the dbus_bus_release_name_APIParam_2 so you can not release it
The rule in a multithreaded app , , is that dbus_bus_register_APIName must be used to register , or you need to have your own locks that all threads in the app will respect
dbus_bus_release_name_APIName return a result code, -1 if dbus_bus_release_name_APIParam_3 is set
dbus_bus_request_name_APIName return a result code, -1 if dbus_bus_request_name_APIParam_4 is set
For shared connections in a multithreaded application , you can not really make the registration calls yourself , , and
First you should know that for each bus dbus_bus_request_name_APIParam_2 , the bus stores a queue of connections that would like to own it
The queue means you do not need to manually watch for the current owner to disappear and request the dbus_bus_request_name_APIParam_2 again
you can specify several dbus_bus_request_name_APIParam_3
DBUS_NAME_FLAG_ALLOW_REPLACEMENT means that another requestor of the dbus_bus_request_name_APIParam_2 can take it away from you by specifying DBUS_NAME_FLAG_REPLACE_EXISTING
dbus_bus_request_name_APIName returns a result code
you do not want to be queued up
DBUS_NAME_FLAG_DO_NOT_QUEUE means that - you only care about being the primary owner
any editor that can be the user editor should specify DBUS_NAME_FLAG_REPLACE_EXISTING to either take over or be queued up according to
DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER means that the dbus_bus_request_name_APIParam_2 had no existing owner , and the caller is now the primary owner
and either the current owner did NOT specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING
or that the dbus_bus_request_name_APIParam_2 had an owner , and the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING , and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT
you need to exit
and either the current owner has NOT specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the caller did NOT specify DBUS_NAME_FLAG_REPLACE_EXISTING
Can only be called once per dbus_bus_set_unique_name_APIParam_1
say `` text editor , '' it should specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT if it wants the last editor started to be the user editor vs. the first one started
The only reason to use dbus_bus_set_unique_name_APIName is to re-implement the equivalent of dbus_bus_register_APIName yourself
Note Just use dbus_bus_get_APIName or dbus_bus_get_private_APIName , or worst case dbus_bus_register_APIName , instead of messing with this function
it is hard to use dbus_bus_set_unique_name_APIName safely on shared connections in a multithreaded application
Thus , you need a way to coordinate which thread sends the registration attempt
Can only be used
there is no mechanism in libdbus itself to avoid sending it twice
you need to avoid using dbus_bus_set_unique_name_APIName on shared connections
dbus_bus_start_service_by_name_APIParam_0 will be one of be one of DBUS_START_REPLY_SUCCESS or DBUS_START_REPLY_ALREADY_RUNNING
The dbus_bus_start_service_by_name_APIParam_3 parameter is for future expansion , currently you should specify 0
The dbus_timeout_handle_APIName should be called each time this interval elapses , starting after The dbus_timeout_handle_APIName elapses once
it should not be polled by the main loop
it should not be polled by the main loop
it should not be polled by the main loop
it should not be polled by the main loop
If dbus_timeout_handle_APIName returns FALSE , there wasn't enough memory to handle the dbus_timeout_handle_APIParam_1
with Qt you might store the QTimer for this dbus_timeout_set_data_APIParam_1 and with GLib you might store a g_timeout_add result id
This string must not be freed
This string must not be freed
This string must not be freed
This string must not be freed
dbus_address_escape_value_APIName return newly-allocated escaped dbus_address_escape_value_APIParam_1 or NULL if no memory
dbus_address_unescape_value_APIName return newly-allocated unescaped dbus_address_unescape_value_APIParam_1 or NULL if no memory
host = example.com , port = 8073 ''
dbus_parse_address_APIName return TRUE on success, FALSE otherwise
the first dbus_parse_address_APIParam_1 entries in the semicolon-separated list should be tried first
Deprecated former name of dbus_watch_get_unix_fd_APIName
Gets flags from DBusWatchFlags indicating what conditions should be monitored on the file descriptor
On Windows, dbus_watch_get_unix_fd_APIName returns -1 but dbus_watch_get_socket_APIName returns a Winsock socket
The flags returned will only contain DBUS_WATCH_READABLE and DBUS_WATCH_WRITABLE, never DBUS_WATCH_HANGUP or DBUS_WATCH_ERROR
Returns a socket to be watched, on UNIX this will return -1 if our transport is not socket-based so dbus_watch_get_unix_fd_APIName is preferred
Always returns -1 on Windows
If you ignore the FALSE return, your application may spin in a busy loop on the file descriptor until memory becomes available, but nothing more catastrophic should happen
dbus_watch_handle_APIName can not be called , as the connection will not be ready to handle that dbus_watch_handle_APIParam_1 yet
with Qt you might store the QSocketNotifier for this dbus_watch_set_data_APIParam_1 and with GLib you might store a GSource

