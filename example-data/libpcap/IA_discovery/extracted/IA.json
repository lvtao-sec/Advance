[{"cond": "null", "prop": "pcap_create_APIName and pcap_activate_APIName were not available in versions of libpcap prior to 1.0"}, {"cond": "null", "prop": "you should use a non-zero timeout"}, {"cond": "null", "prop": "If there is an error, or if pcap_init_APIName has been called, NULL is returned by pcap_lookupdev_APIName and errbuf is filled in with an appropriate error message"}, {"cond": "null", "prop": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block"}, {"cond": "null", "prop": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block"}, {"cond": "null", "prop": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block"}, {"cond": "null", "prop": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block"}, {"cond": "null", "prop": "pcap_set_buffer_size_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_buffer_size_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_protocol_linux_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_protocol_linux_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_timeout_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_timeout_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_immediate_mode_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_immediate_mode_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_promisc_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_promisc_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_snaplen_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_snaplen_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "pcap_set_rfmon_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_rfmon_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "Mac OS X prior to Mac OS X 10.7"}, {"cond": "null", "prop": "Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls , so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices"}, {"cond": "null", "prop": "pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct , usually the result of a call to pcap_compile_APIName"}, {"cond": "null", "prop": "otherwise, PCAP_ERROR be returned by pcap_get_selectable_fd_APIName"}, {"cond": "null", "prop": "otherwise, 0 be returned by pcap_setnonblock_APIName"}, {"cond": "null", "prop": "pcap_setfilter_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_setdirection_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_sendpacket_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_dump_flush_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_set_datalink_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_compile_APIName returns 0 on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop"}, {"cond": "when just", "prop": "using libpcap for compiling BPF code"}, {"cond": "if the packet does not match the filter and non-zero if the packet matches the filter", "prop": "This will be zero"}, {"cond": "null", "prop": "pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN , PCAP_D_OUT or PCAP_D_INOUT"}, {"cond": "null", "prop": "It is typically used"}, {"cond": "null", "prop": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error"}, {"cond": "null", "prop": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error"}, {"cond": "null", "prop": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error"}, {"cond": "null", "prop": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error"}, {"cond": "null", "prop": "pcap_setdirection_APIName is not necessarily fully supported on all platforms"}, {"cond": "null", "prop": "some platforms might return an error for all values, and some other platforms might not support PCAP_D_OUT"}, {"cond": "if using pcap_dump_open_APIName , pcap_dump_APIName , and pcap_dump_close_APIName to write a savefile if there is no pcap_t that supplies the packets to be written", "prop": "it can also be used"}, {"cond": "if a savefile is being read", "prop": "This operation is not supported"}, {"cond": "null", "prop": "One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision"}, {"cond": "null", "prop": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName"}, {"cond": "null", "prop": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName"}, {"cond": "null", "prop": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName"}, {"cond": "null", "prop": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName"}, {"cond": "null", "prop": "pcap_datalink_name_to_val_APIName returns the type value on success and PCAP_ERROR if the pcap_datalink_name_to_val_APIParam_1 is not a known type name"}, {"cond": "null", "prop": "this can happen on 32-bit UNIX-like systems with large file support and on Windows"}, {"cond": "null", "prop": "NULL be returned by pcap_tstamp_type_val_to_description_APIName on failure"}, {"cond": "null", "prop": "NULL be returned by pcap_tstamp_type_val_to_name_APIName on failure"}, {"cond": "null", "prop": "NULL be returned by pcap_dump_open_APIName on failure"}, {"cond": "null", "prop": "These functions became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "These functions became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "These functions became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "These functions became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "pcap_set_tstamp_precision_APIName became available in libpcap release 1.5.1"}, {"cond": "null", "prop": "pcap_set_protocol_linux_APIName became available in libpcap release 1.9.0"}, {"cond": "null", "prop": "pcap_get_tstamp_precision_APIName became available in libpcap release 1.5.1"}, {"cond": "null", "prop": "pcap_open_offline_with_tstamp_precision_APIName and pcap_fopen_offline_with_tstamp_precision_APIName became available in libpcap release 1.5.1"}, {"cond": "null", "prop": "pcap_set_immediate_mode_APIName became available in libpcap release 1.5.0"}, {"cond": "null", "prop": "pcap_tstamp_type_name_to_val_APIName became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "pcap_set_tstamp_type_APIName became available in libpcap release 1.2.1"}, {"cond": "null", "prop": "pcap_get_required_select_timeout_APIName became available in libpcap release 1.9.0"}, {"cond": "null", "prop": "In that case , those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device  , the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the call returns"}, {"cond": "null", "prop": "pcap_setfilter_APIParam_2 is a pointer to a bpf_program struct , usually the result of a call to pcap_compile -LRB- 3PCAP"}, {"cond": "null", "prop": "Applications should be prepared for this to happen , but must not rely on it happening"}, {"cond": "null", "prop": "pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available"}, {"cond": "null", "prop": "pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed"}, {"cond": "null", "prop": "pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed"}, {"cond": "null", "prop": "pcap_is_swapped_APIName returns true  if pcap_is_swapped_APIParam_1 refers to a savefile that uses a different byte order than the current system"}, {"cond": "null", "prop": "pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error"}, {"cond": "null", "prop": "pcap_next_ex_APIName returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR if an error occurred while reading the packet, and PCAP_ERROR_BREAK if packets are being read from a savefile and there are no more packets to read from the savefile"}, {"cond": "null", "prop": "If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet"}, {"cond": "null", "prop": "pcap_dispatch_APIName returns the number of packets processed on success"}, {"cond": "null", "prop": "and PCAP_TSTAMP_PRECISION_NANO should be specified if the packets to be written have time stamps in seconds and nanoseconds"}, {"cond": "if the packets to be written have time stamps in seconds and microseconds", "prop": "PCAP_TSTAMP_PRECISION_MICRO should be specified"}, {"cond": "if no packets were read from a live capture", "prop": "this can be 0 or"}, {"cond": "null", "prop": "The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called"}, {"cond": "null", "prop": "The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called"}, {"cond": "null", "prop": "pcap_set_tstamp_precision_APIName returns 0 on success if the specified time stamp precision is expected to be supported by the capture device, PCAP_ERROR_TSTAMP_PRECISION_NOTSUP if the capture device does not support the requested time stamp precision, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_precision_APIName is called on a capture handle that has been activated"}, {"cond": "null", "prop": "The struct pcap_pkthdr and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns"}, {"cond": "if it is used on any device other than a network interface", "prop": "it will have no effect"}, {"cond": "null", "prop": "It has no effect on savefiles"}, {"cond": "null", "prop": "It should not be used in portable code"}, {"cond": "if the code needs them to be valid after the pcap_loop_APIParam_3", "prop": "it must make a copy of them"}, {"cond": "if the code needs them to remain valid", "prop": "it must make a copy of them"}, {"cond": "if the code needs it to remain valid", "prop": "it must make a copy of it"}, {"cond": "if the code needs them to be valid after the pcap_loop_APIParam_3", "prop": "it must make a copy of them"}, {"cond": "if the code needs them to remain valid", "prop": "it must make a copy of them"}, {"cond": "when pcap_dispatch_APIParam_2 was 0", "prop": "-LRB- In older versions of libpcap , the behavior was undefined"}, {"cond": "null", "prop": "instead , a filter should be specified with pcap_setfilter -LRB- 3PCAP"}, {"cond": "null", "prop": "different platforms and devices behaved differently , so code that must work with older versions of libpcap should use -1 , not 0 , as the value of cnt"}, {"cond": "null", "prop": "applications that use pcap_file_APIName should, if possible, use calls that support large files on the return value of pcap_file_APIName or the value returned by fileno_APIName when passed the return value of pcap_file"}, {"cond": "null", "prop": "Note that the Packet Capture library is usually built with large file support , so the standard I/O stream of the savefile might refer to a file larger than 2 gigabytes"}, {"cond": "null", "prop": "pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed , , the end of the savefile is reached when reading from a savefile , pcap_breakloop_APIName is called , or an error occurs"}, {"cond": "null", "prop": "To work around this , code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode , and must arrange that the call have a timeout less than or equal to the packet buffer timeout , and must try to read packets after that timeout expires , regardless of"}, {"cond": "null", "prop": "Note also that poll_APIName and kevent_APIName does not work on character special files, including BPF devices, in Mac OS X 10.4 and 10.5, so, while select_APIName can be used on the descriptor returned by pcap_get_selectable_fd_APIName, poll_APIName and kevent_APIName cannot be used on it those versions of Mac OS X. poll_APIName, but not kevent_APIName, works on that descriptor in Mac OS X releases prior to 10.4"}, {"cond": "null", "prop": "pcap_inject_APIName returns the number of bytes written on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "Note also that some devices might not support sending packets"}, {"cond": "null", "prop": "if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName"}, {"cond": "null", "prop": "pcap_sendpacket_APIName is like pcap_inject_APIName, but pcap_inject_APIName returns 0 on success, rather than returning the number of bytes written"}, {"cond": "null", "prop": "pcap_list_datalinks_APIName returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED if pcap_list_datalinks_APIName is called on a capture handle that has been created but not activated, and PCAP_ERROR on other errors"}, {"cond": "null", "prop": "pcap_get_tstamp_precision_APIName returns PCAP_TSTAMP_PRECISION_MICRO or PCAP_TSTAMP_PRECISION_NANO, which indicates that pcap captures contains time stamps in microseconds or nanoseconds respectively"}, {"cond": "null", "prop": "Note that on Windows , that stream should be opened in binary mode"}, {"cond": "null", "prop": "Note that on Windows , that stream should be opened in binary mode"}, {"cond": "null", "prop": "Note that on Windows , that stream should be opened in binary mode"}, {"cond": "null", "prop": "Note that on Windows , that stream should be opened in binary mode"}, {"cond": "null", "prop": "If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text"}, {"cond": "null", "prop": "The pcap_dump_open_append_APIName function became available in libpcap release 1.7.2"}, {"cond": "null", "prop": "RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success"}, {"cond": "null", "prop": "In previous releases , there is no support for appending packets to an existing savefile"}, {"cond": "null", "prop": "Even worse , some drivers on some platforms might change the link-layer type field to whatever value , even on platforms that do nominally support sending completely raw and unchanged packets"}, {"cond": "null", "prop": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type"}, {"cond": "null", "prop": "In previous releases , the time stamp type can not be set"}, {"cond": "null", "prop": "In previous releases , the time stamp type can not be set"}, {"cond": "null", "prop": "In previous releases , the time stamp type can not be set"}, {"cond": "null", "prop": "In previous releases , the time stamp type can not be set"}, {"cond": "null", "prop": "If a positive number be returned by pcap_breakloop_APIName, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK and clear the flag"}, {"cond": "null", "prop": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure"}, {"cond": "null", "prop": "pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure"}, {"cond": "null", "prop": "pcap_create_APIName returns a pcap_t * on success and NULL on failure"}, {"cond": "null", "prop": "If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message"}, {"cond": "null", "prop": "If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message"}, {"cond": "null", "prop": "If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP"}, {"cond": "null", "prop": "pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "NULL be returned by pcap_datalink_val_to_description_APIName if the type value does not correspond to a known DLT_ value"}, {"cond": "null", "prop": "NULL be returned by pcap_datalink_val_to_name_APIName if the type value does not correspond to a known DLT_ value"}, {"cond": "null", "prop": "Note that , , you might not have permission to send packets on it , or it might not support sending packets"}, {"cond": "null", "prop": "A struct pcap_stat has the following members"}, {"cond": "null", "prop": "as pcap_open_live_APIName does not have a flag to indicate , you can not request an open that supports sending and be notified at open time"}, {"cond": "null", "prop": "on Linux systems with 2.2 or later kernels , a pcap_open_live_APIParam_1 argument of `` any '' or NULL can be used to capture packets from all interfaces"}, {"cond": "null", "prop": "on Linux systems with 2.2 or later kernels , a pcap_create_APIParam_1 argument of `` any '' or NULL can be used to capture packets from all interfaces"}, {"cond": "null", "prop": "pcap_stats_APIName is supported only on live captures , not on savefiles"}, {"cond": "null", "prop": "ps_drop is not available on all platforms"}, {"cond": "null", "prop": "that loop will not necessarily be terminated by a signal , so pcap_breakloop_APIName should be used to terminate packet processing"}, {"cond": "null", "prop": "it is zero on platforms where it is not available"}, {"cond": "null", "prop": "It also might , or might not , count packets dropped"}, {"cond": "null", "prop": "pcap_stats_APIName returns 0 on success and returns PCAP_ERROR if there is an error or if pcap_stats_APIParam_1 does not support packet statistics"}, {"cond": "null", "prop": "Both ps_recv and ps_drop might , or might not , count packets not yet read from the operating system and thus not yet seen by the application"}, {"cond": "null", "prop": "to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user"}, {"cond": "null", "prop": "ps_ifdrop might , or might not , be implemented"}, {"cond": "null", "prop": "Note that should NOT be restarted by that signal"}, {"cond": "null", "prop": "You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls"}, {"cond": "if you are catching signals on UNIX systems that support restarting system calls after a signal , and calling pcap_breakloop_APIName in the signal handler", "prop": "you must specify , when catching those signals , that system calls"}, {"cond": "null", "prop": "pcap_datalink_APIName returns the link-layer header type on success and PCAP_ERROR_NOT_ACTIVATED if pcap_datalink_APIName is called on a capture handle that has been created but not activated"}, {"cond": "null", "prop": "We recommend always setting the timeout to a non-zero value unless immediate mode is set , in which case the timeout has no effect"}, {"cond": "if the timeout is not specified", "prop": "The behavior , , is undefined , as is the behavior if the timeout is set to zero or to a negative value"}, {"cond": "when the handle was created", "prop": "The capture source specified does not exist"}, {"cond": "when the handle was created", "prop": "The capture source specified does not exist"}, {"cond": "when the handle was created", "prop": "The capture source specified does not exist"}, {"cond": "when the handle was created", "prop": "The capture source specified does not exist"}, {"cond": "If the time stamps in the file do not have the same precision as the requested precision", "prop": "they will be scaled up or down as necessary before being supplied"}, {"cond": "null", "prop": "Another error occurred"}, {"cond": "null", "prop": "Another error occurred"}, {"cond": "null", "prop": "Another error occurred"}, {"cond": "null", "prop": "Another error occurred"}, {"cond": "null", "prop": "For a live capture, it always returns false (0"}, {"cond": "null", "prop": "a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors"}, {"cond": "null", "prop": "pcap_is_swapped_APIName returns true  or false  on success and PCAP_ERROR_NOT_ACTIVATED if pcap_is_swapped_APIName is called on a capture handle that has been created but not activated"}, {"cond": "null", "prop": "pcap_next_ex_APIName reads the next packet and returns a success/failure indication"}, {"cond": "null", "prop": "pcap_geterr_APIName returns the error text pertaining to the last pcap library error"}, {"cond": "null", "prop": "pcap_strerror_APIName is provided in case strerror_APIName is not available"}, {"cond": "null", "prop": "pcap_snapshot_APIName returns the snapshot length on success and PCAP_ERROR_NOT_ACTIVATED if pcap_snapshot_APIName is called on a capture handle that has been created but not activated"}, {"cond": "null", "prop": "it always returns 0 on savefiles"}, {"cond": "null", "prop": "The returned handle must be activated with pcap_activate_APIName before packets can be captured with it"}, {"cond": "null", "prop": "errbuf is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars"}, {"cond": "null", "prop": "If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message"}, {"cond": "null", "prop": "If there is an error, PCAP_ERROR be returned by pcap_getnonblock_APIName and pcap_getnonblock_APIParam_2 is filled in with an appropriate error message"}, {"cond": "null", "prop": "On Linux , with previous releases of libpcap , capture devices are always in immediate mode"}, {"cond": "null", "prop": "you must use or copy the string before closing the pcap_t"}, {"cond": "null", "prop": "the pointer pcap_geterr_APIName returns will no longer point to a valid error message string after the pcap_t passed to it is closed"}, {"cond": "null", "prop": "pcap_tstamp_type_name_to_val_APIName returns time stamp type value on success and PCAP_ERROR on failure"}, {"cond": "null", "prop": "pcap_next_APIName returns a pointer to the packet data on success, and returns NULL if an error occurred, or if no packets were read from a live capture , or if no more packets are available in a savefile"}, {"cond": "null", "prop": "however , in 1.5.0 and , it should be used"}, {"cond": "null", "prop": "on Solaris 10 and earlier versions of Solaris , immediate mode must be turned on by"}, {"cond": "null", "prop": "The packet data is not to be freed by the caller , and is not guaranteed to be valid after the next call to pcap_next_ex_APIName , pcap_next_APIName , pcap_loop_APIName , or pcap_dispatch_APIName"}, {"cond": "null", "prop": "on Windows , immediate mode must be turned on by calling pcap_setmintocopy_APIName with a size of 0"}, {"cond": "null", "prop": "The struct pcap_pkthdr and the packet data are not to be freed by the caller , and are not guaranteed to be valid after the next call to pcap_next_ex_APIName , pcap_next_APIName , pcap_loop_APIName , or pcap_dispatch_APIName"}, {"cond": "null", "prop": "on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11, immediate mode must be turned on with a BIOCIMMEDIATE ioctl_APIName, as documented in bpf_APIName, on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called"}, {"cond": "null", "prop": "on Digital UNIX/Tru64 UNIX, immediate mode must be turned on by doing a BIOCMBIC ioctl, as documented in packetfilter_APIName, to clear the ENBATCH flag on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called"}, {"cond": "null", "prop": "The timeout that should be used in those calls must be no larger than the smallest of all timeouts returned by pcap_get_required_select_timeout_APIName for devices from which packets will be captured"}, {"cond": "null", "prop": "otherwise NULL be returned by pcap_get_required_select_timeout_APIName"}, {"cond": "null", "prop": "In previous releases, select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName cannot be used on any capture source for which pcap_get_selectable_fd_APIName returns -1"}, {"cond": "null", "prop": "Each element of the list is of type pcap_if_t , and has the following members"}, {"cond": "null", "prop": "The device  must be put in non-blocking mode with pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the select_APIName , poll_APIName , epoll_wait_APIName , or kevent_APIName call returns"}, {"cond": "null", "prop": "NULL for the last element of the list name"}, {"cond": "null", "prop": "pcap_get_required_select_timeout_APIName returns, on UNIX, a pointer to a struct timeval containing a value that must be used as the minimum timeout in select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName calls if pcap_get_selectable_fd_APIName returns PCAP_ERROR"}, {"cond": "null", "prop": "Each element of the list of addresses is of type pcap_addr_t , and has the following members"}, {"cond": "If pcap_findalldevs_APIName succeeds", "prop": "the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list , or to NULL if no devices were found"}, {"cond": "null", "prop": "NULL for the last element of the list addr"}, {"cond": "null", "prop": "The list of devices must be freed with pcap_freealldevs_APIName , which frees the list pointed to by alldevs"}, {"cond": "null", "prop": "The PCAP_IF_UP and PCAP_IF_RUNNING constants became available in libpcap release 1.6.1"}, {"cond": "null", "prop": "The PCAP_IF_WIRELESS , PCAP_IF_CONNECTION_STATUS , PCAP_IF_CONNECTION_STATUS_UNKNOWN , PCAP_IF_CONNECTION_STATUS_CONNECTED , PCAP_IF_CONNECTION_STATUS_DISCONNECTED , and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE constants became available in libpcap release 1.9.0"}, {"cond": "null", "prop": "The PCAP_NETMASK_UNKNOWN constant became available in libpcap release 1.1.0"}, {"cond": "null", "prop": "A non-zero return value indicates what warning or error condition occurred"}, {"cond": "null", "prop": "Promiscuous mode was requested , but the capture source does not support promiscuous mode"}, {"cond": "null", "prop": "as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case"}, {"cond": "if the device does not support broadcasts", "prop": "may be null dstaddr"}, {"cond": "if the device is not", "prop": "may be null a point-to-point interface"}, {"cond": "null", "prop": "Another warning condition occurred"}, {"cond": "null", "prop": "The time stamp type specified in a previous pcap_set_tstamp_type_APIName call is not supported by the capture source , PCAP_WARNING"}, {"cond": "null", "prop": "pcap_activate_APIName returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error"}, {"cond": "as if it pointed to a struct sockaddr_in6", "prop": "for IPv6 addresses , it can be interpreted"}, {"cond": "null", "prop": "Monitor mode was specified but the capture source does not support monitor mode"}, {"cond": "null", "prop": "pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName"}, {"cond": "null", "prop": "In WinPcap, pcap_lookupdev_APIName may return a UTF-16 string rather than an ASCII or UTF-8 string"}, {"cond": "null", "prop": "the pcap_t should be closed using pcap_close"}, {"cond": "If pcap_activate_APIName fails", "prop": "the pcap_t * is not closed and freed"}, {"cond": "null", "prop": "If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message"}, {"cond": "null", "prop": "a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors"}, {"cond": "null", "prop": "in libpcap 1.8.0 and later , pcap_compile_APIName can be used in multiple threads within a single process"}, {"cond": "null", "prop": "Note that the addresses in the list of addresses might be IPv4 addresses , IPv6 addresses , or some other type of addresses , so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address"}, {"cond": "If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program , or if packets are being captured on the Linux `` any '' pseudo-interface that can capture on more than one network", "prop": "a value of PCAP_NETMASK_UNKNOWN can be supplied"}, {"cond": "null", "prop": "do not assume that the addresses are all IPv4 addresses , or even all IPv4 or IPv6 addresses"}, {"cond": "null", "prop": "pcap_set_tstamp_type_APIName returns 0 on success if the specified time stamp type is expected to be supported by the capture device, PCAP_WARNING_TSTAMP_TYPE_NOTSUP if the specified time stamp type is not supported by the capture device, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_type_APIName is called on a capture handle that has been activated, and PCAP_ERROR_CANTSET_TSTAMP_TYPE if the capture device does not support setting the time stamp type (only older versions of libpcap will return that"}, {"cond": "null", "prop": "However , in earlier versions of libpcap , it is not safe to use pcap_compile_APIName in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time"}, {"cond": "null", "prop": "If pcap_fileno_APIParam_1 refers to a savefile that was opened using functions such as pcap_open_offline_APIName or pcap_fopen_offline_APIName, a dead pcap_t opened using pcap_open_dead_APIName, or a pcap_t that was created with pcap_create_APIName but that has not yet been activated with pcap_activate_APIName, pcap_fileno_APIName returns PCAP_ERROR"}]