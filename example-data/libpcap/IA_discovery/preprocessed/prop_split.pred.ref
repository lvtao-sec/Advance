['pcap_create_APIName and pcap_activate_APIName were not available in versions of libpcap prior to 1.0', 'api be not available version before constant']
['you should use a non-zero timeout', 'PRON- should use param timeout']
['If there is an error, or if pcap_init_APIName has been called, NULL is returned by pcap_lookupdev_APIName and errbuf is filled in with an appropriate error message', 'if be error , if api have be call , null be return by api be fill appropriate error message']
['pcap_get_selectable_fd_APIName is not available on Windows', 'api be not available window']
['A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block', 'call api return constant but not block']
['A selectable file descriptor be returned by pcap_get_selectable_fd_APIName if one exists', 'selectable file descriptor be return by api']
['FreeBSD prior to FreeBSD 4.6', 'before constant']
['NetBSD prior to NetBSD 3.0', 'before constant']
['pcap_set_buffer_size_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_buffer_size_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['pcap_offline_filter_APIName returns the return value of the filter program', 'api return return value filter program']
['Mac OS X prior to Mac OS X 10.7', 'os before os constant']
['OpenBSD prior to OpenBSD 2.4', 'before constant']
['Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls , so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices', 'network device open api , not support call , constant be return by api device']
['pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct , usually the result of a call to pcap_compile_APIName', 'param be pointer param struct , usually result call api']
['otherwise, PCAP_ERROR be returned by pcap_get_selectable_fd_APIName', 'otherwise , constant be return by api']
['pcap_setfilter_APIName is used to specify a filter program', 'api be use specify filter program']
['the buffer size that will be used on a capture handle', 'buffer size be use handle']
['-LRB- That workaround will not work in FreeBSD 4.3 and later', '_ lrb _ workaround not work constant later']
['pcap_set_buffer_size_APIName sets', 'api set']
['linktype specifies the link-layer type for the pcap_t', 'specifie param type param']
['pcap_setdirection_APIName is used to specify a direction that packets will be captured', 'api be use specify direction be']
['pcap_setfilter_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop', 'if api return null , be not possible wait arrive device event loop']
['Note that a device on which a read can be done without blocking may , on some platforms , not have', 'device which read can be do without block may , platform , not have']
['Its value does not affect pcap_compile -LRB- 3PCAP', 'value do not affect api _ lrb _ 3pcap']
['pcap_setdirection_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['If PCAP_ERROR be returned by pcap_setfilter_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setfilter_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['pcap_offline_filter_APIParam_2 points to the pcap_pkthdr structure for the packet , and pcap_offline_filter_APIParam_3 points to the data in the packet', 'param point param point datum']
['pcap_offline_filter_APIName checks whether a filter matches a packet', 'api check whether filter match']
['snaplen specifies the snapshot length for the pcap_t', 'specifie snapshot length param']
['using libpcap for compiling BPF code', 'use compile code']
['This will be zero', 'be constant']
['however , in FreeBSD 4.6 and later , those calls work correctly on BPF devices , so the workaround is not necessary', 'however , constant later , call work correctly device , workaround be not necessary']
['pcap_statustostr_APIName converts a PCAP_ERROR_ or PCAP_WARNING_ value returned by a libpcap routine to an pcap_statustostr_APIParam_1 string', 'api convert constant _ constant _ value return by api param string']
['pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN , PCAP_D_OUT or PCAP_D_INOUT', 'param be one constant']
['It is typically used', 'be typically use']
['creating a pcap_t structure to use', 'create param use']
['pcap_open_dead_APIName and pcap_open_dead_with_tstamp_precision_APIName are used for', 'api be use']
['PCAP_ERROR be returned by pcap_dump_ftell_APIName on error', 'constant be return by api error']
['pcap_setdirection_APIName is not necessarily fully supported on all platforms', 'api be not necessarily fully support platform']
['PCAP_ERROR be returned by pcap_dump_ftell_APIName on error', 'constant be return by api error']
['some platforms might return an error for all values, and some other platforms might not support PCAP_D_OUT', 'platform may return error value , platform may not support constant']
['The translation is case-insensitive', 'translation be param']
['pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName', 'api return current file position , represent number byte write by api']
['pcap_get_selectable_fd_APIName returns, on UNIX, a file descriptor number for a file descriptor on which one can do a select_APIName, poll_APIName, epoll_wait_APIName, kevent_APIName, or other such call to wait for it to be possible to read packets without blocking, if such a descriptor exists, or PCAP_ERROR, if no such descriptor exists', 'api return , unix , file descriptor number file descriptor which one can api , call wait be possible read without block']
['it can also be used', 'can be use']
['PCAP_D_INOUT is the default setting', 'constant be default setting']
['Two time stamp precisions are supported , microseconds and nanoseconds', 'two time be support']
['This operation is not supported', 'operation be not support']
['By default , time stamps are in microseconds', 'by default , time be']
['One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision', 'one can use option constant request desire']
['If PCAP_ERROR be returned by pcap_setdirection_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setdirection_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['PCAP_D_IN will only capture packets received by the device , PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device', 'constant only receive by device , constant only send by device constant receive by send by device']
['it will be truncated', 'be truncate']
['It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName', 'must be call descriptor create by api have not yet be activate by api']
['select_APIName , poll_APIName , and kevent_APIName do not work correctly on BPF devices', 'api not work correctly device']
['pcap_datalink_name_to_val_APIName returns the type value on success and PCAP_ERROR if the pcap_datalink_name_to_val_APIParam_1 is not a known type name', 'api return type value success constant']
['this can happen on 32-bit UNIX-like systems with large file support and on Windows', 'can happen param system large file support window']
['NULL be returned by pcap_tstamp_type_val_to_description_APIName on failure', 'null be return by api failure']
['These functions became available in libpcap release 1.2.1', 'function become available release constant']
['pcap_datalink_name_to_val_APIName translates a link-layer header type pcap_datalink_name_to_val_APIParam_1 , which is a DLT _ pcap_datalink_name_to_val_APIParam_1 with the DLT _ removed , to the corresponding link-layer header type value', 'api translate param header type param , which be _ param _ remove , corresponding param header type value']
['pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation', 'api return current file position param  , return file without']
['pcap_set_tstamp_precision_APIName became available in libpcap release 1.5.1', 'api become available release constant']
['NULL be returned by pcap_tstamp_type_val_to_name_APIName on failure', 'null be return by api failure']
['pcap_get_selectable_fd_APIName will return a file descriptor on most of those versions , but a simple select_APIName , poll_APIName , or kevent_APIName call will not indicate that the descriptor is readable until a full buffer worth of packets is received', 'api return file descriptor version , but simple api call not indicate descriptor be readable until full buffer be receive']
['pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2', 'api set time desire descriptor type specify by param']
['In that case , those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device  , the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the call returns', 'case , call must be give timeout less equal timeout return by api device , device must be put param mode call api , attempt must always be make read device call return']
['pcap_tstamp_type_val_to_name_APIName translates a time stamp type value to the corresponding time stamp type name', 'api translate time type value correspond time type name']
['It does not return when live packet buffer timeouts occur', 'do not return live buffer timeout occur']
['pcap_setfilter_APIParam_2 is a pointer to a bpf_program struct , usually the result of a call to pcap_compile -LRB- 3PCAP', 'param be pointer param struct , usually result call api _ lrb _ 3pcap']
['The bytes of data from the packet begin with a link-layer header', 'byte datum begin param header']
['//www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values', 'list value api can return describe format correspond value']
['instead , it attempts to read more packets', 'instead , attempt read']
['pcap_tstamp_type_val_to_description_APIName translates a time stamp type value to a short description of that time stamp type', 'api translate time type value short description time type']
['Applications should be prepared for this to happen , but must not rely on it happening', 'application should be prepare happen , but must not rely happen']
['pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available', 'api return constant']
['It does not return when live packet buffer timeouts occur', 'do not return live buffer timeout occur']
['In previous releases , time stamps from a capture device or savefile are always given in seconds and microseconds', 'previous release , time device be always give second']
['pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed', 'api return constant']
['The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName', 'format param header be indicate by return value api handed param value pass api']
['A value of -1 or 0 for pcap_loop_APIParam_2 is equivalent to infinity , so that packets are processed until another ending condition occurs', 'value constant param be equivalent infinity , be process until another end condition occur']
['pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed', 'api return constant']
['If PCAP_ERROR be returned by pcap_dispatch_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_dispatch_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0', 'if application use api , make sure -PRON- explicitly check constant , rather check return value constant']
['Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet', 'not assume give have give param header type , as constant']
['pcap_dispatch_APIName returns the number of packets processed on success', 'api return number process success']
['pcap_set_protocol_linux_APIName became available in libpcap release 1.9.0', 'api become available release constant']
['pcap_set_protocol_linux_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_protocol_linux_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['precision specifies the time stamp precision for packets', 'specify time']
['and PCAP_TSTAMP_PRECISION_NANO should be specified if the packets to be written have time stamps in seconds and nanoseconds', 'constant should be specify']
['The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value , such as the values in the < linux/if _ ether.h > header file , specified in host byte order', 'param be param value , as value _ header file , specify host byte order']
['Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, pcap_dispatch_APIName will return 0, even when not in non-blocking mode, as there are no packets to process', 'do live platform']
['pcap_list_datalinks_APIName allocates an array to hold the list and sets * dlt_buf to point to that array', 'api allocate array hold list set param point array']
['PCAP_TSTAMP_PRECISION_MICRO should be specified', 'constant should be specify']
['On network interface devices on Linux , pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket', 'network api device , api set param be use api call create socket']
['this can be 0 or', 'can be constant']
['The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called', 'value api return be valid receive unless until api be call']
['packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated , otherwise', 'param be handle be activate , otherwise']
['pcap_set_tstamp_precision_APIName returns 0 on success if the specified time stamp precision is expected to be supported by the capture device, PCAP_ERROR_TSTAMP_PRECISION_NOTSUP if the capture device does not support the requested time stamp precision, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_precision_APIName is called on a capture handle that has been activated', 'api return constant success  have be activate']
["the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL", 'device have param header type constant']
['pcap_list_datalinks_APIName is used to get a list of the supported link-layer header types of the interface associated with the pcap descriptor', 'api be use get list support param header type api associate descriptor']
['The struct pcap_pkthdr and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns', 'struct param datum be not be free by param api , be not guarantee be valid after param api return']
['it will have no effect', 'have no effect']
['The caller is responsible for freeing the array with pcap_free_datalinks_APIName , which frees the list of link-layer header types pointed to by dlt_list', 'caller be responsible freeing array api , which free list param header type point by param']
['Thus, when doing a live capture, pcap_dispatch_APIParam_2 is the maximum number of packets to process before returning, but is not a minimum number', 'thus , do live , param be maximum number process before return , but be not minimum number']
['pcap_set_protocol_linux_APIName is only provided on Linux , and', 'api be only provide']
['It should not be used in portable code', 'should not be use portable code']
['callback specifies a pcap_handler routine to be called with three arguments', 'callback specifie param api be call three param']
['after a successful call to pcap_set_datalink_APIName , all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink', 'after successful call api , subsequent have param header type specify by param header type value pass api']
['it must make a copy of them', 'must make copy']
['poll_APIName and kevent_APIName work on that descriptor in Mac OS X 10.6 and later', 'api work descriptor os constant later']
['-LRB- In older versions of libpcap , the behavior was undefined', '_ lrb _ old version , behavior be undefined']
['instead , a filter should be specified with pcap_setfilter -LRB- 3PCAP', 'instead , filter should be specify api _ lrb _ 3pcap']
['pcap_loop_APIName processes packets from a live capture or savefile until pcap_loop_APIParam_2 packets are processed , the end of the savefile is reached', 'api process live until param be process , end be reach']
['so fewer than pcap_dispatch_APIParam_2 packets may be processed', 'few param may be process']
['pcap_file_APIName returns the standard I/O stream of the savefile, if a savefile was opened with pcap_open_offline_APIName, or NULL, if a network device was opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live(3PCAP', 'api return standard stream ,  , param']
['different platforms and devices behaved differently , so code that must work with older versions of libpcap should use -1 , not 0 , as the value of cnt', 'different platform device behave differently , code must work old version should use constant , not constant , as value']
['A value of -1 or 0 for pcap_dispatch_APIParam_2 causes all the packets received in one buffer to be processed , and causes all the packets in the file to be processed when reading a savefile', 'value constant param cause receive one buffer be process , cause file be process read']
['the end of the current bufferful of packets is reached', 'end current be reach']
['applications that use pcap_file_APIName should, if possible, use calls that support large files on the return value of pcap_file_APIName or the value returned by fileno_APIName when passed the return value of pcap_file', 'application use api should ,  , use call support large file return value api value return by api pass return value api']
['Note that the Packet Capture library is usually built with large file support , so the standard I/O stream of the savefile might refer to a file larger than 2 gigabytes', 'library be usually build large file support , standard stream may refer file large constant']
['pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed , , the end of the savefile is reached when reading from a savefile , pcap_breakloop_APIName is called , or an error occurs', 'api process live until param be process , end be reach read , api be call , error occur']
['a u_char pointer which is passed in the pcap_loop_APIParam_4 argument to pcap_loop_APIName or pcap_dispatch_APIName , a const struct pcap_pkthdr pointer pointing to the packet time stamp and lengths , and a const u_char pointer to the first caplen bytes of data from the packet', 'param pointer which be pass param api , const struct param pointer point time length , const param pointer first byte datum']
['To work around this , code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode , and must arrange that the call have a timeout less than or equal to the packet buffer timeout , and must try to read packets after that timeout expires , regardless of', 'work around , code us call wait arrive must put param mode , must arrange call have timeout less equal buffer timeout , must try read after timeout expire , regardless']
['Note also that poll_APIName and kevent_APIName does not work on character special files, including BPF devices, in Mac OS X 10.4 and 10.5, so, while select_APIName can be used on the descriptor returned by pcap_get_selectable_fd_APIName, poll_APIName and kevent_APIName cannot be used on it those versions of Mac OS X. poll_APIName, but not kevent_APIName, works on that descriptor in Mac OS X releases prior to 10.4', 'note api do not work character special file , include device , os constant 10 , , while api can be use descriptor return by api can not be use version os x. api , but not api , work descriptor os release before constant']
['If PCAP_ERROR be returned by pcap_list_datalinks_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_datalinks_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['that packet type can not be filtered with a filter specified with pcap_setfilter_APIName but can be filtered by specifying the socket-layer pcap_set_protocol_linux_APIParam_2 type using pcap_set_protocol_linux', 'type can not be filter filter specify api but can be filter by specify param type use api']
['Both are provided for compatibility', 'be provide compatibility']
['pcap_sendpacket_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['pcap_inject_APIName sends a raw packet through the network interface', 'api send raw network api']
['pcap_inject_APIName returns the number of bytes written on success and PCAP_ERROR on failure', 'api return number byte write success constant failure']
['Note also that some devices might not support sending packets', 'note device may not support send']
['if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName', 'if api be call directly , param be constant as return by api']
['pcap_dump_APIName outputs a packet to the savefile opened with pcap_dump_open_APIName', 'api output open api']
['pcap_inject_APIParam_2 points to the data of the packet , including the link-layer header , and pcap_inject_APIParam_3 is the number of bytes in the packet', 'param point datum , include param header , param be number byte']
['Note that its calling arguments are suitable for use with pcap_dispatch_APIName or pcap_loop_APIName', 'call param be suitable use api']
['pcap_sendpacket_APIName is like pcap_inject_APIName, but pcap_inject_APIName returns 0 on success, rather than returning the number of bytes written', 'api be like api , but api return constant success , rather return number byte write']
['pcap_get_tstamp_precision_APIName became available in libpcap release 1.5.1', 'api become available release constant']
['pcap_get_tstamp_precision_APIName returns the precision of the time stamp returned in packet captures on the pcap descriptor', 'api return time return descriptor']
['If PCAP_ERROR be returned by pcap_sendpacket_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_sendpacket_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['pcap_list_datalinks_APIName returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED if pcap_list_datalinks_APIName is called on a capture handle that has been created but not activated, and PCAP_ERROR on other errors', 'api return number param header type array success , constant']
['pcap_get_tstamp_precision_APIName returns PCAP_TSTAMP_PRECISION_MICRO or PCAP_TSTAMP_PRECISION_NANO, which indicates that pcap captures contains time stamps in microseconds or nanoseconds respectively', 'api return constant , which indicate contain time respectively']
['pcap_dump_open_APIName is called to open a savefile for writing', 'api be call open writing']
['The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName', 'file have format as use by api']
['pcap_dump_open_APIParam_2 specifies the name of the file to open', 'param specifie name file open']
['NULL be returned by pcap_dump_open_APIName on failure', 'null be return by api failure']
['In previous releases , time stamps from a capture device or savefile are always given in seconds and microseconds', 'previous release , time device be always give second']
['Note that on Windows , that stream should be opened in binary mode', 'window , stream should be open binary mode']
['If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text', 'api can be use get error text']
['pcap_dump_fopen_APIName is called to write data to an existing open stream pcap_dump_fopen_APIParam_2', 'api be call write datum exist open stream param']
['this stream will be closed by a subsequent call to pcap_dump_close_APIName', 'stream be close by subsequent call api']
['The pcap_dump_open_append_APIName function became available in libpcap release 1.7.2', 'api function become available release constant']
["The name '' - '' is a synonym for stdout", 'name _ be stdout']
['RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success', 'return value pointer param use subsequent api call be return by api success']
['See pcap-tstamp_APIName for a list of all the time stamp types', 'see api list time type']
['In previous releases , there is no support for appending packets to an existing savefile', 'previous release , be no support append exist']
['If pcap_major_version_APIParam_1 refers to a live capture, the values returned by pcap_major_version_APIName and pcap_minor_version_APIName are not meaningful', 'if param refer live , value return by api be not meaningful']
['p is a capture or savefile handle returned by an earlier call to pcap_create_APIName and activated by an earlier call to pcap_activate_APIName, or returned by an earlier call to pcap_open_offline_APIName, pcap_open_live_APIName, or pcap_open_dead_APIName', 'be handle return by early call api activate by early call api , return by early call api']
['The time stamp precision , link-layer type , and snapshot length from pcap_dump_fopen_APIParam_1 are used as the link-layer type and snapshot length of the output file', 'time , param type , snapshot length param be use as param type snapshot length output file']
['The version number is stored in the savefile', 'version number be store']
['Even worse , some drivers on some platforms might change the link-layer type field to whatever value , even on platforms that do nominally support sending completely raw and unchanged packets', 'even bad , platform may change param type field whatever value , even platform nominally support send completely raw unchanged']
['pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure', 'api return number time type array success constant failure']
['pcap_list_tstamp_types_APIName is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor', 'api be use get list support time type api associate descriptor']
['If pcap_major_version_APIParam_1 refers to a savefile, pcap_major_version_APIName returns the major number of the file format of the savefile and pcap_minor_version_APIName returns the minor number of the file format of the savefile', 'api return major number file format api return minor number file format']
['The caller is responsible for freeing the array with pcap_free_tstamp_types_APIName , which frees the list pointed to by tstamp_types', 'caller be responsible freeing array api , which free list point by param']
['note that the meaning of its values depends on the type of savefile -LRB- , pcap or pcapng', 'meaning value depend type _ lrb _']
['These functions became available in libpcap release 1.2.1', 'function become available release constant']
['If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type', 'return value constant mean only time type support be constant , which be device default time type']
['In previous releases , the time stamp type can not be set', 'previous release , time type can not be set']
['A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type', 'return value one mean only time type support be one list , which be device default time type']
['pcap_breakloop_APIName sets a flag that will force pcap_dispatch_APIName or pcap_loop_APIName to return rather than looping', 'api set flag force api return rather loop']
['pcap_open_live_APIName is used to obtain a packet capture handle to look at packets on the network', 'api be use obtain handle look network']
['they will return the number of packets that have been processed so far, or PCAP_ERROR_BREAK if no packets have been processed so far', 'return number have be process far , constant']
['only the default time stamp type offered by a capture source is available', 'only default time type offer by source be available']
['snaplen specifies the snapshot length to be set on the handle', 'specifie snapshot length be set handle']
['If PCAP_ERROR_BREAK be returned by pcap_breakloop_APIName from pcap_dispatch_APIName or pcap_loop_APIName, the flag is cleared, so a subsequent call will resume reading packets', 'if constant be return by api , flag be clear , subsequent call resume read']
['Asynchronous procedure calls will not work on Windows , as a thread blocked on a pcap_t will not be in an alertable state', 'asynchronous procedure call not work window , as thread block param not be alertable state']
['If a positive number be returned by pcap_breakloop_APIName, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK and clear the flag', 'if positive number be return by api , flag be not clear , subsequent call return constant clear flag']
['to_ms specifies the packet buffer timeout , as a non-negative value , in milliseconds', 'param specifie buffer timeout , as param value , millisecond']
['pcap_breakloop_APIName does not guarantee that no further packets will be processed by pcap_dispatch_APIName or pcap_loop_APIName after it is called', 'api do not guarantee no be process by api after be call']
['The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS', 'flag be check loop read os _ signal by not necessarily terminate loop _ as well as loop processing set return by os']
['at most one more packet might be processed', 'one may be process']
['This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows , as it merely sets a flag that is checked within the loop', 'api be safe use inside signal handler unix control handler window , as merely set flag check within loop']
['pcap_open_live_APIName returns a pcap_t * on success and NULL on failure', 'api return param success null failure']
['If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message', 'if null be return by api , param be fill appropriate error message']
['-LRB- See pcap_APIName for an explanation of the packet buffer timeout', '_ lrb _ see api explanation buffer timeout']
['It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP', 'must not be call descriptor create by api have not yet be activate by api _ lrb _ 3pcap']
['pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['NULL be returned by pcap_datalink_val_to_description_APIName if the type value does not correspond to a known DLT_ value', 'null be return by api']
['NULL be returned by pcap_datalink_val_to_name_APIName if the type value does not correspond to a known DLT_ value', 'null be return by api']
['pcap_datalink_val_to_description_APIName translates a link-layer header type value to a short description of that link-layer header type', 'api translate param header type value short description param header type']
['pcap_stats_APIName fills in the struct pcap_stat pointed to by its second argument', 'api fill struct param point by second param']
['Note that , , you might not have permission to send packets on it , or it might not support sending packets', 'PRON- may not have send , may not support send']
['A struct pcap_stat has the following members', 'struct param have follow member']
['pcap_open_live_APIParam_1 is a string that specifies the network pcap_open_live_APIParam_1 to open', 'param be stre specifie network param open']
['Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes', 'otherwise , if signal interrupt call read live , signal handler return after call api , call be restart , loop not terminate until arrive call complete']
['pcap_datalink_val_to_description_or_dlt_APIName translates a link-layer header type value to a short description of that link-layer header type just like pcap_datalink_val_to_description', 'api translate param header type value short description param header type like api']
['The values represent packet statistics from the start of the run to the time of the call', 'value represent statistic start run time call']
['number of packets received', 'number receive']
['as pcap_open_live_APIName does not have a flag to indicate , you can not request an open that supports sending and be notified at open time', 'as api do not have flag indicate , -PRON- can not request open support send be notify open time']
['Note that pcap_next_APIName and pcap_next_ex_APIName will , on some platforms , loop reading packets from the OS', 'api , platform , loop read os']
["on Linux systems with 2.2 or later kernels , a pcap_open_live_APIParam_1 argument of `` any '' or NULL can be used to capture packets from all interfaces", 'system constant late kernel , param null can be use api']
['number of packets dropped by the network interface or its driver', 'number drop by network api']
['The statistics do not behave the same way on all platforms', 'statistic not behave way platform']
['If the type value does not correspond to a known DLT_ value, the string "DLT n" be returned by pcap_datalink_val_to_description_APIName, where n is the value of the pcap_datalink_val_to_description_APIParam_1 argument', 'if type value do not correspond know _ value , string be return by api , be value param']
['pcap_stats_APIName is supported only on live captures , not on savefiles', 'api be support only live , not']
['pcap_list_tstamp_types_APIName -LRB- -RRB- allocates an array to hold the list and sets * tstamp_typesp to point to the array', 'api _ lrb _ _ rrb _ allocate array hold list set param point array']
['number of packets dropped', 'number drop']
['ps_drop is not available on all platforms', 'param be not available platform']
['that loop will not necessarily be terminated by a signal , so pcap_breakloop_APIName should be used to terminate packet processing', 'loop not necessarily be terminate by signal , api should be use terminate processing']
['will not unblock that thread', 'not unblock thread']
['it is zero on platforms where it is not available', 'be constant platform be not available']
['Note also that , in a multi-threaded application', 'note , param application']
['It also might , or might not , count packets dropped', 'may , may not , count drop']
['Both pcap_lookupnet_APIParam_2 and pcap_lookupnet_APIParam_3 are bpf_u_int32 pointers', 'param be param pointer']
['pcap_stats_APIName returns 0 on success and returns PCAP_ERROR if there is an error or if pcap_stats_APIParam_1 does not support packet statistics', 'api return constant success return constant']
['ps_recv might count packets , or it might count only packets that pass the filter', 'param may count , may count only pass filter']
['pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['no statistics are available', 'no statistic be available']
['pcap_datalink_val_to_name_APIName translates a link-layer header type value to the corresponding link-layer header type name , which is the DLT _ name for the link-layer header type value with the DLT _ removed', 'api translate param header type value correspond param header type name , which be _ name param header type value _ remove']
['no statistics are stored in savefiles , so', 'no statistic be store']
['pcap_lookupnet_APIName is used to determine the IPv4 network number and mask associated with the network pcap_lookupnet_APIParam_1 pcap_lookupnet_APIParam_1', 'api be use determine network number mask associate network param']
['pcap_open_live_APIParam_5 may also be set to warning text', 'param may be set warning text']
['If PCAP_ERROR be returned by pcap_lookupnet_APIName, pcap_lookupnet_APIParam_4 is filled in with an appropriate error message', 'if constant be return by api , param be fill appropriate error message']
['If PCAP_ERROR be returned by pcap_stats_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_stats_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['//www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values', 'list value api can return describe format correspond value']
['Both ps_recv and ps_drop might , or might not , count packets not yet read from the operating system and thus not yet seen by the application', 'param may , may not , count not yet read operate system thus not yet see by application']
['pcap_datalink_APIName returns the link-layer header type for the live capture or savefile specified by p', 'api return param header type live specify by']
['to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user', 'detect case caller should store param string param before call api display warning user']
['ps_ifdrop might , or might not , be implemented', 'param may , may not , be implement']
['it would count packets that do not pass the filter', 'would count not pass filter']
['Note that should NOT be restarted by that signal', 'should not be restart by signal']
['You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls', 'PRON- need use whatever mechanism os provide break thread block call']
['Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet', 'not assume give have give param header type , as constant']
['you must specify , when catching those signals , that system calls', 'PRON- must specify , catch signal , system call']
['pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file', 'api be like api but do not create file']
['It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP', 'must not be call descriptor create by api have not yet be activate by api _ lrb _ 3pcap']
['-LRB- See pcap_APIName for an explanation of the packet buffer timeout', '_ lrb _ see api explanation buffer timeout']
['pcap_datalink_APIName returns the link-layer header type on success and PCAP_ERROR_NOT_ACTIVATED if pcap_datalink_APIName is called on a capture handle that has been created but not activated', 'api return param header type success constant  have be create but not activate']
['fname specifies the name of the file to open', 'specifie name file open']
['Note that , on some platforms , the link-layer header of the packet that sent might not be the same as the link-layer header of the packet supplied to pcap_inject_APIName , as , if the platform does not support sending completely raw and unchanged packets', 'platform , param header send may not be as param header supply api , as']
['pcap_open_offline_APIName and pcap_open_offline_with_tstamp_precision_APIName are called to open a savefile for reading', 'api be call open reading']
['pcap_fopen_offline_with_tstamp_precision_APIName takes an additional precision argument as described above', 'api take additional param as describe']
['pcap_set_timeout_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_timeout_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['the source link-layer address , , might be changed to be the address assigned to the interface on which the packet it sent', 'source param address , may be change be address assign api which send']
['pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure', 'api return param success null failure']
["The name '' - '' is a synonym for stdin", 'name _ be stdin']
['We recommend always setting the timeout to a non-zero value unless immediate mode is set , in which case the timeout has no effect', 'recommend always set timeout param value unless immediate mode be set , which case timeout have no effect']
['If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message', 'if null be return by api , param be fill appropriate error message']
['and , if it does already exist , and is a pcap file with the same byte order as the host opening the file , and has the same time stamp precision , link-layer header type , and snapshot length as pcap_dump_open_APIParam_1 , it will write new packets at the end of the file', 'be file byte order as host opening file , have time , param header type , snapshot length as param , write end file']
['the packet buffer timeout that will be used on a capture handle', 'buffer timeout be use handle']
['Alternatively , you may call pcap_fopen_offline_APIName or pcap_fopen_offline_with_tstamp_precision_APIName to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1', 'alternatively , -PRON- may call api read dump datum exist open stream param']
['pcap_open_offline_with_tstamp_precision_APIName and pcap_fopen_offline_with_tstamp_precision_APIName became available in libpcap release 1.5.1', 'api become available release constant']
['pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['Note that on Windows , that stream should be opened in binary mode', 'window , stream should be open binary mode']
['A negative return value indicates what error condition occurred', 'negative return value indicate error condition occur']
['pcap_set_timeout_APIName sets', 'api set']
["the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL", 'device have param header type constant']
['pcap_can_set_rfmon_APIName checks is activated', 'api check be activate']
['In previous releases , time stamps from a savefile are always given in seconds and microseconds', 'previous release , time be always give second']
['The behavior , , is undefined , as is the behavior if the timeout is set to zero or to a negative value', 'behavior , be undefined , as be behavior']
['The process does not have permission to check', 'process do not have check']
['The capture handle has already been activated', 'handle have already be activate']
['The possible error values are', 'possible error value be']
['The capture source specified does not exist', 'source specify do not exist']
['they will be scaled up or down as necessary before being supplied', 'be scale as necessary before supply']
['Another error occurred', 'another error occur']
['pcap_is_swapped_APIName returns true  if pcap_is_swapped_APIParam_1 refers to a savefile that uses a different byte order than the current system', 'api return constant']
['pcap_open_offline_with_tstamp_precision_APIName takes an additional precision argument specifying the time stamp precision desired', 'api take additional param specify time desire']
['pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_can_set_rfmon_APIParam_1 as an argument to fetch or display a message describing the error', 'api may be call param as param fetch display message describing error']
['pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error', 'api return constant']
['pcap_set_immediate_mode_APIName sets is activated', 'api set be activate']
['Additional error codes may be added in the future', 'additional error code may be add future']
['For a live capture, it always returns false (0', 'live , always return constant']
['a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors', 'program should check , , negative , return code , treat negative return code as error']
['pcap_is_swapped_APIName returns true  or false  on success and PCAP_ERROR_NOT_ACTIVATED if pcap_is_swapped_APIName is called on a capture handle that has been created but not activated', 'api return constant success constant  handle have be create but not activate']
['pcap_statustostr_APIName can be called , with a warning or error code as an argument , to fetch a message describing the warning or error code', 'api can be call , warning error code as param , fetch message describe warning error code']
['pcap_set_immediate_mode_APIName became available in libpcap release 1.5.0', 'api become available release constant']
['pcap_set_immediate_mode_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_immediate_mode_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['pcap_dump_flush_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['In immediate mode , packets are always delivered as soon as they arrive , with no buffering', 'immediate mode , be always deliver as soon as arrive , no buffering']
['pcap_next_ex_APIName reads the next packet and returns a success/failure indication', 'api read next return indication']
['On other platforms , capture devices are always in immediate mode', 'platform , device be always immediate mode']
['pcap_next_APIName reads the next packet  and returns a u_char pointer to the data in that packet', 'api read next return param pointer datum']
['immediate mode will be set , otherwise it will not be set', 'immediate mode be set , otherwise not be set']
['The bytes of data from the packet begin with a link-layer header', 'byte datum begin param header']
['The file can have the pcap file format as described in pcap-savefile_APIName , which is the file format used by , among other programs , tcpdump_APIName and tcpslice_APIName , or can have the pcapng file format', 'file can have file format as describe api , which be file format use by , among program , api , can have file format']
['and if PCAP_TSTAMP_PRECISION_NANO is specified , packet time stamps will be supplied in seconds and nanoseconds', 'if constant be specify , time be supply second']
['In previous releases', 'previous release']
['packet time stamps will be supplied in seconds and microseconds', 'time be supply second']
['pcap_dump_close_APIName closes the savefile', 'api close']
['The pcap_pkthdr structure pointed to by h is filled in with the appropriate values for the packet', 'param point by be fill appropriate value']
['pcap_strerror_APIName returns an pcap_strerror_APIParam_1 message string corresponding to error', 'api return param message string correspond error']
['//www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values', 'list value api can return describe format correspond value']
['pcap_dump_flush_APIName flushes the output buffer to the savefile , so that any packets written with pcap_dump_APIName but not yet written to the savefile will be written', 'api flush output buffer , write api but not yet write be write']
['pcap_geterr_APIName returns the error text pertaining to the last pcap library error', 'api return error text pertain last library error']
['It has no effect on savefiles', 'have no effect']
['pcap_create_APIName returns a pcap_t * on success and NULL on failure', 'api return param success null failure']
['pcap_close_APIName closes the files associated with pcap_close_APIParam_1 and deallocates resources', 'api close file associate param deallocate resource']
['pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName', 'format param header be indicate by return value api handed param value pass api']
['pcap_strerror_APIName is provided in case strerror_APIName is not available', 'api be provide case api be not available']
['Unfortunately , there is no way to determine', 'unfortunately , be no way determine']
['If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message', 'if null be return by api , param be fill appropriate error message']
['pcap_create_APIName is used to create a packet capture handle to look at packets on the network', 'api be use create handle look network']
['pcap_snapshot_APIName returns the snapshot length on success and PCAP_ERROR_NOT_ACTIVATED if pcap_snapshot_APIName is called on a capture handle that has been created but not activated', 'api return snapshot length success constant  have be create but not activate']
['pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode', 'api not work param mode']
['If PCAP_ERROR be returned by pcap_next_ex_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_next_ex_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['pcap_lib_version_APIName returns a pointer to a string giving information about the version of the libpcap library being used', 'api return pointer stre give information version library use']
['note that it contains more information than just a version number', 'contain information version number']
['pcap_perror_APIName prints the text of the last pcap library error on stderr , prefixed by prefix', 'api print text last library error stderr , prefix by prefix']
['pcap_snapshot_APIName returns the snapshot length specified when pcap_set_snaplen_APIName or pcap_open_live_APIName was called, for a live capture, or the snapshot length from the capture file, for a savefile', 'api return snapshot length specify api be call , live , snapshot length file']
['pcap_getnonblock_APIName returns the current non-blocking state of the capture descriptor', 'api return current param state descriptor']
['it always returns 0 on savefiles', 'always return constant']
['otherwise, 0 be returned by pcap_setnonblock_APIName', 'otherwise , constant be return by api']
['Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type , such as DLT_EN10MB for Ethernet', 'not assume give have give param header type , as constant']
['The returned handle must be activated with pcap_activate_APIName before packets can be captured with it', 'return handle must be activate api before can be']
['errbuf is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'be assume be able hold least constant char']
['If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message', 'if be error , constant be return by api param be fill appropriate error message']
['pcap_create_APIParam_1 is a string that specifies the network device to open', 'param be stre specifie network device open']
['pcap_setnonblock_APIName puts a capture handle into non-blocking mode , or takes it out of non-blocking mode , depending on or zero', 'api put handle param mode , take param mode , depend constant']
['options for the capture , such as promiscuous mode , can be set on the handle before activating it', 'option , as promiscuous mode , can be set handle before activate']
['On Linux , with previous releases of libpcap , capture devices are always in immediate mode', 'previous release , device be always immediate mode']
['you must use or copy the string before closing the pcap_t', 'PRON- must use copy string before closing param']
['pcap_set_promisc_APIName sets is activated', 'api set be activate']
['the pointer pcap_geterr_APIName returns will no longer point to a valid error message string after the pcap_t passed to it is closed', 'pointer api return no longer point valid error message string after param pass be close']
['If there is an error, PCAP_ERROR be returned by pcap_getnonblock_APIName and pcap_getnonblock_APIParam_2 is filled in with an appropriate error message', 'if be error , constant be return by api param be fill appropriate error message']
['pcap_tstamp_type_name_to_val_APIName returns time stamp type value on success and PCAP_ERROR on failure', 'api return time type value success constant failure']
["on Linux systems with 2.2 or later kernels , a pcap_create_APIParam_1 argument of `` any '' or NULL can be used to capture packets from all interfaces", 'system constant late kernel , param null can be use api']
['The translation is case-insensitive', 'translation be param']
['pcap_tstamp_type_name_to_val_APIName became available in libpcap release 1.2.1', 'api become available release constant']
['pcap_set_promisc_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_promisc_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['pcap_tstamp_type_name_to_val_APIName translates a time stamp type pcap_tstamp_type_name_to_val_APIParam_1 to the corresponding time stamp type value', 'api translate time type param correspond time type value']
['The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called', 'value api return be valid receive unless until api be call']
['a call to pcap_setnonblock_APIName is required in order to put it into non-blocking mode', 'call api be require order put param mode']
['pcap_next_APIName returns a pointer to the packet data on success, and returns NULL if an error occurred, or if no packets were read from a live capture , or if no more packets are available in a savefile', 'api return pointer datum success , return null']
['promiscuous mode will be set , otherwise it will not be set', 'promiscuous mode be set , otherwise not be set']
['however , in 1.5.0 and , it should be used', 'however , constant , should be use']
['later , they are , by default , not in immediate mode', 'later , be , by default , not immediate mode']
['In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive', 'param mode , attempt read descriptor api , if no be currently available be read , return constant immediately rather block wait arrive']
['It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName', 'must be call descriptor create by api have not yet be activate by api']
['after a successful call to pcap_set_datalink_APIName , all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink', 'after successful call api , subsequent have param header type specify by param header type value pass api']
["the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL", 'device have param header type constant']
['It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP', 'must not be call descriptor create by api have not yet be activate by api _ lrb _ 3pcap']
['on Solaris 10 and earlier versions of Solaris , immediate mode must be turned on by', 'constant early version , immediate mode must be turn by']
['using a read timeout of 0', 'use read timeout constant']
['The packet data is not to be freed by the caller , and is not guaranteed to be valid after the next call to pcap_next_ex_APIName , pcap_next_APIName , pcap_loop_APIName , or pcap_dispatch_APIName', 'datum be not be free by caller , be not guarantee be valid after next call api']
['it must make a copy of it', 'must make copy']
['pcap_next_ex_APIName returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR if an error occurred while reading the packet, and PCAP_ERROR_BREAK if packets are being read from a savefile and there are no more packets to read from the savefile', 'api return constant']
['the pointer pointed to by the pcap_next_ex_APIParam_2 argument is set to point to the pcap_pkthdr struct for the packet', 'pointer point by param be set point param struct']
['on Windows , immediate mode must be turned on by calling pcap_setmintocopy_APIName with a size of 0', 'window , immediate mode must be turn by call api size constant']
['The struct pcap_pkthdr and the packet data are not to be freed by the caller , and are not guaranteed to be valid after the next call to pcap_next_ex_APIName , pcap_next_APIName , pcap_loop_APIName , or pcap_dispatch_APIName', 'struct param datum be not be free by caller , be not guarantee be valid after next call api']
['on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11, immediate mode must be turned on with a BIOCIMMEDIATE ioctl_APIName, as documented in bpf_APIName, on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called', '11 , immediate mode must be turn biocimmediate api , as document api , descriptor return by api , after api be call']
['and the pointer pointed to by the pcap_next_ex_APIParam_3 argument is set to point to the data in the packet', 'pointer point by param be set point datum']
['it must make a copy of them', 'must make copy']
['on Digital UNIX/Tru64 UNIX, immediate mode must be turned on by doing a BIOCMBIC ioctl, as documented in packetfilter_APIName, to clear the ENBATCH flag on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called', 'digital unix , immediate mode must be turn by do biocmbic , as document api , clear enbatch flag descriptor return by api , after api be call']
['It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate -LRB- 3PCAP', 'must not be call descriptor create by api have not yet be activate by api _ lrb _ 3pcap']
['pcap_set_tstamp_type_APIName became available in libpcap release 1.2.1', 'api become available release constant']
['See pcap-tstamp_APIName for a list of all the time stamp types', 'see api list time type']
['pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2', 'api set type time desire descriptor type specify by param']
['pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device', 'api give list time type support by give device']
['pcap_get_required_select_timeout_APIName is not available on Windows', 'api be not available window']
['A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0  but will not block', 'call api return constant but not block']
['In previous releases , the time stamp type can not be set', 'previous release , time type can not be set']
['The timeout that should be used in those calls must be no larger than the smallest of all timeouts returned by pcap_get_required_select_timeout_APIName for devices from which packets will be captured', 'timeout should be use call must be no large small timeout return by api device which be']
['only the default time stamp type offered by a capture source is available', 'only default time type offer by source be available']
['pcap_freecode_APIName is used to free up allocated memory pointed to by a pcap_freecode_APIParam_1 struct generated by pcap_compile_APIName after it has been made the filter program for a pcap structure by a call to pcap_setfilter -LRB- 3PCAP', 'api be use free allocated memory point by param struct generate by api after have be make filter program structure by call api _ lrb _ 3pcap']
['pcap_dump_file_APIName returns the standard I/O stream of the savefile opened by pcap_dump_open(3PCAP', 'api return standard stream open by param']
['pcap_get_required_select_timeout_APIName became available in libpcap release 1.9.0', 'api become available release constant']
['A pointer to a struct timeval be returned by pcap_get_required_select_timeout_APIName if the timeout is required', 'pointer struct be return by api']
['otherwise NULL be returned by pcap_get_required_select_timeout_APIName', 'otherwise null be return by api']
['In previous releases, select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName cannot be used on any capture source for which pcap_get_selectable_fd_APIName returns -1', 'previous release , api can not be use source which api return constant']
['device flags', 'device flag']
['Each element of the list is of type pcap_if_t , and has the following members', 'element list be constant , have follow member']
['The device  must be put in non-blocking mode with pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the select_APIName , poll_APIName , epoll_wait_APIName , or kevent_APIName call returns', 'device must be put param mode api , attempt must always be make read device api call return']
['NULL for the last element of the list name', 'null last element list name']
['a pointer to a string giving a name for the device to pass to pcap_open_live_APIName description', 'pointer stre give name device pass api description']
['pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName', 'api construct list network device can be open api']
['Note that a device on which a read can be done without blocking may , on some platforms , not have', 'device which read can be do without block may , platform , not have']
['the adapter is connected PCAP_IF_CONNECTION_STATUS_DISCONNECTED', 'be connect constant']
['the adapter is disconnected PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE', 'be disconnect constant']
['it is unknown', 'be unknown']
['pcap_get_required_select_timeout_APIName returns, on UNIX, a pointer to a struct timeval containing a value that must be used as the minimum timeout in select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName calls if pcap_get_selectable_fd_APIName returns PCAP_ERROR', 'api return , unix , pointer struct contain value must be use as minimum timeout api call']
['Each element of the list of addresses is of type pcap_addr_t , and has the following members', 'element list address be constant , have follow member']
['NULL , a pointer to a string giving a human-readable description of the device addresses', 'null , pointer stre give param description device address']
["the notion of `` connected '' and `` disconnected '' do not apply to this interface", 'connect disconnect not apply api']
['the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list , or to NULL if no devices were found', 'pointer point by param be set point first element list , null']
['a pointer to a struct sockaddr containing an address netmask', 'pointer struct contain address']
['NULL for the last element of the list addr', 'null last element list']
['it does not apply to a loopback device', 'do not apply device']
['and what types they might have is platform-dependent', 'type may have be param']
['a pointer to the first element of a list of network addresses for the device , or NULL', 'pointer first element list network address device , null']
['If PCAP_ERROR be returned by pcap_findalldevs_APIName, pcap_findalldevs_APIParam_2 is filled in with an appropriate error message', 'if constant be return by api , param be fill appropriate error message']
["for wireless interfaces , `` connected '' means `` associated with a network '' The possible values for the connection status bits are", 'wireless api , connected mean associate network possible value connection status bit be']
['IPv4 addresses have the value AF_INET , IPv6 addresses have the value AF_INET6 , and other addresses have other values', 'address have value constant , address have value constant , address have value']
['pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['The list of devices must be freed with pcap_freealldevs_APIName , which frees the list pointed to by alldevs', 'list device must be free api , which free list point by alldev']
['The PCAP_IF_UP and PCAP_IF_RUNNING constants became available in libpcap release 1.6.1', 'constant become available release constant']
['this includes IrDA as well as radio-based networks such as IEEE 802.15.4 and IEEE 802.11 , so it does not just mean Wi-Fi PCAP_IF_CONNECTION_STATUS', 'include as well as param network as param , do not mean param constant']
['The possible warning values are', 'possible warning value be']
['pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['A non-zero return value indicates what warning or error condition occurred', 'param return value indicate warn error condition occur']
['The PCAP_IF_WIRELESS , PCAP_IF_CONNECTION_STATUS , PCAP_IF_CONNECTION_STATUS_UNKNOWN , PCAP_IF_CONNECTION_STATUS_CONNECTED , PCAP_IF_CONNECTION_STATUS_DISCONNECTED , and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE constants became available in libpcap release 1.9.0', 'constant become available release constant']
['Promiscuous mode was requested , but the capture source does not support promiscuous mode', 'promiscuous mode be request , but source do not support promiscuous mode']
['as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case', 'as indicate , find no device be consider success , rather failure , constant be return case']
['may be null dstaddr', 'may be null']
['The handle has already been activated', 'handle have already be activate']
['The possible error values are', 'possible error value be']
['For IPv4 addresses , the struct sockaddr pointer can be interpreted', 'address , struct pointer can be interpret']
['may be null a point-to-point interface', 'may be null param api']
['Another warning condition occurred', 'another warning condition occur']
['The time stamp type specified in a previous pcap_set_tstamp_type_APIName call is not supported by the capture source , PCAP_WARNING', 'time type specify previous api call be not support by source , constant']
['pcap_activate_APIName returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error', 'api return constant success without warning , param positive value success warning , negative value error']
['for IPv6 addresses , it can be interpreted', 'address , can be interpret']
['The process does not have permission to open the capture source', 'process do not have open source']
['pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the warning condition', 'api may be call param as param fetch display message describe warning condition']
['pcap_activate_APIName is used to activate a packet capture handle to look at packets on the network , with the options that were set on the handle being in effect', 'api be use activate handle look network , option be set handle effect']
['The capture source device is not up', 'source device be not']
['Monitor mode was specified but the capture source does not support monitor mode', 'mode be specify but source do not support mode']
['The capture source specified does not exist', 'source specify do not exist']
['The process has permission to open the capture source but does not have permission to put it into promiscuous mode', 'process have open source but do not have put promiscuous mode']
['pcap_set_datalink_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['Another error occurred', 'another error occur']
['pcap_set_datalink_APIName is used to set the current link-layer header type of the pcap descriptor to the type specified by dlt', 'api be use set current param header type descriptor type specify by']
['pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the error', 'api may be call param as param fetch display message describing error']
['pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName', 'api be deprecate by api']
['pcap_statustostr_APIName can be called , with a warning or error code as an argument , to fetch a message describing the warning or error code', 'api can be call , warning error code as param , fetch message describe warning error code']
['If PCAP_ERROR be returned by pcap_set_datalink_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_set_datalink_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['In WinPcap, pcap_lookupdev_APIName may return a UTF-16 string rather than an ASCII or UTF-8 string', 'api may return param string rather ascii param string']
['the pcap_t should be closed using pcap_close', 'param should be close use api']
['the pcap_t * is not closed and freed', 'param be not close freed']
['If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message', 'if be error , null be return by api param be fill appropriate error message']
['Additional warning and error codes may be added in the future', 'additional warning error code may be add future']
['pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars', 'param be assume be able hold least constant char']
['To find a default device on which to capture, call pcap_findalldevs_APIName and, if the list pcap_lookupdev_APIName returns is not empty, use the first device in the list', 'find default device which , call api ,  first device list']
['-LRB- , there are no devices on which capture is possible', '_ lrb _ , be no device which be possible']
['pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program', 'api be use compile string param filter program']
['a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors', 'program should check positive , negative , constant return code , treat positive return code as warning negative return code as error']
['pcap_set_snaplen_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_snaplen_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['See pcap-filter_APIName for the syntax of that string', 'see api syntax string']
['pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed', 'param control whether optimization result code be perform']
['pcap_lookupdev_APIName returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, and with pcap_lookupnet_APIName', 'api return pointer string give name network device suitable use api']
['If PCAP_WARNING_PROMISC_NOTSUP, PCAP_ERROR_NO_SUCH_DEVICE, or PCAP_ERROR_PERM_DENIED be returned by pcap_activate_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display an message giving additional details about the problem that might be useful for debugging the problem if it is unexpected', 'api may be call param as param fetch display message give additional detail problem may be useful debug problem']
['program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName', 'program be pointer param struct be fill by api']
['The pointer returned by pcap_lookupdev_APIName points to a static buffer', 'pointer return by api point static buffer']
['pcap_set_snaplen_APIName sets the snapshot length to be used on a capture', 'api set snapshot length be use']
['in libpcap 1.8.0 and later , pcap_compile_APIName can be used in multiple threads within a single process', 'constant later , api can be use multiple thread within single process']
['subsequent calls to pcap_lookupdev_APIName in the same thread , or calls to pcap_lookupdev_APIName in another thread , may overwrite that buffer', 'subsequent call api thread , call api another thread , may overwrite buffer']
['pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured', 'param specifie param network which be']
['pcap_compile_APIName returns 0 on success and PCAP_ERROR on failure', 'api return constant success constant failure']
['it is used', 'be use']
['Note that the addresses in the list of addresses might be IPv4 addresses , IPv6 addresses , or some other type of addresses , so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address', 'address list address may be address , address , type address , -PRON- must check param member struct before interpret content address']
['newer versions will always allow the time stamp type to be set to the default type', 'new version always allow time type be set default type']
['a value of PCAP_NETMASK_UNKNOWN can be supplied', 'value constant can be supply']
['do not assume that the addresses are all IPv4 addresses , or even all IPv4 or IPv6 addresses', 'not assume address be address , even address']
['The PCAP_NETMASK_UNKNOWN constant became available in libpcap release 1.1.0', 'constant become available release constant']
['tests for IPv4 broadcast addresses will fail to compile , but all other tests in the filter program will be OK', 'test address fail compile , but test filter program be ok']
['If PCAP_ERROR be returned by pcap_compile_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_compile_APIParam_1 as an argument to fetch or display the error text', 'api may be call param as param fetch display error text']
['pcap_set_rfmon_APIName sets is activated', 'api set be activate']
['pcap_set_rfmon_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_rfmon_APIName is called on a capture handle that has been activated', 'api return constant success constant  handle have be activate']
['monitor mode will be set , otherwise it will not be set', 'mode be set , otherwise not be set']
['pcap_set_tstamp_type_APIName returns 0 on success if the specified time stamp type is expected to be supported by the capture device, PCAP_WARNING_TSTAMP_TYPE_NOTSUP if the specified time stamp type is not supported by the capture device, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_type_APIName is called on a capture handle that has been activated, and PCAP_ERROR_CANTSET_TSTAMP_TYPE if the capture device does not support setting the time stamp type (only older versions of libpcap will return that', 'api return constant success if specify time type be expect be support by device , constant  have be activate , constant']
['If pcap_fileno_APIParam_1 refers to a network device that was opened for a live capture using a combination of pcap_create_APIName and pcap_activate_APIName, or using pcap_open_live_APIName, pcap_fileno_APIName returns the file descriptor from which captured packets are read', 'if param refer network device be open live use combination api , use api return file descriptor which be read']
['However , in earlier versions of libpcap , it is not safe to use pcap_compile_APIName in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time', 'however , early version , be not safe use api multiple thread single process without form mutual allow only one thread call give time']
['If pcap_fileno_APIParam_1 refers to a savefile that was opened using functions such as pcap_open_offline_APIName or pcap_fopen_offline_APIName, a dead pcap_t opened using pcap_open_dead_APIName, or a pcap_t that was created with pcap_create_APIName but that has not yet been activated with pcap_activate_APIName, pcap_fileno_APIName returns PCAP_ERROR', 'if param refer be open use function as api , dead param open use api , param be create api but have not yet be activate api return constant']
