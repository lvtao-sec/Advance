['NULL  is returned on failure.', 'null be return failure']
['pcap_freecode(3PCAP)', 'pcap_freecode 3pcap']
['pcap_fopen_offline_with_tstamp_precision(3PCAP)', 'pcap_fopen_offline_with_tstamp_precision 3pcap']
['read the next packet from a pcap_t', 'read next packet pcap_t']
['The possible error values are:  PCAP_ERROR_ACTIVATED', 'possible error value be : pcap_error_activat']
["pcap_dispatch_APIName  processes packets from a live capture or ``savefile'' until pcap_dispatch_APIParam_2  packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the ``savefile'' is reached when reading from a ``savefile'', pcap_breakloop_APIName  is called, or an error occurs.", 'pcap_dispatch_apiname process packet live capture or savefile until pcap_dispatch_apiparam_2 packet be process , end current bufferful packet be reach when do live capture , end savefile be reach when read savefile , pcap_breakloop_apiname be call , or error occur']
['On some platforms, the time stamp given to packets on live captures can come from different sources that can have different resolutions or that can have different relationships to the time values for the current time supplied by routines on the native operating system. See pcap-tstamp(7) for a list of time stamp types.', 'platform , time stamp give packet live capture can come different source can have different resolution or can have different relationship time value current time supply by routine native operating system . see pcap_tstamp list time stamp type']
['pcap_tstamp_type_val_to_description(3PCAP)', 'pcap_tstamp_type_val_to_description 3pcap']
['In previous releases, select_APIName,  poll_APIName,  epoll_wait_APIName,  and kevent_APIName  cannot be used on any capture source for which pcap_get_selectable_fd_APIName  returns -1.', 'previous release , select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname can be use capture source which pcap_get_selectable_fd_apiname return #']
['Note that pcap_next_APIName  and pcap_next_ex_APIName  will, on some platforms, loop reading packets from the OS; that loop will not necessarily be terminated by a signal, so pcap_breakloop_APIName  should be used to terminate packet processing even if pcap_next_APIName  or pcap_next_ex_APIName  is being used.', 'note pcap_next_apiname pcap_next_ex_apiname , platform , loop read packet os ; loop necessarily be terminate by signal , so pcap_breakloop_apiname should be use terminate packet processing even if pcap_next_apiname or pcap_next_ex_apiname be use']
["To open a handle for a ``savefile'' from which to read packets, given the pathname of the ``savefile'', call pcap_open_offline(); to set up a handle for a ``savefile'', given a FILE * referring to a file already opened for reading, call pcap_fopen_offline().", 'open handle savefile which read packet , give pathname savefile , call pcap_open_offline ; set up handle savefile , give file referring file already open reading , call pcap_fopen_offline']
['Writing packets', 'writing packet']
['if not NULL,  a pointer to a struct sockaddr  that contains the netmask corresponding to the address pointed to by addr  broadaddr', 'if null , pointer struct sockaddr contain netmask correspond address point by addr broadaddr']
['If, instead, packets are not delivered as soon as they arrive, but are delivered after a short delay (called a "packet buffer timeout"), more than one packet can be accumulated before the packets are delivered, so that a single wakeup would be done for multiple packets, and each set of calls made to the operating system would supply multiple packets, rather than a single packet. This reduces the per-packet CPU overhead if packets are arriving at a high rate, increasing the number of packets per second that can be captured.', 'if , instead , packet be deliver as soon as arrive , but be deliver after short delay , more than one packet can be accumulate before packet be deliver , so single wakeup would be do multiple packet , each set call make operating system would supply multiple packet , rather than single packet . reduce per_packet cpu overhead if packet be arrive high rate , increase number packet per second can be capture']
['pcap_dump_ftell(3PCAP)', 'pcap_dump_ftell 3pcap']
['Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop_APIName in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal.', 'note if -PRON- be catch signal unix system support restart system call after signal , call pcap_breakloop_apiname signal handler , -PRON- must specify , when catch signal , system call should be restart by signal']
['write packet to a pcap_dumper_t', 'write packet pcap_dumper_t']
['To force the loop in pcap_dispatch() or pcap_loop() to terminate, call pcap_breakloop().', 'force loop pcap_dispatch or pcap_loop terminate , call pcap_breakloop']
['If the type value does not correspond to a known DLT_value, the string "DLT n" is returned, where n is the value of the pcap_datalink_val_to_description_APIParam_1 argument.', 'if type value do correspond know dlt_value , string dlt n be return , where n be value pcap_datalink_val_to_description_apiparam_1 argument']
['pcap_is_swapped_APIName  returns true (1) or false (0) on success and PCAP_ERROR_NOT_ACTIVATED  if called on a capture handle that has been created but not activated.', 'pcap_is_swapped_apiname return true or false success pcap_error_not_activate if call capture handle have create but activate']
['set the snapshot length for a not-yet-activated pcap_t for live capture', 'set snapshot length not_yet_activated pcap_t live capture']
['If pcap_fileno_APIParam_1  refers to a network device that was opened for a live capture using a combination of pcap_create_APIName  and pcap_activate_APIName,  or using pcap_open_live_APIName,  pcap_fileno_APIName  returns the file descriptor from which captured packets are read.', 'if pcap_fileno_apiparam_1 refer network device be open live capture use combination pcap_create_apiname pcap_activate_apiname , or use pcap_open_live_apiname , pcap_fileno_apiname return file descriptor which capture packet be read']
['get a pcap_t for live capture', 'get pcap_t live capture']
['Another error occurred.', 'another error occur']
['get the standard I/O stream for a savefile being written', 'get standard stream savefile write']
["it's unknown whether the adapter is connected or not PCAP_IF_CONNECTION_STATUS_CONNECTED", 'be unknown whether adapter be connect or pcap_if_connection_status_connect']
['snapshot length', 'snapshot length']
['Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes.', 'otherwise , if signal interrupt call read packet live capture , when -PRON- signal handler return after call pcap_breakloop_apiname , call be restart , loop terminate until more packet arrive call complete']
["(That workaround will not work in FreeBSD 4.3 and later; however, in FreeBSD 4.6 and later, those calls work correctly on BPF devices, so the workaround isn't necessary, although it does no harm.)", 'workaround work freebsd # later ; however , freebsd # later , call work correctly bpf device , so workaround be necessary , although do no harm']
['To report a security issue please send an e-mail to security@tcpdump.org.', 'report security issue please send e_mail security']
['A pointer to a struct timeval  is returned if the timeout is required; otherwise NULL  is returned.', 'pointer struct timeval be return if timeout be require ; otherwise null be return']
['set the time stamp precision returned in captures', 'set time stamp precision return capture']
['pcap_set_tstamp_precision(3PCAP)', 'pcap_set_tstamp_precision 3pcap']
["The process has permission to open the capture source but doesn't have permission to put it into promiscuous mode.", 'process have permission open capture source but do have permission put into promiscuous mode']
['pcap_free_tstamp_types(3PCAP)', 'pcap_free_tstamp_type 3pcap']
['The bytes of data from the packet begin with a link-layer header.', 'byte datum packet begin link_layer header']
['pcap_offline_filter_APIParam_1  is a pointer to a bpf_program  struct, usually the result of a call to pcap_compile_APIName.', 'pcap_offline_filter_apiparam_1 be pointer bpf_program struct , usually result call pcap_compile_apiname']
['pcap_set_buffer_size_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_buffer_size_apiname return # success or pcap_error_activat if call capture handle have activate']
['The name "-" is a synonym for stdout.', 'name be synonym stdout']
['a pointer to a string giving a name for the device to pass to pcap_open_live_APIName  description', 'pointer stre give name device pass pcap_open_live_apiname description']
['pcap_set_promisc(3PCAP)', 'pcap_set_promisc 3pcap']
['pcap_get_selectable_fd_APIName  is not available on Windows.', 'pcap_get_selectable_fd_apiname be available window']
["It also might, or might not, count packets dropped because there was no room in the operating system's buffer when they arrived.", 'may , or may , count packet drop because be no room operate system buffer when arrive']
["The time stamp type specified in a previous pcap_set_tstamp_type_APIName  call isn't supported by the capture source (the time stamp type is left as the default), PCAP_WARNING", 'time stamp type specify previous pcap_set_tstamp_type_apiname call be support by capture source , pcap_warning']
["p  is a capture or ``savefile'' handle returned by an earlier call to pcap_create_APIName  and activated by an earlier call to pcap_activate_APIName,  or returned by an earlier call to pcap_open_offline_APIName,  pcap_open_live_APIName,  or pcap_open_dead_APIName.", 'p be capture or savefile handle return by early call pcap_create_apiname activate by early call pcap_activate_apiname , or return by early call pcap_open_offline_apiname , pcap_open_live_apiname , or pcap_open_dead_apiname']
['pcap_set_promisc_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_promisc_apiname return # success or pcap_error_activat if call capture handle have activate']
["The process doesn't have permission to open the capture source.", 'process do have permission open capture source']
["Note that in monitor mode the adapter might disassociate from the network with which it's associated, so that you will not be able to use any wireless networks with that adapter. This could prevent accessing files on a network server, or resolving host names or network addresses, if you are capturing in monitor mode and are not connected to another network with another adapter.", 'note monitor mode adapter may disassociate network which be associate , so -PRON- be able wireless network adapter . could prevent access file network server , or resolve host name or network address , if -PRON- be capture monitor mode be connect another network another adapter']
['The handle has already been activated.', 'handle have already activate']
['Thus, when doing a live capture, pcap_dispatch_APIParam_2  is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than pcap_dispatch_APIParam_2  packets may be processed.', 'thus , when do live capture , pcap_dispatch_apiparam_2 be maximum number packet process before return , but be minimum number ; when read live capture , only one bufferful packet be read time , so few than pcap_dispatch_apiparam_2 packet be process']
['(Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName,  because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.)', 'note be network device can be open by process call pcap_findalldevs_apiname , because , example , process do have sufficient privilege open -PRON- capture ; if so , device appear list']
['Asynchronous procedure calls will not work on Windows, as a thread blocked on a pcap_t  will not be in an alertable state.', 'asynchronous procedure call work window , as thread block pcap_t be alertable state']
['get the state of non-blocking mode for a pcap_t', 'get state non_blocking mode pcap_t']
['Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family  member of the struct sockaddr  before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses.', 'note address list address may be ipv4 address , ipv6 address , or other type address , so -PRON- must check sa_family member struct sockaddr before interpret content address ; assume address be ipv4 address , or even ipv4 or ipv6 address']
['pcap_loop(3PCAP)', 'pcap_loop 3pcap']
['pcap_findalldevs_APIName  returns 0 on success and PCAP_ERROR  on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case.', 'pcap_findalldevs_apiname return # success pcap_error failure ; as indicate , find no device be consider success , rather than failure , so # be return case']
['If the current file position does not fit in a long,  it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows.', 'if current file position do fit long , be truncate ; can happen 32_bit unix_like system large file support window']
["Note also that poll_APIName  and kevent_APIName  doesn't work on character special files, including BPF devices, in Mac OS X 10.4 and 10.5, so, while select_APIName  can be used on the descriptor returned by pcap_get_selectable_fd_APIName,  poll_APIName  and kevent_APIName  cannot be used on it those versions of Mac OS X. poll_APIName,  but not kevent_APIName,  works on that descriptor in Mac OS X releases prior to 10.4; poll_APIName  and kevent_APIName  work on that descriptor in Mac OS X 10.6 and later.", 'note poll_apiname kevent_apiname do work character special file , include bpf device , mac os x # 10 , so , while select_apiname can be use descriptor return by pcap_get_selectable_fd_apiname , poll_apiname kevent_apiname can be use version mac os x. poll_apiname , but kevent_apiname , work descriptor mac os x release prior 10 ; poll_apiname kevent_apiname work descriptor mac os x # later']
['pcap_list_tstamp_types(3PCAP)', 'pcap_list_tstamp_type 3pcap']
['pcap_create_APIParam_2  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_create_apiparam_2 be assume be able hold least pcap_errbuf_size char']
['One can use options PCAP_TSTAMP_PRECISION_MICRO and  PCAP_TSTAMP_PRECISION_NANO  to request desired precision.', 'one can option pcap_tstamp_precision_micro pcap_tstamp_precision_nano request desire precision']
['The timeout that should be used in those calls must be no larger than the smallest of all timeouts returned by pcap_get_required_select_timeout_APIName  for devices from which packets will be captured.', 'timeout should be use call must be no large than small timeout return by pcap_get_required_select_timeout_apiname device which packet be capture']
['In WinPcap, pcap_lookupdev_APIName may return a UTF-16 string rather than an ASCII or UTF-8 string.', 'winpcap , pcap_lookupdev_apiname return utf_16 stre rather than ascii or utf_8 string']
['set the filter', 'set filter']
['if not NULL,  a pointer to a string giving a human-readable description of the device addresses', 'if null , pointer string give human_readable description device address']
['get the time stamp precision of a pcap_t for live capture', 'get time stamp precision pcap_t live capture']
['If PCAP_ERROR  is returned, pcap_findalldevs_APIParam_2  is filled in with an appropriate error message.', 'if pcap_error be return , pcap_findalldevs_apiparam_2 be fill appropriate error message']
['The PCAP_IF_WIRELESS,  PCAP_IF_CONNECTION_STATUS,  PCAP_IF_CONNECTION_STATUS_UNKNOWN,  PCAP_IF_CONNECTION_STATUS_CONNECTED,  PCAP_IF_CONNECTION_STATUS_DISCONNECTED,  and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE  constants became available in libpcap release 1.9.0.', 'pcap_if_wireless , pcap_if_connection_status , pcap_if_connection_status_unknown , pcap_if_connection_status_connected , pcap_if_connection_status_disconnect , pcap_if_connection_status_not_applicable constant become available libpcap release #']
['get link-layer header type corresponding to a name', 'get link_layer header type correspond name']
['Packets are read with pcap_dispatch() or pcap_loop(), which process one or more packets, calling a callback routine for each packet, or with pcap_next() or pcap_next_ex(), which return the next packet. The callback for pcap_dispatch() and pcap_loop() is supplied a pointer to a struct pcap_pkthdr, which includes the following members:', 'packet be read pcap_dispatch or pcap_loop , which process one or more packet , call callback routine each packet , or pcap_next or pcap_next_ex , which return next packet . callback pcap_dispatch pcap_loop be supply pointer struct pcap_pkthdr , which include follow member']
['The file will have the same format as those used by tcpdump_APIName  and tcpslice_APIName.', 'file have format as use by tcpdump_apiname tcpslice_apiname']
['to_ms  specifies the packet buffer timeout, as a non-negative value, in milliseconds.', 'to_ms specifie packet buffer timeout , as non_negative value , millisecond']
["pcap_next_APIName  returns a pointer to the packet data on success, and returns NULL  if an error occurred, or if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a ``savefile.''", 'pcap_next_apiname return pointer packet datum success , return null if error occur , or if no packet be read live capture , or if no more packet be available savefile']
['find out whether a savefile has the native byte order', 'find out whether savefile have native byte order']
["on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11, immediate mode must be turned on with a BIOCIMMEDIATE  ioctl_APIName,  as documented in bpf_APIName,  on the descriptor returned by pcap_fileno_APIName,  after pcap_activate_APIName  is called;  on Solaris 10 and earlier versions of Solaris, immediate mode must be turned on by using a read timeout of 0 when opening the device (this will not provide immediate delivery of packets on other platforms, so don't assume it's sufficient);  on Digital UNIX/Tru64 UNIX, immediate mode must be turned on by doing a BIOCMBIC  ioctl,  as documented in packetfilter_APIName,  to clear the ENBATCH  flag on the descriptor returned by pcap_fileno_APIName,  after pcap_activate_APIName  is called;  on Windows, immediate mode must be turned on by calling pcap_setmintocopy_APIName  with a size of 0.", 'freebsd , netbsd , openbsd , dragonfly bsd , macos , solaris 11 , immediate mode must be turn biocimmediate ioctl_apiname , as document bpf_apiname , descriptor return by pcap_fileno_apiname , after pcap_activate_apiname be call ; solaris # early version solaris , immediate mode must be turn by use read timeout # when open device ; digital unix , immediate mode must be turn by do biocmbic ioctl , as document packetfilter_apiname , clear enbatch flag descriptor return by pcap_fileno_apiname , after pcap_activate_apiname be call ; window , immediate mode must be turn by call pcap_setmintocopy_apiname size #']
['Both ps_recv  and ps_drop  might, or might not, count packets not yet read from the operating system and thus not yet seen by the application.', 'both ps_recv ps_drop may , or may , count packet yet read operate system thus yet see by application']
['Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch_APIName, pcap_loop_APIName, pcap_next_APIName, or pcap_next_ex_APIName, a call to pcap_breakloop_APIName in a different thread will not unblock that thread.', 'note , multi_threaded application , if one thread be block pcap_dispatch_apiname , pcap_loop_apiname , pcap_next_apiname , or pcap_next_ex_apiname , call pcap_breakloop_apiname different thread unblock thread']
['A negative return value indicates what error condition occurred.', 'negative return value indicate what error condition occur']
['Whether other addresses are returned, and what types they might have is platform-dependent.', 'whether other address be return , what type may have be platform_dependent']
['pcap_open_dead(3PCAP)', 'pcap_open_dead 3pcap']
['In versions of libpcap prior to 1.0, the pcap.h header file was not in a pcap directory on most platforms; if you are writing an application that must work on versions of libpcap prior to 1.0, include <pcap.h>, which will include <pcap/pcap.h> for you, rather than including <pcap/pcap.h>.', 'version libpcap prior 1 , pcap header file be pcap directory most platform ; if -PRON- be write application must work version libpcap prior 1 , include pcap , which include -PRON- , rather than include']
["A handle can be put into ``non-blocking mode'', so that those routines will, rather than blocking, return an indication that no packets are available to read. Call pcap_setnonblock() to put a handle into non-blocking mode or to take it out of non-blocking mode; call pcap_getnonblock() to determine whether a handle is in non-blocking mode. Note that non-blocking mode does not work correctly in Mac OS X 10.6.", 'handle can be put into non_blocking mode , so routine , rather than block , return indication no packet be available read . call pcap_setnonblock put handle into non_block mode or take out non_block mode ; call pcap_getnonblock determine whether handle be non_block mode . note non_block mode do work correctly mac os x #']
['pcap_next() is passed an argument that points to a struct pcap_pkthdr structure, and fills it in with the time stamp and length values for the packet. It returns a const u_char to the first caplen bytes of the packet on success, and NULL on error.', 'pcap_next be pass argument point struct pcap_pkthdr structure , fill time stamp length value packet . return const u_char first caplen byte packet success , null error']
['pcap_lib_version(3PCAP)', 'pcap_lib_version 3pcap']
["get the FILE * for a pcap_dumper_t opened for a ``savefile''", 'get file pcap_dumper_t open savefile']
["The packet buffer timeout is required so that an application won't wait for the operating system's capture buffer to fill up before packets are delivered; if packets are arriving slowly, that wait could take an arbitrarily long period of time.", 'packet buffer timeout be require so application wait operate system capture buffer fill up before packet be deliver ; if packet be arrive slowly , wait could take arbitrarily long period time']
['If pcap_activate_APIName  fails, the pcap_t *  is not closed and freed; it should be closed using pcap_close_APIName.', 'if pcap_activate_apiname fail , pcap_t be closed freed ; should be close use pcap_close_apiname']
["ps_ifdrop  might, or might not, be implemented; if it's zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets.", 'ps_ifdrop may , or may , be implement ; if be zero , may mean no packet be drop by interface , or may mean statistic be unavailable , so should be treat as indication interface do drop packet']
['To report bugs and other problems, contribute patches, request a feature, provide generic feedback etc please see the file CONTRIBUTING.md in the libpcap source tree root.', 'report bug other problem , contribute patch , request feature , provide generic feedback etc please see file libpcap source tree root']
['pcap_can_set_rfmon(3PCAP)', 'pcap_can_set_rfmon 3pcap']
["flush buffered packets written to a pcap_dumper_t to the ``savefile''", 'flush buffer packet write pcap_dumper_t savefile']
['pcap_setnonblock(3PCAP)', 'pcap_setnonblock 3pcap']
['set if the device is up PCAP_IF_RUNNING', 'set if device be up pcap_if_runne']
['The struct pcap_pkthdr  and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns; if the code needs them to be valid after the pcap_loop_APIParam_3, it must make a copy of them.', 'struct pcap_pkthdr packet datum be be free by pcap_loop_apiparam_3 routine , be guarantee be valid after pcap_loop_apiparam_3 routine return ; if code need -PRON- be valid after pcap_loop_apiparam_3 , must make copy -PRON']
['compile a filter expression', 'compile filter expression']
['pcap_set_rfmon(3PCAP)', 'pcap_set_rfmon 3pcap']
['get a list of link', 'get list link']
['apply a filter program to a packet', 'apply filter program packet']
['pcap_dump(3PCAP)', 'pcap_dump 3pcap']
['find the IPv4 network number and netmask for a device', 'find ipv4 network number netmask device']
['The possible warning values are:  PCAP_WARNING_PROMISC_NOTSUP', 'possible warning value be : pcap_warning_promisc_notsup']
['Two time stamp precisions are supported, microseconds and nanoseconds.', 'two time stamp precision be support , microsecond nanosecond']
['get description for a link-layer header type', 'get description link_layer header type']
['free list of link-layer header types', 'free list link_layer header type']
['pcap_offline_filter_APIParam_2  points to the pcap_pkthdr  structure for the packet, and pcap_offline_filter_APIParam_3  points to the data in the packet.', 'pcap_offline_filter_apiparam_2 point pcap_pkthdr structure packet , pcap_offline_filter_apiparam_3 point datum packet']
["pcap_setdirection_APIName  isn't necessarily fully supported on all platforms; some platforms might return an error for all values, and some other platforms might not support PCAP_D_OUT.", 'pcap_setdirection_apiname be necessarily fully support platform ; platform may return error value , other platform may support pcap_d_out']
['This function is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect.', 'function be only provide linux , , if be use device other than network interface , have no effect']
['Opening a capture handle for reading', 'open capture handle read']
['NULL  is returned if the type value does not correspond to a known DLT_value.', 'null be return if type value do correspond know dlt_value']
['pcap_datalink_val_to_description(3PCAP)', 'pcap_datalink_val_to_description 3pcap']
["pcap_set_tstamp_type_APIName  returns 0 on success if the specified time stamp type is expected to be supported by the capture device, PCAP_WARNING_TSTAMP_TYPE_NOTSUP  if the specified time stamp type is not supported by the capture device, PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated, and PCAP_ERROR_CANTSET_TSTAMP_TYPE  if the capture device doesn't support setting the time stamp type (only older versions of libpcap will return that; newer versions will always allow the time stamp type to be set to the default type).", 'pcap_set_tstamp_type_apiname return # success if specify time stamp type be expect be support by capture device , pcap_warning_tstamp_type_notsup if specify time stamp type be support by capture device , pcap_error_activat if call capture handle have activate , pcap_error_cantset_tstamp_type if capture device do support set time stamp type only old version libpcap return ; new version always allow time stamp type be set default type']
['get time stamp type corresponding to a name', 'get time stamp type correspond name']
['Not all handles have such a descriptor available; pcap_get_selectable_fd() will return -1 if no such descriptor is available. If no such descriptor is available, this may be because the device must be polled periodically for packets; in that case, pcap_get_required_select_timeout() will return a pointer to a struct timeval whose value can be used as a timeout in those routines. When the routine returns, an attmept should be made to read packets from the device. If pcap_get_required_select_timeout() returns NULL, no such timeout is available, and those routines cannot be used with the device.', 'handle have such descriptor available ; pcap_get_selectable_fd return # if no such descriptor be available . if no such descriptor be available , be because device must be poll periodically packet ; case , pcap_get_required_select_timeout return pointer struct timeval whose value can be use as timeout routine . when routine return , attmept should be make read packet device . if pcap_get_required_select_timeout return null , no such timeout be available , routine can be use device']
["open a pcap_t for a ``savefile'', given a pathname", 'open pcap_t savefile , give pathname']
['Under SunOS 3.x or 4.x with NIT or BPF:', 'under suno 3 or 4 nit or bpf']
['pcap_lookupdev(3PCAP)', 'pcap_lookupdev 3pcap']
['On broadcast LANs such as Ethernet, if the network isn\'t switched, or if the adapter is connected to a "mirror port" on a switch to which all packets passing through the switch are sent, a network adapter receives all packets on the LAN, including unicast or multicast packets not sent to a network address that the network adapter isn\'t configured to recognize.', 'broadcast lan such as ethernet , if network be switch , or if adapter be connect mirror port switch which packet pass through switch be send , network adapter receive packet lan , include unicast or multicast packet send network address network adapter be configure recognize']
["pcap_dump_flush_APIName  flushes the output buffer to the ``savefile,'' so that any packets written with pcap_dump_APIName  but not yet written to the ``savefile'' will be written.", 'pcap_dump_flush_apiname flush output buffer savefile , so packet write pcap_dump_apiname but yet write savefile be write']
['set capture protocol for a not', 'set capture protocol']
['On network interface devices on Linux, pcap_set_protocol_linux_APIName  sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName  call to create a capture socket when the handle is activated.', 'network interface device linux , pcap_set_protocol_linux_apiname set pcap_set_protocol_linux_apiparam_2 be use socket_apiname call create capture socket when handle be activate']
['If the time stamps in the file do not have the same precision as the requested precision, they will be scaled up or down as necessary before being supplied.', 'if time stamp file have precision as request precision , be scale up or down as necessary before supply']
['pcap_sendpacket_APIName  is like pcap_inject_APIName,  but it returns 0 on success, rather than returning the number of bytes written.', 'pcap_sendpacket_apiname be like pcap_inject_apiname , but return # success , rather than return number byte write']
['pcap_dispatch(3PCAP)', 'pcap_dispatch 3pcap']
["In order to get a ``fake'' pcap_t for use in routines that require a pcap_t as an argument, such as routines to open a ``savefile'' for writing and to compile a filter expression, call pcap_open_dead().", 'order get fake pcap_t routine require pcap_t as argument , such as routine open savefile writing compile filter expression , call pcap_open_dead']
['Its value does not affect pcap_compile_APIName.', 'value do affect pcap_compile_apiname']
['pcap_open_offline_with_tstamp_precision_APIName  takes an additional precision  argument specifying the time stamp precision desired; if PCAP_TSTAMP_PRECISION_MICRO  is specified, packet time stamps will be supplied in seconds and microseconds, and if PCAP_TSTAMP_PRECISION_NANO  is specified, packet time stamps will be supplied in seconds and nanoseconds.', 'pcap_open_offline_with_tstamp_precision_apiname take additional precision argument specify time stamp precision desire ; if pcap_tstamp_precision_micro be specify , packet time stamp be supply second microsecond , if pcap_tstamp_precision_nano be specify , packet time stamp be supply second nanosecond']
['pcap_inject(3PCAP)', 'pcap_inject 3pcap']
['The PCAP_IF_UP  and PCAP_IF_RUNNING  constants became available in libpcap release 1.6.1.', 'pcap_if_up pcap_if_runne constant become available libpcap release #']
['pcap_get_tstamp_precision_APIName  returns the precision of the time stamp returned in packet captures on the pcap descriptor.', 'pcap_get_tstamp_precision_apiname return precision time stamp return packet capture pcap descriptor']
["Not all platforms support a packet buffer timeout; on platforms that don't, the packet buffer timeout is ignored. A zero value for the timeout, on platforms that support a packet buffer timeout, will cause a read to wait forever to allow enough packets to arrive, with no timeout. A negative value is invalid; the result of setting the timeout to a negative value is unpredictable.", 'platform support packet buffer timeout ; platform , packet buffer timeout be ignore . zero value timeout , platform support packet buffer timeout , cause read wait forever allow enough packet arrive , no timeout . negative value be invalid ; result setting timeout negative value be unpredictable']
['Normally, the adapter will discard those packets; however, many network adapters support "promiscuous mode", which is a mode in which all packets, even if they are not sent to an address that the adapter recognizes, are provided to the host. This is useful for passively capturing traffic between two or more other hosts for analysis.', 'normally , adapter discard packet ; however , many network adapter support promiscuous mode , which be mode which packet , even if be send address adapter recognize , be provide host . be useful passively capture traffic between two or more other host analysis']
['pcap_datalink(3PCAP)', 'pcap_datalink 3pcap']
["pcap_dump_APIName  outputs a packet to the ``savefile'' opened with pcap_dump_open_APIName.", 'pcap_dump_apiname output packet savefile open pcap_dump_open_apiname']
['get network address and network mask for a capture device', 'get network address network mask capture device']
['The caller is responsible for freeing the array with pcap_free_datalinks_APIName,  which frees the list of link-layer header types pointed to by pcap_free_datalinks_APIParam_1.', 'caller be responsible freeing array pcap_free_datalinks_apiname , which free list link_layer header type point by pcap_free_datalinks_apiparam_1']
['check whether monitor mode can be set for a not', 'check whether monitor mode can be set']
['get the snapshot length for a pcap_t', 'get snapshot length pcap_t']
['pcap_set_timeout_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_timeout_apiname return # success or pcap_error_activat if call capture handle have activate']
['if not NULL,  a pointer to the next element in the list; NULL  for the last element of the list name', 'if null , pointer next element list ; null last element list name']
['The current version is available from "The Tcpdump Group"\'s Web site at', 'current version be available tcpdump group web site']
['The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h>  header file, specified in host byte order.', 'argument be link_layer pcap_set_protocol_linux_apiparam_2 value , such as value header file , specify host byte order']
['pcap_geterr_APIName  returns the error text pertaining to the last pcap library error.', 'pcap_geterr_apiname return error text pertain last pcap library error']
['Injecting packets', 'inject packet']
['pcap_datalink_name_to_val_APIName  returns the type value on success and PCAP_ERROR  if the pcap_datalink_name_to_val_APIParam_1 is not a known type pcap_datalink_name_to_val_APIParam_1..', 'pcap_datalink_name_to_val_apiname return type value success pcap_error if pcap_datalink_name_to_val_apiparam_1 be know type pcap_datalink_name_to_val_apiparam_1']
['This function became available in libpcap release 1.5.1.', 'function become available libpcap release #']
['get or print libpcap error message text', 'get or print libpcap error message text']
["In order to cause only certain packets to be returned when reading packets, a filter can be set on a handle. For a live capture, the filtering will be performed in kernel mode, if possible, to avoid copying ``uninteresting'' packets from the kernel to user mode.", 'order cause only certain packet be return when read packet , filter can be set handle . live capture , filtering be perform kernel mode , if possible , avoid copy uninteresting packet kernel user mode']
['Under BSD (this includes macOS):', 'under bsd include macos']
['If pcap_set_rfmon_APIParam_2  is non-zero, monitor mode will be set, otherwise it will not be set.', 'if pcap_set_rfmon_apiparam_2 be non_zero , monitor mode be set , otherwise be set']
["if not NULL,  a pointer to a struct sockaddr  that contains the broadcast address corresponding to the address pointed to by addr;  may be null if the device doesn't support broadcasts dstaddr", 'if null , pointer struct sockaddr contain broadcast address correspond address point by addr ; be null if device do support broadcast dstaddr']
['pcap_close_APIName  closes the files associated with pcap_close_APIParam_1  and deallocates resources.', 'pcap_close_apiname close file associate pcap_close_apiparam_1 deallocate resource']
['pcap_open_live_APIParam_5  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_open_live_apiparam_5 be assume be able hold least pcap_errbuf_size char']
['See pcap-filter_APIName  for the syntax of that string.', 'see pcap_filter_apiname syntax string']
['get a string for an error or warning status code', 'get string error or warning status code']
['set promiscuous mode for a not-yet-activated pcap_t for live capture', 'set promiscuous mode not_yet_activated pcap_t live capture']
['The flag is checked in loops reading packets from the OS', 'flag be check loop read packet os']
["Note that, even if you successfully open the network interface, you might not have permission to send packets on it, or it might not support sending packets; as pcap_open_live_APIName  doesn't have a flag to indicate whether to open for capturing, sending, or capturing and sending, you cannot request an open that supports sending and be notified at open time whether sending will be possible.", 'note , even if -PRON- successfully open network interface , -PRON- may have permission send packet , or may support send packet ; as pcap_open_live_apiname do have flag indicate whether open capturing , send , or capture send , -PRON- can request open support send be notify open time whether send be possible']
["To open a ``savefile`` to which to write packets, given the pathname the ``savefile'' should have, call pcap_dump_open(). To open a ``savefile`` to which to write packets, given the pathname the ``savefile'' should have, call pcap_dump_open(); to set up a handle for a ``savefile'', given a FILE * referring to a file already opened for writing, call pcap_dump_fopen(). They each return pointers to a pcap_dumper_t, which is the handle used for writing packets to the ``savefile''. If it succeeds, it will have created the file if it doesn't exist and truncated the file if it does exist. To close a pcap_dumper_t, call pcap_dump_close().", 'open savefile which write packet , give pathname savefile should have , call pcap_dump_open . open savefile which write packet , give pathname savefile should have , call pcap_dump_open ; set up handle savefile , give file referring file already open writing , call pcap_dump_fopen . each return pointer pcap_dumper_t , which be handle use writing packet savefile . if succeed , have create file if do exist truncate file if do exist . close pcap_dumper_t , call pcap_dump_close']
['pcap_lib_version_APIName  returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number.', 'pcap_lib_version_apiname return pointer stre give information about version libpcap library use ; note contain more information than just version number']
['pcap_open_offline_APIParam_2  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_open_offline_apiparam_2 be assume be able hold least pcap_errbuf_size char']
['pcap_lookupdev_APIParam_1  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_lookupdev_apiparam_1 be assume be able hold least pcap_errbuf_size char']
['This function became available in libpcap release 1.9.0.', 'function become available libpcap release #']
['get library version string', 'get library version string']
['pcap_dump_open(3PCAP)', 'pcap_dump_open 3pcap']
["pcap_snapshot_APIName  returns the snapshot length specified when pcap_set_snaplen_APIName  or pcap_open_live_APIName  was called, for a live capture, or the snapshot length from the capture file, for a ``savefile''.", 'pcap_snapshot_apiname return snapshot length specify when pcap_set_snaplen_apiname or pcap_open_live_apiname be call , live capture , or snapshot length capture file , savefile']
["pcap_stats_APIName  returns 0 on success and returns PCAP_ERROR  if there is an error or if pcap_stats_APIParam_1  doesn't support packet statistics.", 'pcap_stats_apiname return # success return pcap_error if be error or if pcap_stats_apiparam_1 do support packet statistic']
['Selecting a link-layer header type for a live capture', 'select link_layer header type live capture']
['pcap_open_offline_with_tstamp_precision(3PCAP)', 'pcap_open_offline_with_tstamp_precision 3pcap']
['pcap_setfilter_APIName  is used to specify a filter program.', 'pcap_setfilter_apiname be use specify filter program']
['free list of available time stamp types', 'free list available time stamp type']
['pcap_set_immediate_mode_APIName  sets whether immediate mode should be set on a capture handle when the handle is activated.', 'pcap_set_immediate_mode_apiname set whether immediate mode should be set capture handle when handle be activate']
["pcap_dump_ftell_APIName  returns the current file position for the ``savefile'', representing the number of bytes written by pcap_dump_open_APIName  and pcap_dump_APIName.", 'pcap_dump_ftell_apiname return current file position savefile , represent number byte write by pcap_dump_open_apiname pcap_dump_apiname']
['We recommend always setting the timeout to a non-zero value unless immediate mode is set, in which case the timeout has no effect.', 'PRON- recommend always set timeout non_zero value unless immediate mode be set , which case timeout have no effect']
['If a given network interface provides a standard link-layer header, with a standard packet type, but provides some packet types with a different socket-layer pcap_set_protocol_linux_APIParam_2 type from the one in the link-layer header, that packet type cannot be filtered with a filter specified with pcap_setfilter_APIName  but can be filtered by specifying the socket-layer pcap_set_protocol_linux_APIParam_2 type using pcap_set_protocol_linux_APIName.', 'if give network interface provide standard link_layer header , standard packet type , but provide packet type different socket_layer pcap_set_protocol_linux_apiparam_2 type one link_layer header , packet type can be filter filter specify pcap_setfilter_apiname but can be filter by specify socket_layer pcap_set_protocol_linux_apiparam_2 type use pcap_set_protocol_linux_apiname']
['specify whether to capture incoming packets, outgoing packets, or both', 'specify whether capture incoming packet , outgoing packet , or both']
["pcap_getnonblock_APIName  returns the current ``non-blocking'' state of the capture descriptor; it always returns 0 on ``savefiles''.", 'pcap_getnonblock_apiname return current non_block state capture descriptor ; always return # savefile']
['convert an errno value to a string', 'convert errno value string']
['promisc  specifies if the interface is to be put into promiscuous mode.', 'promisc specifie if interface be be put into promiscuous mode']
['read the next packet from a pcap_t without an indication whether an error occurred', 'read next packet pcap_t without indication whether error occur']
['pcap_create(3PCAP)', 'pcap_create 3pcap']
['The pcap_pkthdr  structure pointed to by h  is filled in with the appropriate values for the packet.', 'pcap_pkthdr structure point by h be fill appropriate value packet']
['pcap_get_required_select_timeout_APIName  is not available on Windows.', 'pcap_get_required_select_timeout_apiname be available window']
['open a device for capturing', 'open device capturing']
['pcap_list_datalinks_APIName  returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED  if called on a capture handle that has been created but not activated, and PCAP_ERROR  on other errors.', 'pcap_list_datalinks_apiname return number link_layer header type array success , pcap_error_not_activate if call capture handle have create but activate , pcap_error other error']
['packet buffer timeout', 'packet buffer timeout']
['pcap_dump_file(3PCAP)', 'pcap_dump_file 3pcap']
['Under Linux:', 'under linux']
['The caller is responsible for freeing the array with pcap_free_tstamp_types_APIName,  which frees the list pointed to by pcap_free_tstamp_types_APIParam_1.', 'caller be responsible freeing array pcap_free_tstamp_types_apiname , which free list point by pcap_free_tstamp_types_apiparam_1']
['convert a PCAP_ERROR_ or PCAP_WARNING_ value to a string', 'convert pcap_error or pcap_warn value string']
['pcap_open_dead_APIName  and pcap_open_dead_with_tstamp_precision_APIName  are used for creating a pcap_t  structure to use when calling the other functions in libpcap.', 'pcap_open_dead_apiname pcap_open_dead_with_tstamp_precision_apiname be use create pcap_t structure when call other function libpcap']
['snaplen  specifies the snapshot length to be set on the handle.', 'snaplen specifie snapshot length be set handle']
["Note that the Packet Capture library is usually built with large file support, so the standard I/O stream of the ``savefile'' might refer to a file larger than 2 gigabytes; applications that use pcap_file_APIName  should, if possible, use calls that support large files on the return value of pcap_file_APIName  or the value returned by fileno_APIName  when passed the return value of pcap_file_APIName.", 'note packet capture library be usually build large file support , so standard stream savefile may refer file large than # gigabyte ; application pcap_file_apiname should , if possible , call support large file return value pcap_file_apiname or value return by fileno_apiname when pass return value pcap_file_apiname']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_setdirection_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_setdirection_apiparam_1 as argument fetch or display error text']
['check whether a filter matches a packet', 'check whether filter match packet']
['pcap_getnonblock(3PCAP)', 'pcap_getnonblock 3pcap']
['The PCAP_NETMASK_UNKNOWN  constant became available in libpcap release 1.1.0.', 'pcap_netmask_unknown constant become available libpcap release #']
['Reporting errors', 'report error']
["pcap_dump_open_APIName  is called to open a ``savefile'' for writing.", 'pcap_dump_open_apiname be call open savefile writing']
['get the current file offset for a savefile being written', 'get current file offset savefile write']
['The value it returns will be valid for all packets received unless and until pcap_set_datalink_APIName  is called; after a successful call to pcap_set_datalink_APIName,  all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink_APIName.', 'value return be valid packet receive unless until pcap_set_datalink_apiname be call ; after successful call pcap_set_datalink_apiname , subsequent packet have link_layer header type specify by link_layer header type value pass pcap_set_datalink_apiname']
['Getting library version information', 'get library version information']
['pcap_sendpacket_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_sendpacket_apiname return # success pcap_error failure']
['pcap_datalink_name_to_val_APIName  translates a link-layer header type pcap_datalink_name_to_val_APIParam_1, which is a DLT_  pcap_datalink_name_to_val_APIParam_1 with the DLT_  removed, to the corresponding link-layer header type value.', 'pcap_datalink_name_to_val_apiname translate link_layer header type pcap_datalink_name_to_val_apiparam_1 , which be dlt pcap_datalink_name_to_val_apiparam_1 dlt remove , correspond link_layer header type value']
["The callback is also supplied a const u_char pointer to the first caplen (as given in the struct pcap_pkthdr mentioned above) bytes of data from the packet. This won't necessarily be the entire packet; to capture the entire packet, you will have to provide a value for snaplen in your call to pcap_set_snaplen() that is sufficiently large to get all of the packet's data - a value of 65535 should be sufficient on most if not all networks). When reading from a ``savefile'', the snapshot length specified when the capture was performed will limit the amount of packet data available.", 'callback be supply const u_char pointer first caplen byte datum packet . necessarily be entire packet ; capture entire packet , -PRON- have provide value snaplen -PRON- call pcap_set_snaplen be sufficiently large get packet datum value # should be sufficient most if network . when read savefile , snapshot length specify when capture be perform limit amount packet datum available']
['get the standard I/O stream for a savefile being read', 'get standard stream savefile read']
['pcap_setdirection_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_setdirection_apiname return # success pcap_error failure']
['pcap_set_tstamp_type(3PCAP)', 'pcap_set_tstamp_type 3pcap']
['A value of -1 or 0 for pcap_loop_APIParam_2  is equivalent to infinity, so that packets are processed until another ending condition occurs.', 'value # or # pcap_loop_apiparam_2 be equivalent infinity , so packet be process until another end condition occur']
['pcap_compile_APIParam_5  specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program.', 'pcap_compile_apiparam_5 specifie ipv4 pcap_compile_apiparam_5 network which packet be capture ; be use only when check ipv4 broadcast address filter program']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_sendpacket_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_sendpacket_apiparam_1 as argument fetch or display error text']
['Alternatively, you may call pcap_fopen_offline_APIName  or pcap_fopen_offline_with_tstamp_precision_APIName  to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1.', 'alternatively , -PRON- call pcap_fopen_offline_apiname or pcap_fopen_offline_with_tstamp_precision_apiname read dump datum exist open stream pcap_fopen_offline_apiparam_1']
['set filter for a pcap_t', 'set filter pcap_t']
["When first activated with pcap_activate_APIName  or opened with pcap_open_live_APIName,  a capture handle is not in ``non-blocking mode''; a call to pcap_setnonblock_APIName  is required in order to put it into ``non-blocking'' mode.", 'when first activate pcap_activate_apiname or open pcap_open_live_apiname , capture handle be non_block mode ; call pcap_setnonblock_apiname be require order put into non_blocking mode']
['pcap_list_datalinks_APIName  is used to get a list of the supported link-layer header types of the interface associated with the pcap descriptor.', 'pcap_list_datalinks_apiname be use get list support link_layer header type interface associate pcap descriptor']
['The file can have the pcap file format as described in pcap-savefile_APIName,  which is the file format used by, among other programs, tcpdump_APIName  and tcpslice_APIName,  or can have the pcapng file format, although not all pcapng files can be read.', 'file can have pcap file format as describe pcap_savefile_apiname , which be file format use by , among other program , tcpdump_apiname tcpslice_apiname , or can have pcapng file format , although pcapng file can be read']
['pcap_tstamp_type_val_to_name(3PCAP)', 'pcap_tstamp_type_val_to_name 3pcap']
['close a savefile being written to', 'close savefile write']
['It does not  return when live packet buffer timeouts occur; instead, it attempts to read more packets.', 'do return when live packet buffer timeout occur ; instead , attempt read more packet']
["You must have read/write access to the network pseudo device, e.g. /dev/le. On at least some versions of Solaris, however, this is not sufficient to allow tcpdump to capture in promiscuous mode; on those versions of Solaris, you must be root, or the application capturing packets must be installed setuid to root, in order to capture in promiscuous mode. Note that, on many (perhaps all) interfaces, if you don't capture in promiscuous mode, you will not see any outgoing packets, so a capture not done in promiscuous mode may not be very useful.", 'PRON- must have access network pseudo device , e. . least version solaris , however , be sufficient allow tcpdump capture promiscuous mode ; version solari , -PRON- must be root , or application capturing packet must be instal setuid root , order capture promiscuous mode . note , many interface , if -PRON- capture promiscuous mode , -PRON- see outgoing packet , so capture do promiscuous mode be useful']
['pcap_lookupdev_APIName  returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName  and pcap_activate_APIName,  or with pcap_open_live_APIName,  and with pcap_lookupnet_APIName.', 'pcap_lookupdev_apiname return pointer stre give name network device suitable pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname , pcap_lookupnet_apiname']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_set_datalink_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_set_datalink_apiparam_1 as argument fetch or display error text']
['set promiscuous mode for a not', 'set promiscuous mode']
['a pointer to the first element of a list of network addresses for the device, or NULL  if the device has no addresses flags', 'pointer first element list network address device , or null if device have no address flag']
['monitor mode', 'monitor mode']
['pcap_set_snaplen_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_snaplen_apiname return # success or pcap_error_activat if call capture handle have activate']
['In addition, for various reasons, one or more of those routines will not work properly with the descriptor; the documentation for pcap_get_selectable_fd() gives details. Note that, just as an attempt to read packets from a pcap_t may not return any packets if the packet buffer timeout expires, a select(), poll(), or other such call may, if the packet buffer timeout expires, indicate that a descriptor is ready to read even if there are no packets available to read.', 'addition , various reason , one or more routine work properly descriptor ; documentation pcap_get_selectable_fd give detail . note , just as attempt read packet pcap_t return packet if packet buffer timeout expire , select , poll , or other such call , if packet buffer timeout expire , indicate descriptor be ready read even if be no packet available read']
['Under ULTRIX and Digital UNIX/Tru64 UNIX:', 'under ultrix digital unix']
["pcap_loop_APIName  processes packets from a live capture or ``savefile'' until pcap_loop_APIParam_2  packets are processed, the end of the ``savefile'' is reached when reading from a ``savefile'', pcap_breakloop_APIName  is called, or an error occurs.", 'pcap_loop_apiname process packet live capture or savefile until pcap_loop_apiparam_2 packet be process , end savefile be reach when read savefile , pcap_breakloop_apiname be call , or error occur']
['set link-layer header type for a device', 'set link_layer header type device']
["pcap_dump_file_APIName  returns the standard I/O stream of the ``savefile'' opened by pcap_dump_open_APIName.", 'pcap_dump_file_apiname return standard stream savefile open by pcap_dump_open_apiname']
["A value of -1 or 0 for pcap_dispatch_APIParam_2  causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a ``savefile''.", 'value # or # pcap_dispatch_apiparam_2 cause packet receive one buffer be process when read live capture , cause packet file be process when read savefile']
['The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName  routine when handed the pcap_t  value also passed to pcap_loop_APIName  or pcap_dispatch_APIName.', 'format link_layer header be indicate by return value pcap_datalink_apiname routine when handed pcap_t value pass pcap_loop_apiname or pcap_dispatch_apiname']
["determine whether a ``savefile'' being read came from a machine with the opposite byte order", 'determine whether savefile read come machine opposite byte order']
['pcap_setdirection(3PCAP)', 'pcap_setdirection 3pcap']
['pcap_create() and pcap_activate() were not available in versions of libpcap prior to 1.0; if you are writing an application that must work on versions of libpcap prior to 1.0, either use pcap_open_live() to get a handle for a live capture or, if you want to be able to use the additional capabilities offered by using pcap_create() and pcap_activate(), use an autoconf(1) script or some other configuration script to check whether the libpcap 1.0 APIs are available and use them only if they are.  ', 'pcap_create pcap_activate be available version libpcap prior 1 ; if -PRON- be write application must work version libpcap prior 1 , either pcap_open_live get handle live capture or , if -PRON- want be able additional capability offer by use pcap_create pcap_activate , autoconf script or other configuration script check whether libpcap # apis be available -PRON- only if be']
['get the file descriptor for a live capture', 'get file descriptor live capture']
['pcap_open_offline_with_tstamp_precision_APIName  and pcap_fopen_offline_with_tstamp_precision_APIName  became available in libpcap release 1.5.1.', 'pcap_open_offline_with_tstamp_precision_apiname pcap_fopen_offline_with_tstamp_precision_apiname become available libpcap release #']
['The snapshot length is set with pcap_set_snaplen().', 'snapshot length be set pcap_set_snaplen']
['pcap_offline_filter(3PCAP)', 'pcap_offline_filter 3pcap']
['pcap_set_tstamp_type_APIName  sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2.', 'pcap_set_tstamp_type_apiname set type time stamp desire packet capture pcap descriptor type specify by pcap_set_tstamp_type_apiparam_2']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_compile_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_compile_apiparam_1 as argument fetch or display error text']
['Note that on Windows, that stream should be opened in binary mode.', 'note window , stream should be open binary mode']
["pcap_loop_APIName  and pcap_next_APIName  will not work in ``non-blocking'' mode.", 'pcap_loop_apiname pcap_next_apiname work non_blocking mode']
['The time stamp type is set with pcap_set_tstamp_type().', 'time stamp type be set pcap_set_tstamp_type']
['For IPv4 addresses, the struct sockaddr  pointer can be interpreted as if it pointed to a struct sockaddr_in;  for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6.', 'ipv4 address , struct sockaddr pointer can be interpret as if point struct sockaddr_in ; ipv6 address , can be interpret as if point struct sockaddr_in6']
['Applications should be prepared for this to happen, but must not rely on it happening.', 'application should be prepare happen , but must rely happen']
['If NULL  is returned, pcap_create_APIParam_2  is filled in with an appropriate error message.', 'if null be return , pcap_create_apiparam_2 be fill appropriate error message']
["It has no effect on ``savefiles''.", 'have no effect savefile']
['Under Solaris with DLPI:', 'under solaris dlpi']
['pcap_findalldevs_APIParam_2  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_findalldevs_apiparam_2 be assume be able hold least pcap_errbuf_size char']
["pcap_dump_ftell64_APIName  returns the current file position in a int64_t,  so if file offsets that don't fit in a long  but that fit in a int64_t  are supported, this will return the file offset without truncation.", 'pcap_dump_ftell64_apiname return current file position int64_t , so if file offset fit long but fit int64_t be support , return file offset without truncation']
["pcap_next_ex_APIName  returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR  if an error occurred while reading the packet, and PCAP_ERROR_BREAK  if packets are being read from a ``savefile'' and there are no more packets to read from the savefile.", 'pcap_next_ex_apiname return # if packet be read without problem , # if packet be read live capture packet buffer timeout expire , pcap_error if error occur while read packet , pcap_error_break if packet be read savefile be no more packet read savefile']
['You must have read access to /dev/nit or /dev/bpf*.', 'PRON- must have read access or']
['A compiled filter can also be applied directly to a packet that has been read using pcap_offline_filter().', 'compile filter can be apply directly packet have read use pcap_offline_filter']
['Note that even if an application does not set promiscuous mode, the adapter could well be in promiscuous mode for some other reason.', 'note even if application do set promiscuous mode , adapter could well be promiscuous mode other reason']
['pcap_compile_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_compile_apiname return # success pcap_error failure']
['Monitor mode is set with pcap_set_rfmon(), and pcap_can_set_rfmon() can be used to determine whether an adapter can be put into monitor mode.', 'monitor mode be set pcap_set_rfmon , pcap_can_set_rfmon can be use determine whether adapter can be put into monitor mode']
['get the time stamp precision returned in captures', 'get time stamp precision return capture']
['If the pcap_compile_APIParam_5 of the network on which packets are being captured isn\'t known to the program, or if packets are being captured on the Linux "any" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN  can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK.', 'if pcap_compile_apiparam_5 network which packet be capture be know program , or if packet be capture linux pseudo_interface can capture more than one network , value pcap_netmask_unknown can be supply ; test ipv4 broadcast address fail compile , but other test filter program be ok']
['pcap_inject_APIName  returns the number of bytes written on success and PCAP_ERROR  on failure.', 'pcap_inject_apiname return number byte write success pcap_error failure']
['pcap_set_buffer_size_APIName  sets the buffer size that will be used on a capture handle when the handle is activated to pcap_set_buffer_size_APIParam_2,  which is in units of bytes.', 'pcap_set_buffer_size_apiname set buffer size be use capture handle when handle be activate pcap_set_buffer_size_apiparam_2 , which be unit byte']
['This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop.', 'routine be safe inside signal handler unix or console control handler window , as merely set flag be check within loop']
['determine whether monitor mode can be set for a pcap_t for live capture', 'determine whether monitor mode can be set pcap_t live capture']
['open a pcap_dumper_t for a ``savefile``, given a FILE *', 'open pcap_dumper_t savefile , give file']
['set the packet buffer timeout for a not-yet-activated capture handle ', 'set packet buffer timeout not_yet_activated capture handle']
['a bpf_u_int32 giving the number of bytes of the packet that are available from the capture', 'bpf_u_int32 give number byte packet be available capture']
['activate a pcap_t for live capture', 'activate pcap_t live capture']
['The pcap_dump_open_append_APIName  function became available in libpcap release 1.7.2.', 'pcap_dump_open_append_apiname function become available libpcap release #']
['fname  specifies the name of the file to open.', 'fname specifie name file open']
["The Packet Capture library provides a high level interface to packet capture systems. All packets on the network, even those destined for other hosts, are accessible through this mechanism. It also supports saving captured packets to a ``savefile'', and reading packets from a ``savefile''.  ", 'packet capture library provide high level interface packet capture system . packet network , even destine other host , be accessible through mechanism . support save capture packet savefile , read packet savefile']
['If there is an error, PCAP_ERROR  is returned and pcap_setnonblock_APIParam_3  is filled in with an appropriate error message; otherwise, 0 is returned.', 'if be error , pcap_error be return pcap_setnonblock_apiparam_3 be fill appropriate error message ; otherwise , # be return']
["pcap_setnonblock_APIName  puts a capture handle into ``non-blocking'' mode, or takes it out of ``non-blocking'' mode, depending on whether the pcap_setnonblock_APIParam_2  argument is non-zero or zero.", 'pcap_setnonblock_apiname put capture handle into non_block mode , or take out non_block mode , depend whether pcap_setnonblock_apiparam_2 argument be non_zero or zero']
['pcap_next_APIName  reads the next packet (by calling pcap_dispatch_APIName  with a cnt  of 1) and returns a u_char  pointer to the data in that packet.', 'pcap_next_apiname read next packet return u_char pointer datum packet']
['autoconf(1), tcpdump(1), tcpslice(1), pcap-filter(7), pfconfig(8), usermod(8)  ', 'autoconf , tcpdump , tcpslice , pcap_filter , pfconfig , usermod 8']
['Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, pcap_dispatch_APIName  will return 0, even when not in non-blocking mode, as there are no packets to process.', 'note , when do live capture platform , if read timeout expire when be no packet available , pcap_dispatch_apiname return 0 , even when non_block mode , as be no packet process']
['pcap_get_required_select_timeout_APIName  returns, on UNIX, a pointer to a struct timeval  containing a value that must be used as the minimum timeout in select_APIName,  poll_APIName,  epoll_wait_APIName,  and kevent_APIName  calls if pcap_get_selectable_fd_APIName  returns PCAP_ERROR.', 'pcap_get_required_select_timeout_apiname return , unix , pointer struct timeval contain value must be use as minimum timeout select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname call if pcap_get_selectable_fd_apiname return pcap_error']
['The name "-" is a synonym for stdin.', 'name be synonym stdin']
["pcap_dispatch_APIName  returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a ``savefile.''", 'pcap_dispatch_apiname return number packet process success ; can be # if no packet be read live capture or if no more packet be available savefile']
["The capture source specified when the handle was created doesn't exist.", 'capture source specify when handle be create do exist']
['set if the device is a loopback interface PCAP_IF_UP', 'set if device be loopback interface pcap_if_up']
['(In older versions of libpcap, the behavior when pcap_dispatch_APIParam_2 was 0 was undefined; different platforms and devices behaved differently, so code that must work with older versions of libpcap should use -1, not 0, as the value of pcap_dispatch_APIParam_2.)', 'old version libpcap , behavior when pcap_dispatch_apiparam_2 be # be undefined ; different platform device behave differently , so code must work old version libpcap should 1 , 0 , as value pcap_dispatch_apiparam_2']
['device flags:', 'device flag']
['pcap_set_rfmon_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_rfmon_apiname return # success or pcap_error_activat if call capture handle have activate']
['pcap_dump_flush_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_dump_flush_apiname return # success pcap_error failure']
['pcap_activate_APIName  returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error.', 'pcap_activate_apiname return # success without warning , non_zero positive value success warning , negative value error']
['callback  specifies a pcap_handler  routine to be called with three arguments: a u_char  pointer which is passed in the pcap_loop_APIParam_4  argument to pcap_loop_APIName  or pcap_dispatch_APIName,  a const struct pcap_pkthdr  pointer pointing to the packet time stamp and lengths, and a const u_char  pointer to the first caplen  (as given in the struct pcap_pkthdr  a pointer to which is passed to the pcap_loop_APIParam_3 routine) bytes of data from the packet.', 'callback specifie pcap_handler routine be call three argument : u_char pointer which be pass pcap_loop_apiparam_4 argument pcap_loop_apiname or pcap_dispatch_apiname , const struct pcap_pkthdr pointer point packet time stamp length , const u_char pointer first caplen byte datum packet']
['pcap_setfilter_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_setfilter_apiname return # success pcap_error failure']
['The original authors of libpcap are:', 'original author libpcap be']
['pcap_set_tstamp_precision_APIName  sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2.', 'pcap_set_tstamp_precision_apiname set precision time stamp desire packet capture pcap descriptor type specify by pcap_set_tstamp_precision_apiparam_2']
["Promiscuous mode was requested, but the capture source doesn't support promiscuous mode.", 'promiscuous mode be request , but capture source do support promiscuous mode']
["In newer versions of Solaris, you must have been given the net_rawaccess privilege; this is both necessary and sufficient to give you access to the network pseudo-device - there is no need to change the privileges on that device. A user can be given that privilege by, for example, adding that privilege to the user's defaultpriv key with the usermod(8) command.", 'new version solaris , -PRON- must have give net_rawaccess privilege ; be both necessary sufficient give -PRON- access network pseudo_device be no need change privilege device . user can be give privilege by , example , add privilege user defaultpriv key usermod command']
["This operation is not supported if a ``savefile'' is being read.", 'operation be support if savefile be read']
["The behavior, if the timeout isn't specified, is undefined, as is the behavior if the timeout is set to zero or to a negative value.", 'behavior , if timeout be specify , be undefined , as be behavior if timeout be set zero or negative value']
['pcap_set_rfmon_APIName  sets whether monitor mode should be set on a capture handle when the handle is activated.', 'pcap_set_rfmon_apiname set whether monitor mode should be set capture handle when handle be activate']
['To open a handle for a live capture, given the name of the network or other interface on which the capture should be done, call pcap_create(), set the appropriate options on the handle, and then activate it with pcap_activate(). If pcap_activate() fails, the handle should be closed with pcap_close().', 'open handle live capture , give name network or other interface which capture should be do , call pcap_create , set appropriate option handle , then activate pcap_activate . if pcap_activate fail , handle should be close pcap_close']
['pcap_can_set_rfmon_APIName  checks whether monitor mode could be set on a capture handle when the handle is activated.', 'pcap_can_set_rfmon_apiname check whether monitor mode could be set capture handle when handle be activate']
['pcap_breakloop_APIName  sets a flag that will force pcap_dispatch_APIName  or pcap_loop_APIName  to return rather than looping; they will return the number of packets that have been processed so far, or PCAP_ERROR_BREAK  if no packets have been processed so far.', 'pcap_breakloop_apiname set flag force pcap_dispatch_apiname or pcap_loop_apiname return rather than loop ; return number packet have process so far , or pcap_error_break if no packet have process so far']
["pcap_is_swapped_APIName  returns true (1) if pcap_is_swapped_APIParam_1  refers to a ``savefile'' that uses a different byte order than the current system.", 'pcap_is_swapped_apiname return true if pcap_is_swapped_apiparam_1 refer savefile use different byte order than current system']
['Some network devices opened with pcap_create_APIName  and pcap_activate_APIName,  or with pcap_open_live_APIName,  do not support those calls (for example, regular network devices on FreeBSD 4.3 and 4.4, and Endace DAG devices), so PCAP_ERROR  is returned for those devices.', 'network device open pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname , support call , so pcap_error be return device']
['In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds.', 'previous release , time stamp capture device or savefile be always give second microsecond']
['A struct pcap_stat  has the following members:', 'struct pcap_stat have follow member']
['To get statistics about packets received and dropped in a live capture, call pcap_stats().', 'get statistic about packet receive drop live capture , call pcap_stats']
['pcap_datalink_val_to_description_or_dlt_APIName  translates a link-layer header type value to a short description of that link-layer header type just like pcap_datalink_val_to_description.', 'pcap_datalink_val_to_description_or_dlt_apiname translate link_layer header type value short description link_layer header type just like pcap_datalink_val_to_description']
['pcap_compile_APIParam_4  controls whether optimization on the resulting code is performed.', 'pcap_compile_apiparam_4 control whether optimization result code be perform']
['For now, this doesn\'t work on the "any" device; if an argument of "any" or NULL is supplied, the setting of promiscuous mode is ignored.', 'now , do work device ; if argument or null be supply , set promiscuous mode be ignore']
['promiscuous mode', 'promiscuous mode']
['By default, libpcap will attempt to capture both packets sent by the machine and packets received by the machine. To limit it to capturing only packets received by the machine or, if possible, only packets sent by the machine, call pcap_setdirection().', 'by default , libpcap attempt capture both packet send by machine packet receive by machine . limit capturing only packet receive by machine or , if possible , only packet send by machine , call pcap_setdirection']
['pcap_list_tstamp_types_APIName  allocates an array to hold the list and sets *tstamp_typesp  to point to the array.', 'pcap_list_tstamp_types_apiname allocate array hold list set tstamp_typesp point array']
['pcap_setdirection_APIParam_2  is one of the constants PCAP_D_IN,  PCAP_D_OUT  or PCAP_D_INOUT.', 'pcap_setdirection_apiparam_2 be one constant pcap_d_in , pcap_d_out or pcap_d_inout']
['pcap_datalink_val_to_name(3PCAP)', 'pcap_datalink_val_to_name 3pcap']
['pcap_open_live_APIName  returns a pcap_t *  on success and NULL  on failure.', 'pcap_open_live_apiname return pcap_t success null failure']
["pcap_open_offline_APIName  and pcap_open_offline_with_tstamp_precision_APIName  are called to open a ``savefile'' for reading.", 'pcap_open_offline_apiname pcap_open_offline_with_tstamp_precision_apiname be call open savefile reading']
['Capture statistics', 'capture statistic']
['pcap_set_protocol_linux(3PCAP)', 'pcap_set_protocol_linux 3pcap']
['pcap_setfilter_APIParam_2  is a pointer to a bpf_program  struct, usually the result of a call to pcap_compile_APIName.', 'pcap_setfilter_apiparam_2 be pointer bpf_program struct , usually result call pcap_compile_apiname']
["open a pcap_t for a ``savefile'', given a FILE *, and specify the precision to provide for packet time stamps", 'open pcap_t savefile , give file , specify precision provide packet time stamp']
['A filter can be specified as a text string; the syntax and semantics of the string are as described by pcap-filter(7). A filter string is compiled into a program in a pseudo-machine-language by pcap_compile() and the resulting program can be made a filter for a handle with pcap_setfilter(). The result of pcap_compile() can be freed with a call to pcap_freecode(). pcap_compile() may require a network mask for certain expressions in the filter string; pcap_lookupnet() can be used to find the network address and network mask for a given capture device.', 'filter can be specify as text string ; syntax semantic string be as describe by pcap_filter . filter string be compile into program pseudo_machine_language by pcap_compile result program can be make filter handle pcap_setfilter . result pcap_compile can be free call pcap_freecode . pcap_compile require network mask certain expression filter string ; pcap_lookupnet can be use find network address network mask give capture device']
['Reading packets', 'read packet']
['program  is a pointer to a bpf_program  struct and is filled in by pcap_compile_APIName.', 'program be pointer bpf_program struct be fill by pcap_compile_apiname']
['pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_can_set_rfmon_APIParam_1  as an argument to fetch or display a message describing the error.', 'pcap_geterr_apiname or pcap_perror_apiname be call pcap_can_set_rfmon_apiparam_1 as argument fetch or display message describing error']
['If a positive number is returned, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK  and clear the flag.', 'if positive number be return , flag be clear , so subsequent call return pcap_error_break clear flag']
['pcap_lookupnet(3PCAP)', 'pcap_lookupnet 3pcap']
['PCAP_D_INOUT  is the default setting if pcap_setdirection_APIName is not called.', 'pcap_d_inout be default set if pcap_setdirection_apiname be call']
['set or clear non-blocking mode on a pcap_t', 'set or clear non_blocking mode pcap_t']
['pcap_list_datalinks(3PCAP)', 'pcap_list_datalink 3pcap']
['pcap_dump_close(3PCAP)', 'pcap_dump_close 3pcap']
['pcap_lookupnet_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_lookupnet_apiname return # success pcap_error failure']
['pcap_open_offline_APIName,  pcap_open_offline_with_tstamp_precision_APIName,  pcap_fopen_offline_APIName,  and pcap_fopen_offline_with_tstamp_precision_APIName  return a pcap_t *  on success and NULL  on failure.', 'pcap_open_offline_apiname , pcap_open_offline_with_tstamp_precision_apiname , pcap_fopen_offline_apiname , pcap_fopen_offline_with_tstamp_precision_apiname return pcap_t success null failure']
['Note that its calling arguments are suitable for use with pcap_dispatch_APIName  or pcap_loop_APIName.', 'note call argument be suitable pcap_dispatch_apiname or pcap_loop_apiname']
['pcap_freealldevs(3PCAP)', 'pcap_freealldevs 3pcap']
["get the major and minor version of the file format version for a ``savefile''", 'get major minor version file format version savefile']
['the notion of "connected" and "disconnected" don\'t apply to this interface; for example, it doesn\'t apply to a loopback device', 'notion connect disconnected apply interface ; example , do apply loopback device']
['Note also that some devices might not support sending packets.', 'note device may support send packet']
['Do NOT assume that the packets for a given capture or ``savefile`` will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the "any" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the "any" device is opened have some other data link type, such as DLT_EN10MB for Ethernet.', 'assume packet give capture or savefile have give link_layer header type , such as dlt_en10 mb ethernet . example , device linux have link_layer header type dlt_linux_sll even if device system time device be open have other datum link type , such as dlt_en10 mb ethernet']
['To obtain a list of devices that can be opened for a live capture, call pcap_findalldevs(); to free the list returned by pcap_findalldevs(), call pcap_freealldevs(). pcap_lookupdev() will return the first device on that list that is not a ``loopback`` network interface.', 'obtain list device can be open live capture , call pcap_findalldevs ; free list return by pcap_findalldevs , call pcap_freealldevs . pcap_lookupdev return first device list be loopback network interface']
['pcap_file(3PCAP)', 'pcap_file 3pcap']
['The buffer size is set with pcap_set_buffer_size().', 'buffer size be set pcap_set_buffer_size']
['It must not be called on a pcap descriptor created by pcap_create_APIName  that has not yet been activated by pcap_activate_APIName.', 'must be call pcap descriptor create by pcap_create_apiname have yet activate by pcap_activate_apiname']
['In previous releases, there is no support for appending packets to an existing savefile.', 'previous release , be no support append packet exist savefile']
['If pcap_set_immediate_mode_APIParam_2  is non-zero, immediate mode will be set, otherwise it will not be set.', 'if pcap_set_immediate_mode_apiparam_2 be non_zero , immediate mode be set , otherwise be set']
['pcap_tstamp_type_name_to_val_APIName  translates a time stamp type pcap_tstamp_type_name_to_val_APIParam_1 to the corresponding time stamp type value.', 'pcap_tstamp_type_name_to_val_apiname translate time stamp type pcap_tstamp_type_name_to_val_apiparam_1 corresponding time stamp type value']
['Under IRIX with snoop:', 'under irix snoop']
['prematurely terminate the loop in pcap_dispatch() or pcap_loop()', 'prematurely terminate loop pcap_dispatch or pcap_loop']
['pcap_snapshot_APIName  returns the snapshot length on success and PCAP_ERROR_NOT_ACTIVATED  if called on a capture handle that has been created but not activated.', 'pcap_snapshot_apiname return snapshot length success pcap_error_not_activate if call capture handle have create but activate']
['get a name or description for a link', 'get name or description link']
['pcap_dump_fopen_APIName  is called to write data to an existing open stream pcap_dump_fopen_APIParam_2;  this stream will be closed by a subsequent call to pcap_dump_close_APIName.', 'pcap_dump_fopen_apiname be call write datum exist open stream pcap_dump_fopen_apiparam_2 ; stream be close by subsequent call pcap_dump_close_apiname']
['If pcap_set_protocol_linux_APIParam_2  is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured.', 'if pcap_set_protocol_linux_apiparam_2 be non_zero , packet pcap_set_protocol_linux_apiparam_2 be capture when handle be activate , otherwise , packet be capture']
['create a live capture handle', 'create live capture handle']
['pcap_can_set_rfmon_APIName  returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error.', 'pcap_can_set_rfmon_apiname return # if monitor mode could be set , # if monitor mode could be set , negative value error']
["If pcap_fileno_APIParam_1  refers to a ``savefile'' that was opened using functions such as pcap_open_offline_APIName  or pcap_fopen_offline_APIName,  a ``dead'' pcap_t  opened using pcap_open_dead_APIName,  or a pcap_t  that was created with pcap_create_APIName  but that has not yet been activated with pcap_activate_APIName,  it returns PCAP_ERROR.", 'if pcap_fileno_apiparam_1 refer savefile be open use function such as pcap_open_offline_apiname or pcap_fopen_offline_apiname , dead pcap_t open use pcap_open_dead_apiname , or pcap_t be create pcap_create_apiname but have yet activate pcap_activate_apiname , return pcap_error']
['get a list of link-layer header types for a device', 'get list link_layer header type device']
['This function became available in libpcap release 1.5.0.', 'function become available libpcap release #']
['This interface is obsoleted by  pcap_findalldevs_APIName.', 'interface be obsolete by pcap_findalldevs_apiname']
["To obtain the FILE * corresponding to a pcap_t opened for a ``savefile'', call pcap_file().", 'obtain file corresponding pcap_t open savefile , call pcap_file']
['pcap_free_datalinks(3PCAP)', 'pcap_free_datalink 3pcap']
['read packets from a pcap_t until an interrupt or error occurs', 'read packet pcap_t until interrupt or error occur']
['set packet buffer timeout for a not-yet-activated pcap_t for live capture', 'set packet buffer timeout not_yet_activate pcap_t live capture']
['set time stamp precision for a not-yet-activated pcap_t for live capture', 'set time stamp precision not_yet_activate pcap_t live capture']
['find the default device on which to capture', 'find default device which capture']
['If PCAP_ERROR  is returned, pcap_lookupnet_APIParam_4  is filled in with an appropriate error message.', 'if pcap_error be return , pcap_lookupnet_apiparam_4 be fill appropriate error message']
['It must be called on a pcap descriptor created by pcap_create_APIName  that has not yet been activated by pcap_activate_APIName.', 'must be call pcap descriptor create by pcap_create_apiname have yet activate by pcap_activate_apiname']
['pcap_dump_open_APIParam_2  specifies the name of the file to open.', 'pcap_dump_open_apiparam_2 specifie name file open']
['If called directly, the pcap_dump_APIParam_1  parameter is of type pcap_dumper_t  as returned by pcap_dump_open_APIName.', 'if call directly , pcap_dump_apiparam_1 parameter be type pcap_dumper_t as return by pcap_dump_open_apiname']
["pcap_strerror_APIName  is provided in case strerror_APIName  isn't available.", 'pcap_strerror_apiname be provide case strerror_apiname be available']
["The packets read from the handle may include a ``pseudo-header'' containing various forms of packet meta-data, and probably includes a link-layer header whose contents can differ for different network interfaces. To determine the format of the packets supplied by the handle, call pcap_datalink(); https://www.tcpdump.org/linktypes.html lists the values it returns and describes the packet formats that correspond to those values.", 'packet read handle include pseudo_header contain various form packet meta_data , probably include link_layer header whose content can differ different network interface . determine format packet supply by handle , call pcap_datalink ; https : list value return describe packet format correspond value']
["If PCAP_WARNING_PROMISC_NOTSUP,  PCAP_ERROR_NO_SUCH_DEVICE,  or PCAP_ERROR_PERM_DENIED  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_activate_APIParam_1  as an argument to fetch or display an message giving additional details about the problem that might be useful for debugging the problem if it's unexpected.", 'if pcap_warning_promisc_notsup , pcap_error_no_such_device , or pcap_error_perm_deni be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message give additional detail about problem may be useful debug problem if be unexpected']
["Reading a saved packet file doesn't require special privileges.", 'read saved packet file do require special privilege']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_setfilter_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_setfilter_apiparam_1 as argument fetch or display error text']
['open a pcap_dumper_t for a ``savefile``, given a pathname', 'open pcap_dumper_t savefile , give pathname']
['NOTE: in libpcap 1.8.0 and later, pcap_compile_APIName  can be used in multiple threads within a single process.', 'note : libpcap # later , pcap_compile_apiname can be use multiple thread within single process']
['The packet data is not to be freed by the caller, and is not guaranteed to be valid after the next call to pcap_next_ex_APIName,  pcap_next_APIName,  pcap_loop_APIName,  or pcap_dispatch_APIName;  if the code needs it to remain valid, it must make a copy of it.', 'packet datum be be free by caller , be guarantee be valid after next call pcap_next_ex_apiname , pcap_next_apiname , pcap_loop_apiname , or pcap_dispatch_apiname ; if code need remain valid , must make copy']
['pcap_get_selectable_fd_APIName  returns, on UNIX, a file descriptor number for a file descriptor on which one can do a select_APIName,  poll_APIName,  epoll_wait_APIName,  kevent_APIName,  or other such call to wait for it to be possible to read packets without blocking, if such a descriptor exists, or PCAP_ERROR,  if no such descriptor exists.', 'pcap_get_selectable_fd_apiname return , unix , file descriptor number file descriptor which one can select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname , or other such call wait be possible read packet without block , if such descriptor exist , or pcap_error , if no such descriptor exist']
['set the direction for which packets will be captured', 'set direction which packet be capture']
['It is typically used when just using libpcap for compiling BPF code; it can also be used if using pcap_dump_open_APIName,  pcap_dump_APIName,  and pcap_dump_close_APIName  to write a savefile if there is no pcap_t  that supplies the packets to be written.', 'be typically use when just use libpcap compile bpf code ; can be use if use pcap_dump_open_apiname , pcap_dump_apiname , pcap_dump_close_apiname write savefile if be no pcap_t supply packet be write']
['ps_recv  might count packets whether they passed any filter set with pcap_setfilter_APIName  or not, or it might count only packets that pass the filter.', 'ps_recv may count packet whether pass filter set pcap_setfilter_apiname or , or may count only packet pass filter']
['close a pcap_dumper_t', 'close pcap_dumper_t']
['pcap_dump_open_append_APIName  is like pcap_dump_open_APIName  but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1,  it will write new packets at the end of the file.', 'pcap_dump_open_append_apiname be like pcap_dump_open_apiname but do create file if do exist , if do already exist , be pcap file byte order as host opening file , have time stamp precision , link_layer header type , snapshot length as pcap_dump_open_apiparam_1 , write packet end file']
['The list of devices must be freed with pcap_freealldevs_APIName,  which frees the list pointed to by pcap_freealldevs_APIParam_1.', 'list device must be free pcap_freealldevs_apiname , which free list point by pcap_freealldevs_apiparam_1']
["pcap_datalink_APIName  returns the link-layer header type for the live capture or ``savefile'' specified by pcap_datalink_APIParam_1.", 'pcap_datalink_apiname return link_layer header type live capture or savefile specify by pcap_datalink_apiparam_1']
['The device for which pcap_get_selectable_fd_APIName  returned PCAP_ERROR  must be put in non-blocking mode with pcap_setnonblock_APIName,  and an attempt must always be made to read packets from the device when the select_APIName,  poll_APIName,  epoll_wait_APIName,  or kevent_APIName  call returns.', 'device which pcap_get_selectable_fd_apiname return pcap_error must be put non_block mode pcap_setnonblock_apiname , attempt must always be make read packet device when select_apiname , poll_apiname , epoll_wait_apiname , or kevent_apiname call return']
['set the packet buffer timeout for a not', 'set packet buffer timeout']
['if not NULL,  a pointer to the next element in the list; NULL  for the last element of the list addr', 'if null , pointer next element list ; null last element list addr']
['In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available.', 'previous release , time stamp type can be set ; only default time stamp type offer by capture source be available']
['pcap_tstamp_type_val_to_name_APIName  translates a time stamp type value to the corresponding time stamp type name.', 'pcap_tstamp_type_val_to_name_apiname translate time stamp type value correspond time stamp type name']
['In that case, those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName  for the device for which pcap_get_selectable_fd_APIName  returned PCAP_ERROR,  the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName,  and an attempt must always be made to read packets from the device when the call returns.', 'case , call must be give timeout less than or equal timeout return by pcap_get_required_select_timeout_apiname device which pcap_get_selectable_fd_apiname return pcap_error , device must be put non_block mode call pcap_setnonblock_apiname , attempt must always be make read packet device when call return']
['To get a string giving version information about libpcap, call pcap_lib_version().', 'get stre give version information about libpcap , call pcap_lib_version']
['pcap_setfilter(3PCAP)', 'pcap_setfilter 3pcap']
["Note that, on some platforms, the link-layer header of the packet that's sent might not be the same as the link-layer header of the packet supplied to pcap_inject_APIName,  as the source link-layer address, if the header contains such an address, might be changed to be the address assigned to the interface on which the packet it sent, if the platform doesn't support sending completely raw and unchanged packets.", 'note , platform , link_layer header packet send may be as link_layer header packet supply pcap_inject_apiname , as source link_layer address , if header contain such address , may be change be address assign interface which packet send , if platform do support send completely raw unchanged packet']
['pcap_next(3PCAP)', 'pcap_next 3pcap']
['pcap_set_promisc_APIName  sets whether promiscuous mode should be set on a capture handle when the handle is activated.', 'pcap_set_promisc_apiname set whether promiscuous mode should be set capture handle when handle be activate']
['pcap_set_protocol_linux_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_protocol_linux_apiname return # success or pcap_error_activat if call capture handle have activate']
['pcap_datalink_val_to_name_APIName  translates a link-layer header type value to the corresponding link-layer header type name, which is the DLT_  name for the link-layer header type value with the DLT_  removed.', 'pcap_datalink_val_to_name_apiname translate link_layer header type value correspond link_layer header type name , which be dlt name link_layer header type value dlt remove']
['However, in earlier versions of libpcap, it is not  safe to use pcap_compile_APIName  in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time.', 'however , early version libpcap , be safe pcap_compile_apiname multiple thread single process without form mutual exclusion allow only one thread call give time']
['Opening a handle for writing captured packets', 'open handle write capture packet']
["pcap_loop_APIName  returns 0 if pcap_loop_APIParam_2  is exhausted or if, when reading from a ``savefile'', no more packets are available.", 'pcap_loop_apiname return # if pcap_loop_apiparam_2 be exhaust or if , when read savefile , no more packet be available']
['set immediate mode for a not-yet-activated pcap_t for live capture', 'set immediate mode not_yet_activated pcap_t live capture']
['pcap_dump_fopen(3PCAP)', 'pcap_dump_fopen 3pcap']
['It returns an pcap_strerror_APIParam_1 message string corresponding to pcap_strerror_APIParam_1.', 'return pcap_strerror_apiparam_1 message string correspond pcap_strerror_apiparam_1']
['get list of available time stamp types for a not-yet-activated pcap_t for live capture', 'get list available time stamp type not_yet_activate pcap_t live capture']
['read the next packet from a pcap_t with an error indication on an error', 'read next packet pcap_t error indication error']
['Van Jacobson, Craig Leres and Steven McCanne, all of the Lawrence Berkeley National Laboratory, University of California, Berkeley, CA.', 'van jacobson , craig lere steven mccanne , lawrence berkeley national laboratory , university california , berkeley , ca']
['The returned handle must be activated with pcap_activate_APIName  before packets can be captured with it; options for the capture, such as promiscuous mode, can be set on the handle before activating it.', 'return handle must be activate pcap_activate_apiname before packet can be capture ; option capture , such as promiscuous mode , can be set handle before activate']
['get the time stamp type value corresponding to a time stamp type name', 'get time stamp type value correspond time stamp type name']
["pcap_file_APIName  returns the standard I/O stream of the ``savefile,'' if a ``savefile'' was opened with pcap_open_offline_APIName,  or NULL,  if a network device was opened with pcap_create_APIName  and pcap_activate_APIName,  or with pcap_open_live_APIName.", 'pcap_file_apiname return standard stream savefile , if savefile be open pcap_open_offline_apiname , or null , if network device be open pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname']
['set capture protocol for a not-yet-activated pcap_t for live capture (Linux only)', 'set capture protocol not_yet_activated pcap_t live capture linux only']
['set if the device is running PCAP_IF_WIRELESS', 'set if device be run pcap_if_wireless']
['Do NOT  assume that the packets for a given capture or ``savefile`` will have any given link-layer header type, such as DLT_EN10MB  for Ethernet.', 'assume packet give capture or savefile have give link_layer header type , such as dlt_en10 mb ethernet']
['pcap_create_APIName  is used to create a packet capture handle to look at packets on the network.', 'pcap_create_apiname be use create packet capture handle look packet network']
["create a ``fake'' pcap_t", 'create fake pcap_t']
['open a saved capture file for reading', 'open saved capture file reading']
['pcap_next_ex_APIName  reads the next packet and returns a success/failure indication.', 'pcap_next_ex_apiname read next packet return indication']
['pcap_statustostr_APIName  converts a PCAP_ERROR_  or PCAP_WARNING_  value returned by a libpcap routine to an pcap_statustostr_APIParam_1 string.', 'pcap_statustostr_apiname convert pcap_error or pcap_warn value return by libpcap routine pcap_statustostr_apiparam_1 string']
['set the buffer size for a not', 'set buffer size']
['pcap_get_tstamp_precision(3PCAP)', 'pcap_get_tstamp_precision 3pcap']
['a bitmask for an indication of whether the adapter is connected or not; for wireless interfaces, "connected" means "associated with a network" The possible values for the connection status bits are: PCAP_IF_CONNECTION_STATUS_UNKNOWN', 'bitmask indication whether adapter be connect or ; wireless interface , connected mean associate network possible value connection status bit be : pcap_if_connection_status_unknown']
['pcap_list_tstamp_types_APIName  is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor.', 'pcap_list_tstamp_types_apiname be use get list support time stamp type interface associate pcap descriptor']
['pcap_findalldevs(3PCAP)', 'pcap_findalldevs 3pcap']
['A pointer to a pcap_dumper_t  structure to use in subsequent pcap_dump_APIName  and pcap_dump_close_APIName  calls is returned on success.', 'pointer pcap_dumper_t structure subsequent pcap_dump_apiname pcap_dump_close_apiname call be return success']
["The process doesn't have permission to check whether monitor mode could be supported.", 'process do have permission check whether monitor mode could be support']
['get description for a time stamp type', 'get description time stamp type']
['Another warning condition occurred; pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_activate_APIParam_1  as an argument to fetch or display a message describing the warning condition.', 'another warning condition occur ; pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message describe warning condition']
['number of packets received; ps_drop', 'number packet receive ; ps_drop']
["NOTE: the packet buffer timeout cannot be used to cause calls that read packets to return within a limited period of time, because, on some platforms, the packet buffer timeout isn't supported, and, on other platforms, the timer doesn't start until at least one packet arrives. This means that the packet buffer timeout should NOT be used, for example, in an interactive application to allow the packet capture loop to ``poll'' for user input periodically, as there's no guarantee that a call reading packets will return after the timeout expires even if no packets have arrived.", 'note : packet buffer timeout can be use cause call read packet return within limited period time , because , platform , packet buffer timeout be support , , other platform , timer do start until least one packet arrive . mean packet buffer timeout should be use , example , interactive application allow packet capture loop poll user input periodically , as no guarantee call read packet return after timeout expire even if no packet have arrive']
['attempt to get a timeout required for using a pcap_t in calls such as select(2) and poll(2)', 'attempt get timeout require use pcap_t call such as select poll 2']
['timestamp type', 'timestamp type']
['If you have the required privileges, you can inject packets onto a network with a pcap_t for a live capture, using pcap_inject() or pcap_sendpacket(). (The two routines exist for compatibility with both OpenBSD and WinPcap; they perform the same function, but have different return values.)', 'if -PRON- have require privilege , -PRON- can inject packet onto network pcap_t live capture , use pcap_inject or pcap_sendpacket . two routine exist compatibility both openbsd winpcap ; perform function , but have different return value']
['open a file to which to write packets', 'open file which write packet']
['get the version information for libpcap', 'get version information libpcap']
['immediate mode', 'immediate mode']
['When pcap_open_dead_with_tstamp_precision_APIName,  is used to create a pcap_t  for use with pcap_dump_open_APIName,  precision  specifies the time stamp precision for packets; PCAP_TSTAMP_PRECISION_MICRO  should be specified if the packets to be written have time stamps in seconds and microseconds, and PCAP_TSTAMP_PRECISION_NANO  should be specified if the packets to be written have time stamps in seconds and nanoseconds.', 'when pcap_open_dead_with_tstamp_precision_apiname , be use create pcap_t pcap_dump_open_apiname , precision specifie time stamp precision packet ; pcap_tstamp_precision_micro should be specify if packet be write have time stamp second microsecond , pcap_tstamp_precision_nano should be specify if packet be write have time stamp second nanosecond']
['The time stamp precision, link-layer type, and snapshot length from pcap_dump_fopen_APIParam_1  are used as the link-layer type and snapshot length of the output file.', 'time stamp precision , link_layer type , snapshot length pcap_dump_fopen_apiparam_1 be use as link_layer type snapshot length output file']
['Some devices may provide more than one link-layer header type. To obtain a list of all link-layer header types provided by a device, call pcap_list_datalinks() on an activated pcap_t for the device. To free a list of link-layer header types, call pcap_free_datalinks(). To set the link-layer header type for a device, call pcap_set_datalink(). This should be done after the device has been activated but before any packets are read and before any filters are compiled or installed.', 'device provide more than one link_layer header type . obtain list link_layer header type provide by device , call pcap_list_datalink activate pcap_t device . free list link_layer header type , call pcap_free_datalinks . set link_layer header type device , call pcap_set_datalink . should be do after device have activate but before packet be read before filter be compile or instal']
['pcap_set_tstamp_precision_APIName  returns 0 on success if the specified time stamp precision is expected to be supported by the capture device, PCAP_ERROR_TSTAMP_PRECISION_NOTSUP  if the capture device does not support the requested time stamp precision, PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_tstamp_precision_apiname return # success if specify time stamp precision be expect be support by capture device , pcap_error_tstamp_precision_notsup if capture device do support request time stamp precision , pcap_error_activat if call capture handle have activate']
['pcap_set_timeout(3PCAP)', 'pcap_set_timeout 3pcap']
['https://www.tcpdump.org/linktypes.html  lists the values pcap_datalink_APIName  can return and describes the packet formats that correspond to those values.', 'https : list value pcap_datalink_apiname can return describe packet format correspond value']
["Monitor mode was specified but the capture source doesn't support monitor mode.", 'monitor mode be specify but capture source do support monitor mode']
['get a list of time stamp types supported by a capture device, and free that list', 'get list time stamp type support by capture device , free list']
['pcap_open_live_APIParam_1  is a string that specifies the network pcap_open_live_APIParam_1 to open; on Linux systems with 2.2 or later kernels, a pcap_open_live_APIParam_1  argument of "any" or NULL  can be used to capture packets from all interfaces.', 'pcap_open_live_apiparam_1 be stre specifie network pcap_open_live_apiparam_1 open ; linux system # or later kernel , pcap_open_live_apiparam_1 argument or null can be use capture packet interface']
['A selectable file descriptor is returned if one exists; otherwise, PCAP_ERROR  is returned.', 'selectable file descriptor be return if one exist ; otherwise , pcap_error be return']
['pcap_major_version(3PCAP)', 'pcap_major_version 3pcap']
['Both pcap_lookupnet_APIParam_2  and pcap_lookupnet_APIParam_3  are bpf_u_int32  pointers.', 'both pcap_lookupnet_apiparam_2 pcap_lookupnet_apiparam_3 be bpf_u_int32 pointer']
['pcap_close(3PCAP)', 'pcap_close 3pcap']
['If there is an error, PCAP_ERROR  is returned and pcap_getnonblock_APIParam_2  is filled in with an appropriate error message.', 'if be error , pcap_error be return pcap_getnonblock_apiparam_2 be fill appropriate error message']
['pcap_lookupnet_APIParam_4  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'pcap_lookupnet_apiparam_4 be assume be able hold least pcap_errbuf_size char']
['PCAP_D_IN  will only capture packets received by the device, PCAP_D_OUT  will only capture packets sent by the device and PCAP_D_INOUT  will capture packets received by or sent by the device.', 'pcap_d_in only capture packet receive by device , pcap_d_out only capture packet send by device pcap_d_inout capture packet receive by or send by device']
['Non-blocking mode is often combined with routines such as select(2) or poll(2) or other routines a platform offers to wait for any of a set of descriptors to be ready to read. To obtain, for a handle, a descriptor that can be used in those routines, call pcap_get_selectable_fd(). If the routine indicates that data is available to read on the descriptor, an attempt should be made to read from the device.', 'non_block mode be often combine routine such as select or poll or other routine platform offer wait set descriptor be ready read . obtain , handle , descriptor can be use routine , call pcap_get_selectable_fd . if routine indicate datum be available read descriptor , attempt should be make read device']
["You must have read access to /dev/bpf* on systems that don't have a cloning BPF device, or to /dev/bpf on systems that do. On BSDs with a devfs (this includes macOS), this might involve more than just having somebody with super-user access setting the ownership or permissions on the BPF devices - it might involve configuring devfs to set the ownership or permissions every time the system is booted, if the system even supports that; if it doesn't support that, you might have to find some other way to make that happen at boot time.", 'PRON- must have read access system have clone bpf device , or system . bsd devfs , may involve more than just have somebody super_user access set ownership or permission bpf device may involve configure devfs set ownership or permission every time system be boot , if system even support ; if do support , -PRON- may have find other way make happen boot time']
['Some routines return error or warning status codes; to convert them to a string, use pcap_statustostr().', 'routine return error or warning status code ; convert -PRON- string , pcap_statustostr']
['get name for a time stamp type', 'get name time stamp type']
['pcap_snapshot(3PCAP)', 'pcap_snapshot 3pcap']
['The capture source device is not up.', 'capture source device be up']
['set monitor mode for a not-yet-activated pcap_t for live capture', 'set monitor mode not_yet_activated pcap_t live capture']
["number of packets dropped because there was no room in the operating system's buffer when they arrived, because packets weren't being read fast enough; ps_ifdrop", 'number packet drop because be no room operate system buffer when arrive , because packet weren t read fast enough ; ps_ifdrop']
['If PCAP_ERROR_BREAK  is returned from pcap_dispatch_APIName  or pcap_loop_APIName,  the flag is cleared, so a subsequent call will resume reading packets.', 'if pcap_error_break be return pcap_dispatch_apiname or pcap_loop_apiname , flag be clear , so subsequent call resume read packet']
['It returns PCAP_ERROR  if an error occurs or PCAP_ERROR_BREAK  if the loop terminated due to a call to pcap_breakloop_APIName  before any packets were processed.', 'return pcap_error if error occur or pcap_error_break if loop terminate due call pcap_breakloop_apiname before packet be process']
['pcap_list_datalinks_APIName  allocates an array to hold the list and sets *dlt_buf  to point to that array.', 'pcap_list_datalinks_apiname allocate array hold list set dlt_buf point array']
["open a pcap_t for a ``savefile'', given a pathname, and specify the precision to provide for packet time stamps", 'open pcap_t savefile , give pathname , specify precision provide packet time stamp']
['get a file descriptor on which a select() can be done for a live capture', 'get file descriptor which select can be do live capture']
['It does not  return when live packet buffer timeouts occur.', 'do return when live packet buffer timeout occur']
['If, when capturing, packets are delivered as soon as they arrive, the application capturing the packets will be woken up for each packet as it arrives, and might have to make one or more calls to the operating system to fetch each packet.', 'if , when capture , packet be deliver as soon as arrive , application capturing packet be wake up each packet as arrive , may have make one or more call operate system fetch each packet']
['The possible error values are:  PCAP_ERROR_NO_SUCH_DEVICE', 'possible error value be : pcap_error_no_such_device']
["In ``non-blocking'' mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName  will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive.", 'non_block mode , attempt read capture descriptor pcap_dispatch_apiname , if no packet be currently available be read , return # immediately rather than block wait packet arrive']
['free list of devices', 'free list device']
["IPv4 addresses have the value AF_INET,  IPv6 addresses have the value AF_INET6  (which older operating systems that don't support IPv6 might not define), and other addresses have other values.", 'ipv4 address have value af_inet , ipv6 address have value af_inet6 , other address have other value']
['force a pcap_dispatch() or pcap_loop() call to return', 'force pcap_dispatch or pcap_loop call return']
["You must be root or the application capturing packets must be installed setuid to root (unless your distribution has a kernel that supports capability bits such as CAP_NET_RAW and code to allow those capability bits to be given to particular accounts and to cause those bits to be set on a user's initial processes when they log in, in which case you must have CAP_NET_RAW in order to capture and CAP_NET_ADMIN to enumerate network devices with, for example, the -D flag).", 'PRON- must be root or application capturing packet must be instal setuid root unless -PRON- distribution have kernel support capability bit such as cap_net_raw code allow capability bit be give particular account cause bit be set user initial process when log , which case -PRON- must have cap_net_raw order capture cap_net_admin enumerate network device , example , d flag']
['These functions became available in libpcap release 1.2.1.', 'function become available libpcap release #']
['If there is an error, NULL  is returned and pcap_lookupdev_APIParam_1  is filled in with an appropriate error message.', 'if be error , null be return pcap_lookupdev_apiparam_1 be fill appropriate error message']
['set the link', 'set link']
['In previous releases, if immediate delivery of packets is required:', 'previous release , if immediate delivery packet be require']
['get the version number of a savefile', 'get version number savefile']
['set immediate mode for a not', 'set immediate mode']
["pcap_stats_APIName  is supported only on live captures, not on ``savefiles''; no statistics are stored in ``savefiles'', so no statistics are available when reading from a ``savefile''.", 'pcap_stats_apiname be support only live capture , savefile ; no statistic be store savefile , so no statistic be available when read savefile']
['pcap_next_ex() is passed two pointer arguments, one of which points to a structpcap_pkthdr* and one of which points to a const u_char*. It sets the first pointer to point to a struct pcap_pkthdr structure with the time stamp and length values for the packet, and sets the second pointer to point to the first caplen bytes of the packet.', 'pcap_next_ex be pass two pointer argument , one which point structpcap_pkthdr one which point const u_char . set first pointer point struct pcap_pkthdr structure time stamp length value packet , set second pointer point first caplen byte packet']
['pcap_create_APIName  returns a pcap_t *  on success and NULL  on failure.', 'pcap_create_apiname return pcap_t success null failure']
['pcap_get_selectable_fd(3PCAP)', 'pcap_get_selectable_fd 3pcap']
["if not NULL,  a pointer to a struct sockaddr  that contains the destination address corresponding to the address pointed to by addr;  may be null if the device isn't a point-to-point interface", 'if null , pointer struct sockaddr contain destination address correspond address point by addr ; be null if device be point_to_point interface']
['pcap_datalink_name_to_val(3PCAP)', 'pcap_datalink_name_to_val 3pcap']
['set time stamp type for a not-yet-activated pcap_t for live capture', 'set time stamp type not_yet_activate pcap_t live capture']
['get first non-loopback device on that list', 'get first non_loopback device list']
["This will be zero if the packet doesn't match the filter and non-zero if the packet matches the filter.", 'be zero if packet do match filter non_zero if packet match filter']
['You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls in order to unblock the thread, such as thread cancellation or thread signalling in systems that support POSIX threads, or SetEvent_APIName  on the result of pcap_getevent_APIName  on a pcap_t  on which the thread is blocked on Windows.', 'PRON- need whatever mechanism os provide break thread out blocking call order unblock thread , such as thread cancellation or thread signal system support posix thread , or setevent_apiname result pcap_getevent_apiname pcap_t which thread be block window']
['get capture statistics', 'get capture statistic']
['The packet buffer timeout is set with pcap_set_timeout().', 'packet buffer timeout be set pcap_set_timeout']
['pcap_set_buffer_size(3PCAP)', 'pcap_set_buffer_size 3pcap']
["select_APIName,  poll_APIName,  and kevent_APIName  do not work correctly on BPF devices; pcap_get_selectable_fd_APIName  will return a file descriptor on most of those versions (the exceptions being FreeBSD 4.3 and 4.4), but a simple select_APIName,  poll_APIName,  or kevent_APIName  call will not indicate that the descriptor is readable until a full buffer's worth of packets is received, even if the packet timeout expires before then.", 'select_apiname , poll_apiname , kevent_apiname work correctly bpf device ; pcap_get_selectable_fd_apiname return file descriptor most version , but simple select_apiname , poll_apiname , or kevent_apiname call indicate descriptor be readable until full buffer worth packet be receive , even if packet timeout expire before then']
['buffer size', 'buffer size']
['The pointer returned by pcap_lookupdev_APIName  points to a static buffer; subsequent calls to pcap_lookupdev_APIName  in the same thread, or calls to pcap_lookupdev_APIName  in another thread, may overwrite that buffer.', 'pointer return by pcap_lookupdev_apiname point static buffer ; subsequent call pcap_lookupdev_apiname thread , or call pcap_lookupdev_apiname another thread , overwrite buffer']
["get the FILE * for a pcap_t opened for a ``savefile''", 'get file pcap_t open savefile']
['free a BPF program', 'free bpf program']
['In "monitor mode", sometimes also called "rfmon mode" (for "Radio Frequency MONitor"), the adapter will supply all frames that it receives, with 802.11 headers, and might supply a pseudo-header with radio information about the frame as well.', 'monitor mode , sometimes call rfmon mode , adapter supply frame receive , header , may supply pseudo_header radio information about frame as well']
['pcap_sendpacket(3PCAP)', 'pcap_sendpacket 3pcap']
['The capture handle has already been activated.', 'capture handle have already activate']
['pcap_tstamp_type_name_to_val_APIName  returns time stamp type value on success and PCAP_ERROR  on failure.', 'pcap_tstamp_type_name_to_val_apiname return time stamp type value success pcap_error failure']
['pcap_datalink_val_to_description_APIName  translates a link-layer header type value to a short description of that link-layer header type.', 'pcap_datalink_val_to_description_apiname translate link_layer header type value short description link_layer header type']
['If pcap_get_required_select_timeout_APIName  returns NULL,  it is not possible to wait for packets to arrive on the device in an event loop.', 'if pcap_get_required_select_timeout_apiname return null , be possible wait packet arrive device event loop']
['(pcap_inject_APIName  comes from OpenBSD; pcap_sendpacket_APIName  comes from WinPcap.', 'pcap_inject_apiname come openbsd ; pcap_sendpacket_apiname come winpcap']
['pcap_lookupnet_APIName  is used to determine the IPv4 network number and mask associated with the network pcap_lookupnet_APIParam_1 pcap_lookupnet_APIParam_1.', 'pcap_lookupnet_apiname be use determine ipv4 network number mask associate network pcap_lookupnet_apiparam_1 pcap_lookupnet_apiparam_1']
['Even worse, some drivers on some platforms might change the link-layer type field to whatever value libpcap used when attaching to the device, even on platforms that do  nominally support sending completely raw and unchanged packets.', 'even bad , driver platform may change link_layer type field whatever value libpcap use when attach device , even platform nominally support send completely raw unchanged packet']
['On other platforms, capture devices are always in immediate mode.', 'other platform , capture device be always immediate mode']
['For example, the "any" device on Linux will have a link-layer header type of DLT_LINUX_SLL  even if all devices on the system at the time the "any" device is opened have some other data link type, such as DLT_EN10MB  for Ethernet.', 'example , device linux have link_layer header type dlt_linux_sll even if device system time device be open have other datum link type , such as dlt_en10 mb ethernet']
['If NULL  is returned, pcap_geterr_APIName  can be used to get the error text.', 'if null be return , pcap_geterr_apiname can be use get error text']
['In immediate mode, packets are always delivered as soon as they arrive, with no buffering.', 'immediate mode , packet be always deliver as soon as arrive , no buffering']
['The statistics do not behave the same way on all platforms.', 'statistic behave way platform']
['Unfortunately, there is no way to determine whether an error occurred or not.', 'unfortunately , be no way determine whether error occur or']
['Reading packets from a network interface may require that you have special privileges:', 'read packet network interface require -PRON- have special privilege']
['pcap_activate(3PCAP)', 'pcap_activate 3pcap']
['snaplen  specifies the snapshot length for the pcap_t.', 'snaplen specifie snapshot length pcap_t']
['The values represent packet statistics from the start of the run to the time of the call.', 'value represent packet statistic start run time call']
['process packets from a live capture or savefile', 'process packet live capture or savefile']
['pcap_stats(3PCAP)', 'pcap_stats 3pcap']
['You must be root or the application capturing packets must be installed setuid to root.', 'PRON- must be root or application capturing packet must be instal setuid root']
['pcap_set_snaplen_APIName  sets the snapshot length to be used on a capture handle when the handle is activated to pcap_set_snaplen_APIParam_2.', 'pcap_set_snaplen_apiname set snapshot length be use capture handle when handle be activate pcap_set_snaplen_apiparam_2']
['pcap_activate_APIName  is used to activate a packet capture handle to look at packets on the network, with the options that were set on the handle being in effect.', 'pcap_activate_apiname be use activate packet capture handle look packet network , option be set handle effect']
["A return value of one means that the only time stamp type supported is the one in the list, which is the capture device's default time stamp type.", 'return value one mean only time stamp type support be one list , which be capture device default time stamp type']
['pcap_breakloop_APIName  does not guarantee that no further packets will be processed by pcap_dispatch_APIName  or pcap_loop_APIName  after it is called; at most one more packet might be processed.', 'pcap_breakloop_apiname do guarantee no further packet be process by pcap_dispatch_apiname or pcap_loop_apiname after be call ; most one more packet may be process']
['NOTE:  the pointer it returns will no longer point to a valid error message string after the pcap_t  passed to it is closed; you must use or copy the string before closing the pcap_t.', 'note : pointer return no longer point valid error message string after pcap_t pass be close ; -PRON- must or copy string before closing pcap_t']
['pcap_is_swapped(3PCAP)', 'pcap_is_swapp 3pcap']
['pcap_list_tstamp_types_APIName  will give a list of the time stamp types supported by a given capture device.', 'pcap_list_tstamp_types_apiname give list time stamp type support by give capture device']
['If pcap_major_version_APIParam_1  refers to a live capture, the values returned by pcap_major_version_APIName  and pcap_minor_version_APIName  are not meaningful.', 'if pcap_major_version_apiparam_1 refer live capture , value return by pcap_major_version_apiname pcap_minor_version_apiname be meaningful']
['errbuf  is assumed to be able to hold at least PCAP_ERRBUF_SIZE  chars.', 'errbuf be assume be able hold least pcap_errbuf_size char']
['By default, time stamps are in microseconds.', 'by default , time stamp be microsecond']
['linktype  specifies the link-layer type for the pcap_t.', 'linktype specifie link_layer type pcap_t']
['close a capture device or savefile', 'close capture device or savefile']
['a bpf_u_int32 giving the length of the packet, in bytes (which might be more than the number of bytes available from the capture, if the length of the packet is larger than the maximum number of bytes to capture).', 'bpf_u_int32 give length packet , byte which may be more than number byte available capture , if length packet be large than maximum number byte capture']
['Additional warning and error codes may be added in the future; a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors.', 'additional warning error code be add future ; program should check positive , negative , zero return code , treat positive return code as warning negative return code as error']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_list_datalinks_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_list_datalinks_apiparam_1 as argument fetch or display error text']
["read a bufferful of packets from a pcap_t open for a live capture or the full set of packets from a pcap_t open for a ``savefile''", 'read bufferful packet pcap_t open live capture or full set packet pcap_t open savefile']
['pcap_tstamp_type_val_to_description_APIName  translates a time stamp type value to a short description of that time stamp type.', 'pcap_tstamp_type_val_to_description_apiname translate time stamp type value short description time stamp type']
['The translation is case-insensitive.', 'translation be case_insensitive']
['pcap_compile_APIName  is used to compile the string pcap_compile_APIParam_3  into a filter program.', 'pcap_compile_apiname be use compile stre pcap_compile_apiparam_3 into filter program']
['See pcap-tstamp_APIName  for a list of all the time stamp types.', 'see pcap_tstamp_apiname list time stamp type']
['BACKWARD COMPATIBILITY', 'backward compatibility']
['A non-zero return value indicates what warning or error condition occurred.', 'non_zero return value indicate what warning or error condition occur']
['pcap_set_immediate_mode(3PCAP)', 'pcap_set_immediate_mode 3pcap']
['pcap - Packet Capture library  ', 'pcap packet capture library']
['To work around this, code that uses those calls to wait for packets to arrive must put the pcap_t  in non-blocking mode, and must arrange that the call have a timeout less than or equal to the packet buffer timeout, and must try to read packets after that timeout expires, regardless of whether the call indicated that the file descriptor for the pcap_t  is ready to be read or not.', 'work around , code use call wait packet arrive must put pcap_t non_blocking mode , must arrange call have timeout less than or equal packet buffer timeout , must try read packet after timeout expire , regardless whether call indicate file descriptor pcap_t be ready be read or']
['pcap_stats_APIName  fills in the struct pcap_stat  pointed to by its second argument.', 'pcap_stats_apiname fill struct pcap_stat point by second argument']
['pcap_freecode_APIName  is used to free up allocated memory pointed to by a pcap_freecode_APIParam_1  struct generated by pcap_compile_APIName  when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to pcap_setfilter_APIName.', 'pcap_freecode_apiname be use free up allocate memory point by pcap_freecode_apiparam_1 struct generate by pcap_compile_apiname when bpf program be no longer need , example after have make filter program pcap structure by call pcap_setfilter_apiname']
['pcap_get_tstamp_precision_APIName  returns PCAP_TSTAMP_PRECISION_MICRO  or PCAP_TSTAMP_PRECISION_NANO,  which indicates that pcap captures contains time stamps in microseconds or nanoseconds respectively.', 'pcap_get_tstamp_precision_apiname return pcap_tstamp_precision_micro or pcap_tstamp_precision_nano , which indicate pcap capture contain time stamp microsecond or nanosecond respectively']
['the adapter is connected PCAP_IF_CONNECTION_STATUS_DISCONNECTED', 'adapter be connect pcap_if_connection_status_disconnected']
['If NULL  is returned, pcap_open_offline_APIParam_2  is filled in with an appropriate error message.', 'if null be return , pcap_open_offline_apiparam_2 be fill appropriate error message']
['In previous releases, time stamps from a savefile are always given in seconds and microseconds.', 'previous release , time stamp savefile be always give second microsecond']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_next_ex_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_next_ex_apiparam_1 as argument fetch or display error text']
['If pcap_findalldevs_APIName  succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1  is set to point to the first element of the list, or to NULL  if no devices were found (this is considered success).', 'if pcap_findalldevs_apiname succeed , pointer point by pcap_findalldevs_apiparam_1 be set point first element list , or null if no device be find be consider success']
['number of packets dropped by the network interface or its driver.', 'number packet drop by network interface or driver']
['Each element of the list of addresses is of type pcap_addr_t,  and has the following members:', 'each element list address be type pcap_addr_t , have follow member']
['By default, when reading packets from an interface opened for a live capture, pcap_dispatch(), pcap_next(), and pcap_next_ex() will, if no packets are currently available to be read, block waiting for packets to become available. On some, but not all, platforms, if a packet buffer timeout was specified, the wait will terminate after the packet buffer timeout expires; applications should be prepared for this, as it happens on some platforms, but should not rely on it, as it does not happen on other platforms. Note that the wait might, or might not, terminate even if no packets are available; applications should be prepared for this to happen, but must not rely on it happening.', 'by default , when read packet interface open live capture , pcap_dispatch , pcap_next , pcap_next_ex , if no packet be currently available be read , block wait packet become available . , but , platform , if packet buffer timeout be specify , wait terminate after packet buffer timeout expire ; application should be prepare , as happen platform , but should rely , as do happen other platform . note wait may , or may , terminate even if no packet be available ; application should be prepare happen , but must rely happen']
['flush to a savefile packets dumped', 'flush savefile packet dump']
['pcap_list_tstamp_types_APIName  returns the number of time stamp types in the array on success and PCAP_ERROR  on failure.', 'pcap_list_tstamp_types_apiname return number time stamp type array success pcap_error failure']
['pcap_set_immediate_mode_APIName  returns 0 on success or PCAP_ERROR_ACTIVATED  if called on a capture handle that has been activated.', 'pcap_set_immediate_mode_apiname return # success or pcap_error_activat if call capture handle have activate']
['A snapshot length of 65535 should be sufficient, on most if not all networks, to capture all the data available from the packet.', 'snapshot length # should be sufficient , most if network , capture datum available packet']
['If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0.', 'if -PRON- application use pcap_breakloop_apiname , make sure -PRON- explicitly check pcap_error pcap_error_break , rather than just check return value #']
['a struct timeval containing the time when the packet was captured', 'struct timeval contain time when packet be capture']
["A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST,  which is the capture device's default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types).", 'return value zero mean only time stamp type support be pcap_tstamp_host , which be capture device default time stamp type only old version libpcap return ; new version always return one or more type']
["If pcap_major_version_APIParam_1  refers to a ``savefile'', pcap_major_version_APIName  returns the major number of the file format of the ``savefile'' and pcap_minor_version_APIName  returns the minor number of the file format of the ``savefile''.", 'if pcap_major_version_apiparam_1 refer savefile , pcap_major_version_apiname return major number file format savefile pcap_minor_version_apiname return minor number file format savefile']
['(See pcap_APIName  for an explanation of the packet buffer timeout.)', 'see pcap_apiname explanation packet buffer timeout']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_stats_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_stats_apiparam_1 as argument fetch or display error text']
['get the link', 'get link']
['a pointer to a struct sockaddr  containing an address netmask', 'pointer struct sockaddr contain address netmask']
['On Linux, with previous releases of libpcap, capture devices are always in immediate mode; however, in 1.5.0 and later, they are, by default, not  in immediate mode, so if pcap_set_immediate_mode_APIName  is available, it should be used.', 'linux , previous release libpcap , capture device be always immediate mode ; however , # later , be , by default , immediate mode , so if pcap_set_immediate_mode_apiname be available , should be use']
['Each element of the list is of type pcap_if_t,  and has the following members:', 'each element list be type pcap_if_t , have follow member']
['pcap_open_live_APIName  is used to obtain a packet capture handle to look at packets on the network.', 'pcap_open_live_apiname be use obtain packet capture handle look packet network']
["To write a packet to a pcap_dumper_t, call pcap_dump(). Packets written with pcap_dump() may be buffered, rather than being immediately written to the ``savefile''. Closing the pcap_dumper_t will cause all buffered-but-not-yet-written packets to be written to the ``savefile''. To force all packets written to the pcap_dumper_t, and not yet written to the ``savefile'' because they're buffered by the pcap_dumper_t, to be written to the ``savefile'', without closing the pcap_dumper_t, call pcap_dump_flush().", 'write packet pcap_dumper_t , call pcap_dump . packet write pcap_dump be buffer , rather than immediately write savefile . close pcap_dumper_t cause buffered_but_not_yet_written packet be write savefile . force packet write pcap_dumper_t , yet write savefile because re buffer by pcap_dumper_t , be write savefile , without close pcap_dumper_t , call pcap_dump_flush']
['pcap_set_datalink_APIName  returns 0 on success and PCAP_ERROR  on failure.', 'pcap_set_datalink_apiname return # success pcap_error failure']
["Packets that arrive for a capture are stored in a buffer, so that they do not have to be read by the application as soon as they arrive. On some platforms, the buffer's size can be set; a size that's too small could mean that, if too many packets are being captured and the snapshot length doesn't limit the amount of data that's buffered, packets could be dropped if the buffer fills up before the application can read packets from it, while a size that's too large could use more non-pageable operating system memory than is necessary to prevent packets from being dropped.", 'packet arrive capture be store buffer , so have be read by application as soon as arrive . platform , buffer size can be set ; size too small could mean , if too many packet be capture snapshot length do limit amount datum buffer , packet could be drop if buffer fill up before application can read packet , while size too large could more non_pageable operating system memory than be necessary prevent packet drop']
['pcap_datalink_APIName  returns the link-layer header type on success and PCAP_ERROR_NOT_ACTIVATED  if called on a capture handle that has been created but not activated.', 'pcap_datalink_apiname return link_layer header type success pcap_error_not_activate if call capture handle have create but activate']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_list_tstamp_types_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_list_tstamp_types_apiparam_1 as argument fetch or display error text']
['get current file position for a pcap_dumper_t', 'get current file position pcap_dumper_t']
['If pcap_set_promisc_APIParam_2  is non-zero, promiscuous mode will be set, otherwise it will not be set.', 'if pcap_set_promisc_apiparam_2 be non_zero , promiscuous mode be set , otherwise be set']
['PCAP_ERROR  is returned on error.', 'pcap_error be return error']
['In immediate mode, packets are always delivered as soon as they arrive, with no buffering. Immediate mode is set with pcap_set_immediate_mode().', 'immediate mode , packet be always deliver as soon as arrive , no buffer . immediate mode be set pcap_set_immediate_mode']
["If packet filtering is done in libpcap, rather than in the operating system, it would count packets that don't pass the filter.", 'if packet filtering be do libpcap , rather than operate system , would count packet pass filter']
['For a live capture, it always returns false (0).', 'live capture , always return false 0']
['pcap_tstamp_type_name_to_val(3PCAP)', 'pcap_tstamp_type_name_to_val 3pcap']
['pcap_perror_APIName  prints the text of the last pcap library error on stderr,  prefixed by pcap_perror_APIParam_2.', 'pcap_perror_apiname print text last pcap library error stderr , prefix by pcap_perror_apiparam_2']
["The version number is stored in the ``savefile''; note that the meaning of its values depends on the type of ``savefile'' (for example, pcap or pcapng).", 'version number be store savefile ; note meaning value depend type savefile example , pcap or pcapng']
['get link-layer header type for a pcap_t', 'get link_layer header type pcap_t']
['If PCAP_ERROR  is returned, pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_dispatch_APIParam_1  as an argument to fetch or display the error text.', 'if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_dispatch_apiparam_1 as argument fetch or display error text']
['pcap_open_live_APIParam_5  may also be set to warning text when pcap_open_live_APIName  succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5  before calling pcap_open_live_APIName  and display the warning to the user if pcap_open_live_APIParam_5  is no longer a zero-length string.', 'pcap_open_live_apiparam_5 be set warning text when pcap_open_live_apiname succeed ; detect case caller should store zero_length string pcap_open_live_apiparam_5 before call pcap_open_live_apiname display warning user if pcap_open_live_apiparam_5 be no longer zero_length string']
['get name for a link-layer header type', 'get name link_layer header type']
['compile filter expression to a pseudo-machine-language code program', 'compile filter expression pseudo_machine_language code program']
['This function became available in libpcap release 1.2.1.', 'function become available libpcap release #']
["On IEEE 802.11 wireless LANs, even if an adapter is in promiscuous mode, it will supply to the host only frames for the network with which it's associated. It might also supply only data frames, not management or control frames, and might not provide the 802.11 header or radio information pseudo-header for those frames.", 'ieee wireless lan , even if adapter be promiscuous mode , supply host only frame network which be associate . may supply only data frame , management or control frame , may provide header or radio information pseudo_header frame']
['set the snapshot length for a not', 'set snapshot length']
['the adapter is disconnected PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE', 'adapter be disconnect pcap_if_connection_status_not_applicable']
["set if the device is a wireless interface; this includes IrDA as well as radio-based networks such as IEEE 802.15.4 and IEEE 802.11, so it doesn't just mean Wi-Fi PCAP_IF_CONNECTION_STATUS", 'set if device be wireless interface ; include irda as well as radio_based network such as ieee ieee , so do just mean wi_fi pcap_if_connection_status']
['pcap_set_datalink_APIName  is used to set the current link-layer header type of the pcap descriptor to the type specified by pcap_set_datalink_APIParam_2.', 'pcap_set_datalink_apiname be use set current link_layer header type pcap descriptor type specify by pcap_set_datalink_apiparam_2']
['It should not be used in portable code; instead, a filter should be specified with pcap_setfilter_APIName.', 'should be use portable code ; instead , filter should be specify pcap_setfilter_apiname']
['pcap_geterr_APIName  or pcap_perror_APIName  may be called with pcap_activate_APIParam_1  as an argument to fetch or display a message describing the error.', 'pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message describing error']
['Both are provided for compatibility.)', 'both be provide compatibility']
['If the packet was read without problems, the pointer pointed to by the pcap_next_ex_APIParam_2  argument is set to point to the pcap_pkthdr  struct for the packet, and the pointer pointed to by the pcap_next_ex_APIParam_3  argument is set to point to the data in the packet.', 'if packet be read without problem , pointer point by pcap_next_ex_apiparam_2 argument be set point pcap_pkthdr struct packet , pointer point by pcap_next_ex_apiparam_3 argument be set point datum packet']
['Promiscuous mode is set with pcap_set_promisc().', 'promiscuous mode be set pcap_set_promisc']
['Under HP-UX with DLPI:', 'under hp_ux dlpi']
['If NULL  is returned, pcap_open_live_APIParam_5  is filled in with an appropriate error message.', 'if null be return , pcap_open_live_apiparam_5 be fill appropriate error message']
['get the snapshot length', 'get snapshot length']
['pcap_setdirection_APIName  is used to specify a direction that packets will be captured.', 'pcap_setdirection_apiname be use specify direction packet be capture']
['pcap_next_ex(3PCAP)', 'pcap_next_ex 3pcap']
['close a pcap_t', 'close pcap_t']
['set monitor mode for a not', 'set monitor mode']
['The struct pcap_pkthdr  and the packet data are not to be freed by the caller, and are not guaranteed to be valid after the next call to pcap_next_ex_APIName,  pcap_next_APIName,  pcap_loop_APIName,  or pcap_dispatch_APIName;  if the code needs them to remain valid, it must make a copy of them.', 'struct pcap_pkthdr packet datum be be free by caller , be guarantee be valid after next call pcap_next_ex_apiname , pcap_next_apiname , pcap_loop_apiname , or pcap_dispatch_apiname ; if code need -PRON- remain valid , must make copy -PRON']
['pcap_minor_version(3PCAP)', 'pcap_minor_version 3pcap']
['attempt to get a descriptor for a pcap_t that can be used in calls such as select(2) and poll(2)', 'attempt get descriptor pcap_t can be use call such as select poll 2']
['Incoming and outgoing packets', 'incoming outgoing packet']
['pcap_offline_filter_APIName  returns the return value of the filter program.', 'pcap_offline_filter_apiname return return value filter program']
['get a list of capture devices, and free that list', 'get list capture device , free list']
['Any user may capture network traffic. However, no user (not even the super-user) can capture in promiscuous mode on an interface unless the super-user has enabled promiscuous-mode operation on that interface using pfconfig(8), and no user (not even the super-user) can capture unicast traffic received by or sent by the machine on an interface unless the super-user has enabled copy-all-mode operation on that interface using pfconfig, so useful packet capture on an interface probably requires that either promiscuous-mode or copy-all-mode operation, or both modes of operation, be enabled on that interface.', 'user capture network traffic . however , no user can capture promiscuous mode interface unless super_user have enable promiscuous_mode operation interface use pfconfig , no user can capture unicast traffic receive by or send by machine interface unless super_user have enable copy_all_mode operation interface use pfconfig , so useful packet capture interface probably require either promiscuous_mode or copy_all_mode operation , or both mode operation , be enable interface']
['pcap_offline_filter_APIName  checks whether a filter matches a packet.', 'pcap_offline_filter_apiname check whether filter match packet']
['set buffer size for a not-yet-activated pcap_t for live capture', 'set buffer size not_yet_activate pcap_t live capture']
['pcap_fopen_offline(3PCAP)', 'pcap_fopen_offline 3pcap']
["pcap_dump_close_APIName  closes the ``savefile.''", 'pcap_dump_close_apiname close savefile']
['pcap_create_APIParam_1  is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a pcap_create_APIParam_1  argument of "any" or NULL  can be used to capture packets from all interfaces.', 'pcap_create_apiparam_1 be stre specifie network device open ; linux system # or later kernel , pcap_create_apiparam_1 argument or null can be use capture packet interface']
['Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired.', 'note device which read can be do without block , platform , have packet read if packet buffer timeout have expire']
['pcap_inject_APIName  sends a raw packet through the network interface; pcap_inject_APIParam_2  points to the data of the packet, including the link-layer header, and pcap_inject_APIParam_3  is the number of bytes in the packet.', 'pcap_inject_apiname send raw packet through network interface ; pcap_inject_apiparam_2 point datum packet , include link_layer header , pcap_inject_apiparam_3 be number byte packet']
['write a packet to a capture file', 'write packet capture file']
['To find a default device on which to capture, call pcap_findalldevs_APIName  and, if the list it returns is not empty, use the first device in the list.', 'find default device which capture , call pcap_findalldevs_apiname , if list return be empty , first device list']
['pcap_open_offline(3PCAP)', 'pcap_open_offline 3pcap']
["pcap_create(), pcap_open_offline(), pcap_fopen_offline(), and pcap_open_dead() return a pointer to a pcap_t, which is the handle used for reading packets from the capture stream or the ``savefile'', and for finding out information about the capture stream or ``savefile''. To close a handle, use pcap_close().", 'pcap_create , pcap_open_offline , pcap_fopen_offline , pcap_open_dead return pointer pcap_t , which be handle use reading packet capture stream or savefile , find out information about capture stream or savefile . close handle , pcap_close']
['pcap_findalldevs_APIName  constructs a list of network devices that can be opened with pcap_create_APIName  and pcap_activate_APIName  or with pcap_open_live_APIName.', 'pcap_findalldevs_apiname construct list network device can be open pcap_create_apiname pcap_activate_apiname or pcap_open_live_apiname']
["ps_drop  is not available on all platforms; it is zero on platforms where it's not available.", 'ps_drop be available platform ; be zero platform where be available']
['pcap_set_snaplen(3PCAP)', 'pcap_set_snaplen 3pcap']
['pcap_get_required_select_timeout(3PCAP)', 'pcap_get_required_select_timeout 3pcap']
['pcap_set_timeout_APIName  sets the packet buffer timeout that will be used on a capture handle when the handle is activated to pcap_set_timeout_APIParam_2,  which is in units of milliseconds.', 'pcap_set_timeout_apiname set packet buffer timeout be use capture handle when handle be activate pcap_set_timeout_apiparam_2 , which be unit millisecond']
['transmit a packet', 'transmit packet']
['free a filter program', 'free filter program']
["open a pcap_t for a ``savefile'', given a FILE *", 'open pcap_t savefile , give file']
['pcap_statustostr_APIName  can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code.', 'pcap_statustostr_apiname can be call , warning or error code as argument , fetch message describe warning or error code']
['set or get the state of non', 'set or get state non']
['Additional error codes may be added in the future; a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors.', 'additional error code be add future ; program should check 0 , 1 , negative , return code , treat negative return code as error']
['open a fake pcap_t for compiling filters or opening a capture for output', 'open fake pcap_t compile filter or open capture output']
['activate a capture handle', 'activate capture handle']
['pcap_dump_flush(3PCAP)', 'pcap_dump_flush 3pcap']
['pcap_compile(3PCAP)', 'pcap_compile 3pcap']
['get a name or description for a time stamp type value', 'get name or description time stamp type value']
['set the time stamp type to be used by a capture device', 'set time stamp type be use by capture device']
['pcap_breakloop(3PCAP)', 'pcap_breakloop 3pcap']
['pcap_statustostr(3PCAP)', 'pcap_statustostr 3pcap']
['The options that can be set on a capture handle include', 'option can be set capture handle include']
['get a list of devices that can be opened for a live capture', 'get list device can be open live capture']
['A call to pcap_dispatch_APIName  or pcap_next_ex_APIName  will return 0 in this case, but will not block.', 'call pcap_dispatch_apiname or pcap_next_ex_apiname return # case , but block']
['pcap_fopen_offline_with_tstamp_precision_APIName  takes an additional precision  argument as described above.', 'pcap_fopen_offline_with_tstamp_precision_apiname take additional precision argument as describe above']
['pcap_set_datalink(3PCAP)', 'pcap_set_datalink 3pcap']
['If, when capturing, you capture the entire contents of the packet, that requires more CPU time to copy the packet to your application, more disk and possibly network bandwidth to write the packet data to a file, and more disk space to save the packet. If you don\'t need the entire contents of the packet - for example, if you are only interested in the TCP headers of packets - you can set the "snapshot length" for the capture to an appropriate value. If the snapshot length is set to snaplen, and snaplen is less than the size of a packet that is captured, only the first snaplen bytes of that packet will be captured and provided as packet data.', 'if , when capture , -PRON- capture entire content packet , require more cpu time copy packet -PRON- application , more disk possibly network bandwidth write packet datum file , more disk space save packet . if -PRON- need entire content packet example , if -PRON- be only interested tcp header packet -PRON- can set snapshot length capture appropriate value . if snapshot length be set snaplen , snaplen be less than size packet be capture , only first snaplen byte packet be capture provide as packet datum']
['(If the list is empty, there are no devices on which capture is possible.)', 'if list be empty , be no device which capture be possible']

