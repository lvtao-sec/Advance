null be return failure
pcap_freecode 3pcap
pcap_fopen_offline_with_tstamp_precision 3pcap
read next packet pcap_t
possible error value be : pcap_error_activat
pcap_dispatch_apiname process packet live capture or savefile until pcap_dispatch_apiparam_2 packet be process , end current bufferful packet be reach when do live capture , end savefile be reach when read savefile , pcap_breakloop_apiname be call , or error occur
platform , time stamp give packet live capture can come different source can have different resolution or can have different relationship time value current time supply by routine native operating system . see pcap_tstamp list time stamp type
pcap_tstamp_type_val_to_description 3pcap
previous release , select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname can be use capture source which pcap_get_selectable_fd_apiname return #
note pcap_next_apiname pcap_next_ex_apiname , platform , loop read packet os ; loop necessarily be terminate by signal , so pcap_breakloop_apiname should be use terminate packet processing even if pcap_next_apiname or pcap_next_ex_apiname be use
open handle savefile which read packet , give pathname savefile , call pcap_open_offline ; set up handle savefile , give file referring file already open reading , call pcap_fopen_offline
writing packet
if null , pointer struct sockaddr contain netmask correspond address point by addr broadaddr
if , instead , packet be deliver as soon as arrive , but be deliver after short delay , more than one packet can be accumulate before packet be deliver , so single wakeup would be do multiple packet , each set call make operating system would supply multiple packet , rather than single packet . reduce per_packet cpu overhead if packet be arrive high rate , increase number packet per second can be capture
pcap_dump_ftell 3pcap
note if -PRON- be catch signal unix system support restart system call after signal , call pcap_breakloop_apiname signal handler , -PRON- must specify , when catch signal , system call should be restart by signal
write packet pcap_dumper_t
force loop pcap_dispatch or pcap_loop terminate , call pcap_breakloop
if type value do correspond know dlt_value , string dlt n be return , where n be value pcap_datalink_val_to_description_apiparam_1 argument
pcap_is_swapped_apiname return true or false success pcap_error_not_activate if call capture handle have create but activate
set snapshot length not_yet_activated pcap_t live capture
if pcap_fileno_apiparam_1 refer network device be open live capture use combination pcap_create_apiname pcap_activate_apiname , or use pcap_open_live_apiname , pcap_fileno_apiname return file descriptor which capture packet be read
get pcap_t live capture
another error occur
get standard stream savefile write
be unknown whether adapter be connect or pcap_if_connection_status_connect
snapshot length
otherwise , if signal interrupt call read packet live capture , when -PRON- signal handler return after call pcap_breakloop_apiname , call be restart , loop terminate until more packet arrive call complete
workaround work freebsd # later ; however , freebsd # later , call work correctly bpf device , so workaround be necessary , although do no harm
report security issue please send e_mail security
pointer struct timeval be return if timeout be require ; otherwise null be return
set time stamp precision return capture
pcap_set_tstamp_precision 3pcap
process have permission open capture source but do have permission put into promiscuous mode
pcap_free_tstamp_type 3pcap
byte datum packet begin link_layer header
pcap_offline_filter_apiparam_1 be pointer bpf_program struct , usually result call pcap_compile_apiname
pcap_set_buffer_size_apiname return # success or pcap_error_activat if call capture handle have activate
name be synonym stdout
pointer stre give name device pass pcap_open_live_apiname description
pcap_set_promisc 3pcap
pcap_get_selectable_fd_apiname be available window
may , or may , count packet drop because be no room operate system buffer when arrive
time stamp type specify previous pcap_set_tstamp_type_apiname call be support by capture source , pcap_warning
p be capture or savefile handle return by early call pcap_create_apiname activate by early call pcap_activate_apiname , or return by early call pcap_open_offline_apiname , pcap_open_live_apiname , or pcap_open_dead_apiname
pcap_set_promisc_apiname return # success or pcap_error_activat if call capture handle have activate
process do have permission open capture source
note monitor mode adapter may disassociate network which be associate , so -PRON- be able wireless network adapter . could prevent access file network server , or resolve host name or network address , if -PRON- be capture monitor mode be connect another network another adapter
handle have already activate
thus , when do live capture , pcap_dispatch_apiparam_2 be maximum number packet process before return , but be minimum number ; when read live capture , only one bufferful packet be read time , so few than pcap_dispatch_apiparam_2 packet be process
note be network device can be open by process call pcap_findalldevs_apiname , because , example , process do have sufficient privilege open -PRON- capture ; if so , device appear list
asynchronous procedure call work window , as thread block pcap_t be alertable state
get state non_blocking mode pcap_t
note address list address may be ipv4 address , ipv6 address , or other type address , so -PRON- must check sa_family member struct sockaddr before interpret content address ; assume address be ipv4 address , or even ipv4 or ipv6 address
pcap_loop 3pcap
pcap_findalldevs_apiname return # success pcap_error failure ; as indicate , find no device be consider success , rather than failure , so # be return case
if current file position do fit long , be truncate ; can happen 32_bit unix_like system large file support window
note poll_apiname kevent_apiname do work character special file , include bpf device , mac os x # 10 , so , while select_apiname can be use descriptor return by pcap_get_selectable_fd_apiname , poll_apiname kevent_apiname can be use version mac os x. poll_apiname , but kevent_apiname , work descriptor mac os x release prior 10 ; poll_apiname kevent_apiname work descriptor mac os x # later
pcap_list_tstamp_type 3pcap
pcap_create_apiparam_2 be assume be able hold least pcap_errbuf_size char
one can option pcap_tstamp_precision_micro pcap_tstamp_precision_nano request desire precision
timeout should be use call must be no large than small timeout return by pcap_get_required_select_timeout_apiname device which packet be capture
winpcap , pcap_lookupdev_apiname return utf_16 stre rather than ascii or utf_8 string
set filter
if null , pointer string give human_readable description device address
get time stamp precision pcap_t live capture
if pcap_error be return , pcap_findalldevs_apiparam_2 be fill appropriate error message
pcap_if_wireless , pcap_if_connection_status , pcap_if_connection_status_unknown , pcap_if_connection_status_connected , pcap_if_connection_status_disconnect , pcap_if_connection_status_not_applicable constant become available libpcap release #
get link_layer header type correspond name
packet be read pcap_dispatch or pcap_loop , which process one or more packet , call callback routine each packet , or pcap_next or pcap_next_ex , which return next packet . callback pcap_dispatch pcap_loop be supply pointer struct pcap_pkthdr , which include follow member
file have format as use by tcpdump_apiname tcpslice_apiname
to_ms specifie packet buffer timeout , as non_negative value , millisecond
pcap_next_apiname return pointer packet datum success , return null if error occur , or if no packet be read live capture , or if no more packet be available savefile
find out whether savefile have native byte order
freebsd , netbsd , openbsd , dragonfly bsd , macos , solaris 11 , immediate mode must be turn biocimmediate ioctl_apiname , as document bpf_apiname , descriptor return by pcap_fileno_apiname , after pcap_activate_apiname be call ; solaris # early version solaris , immediate mode must be turn by use read timeout # when open device ; digital unix , immediate mode must be turn by do biocmbic ioctl , as document packetfilter_apiname , clear enbatch flag descriptor return by pcap_fileno_apiname , after pcap_activate_apiname be call ; window , immediate mode must be turn by call pcap_setmintocopy_apiname size #
both ps_recv ps_drop may , or may , count packet yet read operate system thus yet see by application
note , multi_threaded application , if one thread be block pcap_dispatch_apiname , pcap_loop_apiname , pcap_next_apiname , or pcap_next_ex_apiname , call pcap_breakloop_apiname different thread unblock thread
negative return value indicate what error condition occur
whether other address be return , what type may have be platform_dependent
pcap_open_dead 3pcap
version libpcap prior 1 , pcap header file be pcap directory most platform ; if -PRON- be write application must work version libpcap prior 1 , include pcap , which include -PRON- , rather than include
handle can be put into non_blocking mode , so routine , rather than block , return indication no packet be available read . call pcap_setnonblock put handle into non_block mode or take out non_block mode ; call pcap_getnonblock determine whether handle be non_block mode . note non_block mode do work correctly mac os x #
pcap_next be pass argument point struct pcap_pkthdr structure , fill time stamp length value packet . return const u_char first caplen byte packet success , null error
pcap_lib_version 3pcap
get file pcap_dumper_t open savefile
packet buffer timeout be require so application wait operate system capture buffer fill up before packet be deliver ; if packet be arrive slowly , wait could take arbitrarily long period time
if pcap_activate_apiname fail , pcap_t be closed freed ; should be close use pcap_close_apiname
ps_ifdrop may , or may , be implement ; if be zero , may mean no packet be drop by interface , or may mean statistic be unavailable , so should be treat as indication interface do drop packet
report bug other problem , contribute patch , request feature , provide generic feedback etc please see file libpcap source tree root
pcap_can_set_rfmon 3pcap
flush buffer packet write pcap_dumper_t savefile
pcap_setnonblock 3pcap
set if device be up pcap_if_runne
struct pcap_pkthdr packet datum be be free by pcap_loop_apiparam_3 routine , be guarantee be valid after pcap_loop_apiparam_3 routine return ; if code need -PRON- be valid after pcap_loop_apiparam_3 , must make copy -PRON
compile filter expression
pcap_set_rfmon 3pcap
get list link
apply filter program packet
pcap_dump 3pcap
find ipv4 network number netmask device
possible warning value be : pcap_warning_promisc_notsup
two time stamp precision be support , microsecond nanosecond
get description link_layer header type
free list link_layer header type
pcap_offline_filter_apiparam_2 point pcap_pkthdr structure packet , pcap_offline_filter_apiparam_3 point datum packet
pcap_setdirection_apiname be necessarily fully support platform ; platform may return error value , other platform may support pcap_d_out
function be only provide linux , , if be use device other than network interface , have no effect
open capture handle read
null be return if type value do correspond know dlt_value
pcap_datalink_val_to_description 3pcap
pcap_set_tstamp_type_apiname return # success if specify time stamp type be expect be support by capture device , pcap_warning_tstamp_type_notsup if specify time stamp type be support by capture device , pcap_error_activat if call capture handle have activate , pcap_error_cantset_tstamp_type if capture device do support set time stamp type only old version libpcap return ; new version always allow time stamp type be set default type
get time stamp type correspond name
handle have such descriptor available ; pcap_get_selectable_fd return # if no such descriptor be available . if no such descriptor be available , be because device must be poll periodically packet ; case , pcap_get_required_select_timeout return pointer struct timeval whose value can be use as timeout routine . when routine return , attmept should be make read packet device . if pcap_get_required_select_timeout return null , no such timeout be available , routine can be use device
open pcap_t savefile , give pathname
under suno 3 or 4 nit or bpf
pcap_lookupdev 3pcap
broadcast lan such as ethernet , if network be switch , or if adapter be connect mirror port switch which packet pass through switch be send , network adapter receive packet lan , include unicast or multicast packet send network address network adapter be configure recognize
pcap_dump_flush_apiname flush output buffer savefile , so packet write pcap_dump_apiname but yet write savefile be write
set capture protocol
network interface device linux , pcap_set_protocol_linux_apiname set pcap_set_protocol_linux_apiparam_2 be use socket_apiname call create capture socket when handle be activate
if time stamp file have precision as request precision , be scale up or down as necessary before supply
pcap_sendpacket_apiname be like pcap_inject_apiname , but return # success , rather than return number byte write
pcap_dispatch 3pcap
order get fake pcap_t routine require pcap_t as argument , such as routine open savefile writing compile filter expression , call pcap_open_dead
value do affect pcap_compile_apiname
pcap_open_offline_with_tstamp_precision_apiname take additional precision argument specify time stamp precision desire ; if pcap_tstamp_precision_micro be specify , packet time stamp be supply second microsecond , if pcap_tstamp_precision_nano be specify , packet time stamp be supply second nanosecond
pcap_inject 3pcap
pcap_if_up pcap_if_runne constant become available libpcap release #
pcap_get_tstamp_precision_apiname return precision time stamp return packet capture pcap descriptor
platform support packet buffer timeout ; platform , packet buffer timeout be ignore . zero value timeout , platform support packet buffer timeout , cause read wait forever allow enough packet arrive , no timeout . negative value be invalid ; result setting timeout negative value be unpredictable
normally , adapter discard packet ; however , many network adapter support promiscuous mode , which be mode which packet , even if be send address adapter recognize , be provide host . be useful passively capture traffic between two or more other host analysis
pcap_datalink 3pcap
pcap_dump_apiname output packet savefile open pcap_dump_open_apiname
get network address network mask capture device
caller be responsible freeing array pcap_free_datalinks_apiname , which free list link_layer header type point by pcap_free_datalinks_apiparam_1
check whether monitor mode can be set
get snapshot length pcap_t
pcap_set_timeout_apiname return # success or pcap_error_activat if call capture handle have activate
if null , pointer next element list ; null last element list name
current version be available tcpdump group web site
argument be link_layer pcap_set_protocol_linux_apiparam_2 value , such as value header file , specify host byte order
pcap_geterr_apiname return error text pertain last pcap library error
inject packet
pcap_datalink_name_to_val_apiname return type value success pcap_error if pcap_datalink_name_to_val_apiparam_1 be know type pcap_datalink_name_to_val_apiparam_1
function become available libpcap release #
get or print libpcap error message text
order cause only certain packet be return when read packet , filter can be set handle . live capture , filtering be perform kernel mode , if possible , avoid copy uninteresting packet kernel user mode
under bsd include macos
if pcap_set_rfmon_apiparam_2 be non_zero , monitor mode be set , otherwise be set
if null , pointer struct sockaddr contain broadcast address correspond address point by addr ; be null if device do support broadcast dstaddr
pcap_close_apiname close file associate pcap_close_apiparam_1 deallocate resource
pcap_open_live_apiparam_5 be assume be able hold least pcap_errbuf_size char
see pcap_filter_apiname syntax string
get string error or warning status code
set promiscuous mode not_yet_activated pcap_t live capture
flag be check loop read packet os
note , even if -PRON- successfully open network interface , -PRON- may have permission send packet , or may support send packet ; as pcap_open_live_apiname do have flag indicate whether open capturing , send , or capture send , -PRON- can request open support send be notify open time whether send be possible
open savefile which write packet , give pathname savefile should have , call pcap_dump_open . open savefile which write packet , give pathname savefile should have , call pcap_dump_open ; set up handle savefile , give file referring file already open writing , call pcap_dump_fopen . each return pointer pcap_dumper_t , which be handle use writing packet savefile . if succeed , have create file if do exist truncate file if do exist . close pcap_dumper_t , call pcap_dump_close
pcap_lib_version_apiname return pointer stre give information about version libpcap library use ; note contain more information than just version number
pcap_open_offline_apiparam_2 be assume be able hold least pcap_errbuf_size char
pcap_lookupdev_apiparam_1 be assume be able hold least pcap_errbuf_size char
function become available libpcap release #
get library version string
pcap_dump_open 3pcap
pcap_snapshot_apiname return snapshot length specify when pcap_set_snaplen_apiname or pcap_open_live_apiname be call , live capture , or snapshot length capture file , savefile
pcap_stats_apiname return # success return pcap_error if be error or if pcap_stats_apiparam_1 do support packet statistic
select link_layer header type live capture
pcap_open_offline_with_tstamp_precision 3pcap
pcap_setfilter_apiname be use specify filter program
free list available time stamp type
pcap_set_immediate_mode_apiname set whether immediate mode should be set capture handle when handle be activate
pcap_dump_ftell_apiname return current file position savefile , represent number byte write by pcap_dump_open_apiname pcap_dump_apiname
PRON- recommend always set timeout non_zero value unless immediate mode be set , which case timeout have no effect
if give network interface provide standard link_layer header , standard packet type , but provide packet type different socket_layer pcap_set_protocol_linux_apiparam_2 type one link_layer header , packet type can be filter filter specify pcap_setfilter_apiname but can be filter by specify socket_layer pcap_set_protocol_linux_apiparam_2 type use pcap_set_protocol_linux_apiname
specify whether capture incoming packet , outgoing packet , or both
pcap_getnonblock_apiname return current non_block state capture descriptor ; always return # savefile
convert errno value string
promisc specifie if interface be be put into promiscuous mode
read next packet pcap_t without indication whether error occur
pcap_create 3pcap
pcap_pkthdr structure point by h be fill appropriate value packet
pcap_get_required_select_timeout_apiname be available window
open device capturing
pcap_list_datalinks_apiname return number link_layer header type array success , pcap_error_not_activate if call capture handle have create but activate , pcap_error other error
packet buffer timeout
pcap_dump_file 3pcap
under linux
caller be responsible freeing array pcap_free_tstamp_types_apiname , which free list point by pcap_free_tstamp_types_apiparam_1
convert pcap_error or pcap_warn value string
pcap_open_dead_apiname pcap_open_dead_with_tstamp_precision_apiname be use create pcap_t structure when call other function libpcap
snaplen specifie snapshot length be set handle
note packet capture library be usually build large file support , so standard stream savefile may refer file large than # gigabyte ; application pcap_file_apiname should , if possible , call support large file return value pcap_file_apiname or value return by fileno_apiname when pass return value pcap_file_apiname
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_setdirection_apiparam_1 as argument fetch or display error text
check whether filter match packet
pcap_getnonblock 3pcap
pcap_netmask_unknown constant become available libpcap release #
report error
pcap_dump_open_apiname be call open savefile writing
get current file offset savefile write
value return be valid packet receive unless until pcap_set_datalink_apiname be call ; after successful call pcap_set_datalink_apiname , subsequent packet have link_layer header type specify by link_layer header type value pass pcap_set_datalink_apiname
get library version information
pcap_sendpacket_apiname return # success pcap_error failure
pcap_datalink_name_to_val_apiname translate link_layer header type pcap_datalink_name_to_val_apiparam_1 , which be dlt pcap_datalink_name_to_val_apiparam_1 dlt remove , correspond link_layer header type value
callback be supply const u_char pointer first caplen byte datum packet . necessarily be entire packet ; capture entire packet , -PRON- have provide value snaplen -PRON- call pcap_set_snaplen be sufficiently large get packet datum value # should be sufficient most if network . when read savefile , snapshot length specify when capture be perform limit amount packet datum available
get standard stream savefile read
pcap_setdirection_apiname return # success pcap_error failure
pcap_set_tstamp_type 3pcap
value # or # pcap_loop_apiparam_2 be equivalent infinity , so packet be process until another end condition occur
pcap_compile_apiparam_5 specifie ipv4 pcap_compile_apiparam_5 network which packet be capture ; be use only when check ipv4 broadcast address filter program
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_sendpacket_apiparam_1 as argument fetch or display error text
alternatively , -PRON- call pcap_fopen_offline_apiname or pcap_fopen_offline_with_tstamp_precision_apiname read dump datum exist open stream pcap_fopen_offline_apiparam_1
set filter pcap_t
when first activate pcap_activate_apiname or open pcap_open_live_apiname , capture handle be non_block mode ; call pcap_setnonblock_apiname be require order put into non_blocking mode
pcap_list_datalinks_apiname be use get list support link_layer header type interface associate pcap descriptor
file can have pcap file format as describe pcap_savefile_apiname , which be file format use by , among other program , tcpdump_apiname tcpslice_apiname , or can have pcapng file format , although pcapng file can be read
pcap_tstamp_type_val_to_name 3pcap
close savefile write
do return when live packet buffer timeout occur ; instead , attempt read more packet
PRON- must have access network pseudo device , e. . least version solaris , however , be sufficient allow tcpdump capture promiscuous mode ; version solari , -PRON- must be root , or application capturing packet must be instal setuid root , order capture promiscuous mode . note , many interface , if -PRON- capture promiscuous mode , -PRON- see outgoing packet , so capture do promiscuous mode be useful
pcap_lookupdev_apiname return pointer stre give name network device suitable pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname , pcap_lookupnet_apiname
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_set_datalink_apiparam_1 as argument fetch or display error text
set promiscuous mode
pointer first element list network address device , or null if device have no address flag
monitor mode
pcap_set_snaplen_apiname return # success or pcap_error_activat if call capture handle have activate
addition , various reason , one or more routine work properly descriptor ; documentation pcap_get_selectable_fd give detail . note , just as attempt read packet pcap_t return packet if packet buffer timeout expire , select , poll , or other such call , if packet buffer timeout expire , indicate descriptor be ready read even if be no packet available read
under ultrix digital unix
pcap_loop_apiname process packet live capture or savefile until pcap_loop_apiparam_2 packet be process , end savefile be reach when read savefile , pcap_breakloop_apiname be call , or error occur
set link_layer header type device
pcap_dump_file_apiname return standard stream savefile open by pcap_dump_open_apiname
value # or # pcap_dispatch_apiparam_2 cause packet receive one buffer be process when read live capture , cause packet file be process when read savefile
format link_layer header be indicate by return value pcap_datalink_apiname routine when handed pcap_t value pass pcap_loop_apiname or pcap_dispatch_apiname
determine whether savefile read come machine opposite byte order
pcap_setdirection 3pcap
pcap_create pcap_activate be available version libpcap prior 1 ; if -PRON- be write application must work version libpcap prior 1 , either pcap_open_live get handle live capture or , if -PRON- want be able additional capability offer by use pcap_create pcap_activate , autoconf script or other configuration script check whether libpcap # apis be available -PRON- only if be
get file descriptor live capture
pcap_open_offline_with_tstamp_precision_apiname pcap_fopen_offline_with_tstamp_precision_apiname become available libpcap release #
snapshot length be set pcap_set_snaplen
pcap_offline_filter 3pcap
pcap_set_tstamp_type_apiname set type time stamp desire packet capture pcap descriptor type specify by pcap_set_tstamp_type_apiparam_2
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_compile_apiparam_1 as argument fetch or display error text
note window , stream should be open binary mode
pcap_loop_apiname pcap_next_apiname work non_blocking mode
time stamp type be set pcap_set_tstamp_type
ipv4 address , struct sockaddr pointer can be interpret as if point struct sockaddr_in ; ipv6 address , can be interpret as if point struct sockaddr_in6
application should be prepare happen , but must rely happen
if null be return , pcap_create_apiparam_2 be fill appropriate error message
have no effect savefile
under solaris dlpi
pcap_findalldevs_apiparam_2 be assume be able hold least pcap_errbuf_size char
pcap_dump_ftell64_apiname return current file position int64_t , so if file offset fit long but fit int64_t be support , return file offset without truncation
pcap_next_ex_apiname return # if packet be read without problem , # if packet be read live capture packet buffer timeout expire , pcap_error if error occur while read packet , pcap_error_break if packet be read savefile be no more packet read savefile
PRON- must have read access or
compile filter can be apply directly packet have read use pcap_offline_filter
note even if application do set promiscuous mode , adapter could well be promiscuous mode other reason
pcap_compile_apiname return # success pcap_error failure
monitor mode be set pcap_set_rfmon , pcap_can_set_rfmon can be use determine whether adapter can be put into monitor mode
get time stamp precision return capture
if pcap_compile_apiparam_5 network which packet be capture be know program , or if packet be capture linux pseudo_interface can capture more than one network , value pcap_netmask_unknown can be supply ; test ipv4 broadcast address fail compile , but other test filter program be ok
pcap_inject_apiname return number byte write success pcap_error failure
pcap_set_buffer_size_apiname set buffer size be use capture handle when handle be activate pcap_set_buffer_size_apiparam_2 , which be unit byte
routine be safe inside signal handler unix or console control handler window , as merely set flag be check within loop
determine whether monitor mode can be set pcap_t live capture
open pcap_dumper_t savefile , give file
set packet buffer timeout not_yet_activated capture handle
bpf_u_int32 give number byte packet be available capture
activate pcap_t live capture
pcap_dump_open_append_apiname function become available libpcap release #
fname specifie name file open
packet capture library provide high level interface packet capture system . packet network , even destine other host , be accessible through mechanism . support save capture packet savefile , read packet savefile
if be error , pcap_error be return pcap_setnonblock_apiparam_3 be fill appropriate error message ; otherwise , # be return
pcap_setnonblock_apiname put capture handle into non_block mode , or take out non_block mode , depend whether pcap_setnonblock_apiparam_2 argument be non_zero or zero
pcap_next_apiname read next packet return u_char pointer datum packet
autoconf , tcpdump , tcpslice , pcap_filter , pfconfig , usermod 8
note , when do live capture platform , if read timeout expire when be no packet available , pcap_dispatch_apiname return 0 , even when non_block mode , as be no packet process
pcap_get_required_select_timeout_apiname return , unix , pointer struct timeval contain value must be use as minimum timeout select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname call if pcap_get_selectable_fd_apiname return pcap_error
name be synonym stdin
pcap_dispatch_apiname return number packet process success ; can be # if no packet be read live capture or if no more packet be available savefile
capture source specify when handle be create do exist
set if device be loopback interface pcap_if_up
old version libpcap , behavior when pcap_dispatch_apiparam_2 be # be undefined ; different platform device behave differently , so code must work old version libpcap should 1 , 0 , as value pcap_dispatch_apiparam_2
device flag
pcap_set_rfmon_apiname return # success or pcap_error_activat if call capture handle have activate
pcap_dump_flush_apiname return # success pcap_error failure
pcap_activate_apiname return # success without warning , non_zero positive value success warning , negative value error
callback specifie pcap_handler routine be call three argument : u_char pointer which be pass pcap_loop_apiparam_4 argument pcap_loop_apiname or pcap_dispatch_apiname , const struct pcap_pkthdr pointer point packet time stamp length , const u_char pointer first caplen byte datum packet
pcap_setfilter_apiname return # success pcap_error failure
original author libpcap be
pcap_set_tstamp_precision_apiname set precision time stamp desire packet capture pcap descriptor type specify by pcap_set_tstamp_precision_apiparam_2
promiscuous mode be request , but capture source do support promiscuous mode
new version solaris , -PRON- must have give net_rawaccess privilege ; be both necessary sufficient give -PRON- access network pseudo_device be no need change privilege device . user can be give privilege by , example , add privilege user defaultpriv key usermod command
operation be support if savefile be read
behavior , if timeout be specify , be undefined , as be behavior if timeout be set zero or negative value
pcap_set_rfmon_apiname set whether monitor mode should be set capture handle when handle be activate
open handle live capture , give name network or other interface which capture should be do , call pcap_create , set appropriate option handle , then activate pcap_activate . if pcap_activate fail , handle should be close pcap_close
pcap_can_set_rfmon_apiname check whether monitor mode could be set capture handle when handle be activate
pcap_breakloop_apiname set flag force pcap_dispatch_apiname or pcap_loop_apiname return rather than loop ; return number packet have process so far , or pcap_error_break if no packet have process so far
pcap_is_swapped_apiname return true if pcap_is_swapped_apiparam_1 refer savefile use different byte order than current system
network device open pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname , support call , so pcap_error be return device
previous release , time stamp capture device or savefile be always give second microsecond
struct pcap_stat have follow member
get statistic about packet receive drop live capture , call pcap_stats
pcap_datalink_val_to_description_or_dlt_apiname translate link_layer header type value short description link_layer header type just like pcap_datalink_val_to_description
pcap_compile_apiparam_4 control whether optimization result code be perform
now , do work device ; if argument or null be supply , set promiscuous mode be ignore
promiscuous mode
by default , libpcap attempt capture both packet send by machine packet receive by machine . limit capturing only packet receive by machine or , if possible , only packet send by machine , call pcap_setdirection
pcap_list_tstamp_types_apiname allocate array hold list set tstamp_typesp point array
pcap_setdirection_apiparam_2 be one constant pcap_d_in , pcap_d_out or pcap_d_inout
pcap_datalink_val_to_name 3pcap
pcap_open_live_apiname return pcap_t success null failure
pcap_open_offline_apiname pcap_open_offline_with_tstamp_precision_apiname be call open savefile reading
capture statistic
pcap_set_protocol_linux 3pcap
pcap_setfilter_apiparam_2 be pointer bpf_program struct , usually result call pcap_compile_apiname
open pcap_t savefile , give file , specify precision provide packet time stamp
filter can be specify as text string ; syntax semantic string be as describe by pcap_filter . filter string be compile into program pseudo_machine_language by pcap_compile result program can be make filter handle pcap_setfilter . result pcap_compile can be free call pcap_freecode . pcap_compile require network mask certain expression filter string ; pcap_lookupnet can be use find network address network mask give capture device
read packet
program be pointer bpf_program struct be fill by pcap_compile_apiname
pcap_geterr_apiname or pcap_perror_apiname be call pcap_can_set_rfmon_apiparam_1 as argument fetch or display message describing error
if positive number be return , flag be clear , so subsequent call return pcap_error_break clear flag
pcap_lookupnet 3pcap
pcap_d_inout be default set if pcap_setdirection_apiname be call
set or clear non_blocking mode pcap_t
pcap_list_datalink 3pcap
pcap_dump_close 3pcap
pcap_lookupnet_apiname return # success pcap_error failure
pcap_open_offline_apiname , pcap_open_offline_with_tstamp_precision_apiname , pcap_fopen_offline_apiname , pcap_fopen_offline_with_tstamp_precision_apiname return pcap_t success null failure
note call argument be suitable pcap_dispatch_apiname or pcap_loop_apiname
pcap_freealldevs 3pcap
get major minor version file format version savefile
notion connect disconnected apply interface ; example , do apply loopback device
note device may support send packet
assume packet give capture or savefile have give link_layer header type , such as dlt_en10 mb ethernet . example , device linux have link_layer header type dlt_linux_sll even if device system time device be open have other datum link type , such as dlt_en10 mb ethernet
obtain list device can be open live capture , call pcap_findalldevs ; free list return by pcap_findalldevs , call pcap_freealldevs . pcap_lookupdev return first device list be loopback network interface
pcap_file 3pcap
buffer size be set pcap_set_buffer_size
must be call pcap descriptor create by pcap_create_apiname have yet activate by pcap_activate_apiname
previous release , be no support append packet exist savefile
if pcap_set_immediate_mode_apiparam_2 be non_zero , immediate mode be set , otherwise be set
pcap_tstamp_type_name_to_val_apiname translate time stamp type pcap_tstamp_type_name_to_val_apiparam_1 corresponding time stamp type value
under irix snoop
prematurely terminate loop pcap_dispatch or pcap_loop
pcap_snapshot_apiname return snapshot length success pcap_error_not_activate if call capture handle have create but activate
get name or description link
pcap_dump_fopen_apiname be call write datum exist open stream pcap_dump_fopen_apiparam_2 ; stream be close by subsequent call pcap_dump_close_apiname
if pcap_set_protocol_linux_apiparam_2 be non_zero , packet pcap_set_protocol_linux_apiparam_2 be capture when handle be activate , otherwise , packet be capture
create live capture handle
pcap_can_set_rfmon_apiname return # if monitor mode could be set , # if monitor mode could be set , negative value error
if pcap_fileno_apiparam_1 refer savefile be open use function such as pcap_open_offline_apiname or pcap_fopen_offline_apiname , dead pcap_t open use pcap_open_dead_apiname , or pcap_t be create pcap_create_apiname but have yet activate pcap_activate_apiname , return pcap_error
get list link_layer header type device
function become available libpcap release #
interface be obsolete by pcap_findalldevs_apiname
obtain file corresponding pcap_t open savefile , call pcap_file
pcap_free_datalink 3pcap
read packet pcap_t until interrupt or error occur
set packet buffer timeout not_yet_activate pcap_t live capture
set time stamp precision not_yet_activate pcap_t live capture
find default device which capture
if pcap_error be return , pcap_lookupnet_apiparam_4 be fill appropriate error message
must be call pcap descriptor create by pcap_create_apiname have yet activate by pcap_activate_apiname
pcap_dump_open_apiparam_2 specifie name file open
if call directly , pcap_dump_apiparam_1 parameter be type pcap_dumper_t as return by pcap_dump_open_apiname
pcap_strerror_apiname be provide case strerror_apiname be available
packet read handle include pseudo_header contain various form packet meta_data , probably include link_layer header whose content can differ different network interface . determine format packet supply by handle , call pcap_datalink ; https : list value return describe packet format correspond value
if pcap_warning_promisc_notsup , pcap_error_no_such_device , or pcap_error_perm_deni be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message give additional detail about problem may be useful debug problem if be unexpected
read saved packet file do require special privilege
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_setfilter_apiparam_1 as argument fetch or display error text
open pcap_dumper_t savefile , give pathname
note : libpcap # later , pcap_compile_apiname can be use multiple thread within single process
packet datum be be free by caller , be guarantee be valid after next call pcap_next_ex_apiname , pcap_next_apiname , pcap_loop_apiname , or pcap_dispatch_apiname ; if code need remain valid , must make copy
pcap_get_selectable_fd_apiname return , unix , file descriptor number file descriptor which one can select_apiname , poll_apiname , epoll_wait_apiname , kevent_apiname , or other such call wait be possible read packet without block , if such descriptor exist , or pcap_error , if no such descriptor exist
set direction which packet be capture
be typically use when just use libpcap compile bpf code ; can be use if use pcap_dump_open_apiname , pcap_dump_apiname , pcap_dump_close_apiname write savefile if be no pcap_t supply packet be write
ps_recv may count packet whether pass filter set pcap_setfilter_apiname or , or may count only packet pass filter
close pcap_dumper_t
pcap_dump_open_append_apiname be like pcap_dump_open_apiname but do create file if do exist , if do already exist , be pcap file byte order as host opening file , have time stamp precision , link_layer header type , snapshot length as pcap_dump_open_apiparam_1 , write packet end file
list device must be free pcap_freealldevs_apiname , which free list point by pcap_freealldevs_apiparam_1
pcap_datalink_apiname return link_layer header type live capture or savefile specify by pcap_datalink_apiparam_1
device which pcap_get_selectable_fd_apiname return pcap_error must be put non_block mode pcap_setnonblock_apiname , attempt must always be make read packet device when select_apiname , poll_apiname , epoll_wait_apiname , or kevent_apiname call return
set packet buffer timeout
if null , pointer next element list ; null last element list addr
previous release , time stamp type can be set ; only default time stamp type offer by capture source be available
pcap_tstamp_type_val_to_name_apiname translate time stamp type value correspond time stamp type name
case , call must be give timeout less than or equal timeout return by pcap_get_required_select_timeout_apiname device which pcap_get_selectable_fd_apiname return pcap_error , device must be put non_block mode call pcap_setnonblock_apiname , attempt must always be make read packet device when call return
get stre give version information about libpcap , call pcap_lib_version
pcap_setfilter 3pcap
note , platform , link_layer header packet send may be as link_layer header packet supply pcap_inject_apiname , as source link_layer address , if header contain such address , may be change be address assign interface which packet send , if platform do support send completely raw unchanged packet
pcap_next 3pcap
pcap_set_promisc_apiname set whether promiscuous mode should be set capture handle when handle be activate
pcap_set_protocol_linux_apiname return # success or pcap_error_activat if call capture handle have activate
pcap_datalink_val_to_name_apiname translate link_layer header type value correspond link_layer header type name , which be dlt name link_layer header type value dlt remove
however , early version libpcap , be safe pcap_compile_apiname multiple thread single process without form mutual exclusion allow only one thread call give time
open handle write capture packet
pcap_loop_apiname return # if pcap_loop_apiparam_2 be exhaust or if , when read savefile , no more packet be available
set immediate mode not_yet_activated pcap_t live capture
pcap_dump_fopen 3pcap
return pcap_strerror_apiparam_1 message string correspond pcap_strerror_apiparam_1
get list available time stamp type not_yet_activate pcap_t live capture
read next packet pcap_t error indication error
van jacobson , craig lere steven mccanne , lawrence berkeley national laboratory , university california , berkeley , ca
return handle must be activate pcap_activate_apiname before packet can be capture ; option capture , such as promiscuous mode , can be set handle before activate
get time stamp type value correspond time stamp type name
pcap_file_apiname return standard stream savefile , if savefile be open pcap_open_offline_apiname , or null , if network device be open pcap_create_apiname pcap_activate_apiname , or pcap_open_live_apiname
set capture protocol not_yet_activated pcap_t live capture linux only
set if device be run pcap_if_wireless
assume packet give capture or savefile have give link_layer header type , such as dlt_en10 mb ethernet
pcap_create_apiname be use create packet capture handle look packet network
create fake pcap_t
open saved capture file reading
pcap_next_ex_apiname read next packet return indication
pcap_statustostr_apiname convert pcap_error or pcap_warn value return by libpcap routine pcap_statustostr_apiparam_1 string
set buffer size
pcap_get_tstamp_precision 3pcap
bitmask indication whether adapter be connect or ; wireless interface , connected mean associate network possible value connection status bit be : pcap_if_connection_status_unknown
pcap_list_tstamp_types_apiname be use get list support time stamp type interface associate pcap descriptor
pcap_findalldevs 3pcap
pointer pcap_dumper_t structure subsequent pcap_dump_apiname pcap_dump_close_apiname call be return success
process do have permission check whether monitor mode could be support
get description time stamp type
another warning condition occur ; pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message describe warning condition
number packet receive ; ps_drop
note : packet buffer timeout can be use cause call read packet return within limited period time , because , platform , packet buffer timeout be support , , other platform , timer do start until least one packet arrive . mean packet buffer timeout should be use , example , interactive application allow packet capture loop poll user input periodically , as no guarantee call read packet return after timeout expire even if no packet have arrive
attempt get timeout require use pcap_t call such as select poll 2
timestamp type
if -PRON- have require privilege , -PRON- can inject packet onto network pcap_t live capture , use pcap_inject or pcap_sendpacket . two routine exist compatibility both openbsd winpcap ; perform function , but have different return value
open file which write packet
get version information libpcap
immediate mode
when pcap_open_dead_with_tstamp_precision_apiname , be use create pcap_t pcap_dump_open_apiname , precision specifie time stamp precision packet ; pcap_tstamp_precision_micro should be specify if packet be write have time stamp second microsecond , pcap_tstamp_precision_nano should be specify if packet be write have time stamp second nanosecond
time stamp precision , link_layer type , snapshot length pcap_dump_fopen_apiparam_1 be use as link_layer type snapshot length output file
device provide more than one link_layer header type . obtain list link_layer header type provide by device , call pcap_list_datalink activate pcap_t device . free list link_layer header type , call pcap_free_datalinks . set link_layer header type device , call pcap_set_datalink . should be do after device have activate but before packet be read before filter be compile or instal
pcap_set_tstamp_precision_apiname return # success if specify time stamp precision be expect be support by capture device , pcap_error_tstamp_precision_notsup if capture device do support request time stamp precision , pcap_error_activat if call capture handle have activate
pcap_set_timeout 3pcap
https : list value pcap_datalink_apiname can return describe packet format correspond value
monitor mode be specify but capture source do support monitor mode
get list time stamp type support by capture device , free list
pcap_open_live_apiparam_1 be stre specifie network pcap_open_live_apiparam_1 open ; linux system # or later kernel , pcap_open_live_apiparam_1 argument or null can be use capture packet interface
selectable file descriptor be return if one exist ; otherwise , pcap_error be return
pcap_major_version 3pcap
both pcap_lookupnet_apiparam_2 pcap_lookupnet_apiparam_3 be bpf_u_int32 pointer
pcap_close 3pcap
if be error , pcap_error be return pcap_getnonblock_apiparam_2 be fill appropriate error message
pcap_lookupnet_apiparam_4 be assume be able hold least pcap_errbuf_size char
pcap_d_in only capture packet receive by device , pcap_d_out only capture packet send by device pcap_d_inout capture packet receive by or send by device
non_block mode be often combine routine such as select or poll or other routine platform offer wait set descriptor be ready read . obtain , handle , descriptor can be use routine , call pcap_get_selectable_fd . if routine indicate datum be available read descriptor , attempt should be make read device
PRON- must have read access system have clone bpf device , or system . bsd devfs , may involve more than just have somebody super_user access set ownership or permission bpf device may involve configure devfs set ownership or permission every time system be boot , if system even support ; if do support , -PRON- may have find other way make happen boot time
routine return error or warning status code ; convert -PRON- string , pcap_statustostr
get name time stamp type
pcap_snapshot 3pcap
capture source device be up
set monitor mode not_yet_activated pcap_t live capture
number packet drop because be no room operate system buffer when arrive , because packet weren t read fast enough ; ps_ifdrop
if pcap_error_break be return pcap_dispatch_apiname or pcap_loop_apiname , flag be clear , so subsequent call resume read packet
return pcap_error if error occur or pcap_error_break if loop terminate due call pcap_breakloop_apiname before packet be process
pcap_list_datalinks_apiname allocate array hold list set dlt_buf point array
open pcap_t savefile , give pathname , specify precision provide packet time stamp
get file descriptor which select can be do live capture
do return when live packet buffer timeout occur
if , when capture , packet be deliver as soon as arrive , application capturing packet be wake up each packet as arrive , may have make one or more call operate system fetch each packet
possible error value be : pcap_error_no_such_device
non_block mode , attempt read capture descriptor pcap_dispatch_apiname , if no packet be currently available be read , return # immediately rather than block wait packet arrive
free list device
ipv4 address have value af_inet , ipv6 address have value af_inet6 , other address have other value
force pcap_dispatch or pcap_loop call return
PRON- must be root or application capturing packet must be instal setuid root unless -PRON- distribution have kernel support capability bit such as cap_net_raw code allow capability bit be give particular account cause bit be set user initial process when log , which case -PRON- must have cap_net_raw order capture cap_net_admin enumerate network device , example , d flag
function become available libpcap release #
if be error , null be return pcap_lookupdev_apiparam_1 be fill appropriate error message
set link
previous release , if immediate delivery packet be require
get version number savefile
set immediate mode
pcap_stats_apiname be support only live capture , savefile ; no statistic be store savefile , so no statistic be available when read savefile
pcap_next_ex be pass two pointer argument , one which point structpcap_pkthdr one which point const u_char . set first pointer point struct pcap_pkthdr structure time stamp length value packet , set second pointer point first caplen byte packet
pcap_create_apiname return pcap_t success null failure
pcap_get_selectable_fd 3pcap
if null , pointer struct sockaddr contain destination address correspond address point by addr ; be null if device be point_to_point interface
pcap_datalink_name_to_val 3pcap
set time stamp type not_yet_activate pcap_t live capture
get first non_loopback device list
be zero if packet do match filter non_zero if packet match filter
PRON- need whatever mechanism os provide break thread out blocking call order unblock thread , such as thread cancellation or thread signal system support posix thread , or setevent_apiname result pcap_getevent_apiname pcap_t which thread be block window
get capture statistic
packet buffer timeout be set pcap_set_timeout
pcap_set_buffer_size 3pcap
select_apiname , poll_apiname , kevent_apiname work correctly bpf device ; pcap_get_selectable_fd_apiname return file descriptor most version , but simple select_apiname , poll_apiname , or kevent_apiname call indicate descriptor be readable until full buffer worth packet be receive , even if packet timeout expire before then
buffer size
pointer return by pcap_lookupdev_apiname point static buffer ; subsequent call pcap_lookupdev_apiname thread , or call pcap_lookupdev_apiname another thread , overwrite buffer
get file pcap_t open savefile
free bpf program
monitor mode , sometimes call rfmon mode , adapter supply frame receive , header , may supply pseudo_header radio information about frame as well
pcap_sendpacket 3pcap
capture handle have already activate
pcap_tstamp_type_name_to_val_apiname return time stamp type value success pcap_error failure
pcap_datalink_val_to_description_apiname translate link_layer header type value short description link_layer header type
if pcap_get_required_select_timeout_apiname return null , be possible wait packet arrive device event loop
pcap_inject_apiname come openbsd ; pcap_sendpacket_apiname come winpcap
pcap_lookupnet_apiname be use determine ipv4 network number mask associate network pcap_lookupnet_apiparam_1 pcap_lookupnet_apiparam_1
even bad , driver platform may change link_layer type field whatever value libpcap use when attach device , even platform nominally support send completely raw unchanged packet
other platform , capture device be always immediate mode
example , device linux have link_layer header type dlt_linux_sll even if device system time device be open have other datum link type , such as dlt_en10 mb ethernet
if null be return , pcap_geterr_apiname can be use get error text
immediate mode , packet be always deliver as soon as arrive , no buffering
statistic behave way platform
unfortunately , be no way determine whether error occur or
read packet network interface require -PRON- have special privilege
pcap_activate 3pcap
snaplen specifie snapshot length pcap_t
value represent packet statistic start run time call
process packet live capture or savefile
pcap_stats 3pcap
PRON- must be root or application capturing packet must be instal setuid root
pcap_set_snaplen_apiname set snapshot length be use capture handle when handle be activate pcap_set_snaplen_apiparam_2
pcap_activate_apiname be use activate packet capture handle look packet network , option be set handle effect
return value one mean only time stamp type support be one list , which be capture device default time stamp type
pcap_breakloop_apiname do guarantee no further packet be process by pcap_dispatch_apiname or pcap_loop_apiname after be call ; most one more packet may be process
note : pointer return no longer point valid error message string after pcap_t pass be close ; -PRON- must or copy string before closing pcap_t
pcap_is_swapp 3pcap
pcap_list_tstamp_types_apiname give list time stamp type support by give capture device
if pcap_major_version_apiparam_1 refer live capture , value return by pcap_major_version_apiname pcap_minor_version_apiname be meaningful
errbuf be assume be able hold least pcap_errbuf_size char
by default , time stamp be microsecond
linktype specifie link_layer type pcap_t
close capture device or savefile
bpf_u_int32 give length packet , byte which may be more than number byte available capture , if length packet be large than maximum number byte capture
additional warning error code be add future ; program should check positive , negative , zero return code , treat positive return code as warning negative return code as error
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_list_datalinks_apiparam_1 as argument fetch or display error text
read bufferful packet pcap_t open live capture or full set packet pcap_t open savefile
pcap_tstamp_type_val_to_description_apiname translate time stamp type value short description time stamp type
translation be case_insensitive
pcap_compile_apiname be use compile stre pcap_compile_apiparam_3 into filter program
see pcap_tstamp_apiname list time stamp type
backward compatibility
non_zero return value indicate what warning or error condition occur
pcap_set_immediate_mode 3pcap
pcap packet capture library
work around , code use call wait packet arrive must put pcap_t non_blocking mode , must arrange call have timeout less than or equal packet buffer timeout , must try read packet after timeout expire , regardless whether call indicate file descriptor pcap_t be ready be read or
pcap_stats_apiname fill struct pcap_stat point by second argument
pcap_freecode_apiname be use free up allocate memory point by pcap_freecode_apiparam_1 struct generate by pcap_compile_apiname when bpf program be no longer need , example after have make filter program pcap structure by call pcap_setfilter_apiname
pcap_get_tstamp_precision_apiname return pcap_tstamp_precision_micro or pcap_tstamp_precision_nano , which indicate pcap capture contain time stamp microsecond or nanosecond respectively
adapter be connect pcap_if_connection_status_disconnected
if null be return , pcap_open_offline_apiparam_2 be fill appropriate error message
previous release , time stamp savefile be always give second microsecond
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_next_ex_apiparam_1 as argument fetch or display error text
if pcap_findalldevs_apiname succeed , pointer point by pcap_findalldevs_apiparam_1 be set point first element list , or null if no device be find be consider success
number packet drop by network interface or driver
each element list address be type pcap_addr_t , have follow member
by default , when read packet interface open live capture , pcap_dispatch , pcap_next , pcap_next_ex , if no packet be currently available be read , block wait packet become available . , but , platform , if packet buffer timeout be specify , wait terminate after packet buffer timeout expire ; application should be prepare , as happen platform , but should rely , as do happen other platform . note wait may , or may , terminate even if no packet be available ; application should be prepare happen , but must rely happen
flush savefile packet dump
pcap_list_tstamp_types_apiname return number time stamp type array success pcap_error failure
pcap_set_immediate_mode_apiname return # success or pcap_error_activat if call capture handle have activate
snapshot length # should be sufficient , most if network , capture datum available packet
if -PRON- application use pcap_breakloop_apiname , make sure -PRON- explicitly check pcap_error pcap_error_break , rather than just check return value #
struct timeval contain time when packet be capture
return value zero mean only time stamp type support be pcap_tstamp_host , which be capture device default time stamp type only old version libpcap return ; new version always return one or more type
if pcap_major_version_apiparam_1 refer savefile , pcap_major_version_apiname return major number file format savefile pcap_minor_version_apiname return minor number file format savefile
see pcap_apiname explanation packet buffer timeout
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_stats_apiparam_1 as argument fetch or display error text
get link
pointer struct sockaddr contain address netmask
linux , previous release libpcap , capture device be always immediate mode ; however , # later , be , by default , immediate mode , so if pcap_set_immediate_mode_apiname be available , should be use
each element list be type pcap_if_t , have follow member
pcap_open_live_apiname be use obtain packet capture handle look packet network
write packet pcap_dumper_t , call pcap_dump . packet write pcap_dump be buffer , rather than immediately write savefile . close pcap_dumper_t cause buffered_but_not_yet_written packet be write savefile . force packet write pcap_dumper_t , yet write savefile because re buffer by pcap_dumper_t , be write savefile , without close pcap_dumper_t , call pcap_dump_flush
pcap_set_datalink_apiname return # success pcap_error failure
packet arrive capture be store buffer , so have be read by application as soon as arrive . platform , buffer size can be set ; size too small could mean , if too many packet be capture snapshot length do limit amount datum buffer , packet could be drop if buffer fill up before application can read packet , while size too large could more non_pageable operating system memory than be necessary prevent packet drop
pcap_datalink_apiname return link_layer header type success pcap_error_not_activate if call capture handle have create but activate
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_list_tstamp_types_apiparam_1 as argument fetch or display error text
get current file position pcap_dumper_t
if pcap_set_promisc_apiparam_2 be non_zero , promiscuous mode be set , otherwise be set
pcap_error be return error
immediate mode , packet be always deliver as soon as arrive , no buffer . immediate mode be set pcap_set_immediate_mode
if packet filtering be do libpcap , rather than operate system , would count packet pass filter
live capture , always return false 0
pcap_tstamp_type_name_to_val 3pcap
pcap_perror_apiname print text last pcap library error stderr , prefix by pcap_perror_apiparam_2
version number be store savefile ; note meaning value depend type savefile example , pcap or pcapng
get link_layer header type pcap_t
if pcap_error be return , pcap_geterr_apiname or pcap_perror_apiname be call pcap_dispatch_apiparam_1 as argument fetch or display error text
pcap_open_live_apiparam_5 be set warning text when pcap_open_live_apiname succeed ; detect case caller should store zero_length string pcap_open_live_apiparam_5 before call pcap_open_live_apiname display warning user if pcap_open_live_apiparam_5 be no longer zero_length string
get name link_layer header type
compile filter expression pseudo_machine_language code program
function become available libpcap release #
ieee wireless lan , even if adapter be promiscuous mode , supply host only frame network which be associate . may supply only data frame , management or control frame , may provide header or radio information pseudo_header frame
set snapshot length
adapter be disconnect pcap_if_connection_status_not_applicable
set if device be wireless interface ; include irda as well as radio_based network such as ieee ieee , so do just mean wi_fi pcap_if_connection_status
pcap_set_datalink_apiname be use set current link_layer header type pcap descriptor type specify by pcap_set_datalink_apiparam_2
should be use portable code ; instead , filter should be specify pcap_setfilter_apiname
pcap_geterr_apiname or pcap_perror_apiname be call pcap_activate_apiparam_1 as argument fetch or display message describing error
both be provide compatibility
if packet be read without problem , pointer point by pcap_next_ex_apiparam_2 argument be set point pcap_pkthdr struct packet , pointer point by pcap_next_ex_apiparam_3 argument be set point datum packet
promiscuous mode be set pcap_set_promisc
under hp_ux dlpi
if null be return , pcap_open_live_apiparam_5 be fill appropriate error message
get snapshot length
pcap_setdirection_apiname be use specify direction packet be capture
pcap_next_ex 3pcap
close pcap_t
set monitor mode
struct pcap_pkthdr packet datum be be free by caller , be guarantee be valid after next call pcap_next_ex_apiname , pcap_next_apiname , pcap_loop_apiname , or pcap_dispatch_apiname ; if code need -PRON- remain valid , must make copy -PRON
pcap_minor_version 3pcap
attempt get descriptor pcap_t can be use call such as select poll 2
incoming outgoing packet
pcap_offline_filter_apiname return return value filter program
get list capture device , free list
user capture network traffic . however , no user can capture promiscuous mode interface unless super_user have enable promiscuous_mode operation interface use pfconfig , no user can capture unicast traffic receive by or send by machine interface unless super_user have enable copy_all_mode operation interface use pfconfig , so useful packet capture interface probably require either promiscuous_mode or copy_all_mode operation , or both mode operation , be enable interface
pcap_offline_filter_apiname check whether filter match packet
set buffer size not_yet_activate pcap_t live capture
pcap_fopen_offline 3pcap
pcap_dump_close_apiname close savefile
pcap_create_apiparam_1 be stre specifie network device open ; linux system # or later kernel , pcap_create_apiparam_1 argument or null can be use capture packet interface
note device which read can be do without block , platform , have packet read if packet buffer timeout have expire
pcap_inject_apiname send raw packet through network interface ; pcap_inject_apiparam_2 point datum packet , include link_layer header , pcap_inject_apiparam_3 be number byte packet
write packet capture file
find default device which capture , call pcap_findalldevs_apiname , if list return be empty , first device list
pcap_open_offline 3pcap
pcap_create , pcap_open_offline , pcap_fopen_offline , pcap_open_dead return pointer pcap_t , which be handle use reading packet capture stream or savefile , find out information about capture stream or savefile . close handle , pcap_close
pcap_findalldevs_apiname construct list network device can be open pcap_create_apiname pcap_activate_apiname or pcap_open_live_apiname
ps_drop be available platform ; be zero platform where be available
pcap_set_snaplen 3pcap
pcap_get_required_select_timeout 3pcap
pcap_set_timeout_apiname set packet buffer timeout be use capture handle when handle be activate pcap_set_timeout_apiparam_2 , which be unit millisecond
transmit packet
free filter program
open pcap_t savefile , give file
pcap_statustostr_apiname can be call , warning or error code as argument , fetch message describe warning or error code
set or get state non
additional error code be add future ; program should check 0 , 1 , negative , return code , treat negative return code as error
open fake pcap_t compile filter or open capture output
activate capture handle
pcap_dump_flush 3pcap
pcap_compile 3pcap
get name or description time stamp type value
set time stamp type be use by capture device
pcap_breakloop 3pcap
pcap_statustostr 3pcap
option can be set capture handle include
get list device can be open live capture
call pcap_dispatch_apiname or pcap_next_ex_apiname return # case , but block
pcap_fopen_offline_with_tstamp_precision_apiname take additional precision argument as describe above
pcap_set_datalink 3pcap
if , when capture , -PRON- capture entire content packet , require more cpu time copy packet -PRON- application , more disk possibly network bandwidth write packet datum file , more disk space save packet . if -PRON- need entire content packet example , if -PRON- be only interested tcp header packet -PRON- can set snapshot length capture appropriate value . if snapshot length be set snaplen , snaplen be less than size packet be capture , only first snaplen byte packet be capture provide as packet datum
if list be empty , be no device which capture be possible
