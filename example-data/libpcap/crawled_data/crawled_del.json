[{"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": ""}, "sent": "pcap_create_APIName and pcap_activate_APIName were not available in versions of libpcap prior to 1.0", "paraph": "", "key": "pcap_create"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": ""}, "sent": "you should use a non-zero timeout", "paraph": "", "key": "pcap_open_live"}, {"API_info": {"var_type": ["char *"], "ret_type": "char *", "var": ["errbuf"], "API_desc": ""}, "sent": "If there is an error, or if pcap_init_APIName has been called, NULL is returned by pcap_lookupdev_APIName and errbuf is filled in with an appropriate error message.", "paraph": "", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "Note that in", "paraph": "Note that in", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop", "paraph": "Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls (for example, regular network devices on FreeBSD 4.3 and 4.4, and Endace DAG devices), so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices. In that case, those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device for which pcap_get_selectable_fd_APIName returned PCAP_ERROR, the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName, and an attempt must always be made to read packets from the device when the call returns. If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "paraph": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired. A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls (for example, regular network devices on FreeBSD 4.3 and 4.4, and Endace DAG devices), so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices.", "paraph": "Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls (for example, regular network devices on FreeBSD 4.3 and 4.4, and Endace DAG devices), so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices. In that case, those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device for which pcap_get_selectable_fd_APIName returned PCAP_ERROR, the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName, and an attempt must always be made to read packets from the device when the call returns. If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "pcap_get_selectable_fd_APIName is not available on Windows", "paraph": "pcap_get_selectable_fd_APIName is not available on Windows", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired.", "paraph": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired. A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "FreeBSD prior to FreeBSD 4.6; NetBSD prior to NetBSD 3.0; OpenBSD prior to OpenBSD 2.4; Mac OS X prior to Mac OS X 10.7", "paraph": "FreeBSD prior to FreeBSD 4.6; NetBSD prior to NetBSD 3.0; OpenBSD prior to OpenBSD 2.4; Mac OS X prior to Mac OS X 10.7", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "A selectable file descriptor be returned by pcap_get_selectable_fd_APIName if one exists; otherwise, PCAP_ERROR be returned by pcap_get_selectable_fd_APIName", "paraph": "A selectable file descriptor be returned by pcap_get_selectable_fd_APIName if one exists; otherwise, PCAP_ERROR be returned by pcap_get_selectable_fd_APIName", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["const struct bpf_program *", "const struct pcap_pkthdr *", "const u_char *"], "ret_type": "int", "var": ["fp", "h", "pkt"], "API_desc": "check whether a filter matches a packet"}, "sent": "pcap_offline_filter_APIName checks whether a filter matches a packet.", "paraph": "pcap_offline_filter_APIName checks whether a filter matches a packet. pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile_APIName. pcap_offline_filter_APIParam_2 points to the pcap_pkthdr structure for the packet, and pcap_offline_filter_APIParam_3 points to the data in the packet", "key": "pcap_offline_filter"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "buffer_size"], "API_desc": "set the buffer size for a not"}, "sent": "pcap_set_buffer_size_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_buffer_size_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_buffer_size_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_buffer_size_APIName is called on a capture handle that has been activated", "key": "pcap_set_buffer_size"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "buffer_size"], "API_desc": "set the buffer size for a not"}, "sent": "pcap_set_buffer_size_APIName sets the buffer size that will be used on a capture handle when the handle is activated to pcap_set_buffer_size_APIParam_2, which is in units of bytes", "paraph": "pcap_set_buffer_size_APIName sets the buffer size that will be used on a capture handle when the handle is activated to pcap_set_buffer_size_APIParam_2, which is in units of bytes", "key": "pcap_set_buffer_size"}, {"API_info": {"var_type": ["const struct bpf_program *", "const struct pcap_pkthdr *", "const u_char *"], "ret_type": "int", "var": ["fp", "h", "pkt"], "API_desc": "check whether a filter matches a packet"}, "sent": "pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile_APIName.", "paraph": "pcap_offline_filter_APIName checks whether a filter matches a packet. pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile_APIName. pcap_offline_filter_APIParam_2 points to the pcap_pkthdr structure for the packet, and pcap_offline_filter_APIParam_3 points to the data in the packet", "key": "pcap_offline_filter"}, {"API_info": {"var_type": ["const struct bpf_program *", "const struct pcap_pkthdr *", "const u_char *"], "ret_type": "int", "var": ["fp", "h", "pkt"], "API_desc": "check whether a filter matches a packet"}, "sent": "pcap_offline_filter_APIName returns the return value of the filter program.", "paraph": "pcap_offline_filter_APIName returns the return value of the filter program. This will be zero if the packet does not match the filter and non-zero if the packet matches the filter", "key": "pcap_offline_filter"}, {"API_info": {"var_type": ["const struct bpf_program *", "const struct pcap_pkthdr *", "const u_char *"], "ret_type": "int", "var": ["fp", "h", "pkt"], "API_desc": "check whether a filter matches a packet"}, "sent": "pcap_offline_filter_APIParam_2 points to the pcap_pkthdr structure for the packet, and pcap_offline_filter_APIParam_3 points to the data in the packet", "paraph": "pcap_offline_filter_APIName checks whether a filter matches a packet. pcap_offline_filter_APIParam_1 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile_APIName. pcap_offline_filter_APIParam_2 points to the pcap_pkthdr structure for the packet, and pcap_offline_filter_APIParam_3 points to the data in the packet", "key": "pcap_offline_filter"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *"], "ret_type": "int", "var": ["p", "fp"], "API_desc": "set the filter"}, "sent": "pcap_setfilter_APIName is used to specify a filter program.", "paraph": "pcap_setfilter_APIName is used to specify a filter program. pcap_setfilter_APIParam_2 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile(3PCAP", "key": "pcap_setfilter"}, {"API_info": {"var_type": ["const struct bpf_program *", "const struct pcap_pkthdr *", "const u_char *"], "ret_type": "int", "var": ["fp", "h", "pkt"], "API_desc": "check whether a filter matches a packet"}, "sent": "This will be zero if the packet does not match the filter and non-zero if the packet matches the filter", "paraph": "pcap_offline_filter_APIName returns the return value of the filter program. This will be zero if the packet does not match the filter and non-zero if the packet matches the filter", "key": "pcap_offline_filter"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *"], "ret_type": "int", "var": ["p", "fp"], "API_desc": "set the filter"}, "sent": "pcap_setfilter_APIName returns 0 on success and PCAP_ERROR on failure.", "paraph": "pcap_setfilter_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_setfilter_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setfilter_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_setfilter"}, {"API_info": {"var_type": ["int", "int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "linktype specifies the link-layer type for the pcap_t", "paraph": "linktype specifies the link-layer type for the pcap_t", "key": "pcap_open_dead"}, {"API_info": {"var_type": ["int", "int", "u_int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen", "precision"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "snaplen specifies the snapshot length for the pcap_t", "paraph": "snaplen specifies the snapshot length for the pcap_t", "key": "pcap_open_dead_with_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "-LRB- That workaround will not work in FreeBSD 4.3 and later ; however , in FreeBSD 4.6 and later , those calls work correctly on BPF devices , so the workaround is not necessary , ", "paraph": "select_APIName, poll_APIName, and kevent_APIName do not work correctly on BPF devices; pcap_get_selectable_fd_APIName will return a file descriptor on most of those versions (the exceptions being FreeBSD 4.3 and 4.4), but a simple select_APIName, poll_APIName, or kevent_APIName call will not indicate that the descriptor is readable until a full buffer worth of packets is received, even if the packet timeout expires before then. To work around this, code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode, and must arrange that the call have a timeout less than or equal to the packet buffer timeout, and must try to read packets after that timeout expires, regardless of whether the call indicated that the file descriptor for the pcap_t is ready to be read or not. (That workaround will not work in FreeBSD 4.3 and later; however, in FreeBSD 4.6 and later, those calls work correctly on BPF devices, so the workaround is not necessary, although it does no harm", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *"], "ret_type": "int", "var": ["p", "fp"], "API_desc": "set the filter"}, "sent": "If PCAP_ERROR be returned by pcap_setfilter_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setfilter_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_setfilter_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_setfilter_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setfilter_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_setfilter"}, {"API_info": {"var_type": ["int", "int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "pcap_open_dead_APIName and pcap_open_dead_with_tstamp_precision_APIName are used for creating a pcap_t structure to use when calling the other functions in libpcap.", "paraph": "pcap_open_dead_APIName and pcap_open_dead_with_tstamp_precision_APIName are used for creating a pcap_t structure to use when calling the other functions in libpcap. It is typically used when just using libpcap for compiling BPF code; it can also be used if using pcap_dump_open_APIName, pcap_dump_APIName, and pcap_dump_close_APIName to write a savefile if there is no pcap_t that supplies the packets to be written", "key": "pcap_open_dead"}, {"API_info": {"var_type": ["int", "int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "Its value does not affect pcap_compile(3PCAP", "paraph": "When pcap_open_dead_with_tstamp_precision_APIName, is used to create a pcap_t for use with pcap_dump_open_APIName, precision specifies the time stamp precision for packets; PCAP_TSTAMP_PRECISION_MICRO should be specified if the packets to be written have time stamps in seconds and microseconds, and PCAP_TSTAMP_PRECISION_NANO should be specified if the packets to be written have time stamps in seconds and nanoseconds. Its value does not affect pcap_compile(3PCAP", "key": "pcap_open_dead"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "pcap_setdirection_APIName is used to specify a direction that packets will be captured.", "paraph": "pcap_setdirection_APIName is used to specify a direction that packets will be captured. pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN, PCAP_D_OUT or PCAP_D_INOUT. PCAP_D_IN will only capture packets received by the device, PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device. PCAP_D_INOUT is the default setting if pcap_setdirection_APIName is not called", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN, PCAP_D_OUT or PCAP_D_INOUT.", "paraph": "pcap_setdirection_APIName is used to specify a direction that packets will be captured. pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN, PCAP_D_OUT or PCAP_D_INOUT. PCAP_D_IN will only capture packets received by the device, PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device. PCAP_D_INOUT is the default setting if pcap_setdirection_APIName is not called", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "PCAP_D_INOUT is the default setting if pcap_setdirection_APIName is not called", "paraph": "pcap_setdirection_APIName is used to specify a direction that packets will be captured. pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN, PCAP_D_OUT or PCAP_D_INOUT. PCAP_D_IN will only capture packets received by the device, PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device. PCAP_D_INOUT is the default setting if pcap_setdirection_APIName is not called", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "This operation is not supported if a savefile is being read", "paraph": "This operation is not supported if a savefile is being read", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "pcap_setdirection_APIName returns 0 on success and PCAP_ERROR on failure.", "paraph": "pcap_setdirection_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_setdirection_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setdirection_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "PCAP_D_IN will only capture packets received by the device, PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device.", "paraph": "pcap_setdirection_APIName is used to specify a direction that packets will be captured. pcap_setdirection_APIParam_2 is one of the constants PCAP_D_IN, PCAP_D_OUT or PCAP_D_INOUT. PCAP_D_IN will only capture packets received by the device, PCAP_D_OUT will only capture packets sent by the device and PCAP_D_INOUT will capture packets received by or sent by the device. PCAP_D_INOUT is the default setting if pcap_setdirection_APIName is not called", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["int", "int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "It is typically used when just using libpcap for compiling BPF code; it can also be used if using pcap_dump_open_APIName, pcap_dump_APIName, and pcap_dump_close_APIName to write a savefile if there is no pcap_t that supplies the packets to be written", "paraph": "pcap_open_dead_APIName and pcap_open_dead_with_tstamp_precision_APIName are used for creating a pcap_t structure to use when calling the other functions in libpcap. It is typically used when just using libpcap for compiling BPF code; it can also be used if using pcap_dump_open_APIName, pcap_dump_APIName, and pcap_dump_close_APIName to write a savefile if there is no pcap_t that supplies the packets to be written", "key": "pcap_open_dead"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["error"], "API_desc": "convert a PCAP_ERROR_ or PCAP_WARNING_ value to a string"}, "sent": "pcap_statustostr_APIName converts a PCAP_ERROR_ or PCAP_WARNING_ value returned by a libpcap routine to an pcap_statustostr_APIParam_1 string", "paraph": "pcap_statustostr_APIName converts a PCAP_ERROR_ or PCAP_WARNING_ value returned by a libpcap routine to an pcap_statustostr_APIParam_1 string", "key": "pcap_statustostr"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "pcap_setdirection_APIName is not necessarily fully supported on all platforms; some platforms might return an error for all values, and some other platforms might not support PCAP_D_OUT", "paraph": "pcap_setdirection_APIName is not necessarily fully supported on all platforms; some platforms might return an error for all values, and some other platforms might not support PCAP_D_OUT", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "pcap_get_selectable_fd_APIName returns, on UNIX, a file descriptor number for a file descriptor on which one can do a select_APIName, poll_APIName, epoll_wait_APIName, kevent_APIName, or other such call to wait for it to be possible to read packets without blocking, if such a descriptor exists, or PCAP_ERROR, if no such descriptor exists", "paraph": "pcap_get_selectable_fd_APIName returns, on UNIX, a file descriptor number for a file descriptor on which one can do a select_APIName, poll_APIName, epoll_wait_APIName, kevent_APIName, or other such call to wait for it to be possible to read packets without blocking, if such a descriptor exists, or PCAP_ERROR, if no such descriptor exists", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "long", "var": ["p"], "API_desc": "get the current file offset for a savefile being written"}, "sent": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error.", "paraph": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error. If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows. pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "key": "pcap_dump_ftell"}, {"API_info": {"var_type": ["pcap_t *", "pcap_direction_t"], "ret_type": "int", "var": ["p", "d"], "API_desc": "set the direction for which packets will be captured"}, "sent": "If PCAP_ERROR be returned by pcap_setdirection_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setdirection_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_setdirection_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_setdirection_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_setdirection_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_setdirection"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "long", "var": ["p"], "API_desc": "get the current file offset for a savefile being written"}, "sent": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName.", "paraph": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error. If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows. pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "key": "pcap_dump_ftell"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "long", "var": ["p"], "API_desc": "get the current file offset for a savefile being written"}, "sent": "PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "paraph": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error. If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows. pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "key": "pcap_dump_ftell"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *"], "ret_type": "int", "var": ["p", "fp"], "API_desc": "set the filter"}, "sent": "pcap_setfilter_APIParam_2 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile(3PCAP", "paraph": "pcap_setfilter_APIName is used to specify a filter program. pcap_setfilter_APIParam_2 is a pointer to a bpf_program struct, usually the result of a call to pcap_compile(3PCAP", "key": "pcap_setfilter"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the link"}, "sent": "The translation is case-insensitive", "paraph": "pcap_datalink_name_to_val_APIName translates a link-layer header type pcap_datalink_name_to_val_APIParam_1, which is a DLT_ pcap_datalink_name_to_val_APIParam_1 with the DLT_ removed, to the corresponding link-layer header type value. The translation is case-insensitive", "key": "pcap_datalink_name_to_val"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "In that case , those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device  , the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the call returns .", "paraph": "Some network devices opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, do not support those calls (for example, regular network devices on FreeBSD 4.3 and 4.4, and Endace DAG devices), so PCAP_ERROR be returned by pcap_get_selectable_fd_APIName for those devices. In that case, those calls must be given a timeout less than or equal to the timeout returned by pcap_get_required_select_timeout_APIName for the device for which pcap_get_selectable_fd_APIName returned PCAP_ERROR, the device must be put in non-blocking mode with a call to pcap_setnonblock_APIName, and an attempt must always be made to read packets from the device when the call returns. If pcap_get_required_select_timeout_APIName returns NULL, it is not possible to wait for packets to arrive on the device in an event loop", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "long", "var": ["p"], "API_desc": "get the current file offset for a savefile being written"}, "sent": "If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows.", "paraph": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error. If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows. pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "key": "pcap_dump_ftell"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the link"}, "sent": "pcap_datalink_name_to_val_APIName returns the type value on success and PCAP_ERROR if the pcap_datalink_name_to_val_APIParam_1 is not a known type name", "paraph": "pcap_datalink_name_to_val_APIName returns the type value on success and PCAP_ERROR if the pcap_datalink_name_to_val_APIParam_1 is not a known type name", "key": "pcap_datalink_name_to_val"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the link"}, "sent": "pcap_datalink_name_to_val_APIName translates a link-layer header type pcap_datalink_name_to_val_APIParam_1, which is a DLT_ pcap_datalink_name_to_val_APIParam_1 with the DLT_ removed, to the corresponding link-layer header type value.", "paraph": "pcap_datalink_name_to_val_APIName translates a link-layer header type pcap_datalink_name_to_val_APIParam_1, which is a DLT_ pcap_datalink_name_to_val_APIParam_1 with the DLT_ removed, to the corresponding link-layer header type value. The translation is case-insensitive", "key": "pcap_datalink_name_to_val"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "Two time stamp precisions are supported, microseconds and nanoseconds.", "paraph": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. Two time stamp precisions are supported, microseconds and nanoseconds. One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision. By default, time stamps are in microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName.", "paraph": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. Two time stamp precisions are supported, microseconds and nanoseconds. One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision. By default, time stamps are in microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision.", "paraph": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. Two time stamp precisions are supported, microseconds and nanoseconds. One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision. By default, time stamps are in microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2.", "paraph": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. Two time stamp precisions are supported, microseconds and nanoseconds. One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision. By default, time stamps are in microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "By default, time stamps are in microseconds", "paraph": "pcap_set_tstamp_precision_APIName sets the precision of the time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_precision_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. Two time stamp precisions are supported, microseconds and nanoseconds. One can use options PCAP_TSTAMP_PRECISION_MICRO and PCAP_TSTAMP_PRECISION_NANO to request desired precision. By default, time stamps are in microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "pcap_set_tstamp_precision_APIName became available in libpcap release 1.5.1.", "paraph": "pcap_set_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "long", "var": ["p"], "API_desc": "get the current file offset for a savefile being written"}, "sent": "pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation.", "paraph": "pcap_dump_ftell_APIName returns the current file position for the savefile, representing the number of bytes written by pcap_dump_open_APIName and pcap_dump_APIName. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error. If the current file position does not fit in a long, it will be truncated; this can happen on 32-bit UNIX-like systems with large file support and on Windows. pcap_dump_ftell64_APIName returns the current file position in a int64_t, so if file offsets that do not fit in a long but that fit in a int64_t are supported, this will return the file offset without truncation. PCAP_ERROR be returned by pcap_dump_ftell_APIName on error", "key": "pcap_dump_ftell"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "select_APIName , poll_APIName , and kevent_APIName do not work correctly on BPF devices ; pcap_get_selectable_fd_APIName will return a file descriptor on most of those versions , but a simple select_APIName , poll_APIName , or kevent_APIName call will not indicate that the descriptor is readable until a full buffer worth of packets is received ,  .", "paraph": "select_APIName, poll_APIName, and kevent_APIName do not work correctly on BPF devices; pcap_get_selectable_fd_APIName will return a file descriptor on most of those versions (the exceptions being FreeBSD 4.3 and 4.4), but a simple select_APIName, poll_APIName, or kevent_APIName call will not indicate that the descriptor is readable until a full buffer worth of packets is received, even if the packet timeout expires before then. To work around this, code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode, and must arrange that the call have a timeout less than or equal to the packet buffer timeout, and must try to read packets after that timeout expires, regardless of whether the call indicated that the file descriptor for the pcap_t is ready to be read or not. (That workaround will not work in FreeBSD 4.3 and later; however, in FreeBSD 4.6 and later, those calls work correctly on BPF devices, so the workaround is not necessary, although it does no harm", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["tstamp_type"], "API_desc": "get a name or description for a time stamp type value"}, "sent": "These functions became available in libpcap release 1.2.1", "paraph": "These functions became available in libpcap release 1.2.1", "key": "pcap_tstamp_type_val_to_description"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["tstamp_type"], "API_desc": "get a name or description for a time stamp type value"}, "sent": "NULL be returned by pcap_tstamp_type_val_to_description_APIName on failure", "paraph": "pcap_tstamp_type_val_to_description_APIName translates a time stamp type value to a short description of that time stamp type. NULL be returned by pcap_tstamp_type_val_to_description_APIName on failure", "key": "pcap_tstamp_type_val_to_description"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["tstamp_type"], "API_desc": "get a name or description for a time stamp type value"}, "sent": "NULL be returned by pcap_tstamp_type_val_to_name_APIName on failure", "paraph": "pcap_tstamp_type_val_to_name_APIName translates a time stamp type value to the corresponding time stamp type name. NULL be returned by pcap_tstamp_type_val_to_name_APIName on failure", "key": "pcap_tstamp_type_val_to_name"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "It does not return when live packet buffer timeouts occur.", "paraph": "pcap_loop_APIName processes packets from a live capture or savefile until pcap_loop_APIParam_2 packets are processed, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. It does not return when live packet buffer timeouts occur. A value of -1 or 0 for pcap_loop_APIParam_2 is equivalent to infinity, so that packets are processed until another ending condition occurs", "key": "pcap_loop"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["tstamp_type"], "API_desc": "get a name or description for a time stamp type value"}, "sent": "pcap_tstamp_type_val_to_name_APIName translates a time stamp type value to the corresponding time stamp type name.", "paraph": "pcap_tstamp_type_val_to_name_APIName translates a time stamp type value to the corresponding time stamp type name. NULL be returned by pcap_tstamp_type_val_to_name_APIName on failure", "key": "pcap_tstamp_type_val_to_name"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "The bytes of data from the packet begin with a link-layer header.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "Applications should be prepared for this to happen, but must not rely on it happening", "paraph": "Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, pcap_dispatch_APIName will return 0, even when not in non-blocking mode, as there are no packets to process. Applications should be prepared for this to happen, but must not rely on it happening", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "paraph": "pcap_set_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["tstamp_type"], "API_desc": "get a name or description for a time stamp type value"}, "sent": "pcap_tstamp_type_val_to_description_APIName translates a time stamp type value to a short description of that time stamp type.", "paraph": "pcap_tstamp_type_val_to_description_APIName translates a time stamp type value to a short description of that time stamp type. NULL be returned by pcap_tstamp_type_val_to_description_APIName on failure", "key": "pcap_tstamp_type_val_to_description"}, {"API_info": {"var_type": ["int", "int"], "ret_type": "pcap_t *", "var": ["linktype", "snaplen"], "API_desc": "open a fake pcap_t for compiling filters or opening a capture for output"}, "sent": "When pcap_open_dead_with_tstamp_precision_APIName, is used to create a pcap_t for use with pcap_dump_open_APIName, precision specifies the time stamp precision for packets; PCAP_TSTAMP_PRECISION_MICRO should be specified if the packets to be written have time stamps in seconds and microseconds, and PCAP_TSTAMP_PRECISION_NANO should be specified if the packets to be written have time stamps in seconds and nanoseconds.", "paraph": "When pcap_open_dead_with_tstamp_precision_APIName, is used to create a pcap_t for use with pcap_dump_open_APIName, precision specifies the time stamp precision for packets; PCAP_TSTAMP_PRECISION_MICRO should be specified if the packets to be written have time stamps in seconds and microseconds, and PCAP_TSTAMP_PRECISION_NANO should be specified if the packets to be written have time stamps in seconds and nanoseconds. Its value does not affect pcap_compile(3PCAP", "key": "pcap_open_dead"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "It does not return when live packet buffer timeouts occur; instead, it attempts to read more packets", "paraph": "pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available. pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. It does not return when live packet buffer timeouts occur; instead, it attempts to read more packets", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available.", "paraph": "pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available. pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. It does not return when live packet buffer timeouts occur; instead, it attempts to read more packets", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "A value of -1 or 0 for pcap_loop_APIParam_2 is equivalent to infinity, so that packets are processed until another ending condition occurs", "paraph": "pcap_loop_APIName processes packets from a live capture or savefile until pcap_loop_APIParam_2 packets are processed, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. It does not return when live packet buffer timeouts occur. A value of -1 or 0 for pcap_loop_APIParam_2 is equivalent to infinity, so that packets are processed until another ending condition occurs", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet.", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed.", "paraph": "pcap_loop_APIName returns 0 if pcap_loop_APIParam_2 is exhausted or if, when reading from a savefile, no more packets are available. pcap_loop_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. It does not return when live packet buffer timeouts occur; instead, it attempts to read more packets", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed.", "paraph": "pcap_dispatch_APIName returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a savefile. pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "If PCAP_ERROR be returned by pcap_dispatch_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_dispatch_APIParam_1 as an argument to fetch or display the error text", "paraph": "If PCAP_ERROR be returned by pcap_dispatch_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_dispatch_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0", "paraph": "pcap_dispatch_APIName returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a savefile. pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_dispatch_APIName returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a savefile.", "paraph": "pcap_dispatch_APIName returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a savefile. pcap_dispatch_APIName returns PCAP_ERROR if an error occurs or PCAP_ERROR_BREAK if the loop terminated due to a call to pcap_breakloop_APIName before any packets were processed. If your application uses pcap_breakloop_APIName, make sure that you explicitly check for PCAP_ERROR and PCAP_ERROR_BREAK, rather than just checking for a return value < 0", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "On network interface devices on Linux, pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket when the handle is activated.", "paraph": "On network interface devices on Linux, pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket when the handle is activated. The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h> header file, specified in host byte order. If pcap_set_protocol_linux_APIParam_2 is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured. pcap_set_protocol_linux_APIName is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h> header file, specified in host byte order.", "paraph": "On network interface devices on Linux, pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket when the handle is activated. The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h> header file, specified in host byte order. If pcap_set_protocol_linux_APIParam_2 is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured. pcap_set_protocol_linux_APIName is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "If pcap_set_protocol_linux_APIParam_2 is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured.", "paraph": "On network interface devices on Linux, pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket when the handle is activated. The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h> header file, specified in host byte order. If pcap_set_protocol_linux_APIParam_2 is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured. pcap_set_protocol_linux_APIName is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "pcap_set_protocol_linux_APIName became available in libpcap release 1.9.0", "paraph": "pcap_set_protocol_linux_APIName became available in libpcap release 1.9.0", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "pcap_set_protocol_linux_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_protocol_linux_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_protocol_linux_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_protocol_linux_APIName is called on a capture handle that has been activated", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "pcap_set_protocol_linux_APIName is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect", "paraph": "On network interface devices on Linux, pcap_set_protocol_linux_APIName sets the pcap_set_protocol_linux_APIParam_2 to be used in the socket_APIName call to create a capture socket when the handle is activated. The argument is a link-layer pcap_set_protocol_linux_APIParam_2 value, such as the values in the <linux/if_ether.h> header file, specified in host byte order. If pcap_set_protocol_linux_APIParam_2 is non-zero, packets of that pcap_set_protocol_linux_APIParam_2 will be captured when the handle is activated, otherwise, all packets will be captured. pcap_set_protocol_linux_APIName is only provided on Linux, and, if it is used on any device other than a network interface, it will have no effect", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_loop_APIName processes packets from a live capture or savefile until pcap_loop_APIParam_2 packets are processed, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs.", "paraph": "pcap_loop_APIName processes packets from a live capture or savefile until pcap_loop_APIParam_2 packets are processed, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. It does not return when live packet buffer timeouts occur. A value of -1 or 0 for pcap_loop_APIParam_2 is equivalent to infinity, so that packets are processed until another ending condition occurs", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "A value of -1 or 0 for pcap_dispatch_APIParam_2 causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a savefile", "paraph": "pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. Thus, when doing a live capture, pcap_dispatch_APIParam_2 is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than pcap_dispatch_APIParam_2 packets may be processed. A value of -1 or 0 for pcap_dispatch_APIParam_2 causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a savefile", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, pcap_dispatch_APIName will return 0, even when not in non-blocking mode, as there are no packets to process.", "paraph": "Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, pcap_dispatch_APIName will return 0, even when not in non-blocking mode, as there are no packets to process. Applications should be prepared for this to happen, but must not rely on it happening", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "dlt_buf"], "API_desc": "get a list of link"}, "sent": "pcap_list_datalinks_APIName allocates an array to hold the list and sets *dlt_buf to point to that array", "paraph": "pcap_list_datalinks_APIName is used to get a list of the supported link-layer header types of the interface associated with the pcap descriptor. pcap_list_datalinks_APIName allocates an array to hold the list and sets *dlt_buf to point to that array", "key": "pcap_list_datalinks"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_precision"], "API_desc": "set the time stamp precision returned in captures"}, "sent": "pcap_set_tstamp_precision_APIName returns 0 on success if the specified time stamp precision is expected to be supported by the capture device, PCAP_ERROR_TSTAMP_PRECISION_NOTSUP if the capture device does not support the requested time stamp precision, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_precision_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_tstamp_precision_APIName returns 0 on success if the specified time stamp precision is expected to be supported by the capture device, PCAP_ERROR_TSTAMP_PRECISION_NOTSUP if the capture device does not support the requested time stamp precision, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_precision_APIName is called on a capture handle that has been activated", "key": "pcap_set_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "dlt_buf"], "API_desc": "get a list of link"}, "sent": "pcap_list_datalinks_APIName is used to get a list of the supported link-layer header types of the interface associated with the pcap descriptor.", "paraph": "pcap_list_datalinks_APIName is used to get a list of the supported link-layer header types of the interface associated with the pcap descriptor. pcap_list_datalinks_APIName allocates an array to hold the list and sets *dlt_buf to point to that array", "key": "pcap_list_datalinks"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "For example , the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL ", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_loop"}, {"API_info": {"var_type": ["int *"], "ret_type": "void", "var": ["dlt_list"], "API_desc": "get a list of link"}, "sent": "The caller is responsible for freeing the array with pcap_free_datalinks_APIName, which frees the list of link-layer header types pointed to by dlt_list", "paraph": "The caller is responsible for freeing the array with pcap_free_datalinks_APIName, which frees the list of link-layer header types pointed to by dlt_list", "key": "pcap_free_datalinks"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_loop_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "The struct pcap_pkthdr and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns; if the code needs them to be valid after the pcap_loop_APIParam_3, it must make a copy of them", "paraph": "callback specifies a pcap_handler routine to be called with three arguments: a u_char pointer which is passed in the pcap_loop_APIParam_4 argument to pcap_loop_APIName or pcap_dispatch_APIName, a const struct pcap_pkthdr pointer pointing to the packet time stamp and lengths, and a const u_char pointer to the first caplen (as given in the struct pcap_pkthdr a pointer to which is passed to the pcap_loop_APIParam_3 routine) bytes of data from the packet. The struct pcap_pkthdr and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns; if the code needs them to be valid after the pcap_loop_APIParam_3, it must make a copy of them", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "(In older versions of libpcap, the behavior when pcap_dispatch_APIParam_2 was 0 was undefined; different platforms and devices behaved differently, so code that must work with older versions of libpcap should use -1, not 0, as the value of cnt", "paraph": "(In older versions of libpcap, the behavior when pcap_dispatch_APIParam_2 was 0 was undefined; different platforms and devices behaved differently, so code that must work with older versions of libpcap should use -1, not 0, as the value of cnt", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "To work around this , code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode , and must arrange that the call have a timeout less than or equal to the packet buffer timeout , and must try to read packets after that timeout expires , regardless of  .", "paraph": "select_APIName, poll_APIName, and kevent_APIName do not work correctly on BPF devices; pcap_get_selectable_fd_APIName will return a file descriptor on most of those versions (the exceptions being FreeBSD 4.3 and 4.4), but a simple select_APIName, poll_APIName, or kevent_APIName call will not indicate that the descriptor is readable until a full buffer worth of packets is received, even if the packet timeout expires before then. To work around this, code that uses those calls to wait for packets to arrive must put the pcap_t in non-blocking mode, and must arrange that the call have a timeout less than or equal to the packet buffer timeout, and must try to read packets after that timeout expires, regardless of whether the call indicated that the file descriptor for the pcap_t is ready to be read or not. (That workaround will not work in FreeBSD 4.3 and later; however, in FreeBSD 4.6 and later, those calls work correctly on BPF devices, so the workaround is not necessary, although it does no harm", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "Thus, when doing a live capture, pcap_dispatch_APIParam_2 is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than pcap_dispatch_APIParam_2 packets may be processed.", "paraph": "pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. Thus, when doing a live capture, pcap_dispatch_APIParam_2 is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than pcap_dispatch_APIParam_2 packets may be processed. A value of -1 or 0 for pcap_dispatch_APIParam_2 causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a savefile", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "FILE *", "var": ["p"], "API_desc": "get the standard I/O stream for a savefile being read"}, "sent": "Note that the Packet Capture library is usually built with large file support, so the standard I/O stream of the savefile might refer to a file larger than 2 gigabytes; applications that use pcap_file_APIName should, if possible, use calls that support large files on the return value of pcap_file_APIName or the value returned by fileno_APIName when passed the return value of pcap_file", "paraph": "Note that the Packet Capture library is usually built with large file support, so the standard I/O stream of the savefile might refer to a file larger than 2 gigabytes; applications that use pcap_file_APIName should, if possible, use calls that support large files on the return value of pcap_file_APIName or the value returned by fileno_APIName when passed the return value of pcap_file", "key": "pcap_file"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs.", "paraph": "pcap_dispatch_APIName processes packets from a live capture or savefile until pcap_dispatch_APIParam_2 packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the savefile is reached when reading from a savefile, pcap_breakloop_APIName is called, or an error occurs. Thus, when doing a live capture, pcap_dispatch_APIParam_2 is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than pcap_dispatch_APIParam_2 packets may be processed. A value of -1 or 0 for pcap_dispatch_APIParam_2 causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a savefile", "key": "pcap_dispatch"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "It should not be used in portable code; instead, a filter should be specified with pcap_setfilter(3PCAP", "paraph": "It should not be used in portable code; instead, a filter should be specified with pcap_setfilter(3PCAP", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *", "int", "pcap_handler", "u_char *"], "ret_type": "int", "var": ["p", "cnt", "callback", "user"], "API_desc": "process packets from a live capture or savefile"}, "sent": "callback specifies a pcap_handler routine to be called with three arguments: a u_char pointer which is passed in the pcap_loop_APIParam_4 argument to pcap_loop_APIName or pcap_dispatch_APIName, a const struct pcap_pkthdr pointer pointing to the packet time stamp and lengths, and a const u_char pointer to the first caplen (as given in the struct pcap_pkthdr a pointer to which is passed to the pcap_loop_APIParam_3 routine) bytes of data from the packet.", "paraph": "callback specifies a pcap_handler routine to be called with three arguments: a u_char pointer which is passed in the pcap_loop_APIParam_4 argument to pcap_loop_APIName or pcap_dispatch_APIName, a const struct pcap_pkthdr pointer pointing to the packet time stamp and lengths, and a const u_char pointer to the first caplen (as given in the struct pcap_pkthdr a pointer to which is passed to the pcap_loop_APIParam_3 routine) bytes of data from the packet. The struct pcap_pkthdr and the packet data are not to be freed by the pcap_loop_APIParam_3 routine, and are not guaranteed to be valid after the pcap_loop_APIParam_3 routine returns; if the code needs them to be valid after the pcap_loop_APIParam_3, it must make a copy of them", "key": "pcap_loop"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "protocol"], "API_desc": "set capture protocol for a not"}, "sent": "If a given network interface provides a standard link-layer header, with a standard packet type, but provides some packet types with a different socket-layer pcap_set_protocol_linux_APIParam_2 type from the one in the link-layer header, that packet type cannot be filtered with a filter specified with pcap_setfilter_APIName but can be filtered by specifying the socket-layer pcap_set_protocol_linux_APIParam_2 type using pcap_set_protocol_linux", "paraph": "If a given network interface provides a standard link-layer header, with a standard packet type, but provides some packet types with a different socket-layer pcap_set_protocol_linux_APIParam_2 type from the one in the link-layer header, that packet type cannot be filtered with a filter specified with pcap_setfilter_APIName but can be filtered by specifying the socket-layer pcap_set_protocol_linux_APIParam_2 type using pcap_set_protocol_linux", "key": "pcap_set_protocol_linux"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "Note also that poll_APIName and kevent_APIName does not work on character special files, including BPF devices, in Mac OS X 10.4 and 10.5, so, while select_APIName can be used on the descriptor returned by pcap_get_selectable_fd_APIName, poll_APIName and kevent_APIName cannot be used on it those versions of Mac OS X. poll_APIName, but not kevent_APIName, works on that descriptor in Mac OS X releases prior to 10.4; poll_APIName and kevent_APIName work on that descriptor in Mac OS X 10.6 and later", "paraph": "Note also that poll_APIName and kevent_APIName does not work on character special files, including BPF devices, in Mac OS X 10.4 and 10.5, so, while select_APIName can be used on the descriptor returned by pcap_get_selectable_fd_APIName, poll_APIName and kevent_APIName cannot be used on it those versions of Mac OS X. poll_APIName, but not kevent_APIName, works on that descriptor in Mac OS X releases prior to 10.4; poll_APIName and kevent_APIName work on that descriptor in Mac OS X 10.6 and later", "key": "pcap_get_selectable_fd"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "FILE *", "var": ["p"], "API_desc": "get the standard I/O stream for a savefile being read"}, "sent": "pcap_file_APIName returns the standard I/O stream of the savefile, if a savefile was opened with pcap_open_offline_APIName, or NULL, if a network device was opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live(3PCAP", "paraph": "pcap_file_APIName returns the standard I/O stream of the savefile, if a savefile was opened with pcap_open_offline_APIName, or NULL, if a network device was opened with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live(3PCAP", "key": "pcap_file"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "dlt_buf"], "API_desc": "get a list of link"}, "sent": "If PCAP_ERROR be returned by pcap_list_datalinks_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_datalinks_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_list_datalinks_APIName returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED if pcap_list_datalinks_APIName is called on a capture handle that has been created but not activated, and PCAP_ERROR on other errors. If PCAP_ERROR be returned by pcap_list_datalinks_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_datalinks_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_datalinks"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "Note also that some devices might not support sending packets", "paraph": "Note that, even if you successfully open the network interface, you might not have permission to send packets on it, or it might not support sending packets; as pcap_open_live_APIName does not have a flag to indicate whether to open for capturing, sending, or capturing and sending, you cannot request an open that supports sending and be notified at open time whether sending will be possible. Note also that some devices might not support sending packets", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "Both are provided for compatibility", "paraph": "pcap_sendpacket_APIName is like pcap_inject_APIName, but pcap_inject_APIName returns 0 on success, rather than returning the number of bytes written. (pcap_inject_APIName comes from OpenBSD; pcap_sendpacket_APIName comes from WinPcap. Both are provided for compatibility", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "pcap_sendpacket_APIName is like pcap_inject_APIName, but pcap_inject_APIName returns 0 on success, rather than returning the number of bytes written.", "paraph": "pcap_sendpacket_APIName is like pcap_inject_APIName, but pcap_inject_APIName returns 0 on success, rather than returning the number of bytes written. (pcap_inject_APIName comes from OpenBSD; pcap_sendpacket_APIName comes from WinPcap. Both are provided for compatibility", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "pcap_inject_APIName returns the number of bytes written on success and PCAP_ERROR on failure", "paraph": "pcap_inject_APIName returns the number of bytes written on success and PCAP_ERROR on failure", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "const u_char *", "int"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "pcap_sendpacket_APIName returns 0 on success and PCAP_ERROR on failure", "paraph": "pcap_sendpacket_APIName returns 0 on success and PCAP_ERROR on failure", "key": "pcap_sendpacket"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "pcap_inject_APIName sends a raw packet through the network interface; pcap_inject_APIParam_2 points to the data of the packet, including the link-layer header, and pcap_inject_APIParam_3 is the number of bytes in the packet", "paraph": "pcap_inject_APIName sends a raw packet through the network interface; pcap_inject_APIParam_2 points to the data of the packet, including the link-layer header, and pcap_inject_APIParam_3 is the number of bytes in the packet", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "dlt_buf"], "API_desc": "get a list of link"}, "sent": "pcap_list_datalinks_APIName returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED if pcap_list_datalinks_APIName is called on a capture handle that has been created but not activated, and PCAP_ERROR on other errors.", "paraph": "pcap_list_datalinks_APIName returns the number of link-layer header types in the array on success, PCAP_ERROR_NOT_ACTIVATED if pcap_list_datalinks_APIName is called on a capture handle that has been created but not activated, and PCAP_ERROR on other errors. If PCAP_ERROR be returned by pcap_list_datalinks_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_datalinks_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_datalinks"}, {"API_info": {"var_type": ["u_char *", "struct pcap_pkthdr *", "u_char *"], "ret_type": "void", "var": ["user", "h", "sp"], "API_desc": "write a packet to a capture file"}, "sent": "pcap_dump_APIName outputs a packet to the savefile opened with pcap_dump_open_APIName.", "paraph": "pcap_dump_APIName outputs a packet to the savefile opened with pcap_dump_open_APIName. Note that its calling arguments are suitable for use with pcap_dispatch_APIName or pcap_loop_APIName. if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName", "key": "pcap_dump"}, {"API_info": {"var_type": ["u_char *", "struct pcap_pkthdr *", "u_char *"], "ret_type": "void", "var": ["user", "h", "sp"], "API_desc": "write a packet to a capture file"}, "sent": "Note that its calling arguments are suitable for use with pcap_dispatch_APIName or pcap_loop_APIName.", "paraph": "pcap_dump_APIName outputs a packet to the savefile opened with pcap_dump_open_APIName. Note that its calling arguments are suitable for use with pcap_dispatch_APIName or pcap_loop_APIName. if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName", "key": "pcap_dump"}, {"API_info": {"var_type": ["pcap_t *", "const u_char *", "int"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "If PCAP_ERROR be returned by pcap_sendpacket_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_sendpacket_APIParam_1 as an argument to fetch or display the error text", "paraph": "If PCAP_ERROR be returned by pcap_sendpacket_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_sendpacket_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_sendpacket"}, {"API_info": {"var_type": ["u_char *", "struct pcap_pkthdr *", "u_char *"], "ret_type": "void", "var": ["user", "h", "sp"], "API_desc": "write a packet to a capture file"}, "sent": "if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName", "paraph": "pcap_dump_APIName outputs a packet to the savefile opened with pcap_dump_open_APIName. Note that its calling arguments are suitable for use with pcap_dispatch_APIName or pcap_loop_APIName. if pcap_dump_APIName is called directly, the pcap_dump_APIParam_1 parameter is of type pcap_dumper_t_APIConstant_1 as returned by pcap_dump_open_APIName", "key": "pcap_dump"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the time stamp precision returned in captures"}, "sent": "pcap_get_tstamp_precision_APIName became available in libpcap release 1.5.1.", "paraph": "pcap_get_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "key": "pcap_get_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the time stamp precision returned in captures"}, "sent": "pcap_get_tstamp_precision_APIName returns the precision of the time stamp returned in packet captures on the pcap descriptor", "paraph": "pcap_get_tstamp_precision_APIName returns the precision of the time stamp returned in packet captures on the pcap descriptor", "key": "pcap_get_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "Even worse, some drivers on some platforms might change the link-layer type field to whatever value libpcap used when attaching to the device, even on platforms that do nominally support sending completely raw and unchanged packets", "paraph": "Note that, on some platforms, the link-layer header of the packet that sent might not be the same as the link-layer header of the packet supplied to pcap_inject_APIName, as the source link-layer address, if the header contains such an address, might be changed to be the address assigned to the interface on which the packet it sent, if the platform does not support sending completely raw and unchanged packets. Even worse, some drivers on some platforms might change the link-layer type field to whatever value libpcap used when attaching to the device, even on platforms that do nominally support sending completely raw and unchanged packets", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the time stamp precision returned in captures"}, "sent": "pcap_get_tstamp_precision_APIName returns PCAP_TSTAMP_PRECISION_MICRO or PCAP_TSTAMP_PRECISION_NANO, which indicates that pcap captures contains time stamps in microseconds or nanoseconds respectively", "paraph": "pcap_get_tstamp_precision_APIName returns PCAP_TSTAMP_PRECISION_MICRO or PCAP_TSTAMP_PRECISION_NANO, which indicates that pcap captures contains time stamps in microseconds or nanoseconds respectively", "key": "pcap_get_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "pcap_dump_open_APIName is called to open a savefile for writing.", "paraph": "pcap_dump_open_APIName is called to open a savefile for writing. pcap_dump_open_APIParam_2 specifies the name of the file to open. The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName. The name \"-\" is a synonym for stdout", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "pcap_dump_open_APIParam_2 specifies the name of the file to open.", "paraph": "pcap_dump_open_APIName is called to open a savefile for writing. pcap_dump_open_APIParam_2 specifies the name of the file to open. The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName. The name \"-\" is a synonym for stdout", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the time stamp precision returned in captures"}, "sent": "In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "paraph": "pcap_get_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a capture device or savefile are always given in seconds and microseconds", "key": "pcap_get_tstamp_precision"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName.", "paraph": "pcap_dump_open_APIName is called to open a savefile for writing. pcap_dump_open_APIParam_2 specifies the name of the file to open. The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName. The name \"-\" is a synonym for stdout", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "FILE *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fp"], "API_desc": "open a file to which to write packets"}, "sent": "Note that on Windows, that stream should be opened in binary mode", "paraph": "pcap_dump_fopen_APIName is called to write data to an existing open stream pcap_dump_fopen_APIParam_2; this stream will be closed by a subsequent call to pcap_dump_close_APIName. Note that on Windows, that stream should be opened in binary mode", "key": "pcap_dump_fopen"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "The name \"-\" is a synonym for stdout", "paraph": "pcap_dump_open_APIName is called to open a savefile for writing. pcap_dump_open_APIParam_2 specifies the name of the file to open. The file will have the same format as those used by tcpdump_APIName and tcpslice_APIName. The name \"-\" is a synonym for stdout", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "FILE *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fp"], "API_desc": "open a file to which to write packets"}, "sent": "pcap_dump_fopen_APIName is called to write data to an existing open stream pcap_dump_fopen_APIParam_2; this stream will be closed by a subsequent call to pcap_dump_close_APIName.", "paraph": "pcap_dump_fopen_APIName is called to write data to an existing open stream pcap_dump_fopen_APIParam_2; this stream will be closed by a subsequent call to pcap_dump_close_APIName. Note that on Windows, that stream should be opened in binary mode", "key": "pcap_dump_fopen"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "NULL be returned by pcap_dump_open_APIName on failure.", "paraph": "pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1, it will write new packets at the end of the file. RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success. NULL be returned by pcap_dump_open_APIName on failure. If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["int *"], "ret_type": "void", "var": ["dlt_list"], "API_desc": "get a list of link"}, "sent": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "paraph": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "key": "pcap_free_datalinks"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text", "paraph": "pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1, it will write new packets at the end of the file. RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success. NULL be returned by pcap_dump_open_APIName on failure. If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "The pcap_dump_open_append_APIName function became available in libpcap release 1.7.2.", "paraph": "The pcap_dump_open_append_APIName function became available in libpcap release 1.7.2. In previous releases, there is no support for appending packets to an existing savefile", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "FILE *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fp"], "API_desc": "open a file to which to write packets"}, "sent": "The time stamp precision, link-layer type, and snapshot length from pcap_dump_fopen_APIParam_1 are used as the link-layer type and snapshot length of the output file", "paraph": "p is a capture or savefile handle returned by an earlier call to pcap_create_APIName and activated by an earlier call to pcap_activate_APIName, or returned by an earlier call to pcap_open_offline_APIName, pcap_open_live_APIName, or pcap_open_dead_APIName. The time stamp precision, link-layer type, and snapshot length from pcap_dump_fopen_APIParam_1 are used as the link-layer type and snapshot length of the output file", "key": "pcap_dump_fopen"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "In previous releases, there is no support for appending packets to an existing savefile", "paraph": "The pcap_dump_open_append_APIName function became available in libpcap release 1.7.2. In previous releases, there is no support for appending packets to an existing savefile", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success.", "paraph": "pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1, it will write new packets at the end of the file. RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success. NULL be returned by pcap_dump_open_APIName on failure. If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the version number of a savefile"}, "sent": "If pcap_major_version_APIParam_1 refers to a live capture, the values returned by pcap_major_version_APIName and pcap_minor_version_APIName are not meaningful", "paraph": "If pcap_major_version_APIParam_1 refers to a live capture, the values returned by pcap_major_version_APIName and pcap_minor_version_APIName are not meaningful", "key": "pcap_major_version"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "See pcap-tstamp_APIName for a list of all the time stamp types", "paraph": "pcap_list_tstamp_types_APIName is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor. pcap_list_tstamp_types_APIName() allocates an array to hold the list and sets *tstamp_typesp to point to the array. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *", "FILE *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fp"], "API_desc": "open a file to which to write packets"}, "sent": "p is a capture or savefile handle returned by an earlier call to pcap_create_APIName and activated by an earlier call to pcap_activate_APIName, or returned by an earlier call to pcap_open_offline_APIName, pcap_open_live_APIName, or pcap_open_dead_APIName.", "paraph": "p is a capture or savefile handle returned by an earlier call to pcap_create_APIName and activated by an earlier call to pcap_activate_APIName, or returned by an earlier call to pcap_open_offline_APIName, pcap_open_live_APIName, or pcap_open_dead_APIName. The time stamp precision, link-layer type, and snapshot length from pcap_dump_fopen_APIParam_1 are used as the link-layer type and snapshot length of the output file", "key": "pcap_dump_fopen"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "pcap_list_tstamp_types_APIName is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor.", "paraph": "pcap_list_tstamp_types_APIName is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor. pcap_list_tstamp_types_APIName() allocates an array to hold the list and sets *tstamp_typesp to point to the array. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the version number of a savefile"}, "sent": "The version number is stored in the savefile; note that the meaning of its values depends on the type of savefile (for example, pcap or pcapng", "paraph": "If pcap_major_version_APIParam_1 refers to a savefile, pcap_major_version_APIName returns the major number of the file format of the savefile and pcap_minor_version_APIName returns the minor number of the file format of the savefile. The version number is stored in the savefile; note that the meaning of its values depends on the type of savefile (for example, pcap or pcapng", "key": "pcap_major_version"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the version number of a savefile"}, "sent": "If pcap_major_version_APIParam_1 refers to a savefile, pcap_major_version_APIName returns the major number of the file format of the savefile and pcap_minor_version_APIName returns the minor number of the file format of the savefile.", "paraph": "If pcap_major_version_APIParam_1 refers to a savefile, pcap_major_version_APIName returns the major number of the file format of the savefile and pcap_minor_version_APIName returns the minor number of the file format of the savefile. The version number is stored in the savefile; note that the meaning of its values depends on the type of savefile (for example, pcap or pcapng", "key": "pcap_major_version"}, {"API_info": {"var_type": ["int *"], "ret_type": "void", "var": ["tstamp_types"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "The caller is responsible for freeing the array with pcap_free_tstamp_types_APIName, which frees the list pointed to by tstamp_types", "paraph": "The caller is responsible for freeing the array with pcap_free_tstamp_types_APIName, which frees the list pointed to by tstamp_types", "key": "pcap_free_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure.", "paraph": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure. A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type. A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types). If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["int *"], "ret_type": "void", "var": ["tstamp_types"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "These functions became available in libpcap release 1.2.1.", "paraph": "These functions became available in libpcap release 1.2.1. In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "key": "pcap_free_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure. A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type. A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types). If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types).", "paraph": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure. A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type. A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types). If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type.", "paraph": "pcap_list_tstamp_types_APIName returns the number of time stamp types in the array on success and PCAP_ERROR on failure. A return value of one means that the only time stamp type supported is the one in the list, which is the capture device default time stamp type. A return value of zero means that the only time stamp type supported is PCAP_TSTAMP_HOST, which is the capture device default time stamp type (only older versions of libpcap will return that; newer versions will always return one or more types). If PCAP_ERROR be returned by pcap_list_tstamp_types_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_list_tstamp_types_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["int *"], "ret_type": "void", "var": ["tstamp_types"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "paraph": "These functions became available in libpcap release 1.2.1. In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "key": "pcap_free_tstamp_types"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop", "paraph": "This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "Asynchronous procedure calls will not work on Windows, as a thread blocked on a pcap_t will not be in an alertable state", "paraph": "Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch_APIName, pcap_loop_APIName, pcap_next_APIName, or pcap_next_ex_APIName, a call to pcap_breakloop_APIName in a different thread will not unblock that thread. You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls in order to unblock the thread, such as thread cancellation or thread signalling in systems that support POSIX threads, or SetEvent_APIName on the result of pcap_getevent_APIName on a pcap_t on which the thread is blocked on Windows. Asynchronous procedure calls will not work on Windows, as a thread blocked on a pcap_t will not be in an alertable state", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "pcap_open_live_APIName is used to obtain a packet capture handle to look at packets on the network.", "paraph": "pcap_open_live_APIName is used to obtain a packet capture handle to look at packets on the network. pcap_open_live_APIParam_1 is a string that specifies the network pcap_open_live_APIParam_1 to open; on Linux systems with 2.2 or later kernels, a pcap_open_live_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "pcap_breakloop_APIName sets a flag that will force pcap_dispatch_APIName or pcap_loop_APIName to return rather than looping; they will return the number of packets that have been processed so far, or PCAP_ERROR_BREAK if no packets have been processed so far", "paraph": "pcap_breakloop_APIName sets a flag that will force pcap_dispatch_APIName or pcap_loop_APIName to return rather than looping; they will return the number of packets that have been processed so far, or PCAP_ERROR_BREAK if no packets have been processed so far", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "snaplen specifies the snapshot length to be set on the handle", "paraph": "snaplen specifies the snapshot length to be set on the handle", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "If PCAP_ERROR_BREAK be returned by pcap_breakloop_APIName from pcap_dispatch_APIName or pcap_loop_APIName, the flag is cleared, so a subsequent call will resume reading packets.", "paraph": "If PCAP_ERROR_BREAK be returned by pcap_breakloop_APIName from pcap_dispatch_APIName or pcap_loop_APIName, the flag is cleared, so a subsequent call will resume reading packets. If a positive number be returned by pcap_breakloop_APIName, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK and clear the flag", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "promisc specifies if the interface is to be put into promiscuous mode", "paraph": "promisc specifies if the interface is to be put into promiscuous mode", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS.", "paraph": "The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop_APIName in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal. Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "If a positive number be returned by pcap_breakloop_APIName, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK and clear the flag", "paraph": "If PCAP_ERROR_BREAK be returned by pcap_breakloop_APIName from pcap_dispatch_APIName or pcap_loop_APIName, the flag is cleared, so a subsequent call will resume reading packets. If a positive number be returned by pcap_breakloop_APIName, the flag is not cleared, so a subsequent call will return PCAP_ERROR_BREAK and clear the flag", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "pcap_breakloop_APIName does not guarantee that no further packets will be processed by pcap_dispatch_APIName or pcap_loop_APIName after it is called; at most one more packet might be processed", "paraph": "pcap_breakloop_APIName does not guarantee that no further packets will be processed by pcap_dispatch_APIName or pcap_loop_APIName after it is called; at most one more packet might be processed", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "to_ms specifies the packet buffer timeout, as a non-negative value, in milliseconds.", "paraph": "to_ms specifies the packet buffer timeout, as a non-negative value, in milliseconds. (See pcap_APIName for an explanation of the packet buffer timeout", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *", "int **"], "ret_type": "int", "var": ["p", "tstamp_typesp"], "API_desc": "get a list of time stamp types supported by a capture device, and free that list"}, "sent": "pcap_list_tstamp_types_APIName() allocates an array to hold the list and sets *tstamp_typesp to point to the array.", "paraph": "pcap_list_tstamp_types_APIName is used to get a list of the supported time stamp types of the interface associated with the pcap descriptor. pcap_list_tstamp_types_APIName() allocates an array to hold the list and sets *tstamp_typesp to point to the array. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_list_tstamp_types"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "(See pcap_APIName for an explanation of the packet buffer timeout", "paraph": "to_ms specifies the packet buffer timeout, as a non-negative value, in milliseconds. (See pcap_APIName for an explanation of the packet buffer timeout", "key": "pcap_open_live"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure.", "paraph": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message. pcap_open_live_APIParam_5 may also be set to warning text when pcap_open_live_APIName succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user if pcap_open_live_APIParam_5 is no longer a zero-length string. pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_live"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message.", "paraph": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message. pcap_open_live_APIParam_5 may also be set to warning text when pcap_open_live_APIName succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user if pcap_open_live_APIParam_5 is no longer a zero-length string. pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_live"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message. pcap_open_live_APIParam_5 may also be set to warning text when pcap_open_live_APIName succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user if pcap_open_live_APIParam_5 is no longer a zero-length string. pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch_APIName, pcap_loop_APIName, pcap_next_APIName, or pcap_next_ex_APIName, a call to pcap_breakloop_APIName in a different thread will not unblock that thread.", "paraph": "Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch_APIName, pcap_loop_APIName, pcap_next_APIName, or pcap_next_ex_APIName, a call to pcap_breakloop_APIName in a different thread will not unblock that thread. You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls in order to unblock the thread, such as thread cancellation or thread signalling in systems that support POSIX threads, or SetEvent_APIName on the result of pcap_getevent_APIName on a pcap_t on which the thread is blocked on Windows. Asynchronous procedure calls will not work on Windows, as a thread blocked on a pcap_t will not be in an alertable state", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "NULL be returned by pcap_datalink_val_to_name_APIName if the type value does not correspond to a known DLT_ value", "paraph": "pcap_datalink_val_to_name_APIName translates a link-layer header type value to the corresponding link-layer header type name, which is the DLT_ name for the link-layer header type value with the DLT_ removed. NULL be returned by pcap_datalink_val_to_name_APIName if the type value does not correspond to a known DLT_ value", "key": "pcap_datalink_val_to_name"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "pcap_datalink_val_to_description_APIName translates a link-layer header type value to a short description of that link-layer header type.", "paraph": "pcap_datalink_val_to_description_APIName translates a link-layer header type value to a short description of that link-layer header type. NULL be returned by pcap_datalink_val_to_description_APIName if the type value does not correspond to a known DLT_ value", "key": "pcap_datalink_val_to_description"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "Note that ,  , you might not have permission to send packets on it , or it might not support sending packets ; as pcap_open_live_APIName does not have a flag to indicate  , you can not request an open that supports sending and be notified at open time  .", "paraph": "Note that, even if you successfully open the network interface, you might not have permission to send packets on it, or it might not support sending packets; as pcap_open_live_APIName does not have a flag to indicate whether to open for capturing, sending, or capturing and sending, you cannot request an open that supports sending and be notified at open time whether sending will be possible. Note also that some devices might not support sending packets", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "pcap_stats_APIName fills in the struct pcap_stat pointed to by its second argument.", "paraph": "pcap_stats_APIName fills in the struct pcap_stat pointed to by its second argument. The values represent packet statistics from the start of the run to the time of the call", "key": "pcap_stats"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "NULL be returned by pcap_datalink_val_to_description_APIName if the type value does not correspond to a known DLT_ value", "paraph": "pcap_datalink_val_to_description_APIName translates a link-layer header type value to a short description of that link-layer header type. NULL be returned by pcap_datalink_val_to_description_APIName if the type value does not correspond to a known DLT_ value", "key": "pcap_datalink_val_to_description"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "pcap_datalink_val_to_description_or_dlt_APIName translates a link-layer header type value to a short description of that link-layer header type just like pcap_datalink_val_to_description.", "paraph": "pcap_datalink_val_to_description_or_dlt_APIName translates a link-layer header type value to a short description of that link-layer header type just like pcap_datalink_val_to_description. If the type value does not correspond to a known DLT_ value, the string \"DLT n\" be returned by pcap_datalink_val_to_description_APIName, where n is the value of the pcap_datalink_val_to_description_APIParam_1 argument", "key": "pcap_datalink_val_to_description"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "A struct pcap_stat has the following members", "paraph": "A struct pcap_stat has the following members", "key": "pcap_stats"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "pcap_open_live_APIParam_1 is a string that specifies the network pcap_open_live_APIParam_1 to open; on Linux systems with 2.2 or later kernels, a pcap_open_live_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "paraph": "pcap_open_live_APIName is used to obtain a packet capture handle to look at packets on the network. pcap_open_live_APIParam_1 is a string that specifies the network pcap_open_live_APIParam_1 to open; on Linux systems with 2.2 or later kernels, a pcap_open_live_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop_APIName in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal.", "paraph": "The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop_APIName in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal. Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes", "paraph": "The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop_APIName in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal. Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop_APIName, the call will be restarted, and the loop will not terminate until more packets arrive and the call completes", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "ps_recv", "paraph": "ps_recv", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "The values represent packet statistics from the start of the run to the time of the call", "paraph": "pcap_stats_APIName fills in the struct pcap_stat pointed to by its second argument. The values represent packet statistics from the start of the run to the time of the call", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "Note that pcap_next_APIName and pcap_next_ex_APIName will , on some platforms , loop reading packets from the OS ; that loop will not necessarily be terminated by a signal , so pcap_breakloop_APIName should be used to terminate packet processing ", "paraph": "Note that pcap_next_APIName and pcap_next_ex_APIName will, on some platforms, loop reading packets from the OS; that loop will not necessarily be terminated by a signal, so pcap_breakloop_APIName should be used to terminate packet processing even if pcap_next_APIName or pcap_next_ex_APIName is being used", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "number of packets received; ps_drop", "paraph": "number of packets received; ps_drop", "key": "pcap_stats"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "pcap_datalink_val_to_name_APIName translates a link-layer header type value to the corresponding link-layer header type name, which is the DLT_ name for the link-layer header type value with the DLT_ removed.", "paraph": "pcap_datalink_val_to_name_APIName translates a link-layer header type value to the corresponding link-layer header type name, which is the DLT_ name for the link-layer header type value with the DLT_ removed. NULL be returned by pcap_datalink_val_to_name_APIName if the type value does not correspond to a known DLT_ value", "key": "pcap_datalink_val_to_name"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "number of packets dropped by the network interface or its driver", "paraph": "number of packets dropped by the network interface or its driver", "key": "pcap_stats"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["dlt"], "API_desc": "get a name or description for a link"}, "sent": "If the type value does not correspond to a known DLT_ value, the string \"DLT n\" be returned by pcap_datalink_val_to_description_APIName, where n is the value of the pcap_datalink_val_to_description_APIParam_1 argument", "paraph": "pcap_datalink_val_to_description_or_dlt_APIName translates a link-layer header type value to a short description of that link-layer header type just like pcap_datalink_val_to_description. If the type value does not correspond to a known DLT_ value, the string \"DLT n\" be returned by pcap_datalink_val_to_description_APIName, where n is the value of the pcap_datalink_val_to_description_APIParam_1 argument", "key": "pcap_datalink_val_to_description"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "The statistics do not behave the same way on all platforms.", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "pcap_stats_APIName is supported only on live captures, not on savefiles; no statistics are stored in savefiles, so no statistics are available when reading from a savefile", "paraph": "pcap_stats_APIName is supported only on live captures, not on savefiles; no statistics are stored in savefiles, so no statistics are available when reading from a savefile", "key": "pcap_stats"}, {"API_info": {"var_type": ["const char *", "int", "int", "int", "char *"], "ret_type": "pcap_t *", "var": ["device", "snaplen", "promisc", "to_ms", "errbuf"], "API_desc": "open a device for capturing"}, "sent": "pcap_open_live_APIParam_5 may also be set to warning text when pcap_open_live_APIName succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user if pcap_open_live_APIParam_5 is no longer a zero-length string.", "paraph": "pcap_open_live_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_live_APIName, pcap_open_live_APIParam_5 is filled in with an appropriate error message. pcap_open_live_APIParam_5 may also be set to warning text when pcap_open_live_APIName succeeds; to detect this case the caller should store a zero-length string in pcap_open_live_APIParam_5 before calling pcap_open_live_APIName and display the warning to the user if pcap_open_live_APIParam_5 is no longer a zero-length string. pcap_open_live_APIParam_5 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_live"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "number of packets dropped ", "paraph": "number of packets dropped because there was no room in the operating system buffer when they arrived, because packets weren't being read fast enough; ps_ifdrop", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "ps_drop is not available on all platforms; it is zero on platforms where it is not available.", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "ps_recv might count packets  , or it might count only packets that pass the filter .", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "It also might , or might not , count packets dropped  .", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter.", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["const char *", "bpf_u_int32 *", "bpf_u_int32 *", "char *"], "ret_type": "int", "var": ["device", "netp", "maskp", "errbuf"], "API_desc": "find the IPv4 network number and netmask for a device"}, "sent": "Both pcap_lookupnet_APIParam_2 and pcap_lookupnet_APIParam_3 are bpf_u_int32 pointers", "paraph": "pcap_lookupnet_APIName is used to determine the IPv4 network number and mask associated with the network pcap_lookupnet_APIParam_1 pcap_lookupnet_APIParam_1. Both pcap_lookupnet_APIParam_2 and pcap_lookupnet_APIParam_3 are bpf_u_int32 pointers", "key": "pcap_lookupnet"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "pcap_stats_APIName returns 0 on success and returns PCAP_ERROR if there is an error or if pcap_stats_APIParam_1 does not support packet statistics.", "paraph": "pcap_stats_APIName returns 0 on success and returns PCAP_ERROR if there is an error or if pcap_stats_APIParam_1 does not support packet statistics. If PCAP_ERROR be returned by pcap_stats_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_stats_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_stats"}, {"API_info": {"var_type": ["const char *", "bpf_u_int32 *", "bpf_u_int32 *", "char *"], "ret_type": "int", "var": ["device", "netp", "maskp", "errbuf"], "API_desc": "find the IPv4 network number and netmask for a device"}, "sent": "pcap_lookupnet_APIName is used to determine the IPv4 network number and mask associated with the network pcap_lookupnet_APIParam_1 pcap_lookupnet_APIParam_1.", "paraph": "pcap_lookupnet_APIName is used to determine the IPv4 network number and mask associated with the network pcap_lookupnet_APIParam_1 pcap_lookupnet_APIParam_1. Both pcap_lookupnet_APIParam_2 and pcap_lookupnet_APIParam_3 are bpf_u_int32 pointers", "key": "pcap_lookupnet"}, {"API_info": {"var_type": ["const char *", "bpf_u_int32 *", "bpf_u_int32 *", "char *"], "ret_type": "int", "var": ["device", "netp", "maskp", "errbuf"], "API_desc": "find the IPv4 network number and netmask for a device"}, "sent": "pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure.", "paraph": "pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_lookupnet_APIName, pcap_lookupnet_APIParam_4 is filled in with an appropriate error message. pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupnet"}, {"API_info": {"var_type": ["pcap_t *", "const void *", "size_t"], "ret_type": "int", "var": ["p", "buf", "size"], "API_desc": "transmit a packet"}, "sent": "Note that, on some platforms, the link-layer header of the packet that sent might not be the same as the link-layer header of the packet supplied to pcap_inject_APIName, as the source link-layer address, if the header contains such an address, might be changed to be the address assigned to the interface on which the packet it sent, if the platform does not support sending completely raw and unchanged packets.", "paraph": "Note that, on some platforms, the link-layer header of the packet that sent might not be the same as the link-layer header of the packet supplied to pcap_inject_APIName, as the source link-layer address, if the header contains such an address, might be changed to be the address assigned to the interface on which the packet it sent, if the platform does not support sending completely raw and unchanged packets. Even worse, some drivers on some platforms might change the link-layer type field to whatever value libpcap used when attaching to the device, even on platforms that do nominally support sending completely raw and unchanged packets", "key": "pcap_inject"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application.", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "If PCAP_ERROR be returned by pcap_stats_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_stats_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_stats_APIName returns 0 on success and returns PCAP_ERROR if there is an error or if pcap_stats_APIParam_1 does not support packet statistics. If PCAP_ERROR be returned by pcap_stats_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_stats_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_stats"}, {"API_info": {"var_type": ["const char *", "bpf_u_int32 *", "bpf_u_int32 *", "char *"], "ret_type": "int", "var": ["device", "netp", "maskp", "errbuf"], "API_desc": "find the IPv4 network number and netmask for a device"}, "sent": "If PCAP_ERROR be returned by pcap_lookupnet_APIName, pcap_lookupnet_APIParam_4 is filled in with an appropriate error message.", "paraph": "pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_lookupnet_APIName, pcap_lookupnet_APIParam_4 is filled in with an appropriate error message. pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupnet"}, {"API_info": {"var_type": ["const char *", "bpf_u_int32 *", "bpf_u_int32 *", "char *"], "ret_type": "int", "var": ["device", "netp", "maskp", "errbuf"], "API_desc": "find the IPv4 network number and netmask for a device"}, "sent": "pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_lookupnet_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_lookupnet_APIName, pcap_lookupnet_APIParam_4 is filled in with an appropriate error message. pcap_lookupnet_APIParam_4 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupnet"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "pcap_datalink_APIName returns the link-layer header type for the live capture or savefile specified by p", "paraph": "pcap_datalink_APIName returns the link-layer header type for the live capture or savefile specified by p", "key": "pcap_datalink"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["pcap_t *"], "API_desc": "force a pcap_dispatch() or pcap_loop() call to return"}, "sent": "You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls  .", "paraph": "Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch_APIName, pcap_loop_APIName, pcap_next_APIName, or pcap_next_ex_APIName, a call to pcap_breakloop_APIName in a different thread will not unblock that thread. You will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls in order to unblock the thread, such as thread cancellation or thread signalling in systems that support POSIX threads, or SetEvent_APIName on the result of pcap_getevent_APIName on a pcap_t on which the thread is blocked on Windows. Asynchronous procedure calls will not work on Windows, as a thread blocked on a pcap_t will not be in an alertable state", "key": "pcap_breakloop"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values", "paraph": "https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values", "key": "pcap_datalink"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "pcap_dumper_t *", "var": ["p", "fname"], "API_desc": "open a file to which to write packets"}, "sent": "pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1, it will write new packets at the end of the file.", "paraph": "pcap_dump_open_append_APIName is like pcap_dump_open_APIName but does not create the file if it does not exist and, if it does already exist, and is a pcap file with the same byte order as the host opening the file, and has the same time stamp precision, link-layer header type, and snapshot length as pcap_dump_open_APIParam_1, it will write new packets at the end of the file. RETURN VALUES A pointer to a pcap_dumper_t structure to use in subsequent pcap_dump_APIName and pcap_dump_close_APIName calls be returned by pcap_dump_open_APIName on success. NULL be returned by pcap_dump_open_APIName on failure. If NULL be returned by pcap_dump_open_APIName, pcap_geterr_APIName can be used to get the error text", "key": "pcap_dump_open"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_stat *"], "ret_type": "int", "var": ["p", "ps"], "API_desc": "get capture statistics"}, "sent": "ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "paraph": "The statistics do not behave the same way on all platforms. ps_recv might count packets whether they passed any filter set with pcap_setfilter_APIName or not, or it might count only packets that pass the filter. It also might, or might not, count packets dropped because there was no room in the operating system buffer when they arrived. ps_drop is not available on all platforms; it is zero on platforms where it is not available. If packet filtering is done in libpcap, rather than in the operating system, it would count packets that do not pass the filter. Both ps_recv and ps_drop might, or might not, count packets not yet read from the operating system and thus not yet seen by the application. ps_ifdrop might, or might not, be implemented; if it is zero, that might mean that no packets were dropped by the interface, or it might mean that the statistic is unavailable, so it should not be treated as an indication that the interface did not drop any packets", "key": "pcap_stats"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "paraph": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "key": "pcap_datalink"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet.", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_datalink"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "to_ms"], "API_desc": "set the packet buffer timeout for a not"}, "sent": "(See pcap_APIName for an explanation of the packet buffer timeout", "paraph": "pcap_set_timeout_APIName sets the packet buffer timeout that will be used on a capture handle when the handle is activated to pcap_set_timeout_APIParam_2, which is in units of milliseconds. (See pcap_APIName for an explanation of the packet buffer timeout", "key": "pcap_set_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "pcap_datalink_APIName returns the link-layer header type on success and PCAP_ERROR_NOT_ACTIVATED if pcap_datalink_APIName is called on a capture handle that has been created but not activated", "paraph": "pcap_datalink_APIName returns the link-layer header type on success and PCAP_ERROR_NOT_ACTIVATED if pcap_datalink_APIName is called on a capture handle that has been created but not activated", "key": "pcap_datalink"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "to_ms"], "API_desc": "set the packet buffer timeout for a not"}, "sent": "pcap_set_timeout_APIName sets the packet buffer timeout that will be used on a capture handle when the handle is activated to pcap_set_timeout_APIParam_2, which is in units of milliseconds.", "paraph": "pcap_set_timeout_APIName sets the packet buffer timeout that will be used on a capture handle when the handle is activated to pcap_set_timeout_APIParam_2, which is in units of milliseconds. (See pcap_APIName for an explanation of the packet buffer timeout", "key": "pcap_set_timeout"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_open_offline_APIName and pcap_open_offline_with_tstamp_precision_APIName are called to open a savefile for reading", "paraph": "pcap_open_offline_APIName and pcap_open_offline_with_tstamp_precision_APIName are called to open a savefile for reading", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "to_ms"], "API_desc": "set the packet buffer timeout for a not"}, "sent": "pcap_set_timeout_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_timeout_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_timeout_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_timeout_APIName is called on a capture handle that has been activated", "key": "pcap_set_timeout"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "fname specifies the name of the file to open.", "paraph": "fname specifies the name of the file to open. The file can have the pcap file format as described in pcap-savefile_APIName, which is the file format used by, among other programs, tcpdump_APIName and tcpslice_APIName, or can have the pcapng file format, although not all pcapng files can be read. The name \"-\" is a synonym for stdin", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "to_ms"], "API_desc": "set the packet buffer timeout for a not"}, "sent": "We recommend always setting the timeout to a non-zero value unless immediate mode is set, in which case the timeout has no effect", "paraph": "The behavior, if the timeout is not specified, is undefined, as is the behavior if the timeout is set to zero or to a negative value. We recommend always setting the timeout to a non-zero value unless immediate mode is set, in which case the timeout has no effect", "key": "pcap_set_timeout"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "to_ms"], "API_desc": "set the packet buffer timeout for a not"}, "sent": "The behavior, if the timeout is not specified, is undefined, as is the behavior if the timeout is set to zero or to a negative value.", "paraph": "The behavior, if the timeout is not specified, is undefined, as is the behavior if the timeout is set to zero or to a negative value. We recommend always setting the timeout to a non-zero value unless immediate mode is set, in which case the timeout has no effect", "key": "pcap_set_timeout"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "The name \"-\" is a synonym for stdin", "paraph": "fname specifies the name of the file to open. The file can have the pcap file format as described in pcap-savefile_APIName, which is the file format used by, among other programs, tcpdump_APIName and tcpslice_APIName, or can have the pcapng file format, although not all pcapng files can be read. The name \"-\" is a synonym for stdin", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["FILE *", "char *"], "ret_type": "pcap_t *", "var": ["fp", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_fopen_offline_with_tstamp_precision_APIName takes an additional precision argument as described above.", "paraph": "Alternatively, you may call pcap_fopen_offline_APIName or pcap_fopen_offline_with_tstamp_precision_APIName to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1. pcap_fopen_offline_with_tstamp_precision_APIName takes an additional precision argument as described above. Note that on Windows, that stream should be opened in binary mode", "key": "pcap_fopen_offline"}, {"API_info": {"var_type": ["FILE *", "char *"], "ret_type": "pcap_t *", "var": ["fp", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "Alternatively, you may call pcap_fopen_offline_APIName or pcap_fopen_offline_with_tstamp_precision_APIName to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1.", "paraph": "Alternatively, you may call pcap_fopen_offline_APIName or pcap_fopen_offline_with_tstamp_precision_APIName to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1. pcap_fopen_offline_with_tstamp_precision_APIName takes an additional precision argument as described above. Note that on Windows, that stream should be opened in binary mode", "key": "pcap_fopen_offline"}, {"API_info": {"var_type": ["FILE *", "char *"], "ret_type": "pcap_t *", "var": ["fp", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "Note that on Windows, that stream should be opened in binary mode", "paraph": "Alternatively, you may call pcap_fopen_offline_APIName or pcap_fopen_offline_with_tstamp_precision_APIName to read dumped data from an existing open stream pcap_fopen_offline_APIParam_1. pcap_fopen_offline_with_tstamp_precision_APIName takes an additional precision argument as described above. Note that on Windows, that stream should be opened in binary mode", "key": "pcap_fopen_offline"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure.", "paraph": "pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message. pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message.", "paraph": "pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message. pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "If the time stamps in the file do not have the same precision as the requested precision, they will be scaled up or down as necessary before being supplied", "paraph": "pcap_open_offline_with_tstamp_precision_APIName takes an additional precision argument specifying the time stamp precision desired; if PCAP_TSTAMP_PRECISION_MICRO is specified, packet time stamps will be supplied in seconds and microseconds, and if PCAP_TSTAMP_PRECISION_NANO is specified, packet time stamps will be supplied in seconds and nanoseconds. If the time stamps in the file do not have the same precision as the requested precision, they will be scaled up or down as necessary before being supplied", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_open_offline_APIName, pcap_open_offline_with_tstamp_precision_APIName, pcap_fopen_offline_APIName, and pcap_fopen_offline_with_tstamp_precision_APIName return a pcap_t * on success and NULL on failure. If NULL be returned by pcap_open_offline_APIName, pcap_open_offline_APIParam_2 is filled in with an appropriate error message. pcap_open_offline_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_open_offline_with_tstamp_precision_APIName and pcap_fopen_offline_with_tstamp_precision_APIName became available in libpcap release 1.5.1.", "paraph": "pcap_open_offline_with_tstamp_precision_APIName and pcap_fopen_offline_with_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a savefile are always given in seconds and microseconds", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the link"}, "sent": "For example , the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL ", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_datalink"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "In previous releases, time stamps from a savefile are always given in seconds and microseconds", "paraph": "pcap_open_offline_with_tstamp_precision_APIName and pcap_fopen_offline_with_tstamp_precision_APIName became available in libpcap release 1.5.1. In previous releases, time stamps from a savefile are always given in seconds and microseconds", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "pcap_can_set_rfmon_APIName checks  is activated", "paraph": "pcap_can_set_rfmon_APIName checks whether monitor mode could be set on a capture handle when the handle is activated", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "A negative return value indicates what error condition occurred.", "paraph": "pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error. A negative return value indicates what error condition occurred. The possible error values are: PCAP_ERROR_NO_SUCH_DEVICE", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "The possible error values are: PCAP_ERROR_NO_SUCH_DEVICE", "paraph": "pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error. A negative return value indicates what error condition occurred. The possible error values are: PCAP_ERROR_NO_SUCH_DEVICE", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "PCAP_ERROR_PERM_DENIED", "paraph": "The capture source specified when the handle was created does not exist. PCAP_ERROR_PERM_DENIED", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "The capture source specified when the handle was created does not exist.", "paraph": "The capture source specified when the handle was created does not exist. PCAP_ERROR_PERM_DENIED", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error.", "paraph": "pcap_can_set_rfmon_APIName returns 0 if monitor mode could not be set, 1 if monitor mode could be set, and a negative value on error. A negative return value indicates what error condition occurred. The possible error values are: PCAP_ERROR_NO_SUCH_DEVICE", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "PCAP_ERROR_ACTIVATED", "paraph": "The process does not have permission to check whether monitor mode could be supported. PCAP_ERROR_ACTIVATED", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "The process does not have permission to check  .", "paraph": "The process does not have permission to check whether monitor mode could be supported. PCAP_ERROR_ACTIVATED", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "The capture handle has already been activated.", "paraph": "The capture handle has already been activated. PCAP_ERROR", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "PCAP_ERROR", "paraph": "The capture handle has already been activated. PCAP_ERROR", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "The file can have the pcap file format as described in pcap-savefile_APIName , which is the file format used by , among other programs , tcpdump_APIName and tcpslice_APIName , or can have the pcapng file format ,  .", "paraph": "fname specifies the name of the file to open. The file can have the pcap file format as described in pcap-savefile_APIName, which is the file format used by, among other programs, tcpdump_APIName and tcpslice_APIName, or can have the pcapng file format, although not all pcapng files can be read. The name \"-\" is a synonym for stdin", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "Another error occurred.", "paraph": "Another error occurred. pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_can_set_rfmon_APIParam_1 as an argument to fetch or display a message describing the error", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["fname", "errbuf"], "API_desc": "open a saved capture file for reading"}, "sent": "pcap_open_offline_with_tstamp_precision_APIName takes an additional precision argument specifying the time stamp precision desired; if PCAP_TSTAMP_PRECISION_MICRO is specified, packet time stamps will be supplied in seconds and microseconds, and if PCAP_TSTAMP_PRECISION_NANO is specified, packet time stamps will be supplied in seconds and nanoseconds.", "paraph": "pcap_open_offline_with_tstamp_precision_APIName takes an additional precision argument specifying the time stamp precision desired; if PCAP_TSTAMP_PRECISION_MICRO is specified, packet time stamps will be supplied in seconds and microseconds, and if PCAP_TSTAMP_PRECISION_NANO is specified, packet time stamps will be supplied in seconds and nanoseconds. If the time stamps in the file do not have the same precision as the requested precision, they will be scaled up or down as necessary before being supplied", "key": "pcap_open_offline"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_can_set_rfmon_APIParam_1 as an argument to fetch or display a message describing the error", "paraph": "Another error occurred. pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_can_set_rfmon_APIParam_1 as an argument to fetch or display a message describing the error", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "find out whether a savefile has the native byte order"}, "sent": "pcap_is_swapped_APIName returns true (1) if pcap_is_swapped_APIParam_1 refers to a savefile that uses a different byte order than the current system.", "paraph": "pcap_is_swapped_APIName returns true (1) if pcap_is_swapped_APIParam_1 refers to a savefile that uses a different byte order than the current system. For a live capture, it always returns false (0", "key": "pcap_is_swapped"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "paraph": "Additional error codes may be added in the future; a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors. pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "pcap_set_immediate_mode_APIName sets  is activated .", "paraph": "pcap_set_immediate_mode_APIName sets whether immediate mode should be set on a capture handle when the handle is activated. In immediate mode, packets are always delivered as soon as they arrive, with no buffering. If pcap_set_immediate_mode_APIParam_2 is non-zero, immediate mode will be set, otherwise it will not be set", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "check whether monitor mode can be set for a not"}, "sent": "Additional error codes may be added in the future; a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors.", "paraph": "Additional error codes may be added in the future; a program should check for 0, 1, and negative, return codes, and treat all negative return codes as errors. pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "key": "pcap_can_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "find out whether a savefile has the native byte order"}, "sent": "pcap_is_swapped_APIName returns true (1) or false (0) on success and PCAP_ERROR_NOT_ACTIVATED if pcap_is_swapped_APIName is called on a capture handle that has been created but not activated", "paraph": "pcap_is_swapped_APIName returns true (1) or false (0) on success and PCAP_ERROR_NOT_ACTIVATED if pcap_is_swapped_APIName is called on a capture handle that has been created but not activated", "key": "pcap_is_swapped"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "If pcap_set_immediate_mode_APIParam_2 is non-zero, immediate mode will be set, otherwise it will not be set", "paraph": "pcap_set_immediate_mode_APIName sets whether immediate mode should be set on a capture handle when the handle is activated. In immediate mode, packets are always delivered as soon as they arrive, with no buffering. If pcap_set_immediate_mode_APIParam_2 is non-zero, immediate mode will be set, otherwise it will not be set", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "find out whether a savefile has the native byte order"}, "sent": "For a live capture, it always returns false (0", "paraph": "pcap_is_swapped_APIName returns true (1) if pcap_is_swapped_APIParam_1 refers to a savefile that uses a different byte order than the current system. For a live capture, it always returns false (0", "key": "pcap_is_swapped"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "In immediate mode, packets are always delivered as soon as they arrive, with no buffering.", "paraph": "pcap_set_immediate_mode_APIName sets whether immediate mode should be set on a capture handle when the handle is activated. In immediate mode, packets are always delivered as soon as they arrive, with no buffering. If pcap_set_immediate_mode_APIParam_2 is non-zero, immediate mode will be set, otherwise it will not be set", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "pcap_set_immediate_mode_APIName became available in libpcap release 1.5.0.", "paraph": "pcap_set_immediate_mode_APIName became available in libpcap release 1.5.0. In previous releases, if immediate delivery of packets is required", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "pcap_set_immediate_mode_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_immediate_mode_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_immediate_mode_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_immediate_mode_APIName is called on a capture handle that has been activated", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "In previous releases, if immediate delivery of packets is required", "paraph": "pcap_set_immediate_mode_APIName became available in libpcap release 1.5.0. In previous releases, if immediate delivery of packets is required", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "On other platforms, capture devices are always in immediate mode", "paraph": "On other platforms, capture devices are always in immediate mode", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "int", "var": ["p"], "API_desc": "flush to a savefile packets dumped"}, "sent": "pcap_dump_flush_APIName returns 0 on success and PCAP_ERROR on failure", "paraph": "pcap_dump_flush_APIName returns 0 on success and PCAP_ERROR on failure", "key": "pcap_dump_flush"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "pcap_next_ex_APIName reads the next packet and returns a success/failure indication.", "paraph": "pcap_next_ex_APIName reads the next packet and returns a success/failure indication. If the packet was read without problems, the pointer pointed to by the pcap_next_ex_APIParam_2 argument is set to point to the pcap_pkthdr struct for the packet, and the pointer pointed to by the pcap_next_ex_APIParam_3 argument is set to point to the data in the packet. The struct pcap_pkthdr and the packet data are not to be freed by the caller, and are not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs them to remain valid, it must make a copy of them", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "pcap_next_APIName reads the next packet (by calling pcap_dispatch_APIName with a cnt of 1) and returns a u_char pointer to the data in that packet.", "paraph": "pcap_next_APIName reads the next packet (by calling pcap_dispatch_APIName with a cnt of 1) and returns a u_char pointer to the data in that packet. The packet data is not to be freed by the caller, and is not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs it to remain valid, it must make a copy of it. The pcap_pkthdr structure pointed to by h is filled in with the appropriate values for the packet", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The bytes of data from the packet begin with a link-layer header.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "int", "var": ["p"], "API_desc": "flush to a savefile packets dumped"}, "sent": "pcap_dump_flush_APIName flushes the output buffer to the savefile, so that any packets written with pcap_dump_APIName but not yet written to the savefile will be written", "paraph": "pcap_dump_flush_APIName flushes the output buffer to the savefile, so that any packets written with pcap_dump_APIName but not yet written to the savefile will be written", "key": "pcap_dump_flush"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The pcap_pkthdr structure pointed to by h is filled in with the appropriate values for the packet", "paraph": "pcap_next_APIName reads the next packet (by calling pcap_dispatch_APIName with a cnt of 1) and returns a u_char pointer to the data in that packet. The packet data is not to be freed by the caller, and is not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs it to remain valid, it must make a copy of it. The pcap_pkthdr structure pointed to by h is filled in with the appropriate values for the packet", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "void", "var": ["p"], "API_desc": "close a savefile being written to"}, "sent": "pcap_dump_close_APIName closes the savefile", "paraph": "pcap_dump_close_APIName closes the savefile", "key": "pcap_dump_close"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["error"], "API_desc": "convert an errno value to a string"}, "sent": "pcap_strerror_APIName returns an pcap_strerror_APIParam_1 message string corresponding to error", "paraph": "pcap_strerror_APIName is provided in case strerror_APIName is not available. pcap_strerror_APIName returns an pcap_strerror_APIParam_1 message string corresponding to error", "key": "pcap_strerror"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "char *", "var": ["p"], "API_desc": "get or print libpcap error message text"}, "sent": "pcap_geterr_APIName returns the error text pertaining to the last pcap library error.", "paraph": "pcap_geterr_APIName returns the error text pertaining to the last pcap library error. NOTE: the pointer pcap_geterr_APIName returns will no longer point to a valid error message string after the pcap_t passed to it is closed; you must use or copy the string before closing the pcap_t", "key": "pcap_geterr"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "It has no effect on savefiles.", "paraph": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode, or takes it out of non-blocking mode, depending on whether the pcap_setnonblock_APIParam_2 argument is non-zero or zero. It has no effect on savefiles. If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName. In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "pcap_create_APIName returns a pcap_t * on success and NULL on failure.", "paraph": "pcap_create_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message. pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_create"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "void", "var": ["p"], "API_desc": "close a capture device or savefile pcap_t p"}, "sent": "pcap_close_APIName closes the files associated with pcap_close_APIParam_1 and deallocates resources", "paraph": "pcap_close_APIName closes the files associated with pcap_close_APIParam_1 and deallocates resources", "key": "pcap_close"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_create_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message. pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_create"}, {"API_info": {"var_type": ["int"], "ret_type": "const char *", "var": ["error"], "API_desc": "convert an errno value to a string"}, "sent": "pcap_strerror_APIName is provided in case strerror_APIName is not available.", "paraph": "pcap_strerror_APIName is provided in case strerror_APIName is not available. pcap_strerror_APIName returns an pcap_strerror_APIParam_1 message string corresponding to error", "key": "pcap_strerror"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName.", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message.", "paraph": "pcap_create_APIName returns a pcap_t * on success and NULL on failure. If NULL be returned by pcap_create_APIName, pcap_create_APIParam_2 is filled in with an appropriate error message. pcap_create_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_create"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "pcap_create_APIName is used to create a packet capture handle to look at packets on the network.", "paraph": "pcap_create_APIName is used to create a packet capture handle to look at packets on the network. pcap_create_APIParam_1 is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a pcap_create_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "key": "pcap_create"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr *"], "ret_type": "const u_char *", "var": ["p", "h"], "API_desc": "read the next packet from a pcap_t"}, "sent": "Unfortunately , there is no way to determine ", "paraph": "pcap_next_APIName returns a pointer to the packet data on success, and returns NULL if an error occurred, or if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a savefile. Unfortunately, there is no way to determine whether an error occurred or not", "key": "pcap_next"}, {"API_info": {"var_type": ["pcap_t *", "const char *"], "ret_type": "void", "var": ["p", "prefix"], "API_desc": "get or print libpcap error message text"}, "sent": "pcap_perror_APIName prints the text of the last pcap library error on stderr, prefixed by prefix", "paraph": "pcap_perror_APIName prints the text of the last pcap library error on stderr, prefixed by prefix", "key": "pcap_perror"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr *"], "ret_type": "const u_char *", "var": ["p", "h"], "API_desc": "read the next packet from a pcap_t"}, "sent": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet.", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_next"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the snapshot length"}, "sent": "pcap_snapshot_APIName returns the snapshot length on success and PCAP_ERROR_NOT_ACTIVATED if pcap_snapshot_APIName is called on a capture handle that has been created but not activated", "paraph": "pcap_snapshot_APIName returns the snapshot length on success and PCAP_ERROR_NOT_ACTIVATED if pcap_snapshot_APIName is called on a capture handle that has been created but not activated", "key": "pcap_snapshot"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "If PCAP_ERROR be returned by pcap_next_ex_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_next_ex_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_next_ex_APIName returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR if an error occurred while reading the packet, and PCAP_ERROR_BREAK if packets are being read from a savefile and there are no more packets to read from the savefile. If PCAP_ERROR be returned by pcap_next_ex_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_next_ex_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "paraph": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode, or takes it out of non-blocking mode, depending on whether the pcap_setnonblock_APIParam_2 argument is non-zero or zero. It has no effect on savefiles. If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName. In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode , or takes it out of non-blocking mode , depending on  or zero .", "paraph": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode, or takes it out of non-blocking mode, depending on whether the pcap_setnonblock_APIParam_2 argument is non-zero or zero. It has no effect on savefiles. If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName. In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "find out whether a savefile has the native byte order"}, "sent": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "paraph": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "key": "pcap_is_swapped"}, {"API_info": {"var_type": ["void"], "ret_type": "const char *", "var": ["void"], "API_desc": "get the version information for libpcap"}, "sent": "pcap_lib_version_APIName returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number", "paraph": "pcap_lib_version_APIName returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number", "key": "pcap_lib_version"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the snapshot length"}, "sent": "pcap_snapshot_APIName returns the snapshot length specified when pcap_set_snaplen_APIName or pcap_open_live_APIName was called, for a live capture, or the snapshot length from the capture file, for a savefile", "paraph": "pcap_snapshot_APIName returns the snapshot length specified when pcap_set_snaplen_APIName or pcap_open_live_APIName was called, for a live capture, or the snapshot length from the capture file, for a savefile", "key": "pcap_snapshot"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName.", "paraph": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode, or takes it out of non-blocking mode, depending on whether the pcap_setnonblock_APIParam_2 argument is non-zero or zero. It has no effect on savefiles. If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName. In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["pcap_t *", "char *"], "ret_type": "int", "var": ["p", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "pcap_getnonblock_APIName returns the current non-blocking state of the capture descriptor; it always returns 0 on savefiles.", "paraph": "pcap_getnonblock_APIName returns the current non-blocking state of the capture descriptor; it always returns 0 on savefiles. If there is an error, PCAP_ERROR be returned by pcap_getnonblock_APIName and pcap_getnonblock_APIParam_2 is filled in with an appropriate error message", "key": "pcap_getnonblock"}, {"API_info": {"var_type": ["pcap_t *", "char *"], "ret_type": "int", "var": ["p", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "errbuf is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "errbuf is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_getnonblock"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "The returned handle must be activated with pcap_activate_APIName before packets can be captured with it; options for the capture, such as promiscuous mode, can be set on the handle before activating it", "paraph": "The returned handle must be activated with pcap_activate_APIName before packets can be captured with it; options for the capture, such as promiscuous mode, can be set on the handle before activating it", "key": "pcap_create"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "char *", "var": ["p"], "API_desc": "get or print libpcap error message text"}, "sent": "NOTE: the pointer pcap_geterr_APIName returns will no longer point to a valid error message string after the pcap_t passed to it is closed; you must use or copy the string before closing the pcap_t", "paraph": "pcap_geterr_APIName returns the error text pertaining to the last pcap library error. NOTE: the pointer pcap_geterr_APIName returns will no longer point to a valid error message string after the pcap_t passed to it is closed; you must use or copy the string before closing the pcap_t", "key": "pcap_geterr"}, {"API_info": {"var_type": ["pcap_t *", "char *"], "ret_type": "int", "var": ["p", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "If there is an error, PCAP_ERROR be returned by pcap_getnonblock_APIName and pcap_getnonblock_APIParam_2 is filled in with an appropriate error message", "paraph": "pcap_getnonblock_APIName returns the current non-blocking state of the capture descriptor; it always returns 0 on savefiles. If there is an error, PCAP_ERROR be returned by pcap_getnonblock_APIName and pcap_getnonblock_APIParam_2 is filled in with an appropriate error message", "key": "pcap_getnonblock"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "On Linux, with previous releases of libpcap, capture devices are always in immediate mode; however, in 1.5.0 and later, they are, by default, not in immediate mode, so if pcap_set_immediate_mode_APIName is available, it should be used", "paraph": "On Linux, with previous releases of libpcap, capture devices are always in immediate mode; however, in 1.5.0 and later, they are, by default, not in immediate mode, so if pcap_set_immediate_mode_APIName is available, it should be used", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["const char *", "char *"], "ret_type": "pcap_t *", "var": ["source", "errbuf"], "API_desc": "create a live capture handle"}, "sent": "pcap_create_APIParam_1 is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a pcap_create_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "paraph": "pcap_create_APIName is used to create a packet capture handle to look at packets on the network. pcap_create_APIParam_1 is a string that specifies the network device to open; on Linux systems with 2.2 or later kernels, a pcap_create_APIParam_1 argument of \"any\" or NULL can be used to capture packets from all interfaces", "key": "pcap_create"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "promisc"], "API_desc": "set promiscuous mode for a not"}, "sent": "If pcap_set_promisc_APIParam_2 is non-zero, promiscuous mode will be set, otherwise it will not be set", "paraph": "pcap_set_promisc_APIName sets whether promiscuous mode should be set on a capture handle when the handle is activated. If pcap_set_promisc_APIParam_2 is non-zero, promiscuous mode will be set, otherwise it will not be set", "key": "pcap_set_promisc"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "promisc"], "API_desc": "set promiscuous mode for a not"}, "sent": "pcap_set_promisc_APIName sets  is activated .", "paraph": "pcap_set_promisc_APIName sets whether promiscuous mode should be set on a capture handle when the handle is activated. If pcap_set_promisc_APIParam_2 is non-zero, promiscuous mode will be set, otherwise it will not be set", "key": "pcap_set_promisc"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "If the packet was read without problems, the pointer pointed to by the pcap_next_ex_APIParam_2 argument is set to point to the pcap_pkthdr struct for the packet, and the pointer pointed to by the pcap_next_ex_APIParam_3 argument is set to point to the data in the packet.", "paraph": "pcap_next_ex_APIName reads the next packet and returns a success/failure indication. If the packet was read without problems, the pointer pointed to by the pcap_next_ex_APIParam_2 argument is set to point to the pcap_pkthdr struct for the packet, and the pointer pointed to by the pcap_next_ex_APIParam_3 argument is set to point to the data in the packet. The struct pcap_pkthdr and the packet data are not to be freed by the caller, and are not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs them to remain valid, it must make a copy of them", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the time stamp type value corresponding to a time stamp type name"}, "sent": "The translation is case-insensitive", "paraph": "pcap_tstamp_type_name_to_val_APIName translates a time stamp type pcap_tstamp_type_name_to_val_APIParam_1 to the corresponding time stamp type value. The translation is case-insensitive", "key": "pcap_tstamp_type_name_to_val"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "promisc"], "API_desc": "set promiscuous mode for a not"}, "sent": "pcap_set_promisc_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_promisc_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_promisc_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_promisc_APIName is called on a capture handle that has been activated", "key": "pcap_set_promisc"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the time stamp type value corresponding to a time stamp type name"}, "sent": "pcap_tstamp_type_name_to_val_APIName translates a time stamp type pcap_tstamp_type_name_to_val_APIParam_1 to the corresponding time stamp type value.", "paraph": "pcap_tstamp_type_name_to_val_APIName translates a time stamp type pcap_tstamp_type_name_to_val_APIParam_1 to the corresponding time stamp type value. The translation is case-insensitive", "key": "pcap_tstamp_type_name_to_val"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "When first activated with pcap_activate_APIName or opened with pcap_open_live_APIName, a capture handle is not in non-blocking mode; a call to pcap_setnonblock_APIName is required in order to put it into non-blocking mode", "paraph": "When first activated with pcap_activate_APIName or opened with pcap_open_live_APIName, a capture handle is not in non-blocking mode; a call to pcap_setnonblock_APIName is required in order to put it into non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the time stamp type value corresponding to a time stamp type name"}, "sent": "pcap_tstamp_type_name_to_val_APIName returns time stamp type value on success and PCAP_ERROR on failure", "paraph": "pcap_tstamp_type_name_to_val_APIName returns time stamp type value on success and PCAP_ERROR on failure", "key": "pcap_tstamp_type_name_to_val"}, {"API_info": {"var_type": ["const char *"], "ret_type": "int", "var": ["name"], "API_desc": "get the time stamp type value corresponding to a time stamp type name"}, "sent": "pcap_tstamp_type_name_to_val_APIName became available in libpcap release 1.2.1", "paraph": "pcap_tstamp_type_name_to_val_APIName became available in libpcap release 1.2.1", "key": "pcap_tstamp_type_name_to_val"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr *"], "ret_type": "const u_char *", "var": ["p", "h"], "API_desc": "read the next packet from a pcap_t"}, "sent": "pcap_next_APIName returns a pointer to the packet data on success, and returns NULL if an error occurred, or if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a savefile.", "paraph": "pcap_next_APIName returns a pointer to the packet data on success, and returns NULL if an error occurred, or if no packets were read from a live capture (if, for example, they were discarded because they did not pass the packet filter, or if, on platforms that support a packet buffer timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read), or if no more packets are available in a savefile. Unfortunately, there is no way to determine whether an error occurred or not", "key": "pcap_next"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "paraph": "The bytes of data from the packet begin with a link-layer header. The format of the link-layer header is indicated by the return value of the pcap_datalink_APIName routine when handed the pcap_t value also passed to pcap_loop_APIName or pcap_dispatch_APIName. https://www.tcpdump.org/linktypes.html lists the values pcap_datalink_APIName can return and describes the packet formats that correspond to those values. The value pcap_next_ex_APIName returns will be valid for all packets received unless and until pcap_set_datalink_APIName is called; after a successful call to pcap_set_datalink_APIName, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to pcap_set_datalink", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "int", "char *"], "ret_type": "int", "var": ["p", "nonblock", "errbuf"], "API_desc": "set or get the state of non"}, "sent": "In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive.", "paraph": "pcap_setnonblock_APIName puts a capture handle into non-blocking mode, or takes it out of non-blocking mode, depending on whether the pcap_setnonblock_APIParam_2 argument is non-zero or zero. It has no effect on savefiles. If there is an error, PCAP_ERROR be returned by pcap_setnonblock_APIName and pcap_setnonblock_APIParam_3 is filled in with an appropriate error message; otherwise, 0 be returned by pcap_setnonblock_APIName. In non-blocking mode, an attempt to read from the capture descriptor with pcap_dispatch_APIName will, if no packets are currently available to be read, return 0 immediately rather than blocking waiting for packets to arrive. pcap_loop_APIName and pcap_next_APIName will not work in non-blocking mode", "key": "pcap_setnonblock"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The packet data is not to be freed by the caller, and is not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs it to remain valid, it must make a copy of it.", "paraph": "pcap_next_APIName reads the next packet (by calling pcap_dispatch_APIName with a cnt of 1) and returns a u_char pointer to the data in that packet. The packet data is not to be freed by the caller, and is not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs it to remain valid, it must make a copy of it. The pcap_pkthdr structure pointed to by h is filled in with the appropriate values for the packet", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr *"], "ret_type": "const u_char *", "var": ["p", "h"], "API_desc": "read the next packet from a pcap_t"}, "sent": "For example , the `` any '' device on Linux will have a link-layer header type of DLT_LINUX_SLL ", "paraph": "Do NOT assume that the packets for a given capture or savefile will have any given link-layer header type, such as DLT_EN10MB for Ethernet. For example, the \"any\" device on Linux will have a link-layer header type of DLT_LINUX_SLL even if all devices on the system at the time the \"any\" device is opened have some other data link type, such as DLT_EN10MB for Ethernet", "key": "pcap_next"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "The struct pcap_pkthdr and the packet data are not to be freed by the caller, and are not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs them to remain valid, it must make a copy of them", "paraph": "pcap_next_ex_APIName reads the next packet and returns a success/failure indication. If the packet was read without problems, the pointer pointed to by the pcap_next_ex_APIParam_2 argument is set to point to the pcap_pkthdr struct for the packet, and the pointer pointed to by the pcap_next_ex_APIParam_3 argument is set to point to the data in the packet. The struct pcap_pkthdr and the packet data are not to be freed by the caller, and are not guaranteed to be valid after the next call to pcap_next_ex_APIName, pcap_next_APIName, pcap_loop_APIName, or pcap_dispatch_APIName; if the code needs them to remain valid, it must make a copy of them", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the snapshot length"}, "sent": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "paraph": "It must not be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate(3PCAP", "key": "pcap_snapshot"}, {"API_info": {"var_type": ["pcap_t *", "struct pcap_pkthdr **", "const u_char **"], "ret_type": "int", "var": ["p", "pkt_header", "pkt_data"], "API_desc": "read the next packet from a pcap_t"}, "sent": "pcap_next_ex_APIName returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR if an error occurred while reading the packet, and PCAP_ERROR_BREAK if packets are being read from a savefile and there are no more packets to read from the savefile.", "paraph": "pcap_next_ex_APIName returns 1 if the packet was read without problems, 0 if packets are being read from a live capture and the packet buffer timeout expired, PCAP_ERROR if an error occurred while reading the packet, and PCAP_ERROR_BREAK if packets are being read from a savefile and there are no more packets to read from the savefile. If PCAP_ERROR be returned by pcap_next_ex_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_next_ex_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_next_ex"}, {"API_info": {"var_type": ["struct bp"], "ret_type": "void", "var": ["bpf_program"], "API_desc": "free a BPF program"}, "sent": "pcap_freecode_APIName is used to free up allocated memory pointed to by a pcap_freecode_APIParam_1 struct generated by pcap_compile_APIName when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to pcap_setfilter(3PCAP", "paraph": "pcap_freecode_APIName is used to free up allocated memory pointed to by a pcap_freecode_APIParam_1 struct generated by pcap_compile_APIName when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to pcap_setfilter(3PCAP", "key": "pcap_freecode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "immediate_mode"], "API_desc": "set immediate mode for a not"}, "sent": "on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11, immediate mode must be turned on with a BIOCIMMEDIATE ioctl_APIName, as documented in bpf_APIName, on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called; on Solaris 10 and earlier versions of Solaris, immediate mode must be turned on by using a read timeout of 0 when opening the device (this will not provide immediate delivery of packets on other platforms, so do not assume it is sufficient); on Digital UNIX/Tru64 UNIX, immediate mode must be turned on by doing a BIOCMBIC ioctl, as documented in packetfilter_APIName, to clear the ENBATCH flag on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called; on Windows, immediate mode must be turned on by calling pcap_setmintocopy_APIName with a size of 0", "paraph": "on FreeBSD, NetBSD, OpenBSD, DragonFly BSD, macOS, and Solaris 11, immediate mode must be turned on with a BIOCIMMEDIATE ioctl_APIName, as documented in bpf_APIName, on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called; on Solaris 10 and earlier versions of Solaris, immediate mode must be turned on by using a read timeout of 0 when opening the device (this will not provide immediate delivery of packets on other platforms, so do not assume it is sufficient); on Digital UNIX/Tru64 UNIX, immediate mode must be turned on by doing a BIOCMBIC ioctl, as documented in packetfilter_APIName, to clear the ENBATCH flag on the descriptor returned by pcap_fileno_APIName, after pcap_activate_APIName is called; on Windows, immediate mode must be turned on by calling pcap_setmintocopy_APIName with a size of 0", "key": "pcap_set_immediate_mode"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName.", "paraph": "pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2.", "paraph": "pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "See pcap-tstamp_APIName for a list of all the time stamp types", "paraph": "pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device.", "paraph": "pcap_set_tstamp_type_APIName sets the type of time stamp desired for packets captured on the pcap descriptor to the type specified by pcap_set_tstamp_type_APIParam_2. It must be called on a pcap descriptor created by pcap_create_APIName that has not yet been activated by pcap_activate_APIName. pcap_list_tstamp_types_APIName will give a list of the time stamp types supported by a given capture device. See pcap-tstamp_APIName for a list of all the time stamp types", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "pcap_set_tstamp_type_APIName became available in libpcap release 1.2.1.", "paraph": "pcap_set_tstamp_type_APIName became available in libpcap release 1.2.1. In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "paraph": "pcap_set_tstamp_type_APIName became available in libpcap release 1.2.1. In previous releases, the time stamp type cannot be set; only the default time stamp type offered by a capture source is available", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "pcap_get_required_select_timeout_APIName is not available on Windows", "paraph": "pcap_get_required_select_timeout_APIName is not available on Windows", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "paraph": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired. A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "The timeout that should be used in those calls must be no larger than the smallest of all timeouts returned by pcap_get_required_select_timeout_APIName for devices from which packets will be captured", "paraph": "The timeout that should be used in those calls must be no larger than the smallest of all timeouts returned by pcap_get_required_select_timeout_APIName for devices from which packets will be captured", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "pcap_get_required_select_timeout_APIName became available in libpcap release 1.9.0.", "paraph": "pcap_get_required_select_timeout_APIName became available in libpcap release 1.9.0. In previous releases, select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName cannot be used on any capture source for which pcap_get_selectable_fd_APIName returns -1", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_dumper_t *"], "ret_type": "FILE *", "var": ["p"], "API_desc": "get the standard I/O stream for a savefile being written"}, "sent": "pcap_dump_file_APIName returns the standard I/O stream of the savefile opened by pcap_dump_open(3PCAP", "paraph": "pcap_dump_file_APIName returns the standard I/O stream of the savefile opened by pcap_dump_open(3PCAP", "key": "pcap_dump_file"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "(Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.)", "paraph": "pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName. (Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) If pcap_findalldevs_APIName succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list, or to NULL if no devices were found (this is considered success). Each element of the list is of type pcap_if_t, and has the following members", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "A pointer to a struct timeval be returned by pcap_get_required_select_timeout_APIName if the timeout is required; otherwise NULL be returned by pcap_get_required_select_timeout_APIName", "paraph": "A pointer to a struct timeval be returned by pcap_get_required_select_timeout_APIName if the timeout is required; otherwise NULL be returned by pcap_get_required_select_timeout_APIName", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired.", "paraph": "Note that a device on which a read can be done without blocking may, on some platforms, not have any packets to read if the packet buffer timeout has expired. A call to pcap_dispatch_APIName or pcap_next_ex_APIName will return 0 in this case, but will not block", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "pcap_get_required_select_timeout_APIName returns, on UNIX, a pointer to a struct timeval containing a value that must be used as the minimum timeout in select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName calls if pcap_get_selectable_fd_APIName returns PCAP_ERROR", "paraph": "pcap_get_required_select_timeout_APIName returns, on UNIX, a pointer to a struct timeval containing a value that must be used as the minimum timeout in select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName calls if pcap_get_selectable_fd_APIName returns PCAP_ERROR", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName.", "paraph": "pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName. (Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) If pcap_findalldevs_APIName succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list, or to NULL if no devices were found (this is considered success). Each element of the list is of type pcap_if_t, and has the following members", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "In previous releases, select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName cannot be used on any capture source for which pcap_get_selectable_fd_APIName returns -1", "paraph": "pcap_get_required_select_timeout_APIName became available in libpcap release 1.9.0. In previous releases, select_APIName, poll_APIName, epoll_wait_APIName, and kevent_APIName cannot be used on any capture source for which pcap_get_selectable_fd_APIName returns -1", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "next", "paraph": "next", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "Each element of the list is of type pcap_if_t, and has the following members", "paraph": "pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName. (Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) If pcap_findalldevs_APIName succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list, or to NULL if no devices were found (this is considered success). Each element of the list is of type pcap_if_t, and has the following members", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "a pointer to a string giving a name for the device to pass to pcap_open_live_APIName description", "paraph": "a pointer to a string giving a name for the device to pass to pcap_open_live_APIName description", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "struct timeval *", "var": ["p"], "API_desc": "get a file descriptor on which a select() can be done for a live capture"}, "sent": "The device  must be put in non-blocking mode with pcap_setnonblock_APIName , and an attempt must always be made to read packets from the device when the select_APIName , poll_APIName , epoll_wait_APIName , or kevent_APIName call returns", "paraph": "The device for which pcap_get_selectable_fd_APIName returned PCAP_ERROR must be put in non-blocking mode with pcap_setnonblock_APIName, and an attempt must always be made to read packets from the device when the select_APIName, poll_APIName, epoll_wait_APIName, or kevent_APIName call returns", "key": "pcap_get_required_select_timeout"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "device flags", "paraph": "device flags", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "If pcap_findalldevs_APIName succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list, or to NULL if no devices were found (this is considered success).", "paraph": "pcap_findalldevs_APIName constructs a list of network devices that can be opened with pcap_create_APIName and pcap_activate_APIName or with pcap_open_live_APIName. (Note that there may be network devices that cannot be opened by the process calling pcap_findalldevs_APIName, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) If pcap_findalldevs_APIName succeeds, the pointer pointed to by pcap_findalldevs_APIParam_1 is set to point to the first element of the list, or to NULL if no devices were found (this is considered success). Each element of the list is of type pcap_if_t, and has the following members", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to a string giving a human-readable description of the device addresses", "paraph": "if not NULL, a pointer to a string giving a human-readable description of the device addresses", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "PCAP_IF_LOOPBACK", "paraph": "PCAP_IF_LOOPBACK", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to the next element in the list; NULL for the last element of the list name", "paraph": "if not NULL, a pointer to the next element in the list; NULL for the last element of the list name", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "set if the device is a loopback interface PCAP_IF_UP", "paraph": "set if the device is a loopback interface PCAP_IF_UP", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "set if the device is up PCAP_IF_RUNNING", "paraph": "set if the device is up PCAP_IF_RUNNING", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "set if the device is running PCAP_IF_WIRELESS", "paraph": "set if the device is running PCAP_IF_WIRELESS", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "a pointer to the first element of a list of network addresses for the device, or NULL if the device has no addresses flags", "paraph": "a pointer to the first element of a list of network addresses for the device, or NULL if the device has no addresses flags", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "it is unknown ", "paraph": "it is unknown whether the adapter is connected or not PCAP_IF_CONNECTION_STATUS_CONNECTED", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "the adapter is connected PCAP_IF_CONNECTION_STATUS_DISCONNECTED", "paraph": "the adapter is connected PCAP_IF_CONNECTION_STATUS_DISCONNECTED", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "the adapter is disconnected PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE", "paraph": "the adapter is disconnected PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "next", "paraph": "next", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "Each element of the list of addresses is of type pcap_addr_t, and has the following members", "paraph": "Each element of the list of addresses is of type pcap_addr_t, and has the following members", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "set if the device is a wireless interface; this includes IrDA as well as radio-based networks such as IEEE 802.15.4 and IEEE 802.11, so it does not just mean Wi-Fi PCAP_IF_CONNECTION_STATUS", "paraph": "set if the device is a wireless interface; this includes IrDA as well as radio-based networks such as IEEE 802.15.4 and IEEE 802.11, so it does not just mean Wi-Fi PCAP_IF_CONNECTION_STATUS", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "the notion of \"connected\" and \"disconnected\" do not apply to this interface; for example, it does not apply to a loopback device", "paraph": "the notion of \"connected\" and \"disconnected\" do not apply to this interface; for example, it does not apply to a loopback device", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "a pointer to a struct sockaddr containing an address netmask", "paraph": "a pointer to a struct sockaddr containing an address netmask", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to the next element in the list; NULL for the last element of the list addr", "paraph": "if not NULL, a pointer to the next element in the list; NULL for the last element of the list addr", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "a bitmask for an indication of  ; for wireless interfaces , `` connected '' means `` associated with a network '' The possible values for the connection status bits are : PCAP_IF_CONNECTION_STATUS_UNKNOWN", "paraph": "a bitmask for an indication of whether the adapter is connected or not; for wireless interfaces, \"connected\" means \"associated with a network\" The possible values for the connection status bits are: PCAP_IF_CONNECTION_STATUS_UNKNOWN", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to a struct sockaddr that contains the netmask corresponding to the address pointed to by addr broadaddr", "paraph": "if not NULL, a pointer to a struct sockaddr that contains the netmask corresponding to the address pointed to by addr broadaddr", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": " , and what types they might have is platform-dependent .", "paraph": "Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses. IPv4 addresses have the value AF_INET, IPv6 addresses have the value AF_INET6 (which older operating systems that do not support IPv6 might not define), and other addresses have other values. Whether other addresses be returned by pcap_freealldevs_APIName, and what types they might have is platform-dependent. For IPv4 addresses, the struct sockaddr pointer can be interpreted as if it pointed to a struct sockaddr_in; for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "IPv4 addresses have the value AF_INET, IPv6 addresses have the value AF_INET6 (which older operating systems that do not support IPv6 might not define), and other addresses have other values.", "paraph": "Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses. IPv4 addresses have the value AF_INET, IPv6 addresses have the value AF_INET6 (which older operating systems that do not support IPv6 might not define), and other addresses have other values. Whether other addresses be returned by pcap_freealldevs_APIName, and what types they might have is platform-dependent. For IPv4 addresses, the struct sockaddr pointer can be interpreted as if it pointed to a struct sockaddr_in; for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "The list of devices must be freed with pcap_freealldevs_APIName, which frees the list pointed to by alldevs", "paraph": "The list of devices must be freed with pcap_freealldevs_APIName, which frees the list pointed to by alldevs", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to a struct sockaddr that contains the broadcast address corresponding to the address pointed to by addr; may be null if the device does not support broadcasts dstaddr", "paraph": "if not NULL, a pointer to a struct sockaddr that contains the broadcast address corresponding to the address pointed to by addr; may be null if the device does not support broadcasts dstaddr", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "If PCAP_ERROR be returned by pcap_findalldevs_APIName, pcap_findalldevs_APIParam_2 is filled in with an appropriate error message.", "paraph": "pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case. If PCAP_ERROR be returned by pcap_findalldevs_APIName, pcap_findalldevs_APIParam_2 is filled in with an appropriate error message. pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case. If PCAP_ERROR be returned by pcap_findalldevs_APIName, pcap_findalldevs_APIParam_2 is filled in with an appropriate error message. pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "The PCAP_IF_UP and PCAP_IF_RUNNING constants became available in libpcap release 1.6.1.", "paraph": "The PCAP_IF_UP and PCAP_IF_RUNNING constants became available in libpcap release 1.6.1. The PCAP_IF_WIRELESS, PCAP_IF_CONNECTION_STATUS, PCAP_IF_CONNECTION_STATUS_UNKNOWN, PCAP_IF_CONNECTION_STATUS_CONNECTED, PCAP_IF_CONNECTION_STATUS_DISCONNECTED, and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE constants became available in libpcap release 1.9.0", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "if not NULL, a pointer to a struct sockaddr that contains the destination address corresponding to the address pointed to by addr; may be null if the device is not a point-to-point interface", "paraph": "if not NULL, a pointer to a struct sockaddr that contains the destination address corresponding to the address pointed to by addr; may be null if the device is not a point-to-point interface", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "The PCAP_IF_WIRELESS, PCAP_IF_CONNECTION_STATUS, PCAP_IF_CONNECTION_STATUS_UNKNOWN, PCAP_IF_CONNECTION_STATUS_CONNECTED, PCAP_IF_CONNECTION_STATUS_DISCONNECTED, and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE constants became available in libpcap release 1.9.0", "paraph": "The PCAP_IF_UP and PCAP_IF_RUNNING constants became available in libpcap release 1.6.1. The PCAP_IF_WIRELESS, PCAP_IF_CONNECTION_STATUS, PCAP_IF_CONNECTION_STATUS_UNKNOWN, PCAP_IF_CONNECTION_STATUS_CONNECTED, PCAP_IF_CONNECTION_STATUS_DISCONNECTED, and PCAP_IF_CONNECTION_STATUS_NOT_APPLICABLE constants became available in libpcap release 1.9.0", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "A non-zero return value indicates what warning or error condition occurred", "paraph": "pcap_activate_APIName returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error. A non-zero return value indicates what warning or error condition occurred", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The possible warning values are: PCAP_WARNING_PROMISC_NOTSUP", "paraph": "The possible warning values are: PCAP_WARNING_PROMISC_NOTSUP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "For IPv4 addresses, the struct sockaddr pointer can be interpreted as if it pointed to a struct sockaddr_in; for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6", "paraph": "Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses. IPv4 addresses have the value AF_INET, IPv6 addresses have the value AF_INET6 (which older operating systems that do not support IPv6 might not define), and other addresses have other values. Whether other addresses be returned by pcap_freealldevs_APIName, and what types they might have is platform-dependent. For IPv4 addresses, the struct sockaddr pointer can be interpreted as if it pointed to a struct sockaddr_in; for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["pcap_if_t **", "char *"], "ret_type": "int", "var": ["alldevsp", "errbuf"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case.", "paraph": "pcap_findalldevs_APIName returns 0 on success and PCAP_ERROR on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case. If PCAP_ERROR be returned by pcap_findalldevs_APIName, pcap_findalldevs_APIParam_2 is filled in with an appropriate error message. pcap_findalldevs_APIParam_2 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_findalldevs"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_WARNING_TSTAMP_TYPE_NOTSUP", "paraph": "Promiscuous mode was requested, but the capture source does not support promiscuous mode. PCAP_WARNING_TSTAMP_TYPE_NOTSUP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "Promiscuous mode was requested, but the capture source does not support promiscuous mode.", "paraph": "Promiscuous mode was requested, but the capture source does not support promiscuous mode. PCAP_WARNING_TSTAMP_TYPE_NOTSUP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "pcap_activate_APIName is used to activate a packet capture handle to look at packets on the network, with the options that were set on the handle being in effect", "paraph": "pcap_activate_APIName is used to activate a packet capture handle to look at packets on the network, with the options that were set on the handle being in effect", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The possible error values are: PCAP_ERROR_ACTIVATED", "paraph": "The possible error values are: PCAP_ERROR_ACTIVATED", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The time stamp type specified in a previous pcap_set_tstamp_type_APIName call is not supported by the capture source (the time stamp type is left as the default), PCAP_WARNING", "paraph": "The time stamp type specified in a previous pcap_set_tstamp_type_APIName call is not supported by the capture source (the time stamp type is left as the default), PCAP_WARNING", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "pcap_activate_APIName returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error.", "paraph": "pcap_activate_APIName returns 0 on success without warnings, a non-zero positive value on success with warnings, and a negative value on error. A non-zero return value indicates what warning or error condition occurred", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The handle has already been activated.", "paraph": "The handle has already been activated. PCAP_ERROR_NO_SUCH_DEVICE", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR_NO_SUCH_DEVICE", "paraph": "The handle has already been activated. PCAP_ERROR_NO_SUCH_DEVICE", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "Another warning condition occurred; pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the warning condition", "paraph": "Another warning condition occurred; pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the warning condition", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR_PERM_DENIED", "paraph": "The capture source specified when the handle was created does not exist. PCAP_ERROR_PERM_DENIED", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The capture source specified when the handle was created does not exist.", "paraph": "The capture source specified when the handle was created does not exist. PCAP_ERROR_PERM_DENIED", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR_PROMISC_PERM_DENIED", "paraph": "The process does not have permission to open the capture source. PCAP_ERROR_PROMISC_PERM_DENIED", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The process does not have permission to open the capture source.", "paraph": "The process does not have permission to open the capture source. PCAP_ERROR_PROMISC_PERM_DENIED", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR_RFMON_NOTSUP", "paraph": "The process has permission to open the capture source but does not have permission to put it into promiscuous mode. PCAP_ERROR_RFMON_NOTSUP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR_IFACE_NOT_UP", "paraph": "Monitor mode was specified but the capture source does not support monitor mode. PCAP_ERROR_IFACE_NOT_UP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The process has permission to open the capture source but does not have permission to put it into promiscuous mode.", "paraph": "The process has permission to open the capture source but does not have permission to put it into promiscuous mode. PCAP_ERROR_RFMON_NOTSUP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "Monitor mode was specified but the capture source does not support monitor mode.", "paraph": "Monitor mode was specified but the capture source does not support monitor mode. PCAP_ERROR_IFACE_NOT_UP", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "The capture source device is not up.", "paraph": "The capture source device is not up. PCAP_ERROR", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "PCAP_ERROR", "paraph": "The capture source device is not up. PCAP_ERROR", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "Another error occurred.", "paraph": "Another error occurred. pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the error", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the error", "paraph": "Another error occurred. pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display a message describing the error", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "If pcap_activate_APIName fails, the pcap_t * is not closed and freed; the pcap_t should be closed using pcap_close", "paraph": "If pcap_activate_APIName fails, the pcap_t * is not closed and freed; the pcap_t should be closed using pcap_close", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "dlt"], "API_desc": "set the link"}, "sent": "pcap_set_datalink_APIName returns 0 on success and PCAP_ERROR on failure.", "paraph": "pcap_set_datalink_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_set_datalink_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_set_datalink_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_set_datalink"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "paraph": "Additional warning and error codes may be added in the future; a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors. pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "dlt"], "API_desc": "set the link"}, "sent": "pcap_set_datalink_APIName is used to set the current link-layer header type of the pcap descriptor to the type specified by dlt", "paraph": "pcap_set_datalink_APIName is used to set the current link-layer header type of the pcap descriptor to the type specified by dlt", "key": "pcap_set_datalink"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName.", "paraph": "pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName. To find a default device on which to capture, call pcap_findalldevs_APIName and, if the list pcap_lookupdev_APIName returns is not empty, use the first device in the list. (If the list is empty, there are no devices on which capture is possible", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "dlt"], "API_desc": "set the link"}, "sent": "If PCAP_ERROR be returned by pcap_set_datalink_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_set_datalink_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_set_datalink_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_set_datalink_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_set_datalink_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_set_datalink"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "(If the list is empty, there are no devices on which capture is possible", "paraph": "pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName. To find a default device on which to capture, call pcap_findalldevs_APIName and, if the list pcap_lookupdev_APIName returns is not empty, use the first device in the list. (If the list is empty, there are no devices on which capture is possible", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_if_t *"], "ret_type": "void", "var": ["alldevs"], "API_desc": "get a list of capture devices, and free that list"}, "sent": "Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses.", "paraph": "Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the sa_family member of the struct sockaddr before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses. IPv4 addresses have the value AF_INET, IPv6 addresses have the value AF_INET6 (which older operating systems that do not support IPv6 might not define), and other addresses have other values. Whether other addresses be returned by pcap_freealldevs_APIName, and what types they might have is platform-dependent. For IPv4 addresses, the struct sockaddr pointer can be interpreted as if it pointed to a struct sockaddr_in; for IPv6 addresses, it can be interpreted as if it pointed to a struct sockaddr_in6", "key": "pcap_freealldevs"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "paraph": "pcap_lookupdev_APIName returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, and with pcap_lookupnet_APIName. If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message. pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message.", "paraph": "pcap_lookupdev_APIName returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, and with pcap_lookupnet_APIName. If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message. pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "In WinPcap, pcap_lookupdev_APIName may return a UTF-16 string rather than an ASCII or UTF-8 string", "paraph": "In WinPcap, pcap_lookupdev_APIName may return a UTF-16 string rather than an ASCII or UTF-8 string", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "To find a default device on which to capture, call pcap_findalldevs_APIName and, if the list pcap_lookupdev_APIName returns is not empty, use the first device in the list.", "paraph": "pcap_lookupdev_APIName is obsoleted by pcap_findalldevs_APIName. To find a default device on which to capture, call pcap_findalldevs_APIName and, if the list pcap_lookupdev_APIName returns is not empty, use the first device in the list. (If the list is empty, there are no devices on which capture is possible", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "Additional warning and error codes may be added in the future; a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors.", "paraph": "Additional warning and error codes may be added in the future; a program should check for positive, negative, and zero return codes, and treat all positive return codes as warnings and all negative return codes as errors. pcap_statustostr_APIName can be called, with a warning or error code as an argument, to fetch a message describing the warning or error code", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "snaplen"], "API_desc": "set the snapshot length for a not"}, "sent": "pcap_set_snaplen_APIName sets the snapshot length to be used on a capture handle when the handle is activated to snaplen", "paraph": "pcap_set_snaplen_APIName sets the snapshot length to be used on a capture handle when the handle is activated to snaplen", "key": "pcap_set_snaplen"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program.", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "activate a capture handle"}, "sent": "If PCAP_WARNING_PROMISC_NOTSUP, PCAP_ERROR_NO_SUCH_DEVICE, or PCAP_ERROR_PERM_DENIED be returned by pcap_activate_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display an message giving additional details about the problem that might be useful for debugging the problem if it is unexpected", "paraph": "If PCAP_WARNING_PROMISC_NOTSUP, PCAP_ERROR_NO_SUCH_DEVICE, or PCAP_ERROR_PERM_DENIED be returned by pcap_activate_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_activate_APIParam_1 as an argument to fetch or display an message giving additional details about the problem that might be useful for debugging the problem if it is unexpected", "key": "pcap_activate"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "See pcap-filter_APIName for the syntax of that string.", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "snaplen"], "API_desc": "set the snapshot length for a not"}, "sent": "pcap_set_snaplen_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_snaplen_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_snaplen_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_snaplen_APIName is called on a capture handle that has been activated", "key": "pcap_set_snaplen"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "pcap_lookupdev_APIName returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, and with pcap_lookupnet_APIName.", "paraph": "pcap_lookupdev_APIName returns a pointer to a string giving the name of a network device suitable for use with pcap_create_APIName and pcap_activate_APIName, or with pcap_open_live_APIName, and with pcap_lookupnet_APIName. If there is an error, NULL be returned by pcap_lookupdev_APIName and pcap_lookupdev_APIParam_1 is filled in with an appropriate error message. pcap_lookupdev_APIParam_1 is assumed to be able to hold at least PCAP_ERRBUF_SIZE chars", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed.", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName.", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["char *"], "ret_type": "[DEPRECATED] char *", "var": ["errbuf"], "API_desc": "find the default device on which to capture"}, "sent": "The pointer returned by pcap_lookupdev_APIName points to a static buffer; subsequent calls to pcap_lookupdev_APIName in the same thread, or calls to pcap_lookupdev_APIName in another thread, may overwrite that buffer", "paraph": "The pointer returned by pcap_lookupdev_APIName points to a static buffer; subsequent calls to pcap_lookupdev_APIName in the same thread, or calls to pcap_lookupdev_APIName in another thread, may overwrite that buffer", "key": "pcap_lookupdev"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "NOTE: in libpcap 1.8.0 and later, pcap_compile_APIName can be used in multiple threads within a single process.", "paraph": "NOTE: in libpcap 1.8.0 and later, pcap_compile_APIName can be used in multiple threads within a single process. However, in earlier versions of libpcap, it is not safe to use pcap_compile_APIName in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program.", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "tstamp_type"], "API_desc": "set the time stamp type to be used by a capture device"}, "sent": "pcap_set_tstamp_type_APIName returns 0 on success if the specified time stamp type is expected to be supported by the capture device, PCAP_WARNING_TSTAMP_TYPE_NOTSUP if the specified time stamp type is not supported by the capture device, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_type_APIName is called on a capture handle that has been activated, and PCAP_ERROR_CANTSET_TSTAMP_TYPE if the capture device does not support setting the time stamp type (only older versions of libpcap will return that; newer versions will always allow the time stamp type to be set to the default type", "paraph": "pcap_set_tstamp_type_APIName returns 0 on success if the specified time stamp type is expected to be supported by the capture device, PCAP_WARNING_TSTAMP_TYPE_NOTSUP if the specified time stamp type is not supported by the capture device, PCAP_ERROR_ACTIVATED if pcap_set_tstamp_type_APIName is called on a capture handle that has been activated, and PCAP_ERROR_CANTSET_TSTAMP_TYPE if the capture device does not support setting the time stamp type (only older versions of libpcap will return that; newer versions will always allow the time stamp type to be set to the default type", "key": "pcap_set_tstamp_type"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "paraph": "pcap_compile_APIName is used to compile the string pcap_compile_APIParam_3 into a filter program. See pcap-filter_APIName for the syntax of that string. program is a pointer to a bpf_program struct and is filled in by pcap_compile_APIName. pcap_compile_APIParam_4 controls whether optimization on the resulting code is performed. pcap_compile_APIParam_5 specifies the IPv4 pcap_compile_APIParam_5 of the network on which packets are being captured; it is used only when checking for IPv4 broadcast addresses in the filter program. If the pcap_compile_APIParam_5 of the network on which packets are being captured is not known to the program, or if packets are being captured on the Linux \"any\" pseudo-interface that can capture on more than one network, a value of PCAP_NETMASK_UNKNOWN can be supplied; tests for IPv4 broadcast addresses will fail to compile, but all other tests in the filter program will be OK", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "pcap_compile_APIName returns 0 on success and PCAP_ERROR on failure.", "paraph": "pcap_compile_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_compile_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_compile_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "The PCAP_NETMASK_UNKNOWN constant became available in libpcap release 1.1.0", "paraph": "The PCAP_NETMASK_UNKNOWN constant became available in libpcap release 1.1.0", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "If PCAP_ERROR be returned by pcap_compile_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_compile_APIParam_1 as an argument to fetch or display the error text", "paraph": "pcap_compile_APIName returns 0 on success and PCAP_ERROR on failure. If PCAP_ERROR be returned by pcap_compile_APIName, pcap_geterr_APIName or pcap_perror_APIName may be called with pcap_compile_APIParam_1 as an argument to fetch or display the error text", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "rfmon"], "API_desc": "set monitor mode for a not"}, "sent": "If pcap_set_rfmon_APIParam_2 is non-zero, monitor mode will be set, otherwise it will not be set", "paraph": "pcap_set_rfmon_APIName sets whether monitor mode should be set on a capture handle when the handle is activated. If pcap_set_rfmon_APIParam_2 is non-zero, monitor mode will be set, otherwise it will not be set", "key": "pcap_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "rfmon"], "API_desc": "set monitor mode for a not"}, "sent": "pcap_set_rfmon_APIName sets  is activated .", "paraph": "pcap_set_rfmon_APIName sets whether monitor mode should be set on a capture handle when the handle is activated. If pcap_set_rfmon_APIParam_2 is non-zero, monitor mode will be set, otherwise it will not be set", "key": "pcap_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *", "int"], "ret_type": "int", "var": ["p", "rfmon"], "API_desc": "set monitor mode for a not"}, "sent": "pcap_set_rfmon_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_rfmon_APIName is called on a capture handle that has been activated", "paraph": "pcap_set_rfmon_APIName returns 0 on success or PCAP_ERROR_ACTIVATED if pcap_set_rfmon_APIName is called on a capture handle that has been activated", "key": "pcap_set_rfmon"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the file descriptor for a live capture"}, "sent": "If pcap_fileno_APIParam_1 refers to a network device that was opened for a live capture using a combination of pcap_create_APIName and pcap_activate_APIName, or using pcap_open_live_APIName, pcap_fileno_APIName returns the file descriptor from which captured packets are read", "paraph": "If pcap_fileno_APIParam_1 refers to a network device that was opened for a live capture using a combination of pcap_create_APIName and pcap_activate_APIName, or using pcap_open_live_APIName, pcap_fileno_APIName returns the file descriptor from which captured packets are read", "key": "pcap_fileno"}, {"API_info": {"var_type": ["pcap_t *", "struct bpf_program *", "const char *", "int", "bpf_u_int32"], "ret_type": "int", "var": ["p", "fp", "str", "optimize", "netmask"], "API_desc": "compile a filter expression"}, "sent": "However, in earlier versions of libpcap, it is not safe to use pcap_compile_APIName in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time", "paraph": "NOTE: in libpcap 1.8.0 and later, pcap_compile_APIName can be used in multiple threads within a single process. However, in earlier versions of libpcap, it is not safe to use pcap_compile_APIName in multiple threads in a single process without some form of mutual exclusion allowing only one thread to call it at any given time", "key": "pcap_compile"}, {"API_info": {"var_type": ["pcap_t *"], "ret_type": "int", "var": ["p"], "API_desc": "get the file descriptor for a live capture"}, "sent": "If pcap_fileno_APIParam_1 refers to a savefile that was opened using functions such as pcap_open_offline_APIName or pcap_fopen_offline_APIName, a dead pcap_t opened using pcap_open_dead_APIName, or a pcap_t that was created with pcap_create_APIName but that has not yet been activated with pcap_activate_APIName, pcap_fileno_APIName returns PCAP_ERROR", "paraph": "If pcap_fileno_APIParam_1 refers to a savefile that was opened using functions such as pcap_open_offline_APIName or pcap_fopen_offline_APIName, a dead pcap_t opened using pcap_open_dead_APIName, or a pcap_t that was created with pcap_create_APIName but that has not yet been activated with pcap_activate_APIName, pcap_fileno_APIName returns PCAP_ERROR", "key": "pcap_fileno"}]