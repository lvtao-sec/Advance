RSA_private_decrypt_APIParam_3 must point to RSA_size_APIName RSA_private_decrypt_APIParam_4 bytes of memory
The following return values of SSL_connect_APIName can occur, 0, 1, <0
SSL_get_certificate_APIName and SSL_get_privatekey_APIName return internal pointers that must not be freed by the application program.
EVP_PKEY_CTX_new_APIName, EVP_PKEY_CTX_new_id_APIName, EVP_PKEY_CTX_dup_APIName returns either the newly allocated EVP_PKEY_CTX structure or NULL if an error occurred.
X509_get_notBefore() and X509_get_notAfter() were deprecated in OpenSSL 1.1.0
RAND_pseudo_bytes_APIName was deprecated in OpenSSL 1.1.0
SSL_CTX_free_APIName decrements the reference count of SSL_CTX_free_APIParam_1, and removes the SSL_CTX object pointed to by SSL_CTX_free_APIParam_1 and frees up the allocated memory if the the reference count has reached 0
It also calls the free_APINameing procedures for indirectly affected items, if applicable: the session cache, the list of ciphers, the list of Client CAs, the certificates and keys
If a session-remove callback is set (SSL_CTX_sess_set_remove_cb_APIName), this callback will be called for each session being freed from SSL_CTX_free_APIParam_1's session cache
This implies, that all corresponding sessions from an external session cache are removed as well
If this is not desired, the user should explicitly unset the callback by calling SSL_CTX_sess_set_remove_cb(SSL_CTX_free_APIParam_1, NULL) prior to calling SSL_CTX_free_APIName
SSL_CTX_free_APIName does not provide diagnostic information
DSA_sign_setup_APIName may be used to precompute part of the signing operation for each signature in case signature generation is time-critical
DSA_do_sign_APIName returns the signature, NULL on error
DSA_do_verify_APIName returns 1 for a valid signature, 0 for an incorrect signature and -1 on error
The error codes can be obtained by ERR_get_error_APIName
The lh_stats_bio_APIParam_1 lh_stats_APIParam_1 lh_node_stats_bio_APIParam_1 lh_node_stats_APIParam_1 lh_node_usage_stats_APIParam_1 lh_node_usage_stats_bio_APIParam_1 structure records statistics about most aspects of accessing the hash table
This is mostly a legacy of Eric Young writing this library for the reasons of implementing what looked like a nice algorithm rather than for a particular software product
lh_stats_APIName prints out statistics on the size of the hash table, how many entries are in it, and the number and result of calls to the routines in this library
lh_node_stats_APIName prints the number of entries for each 'bucket' in the hash table
lh_node_usage_stats_APIName prints out a short summary of the state of the hash table
It prints the 'load' and the 'actual load'
The load is the average number of data items per 'bucket' in the hash table
The 'actual load' is the average number of items per 'bucket', but only for buckets which contain entries
So the 'actual load' is the average number of searches that will need to find an item in the hash table, while the 'load' is the average number that will be done to record a miss
lh_stats_bio_APIName, lh_node_stats_bio_APIName and lh_node_usage_stats_bio_APIName are the same as the above, except that the output goes to a lh_stats_bio_APIParam_2 lh_node_stats_bio_APIParam_2 lh_node_usage_stats_bio_APIParam_2
These functions do not return values
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure
On failure an error code can be obtained from ERR_get_error_APIName
i2d_CMS_bio_stream_APIName outputs a CMS_ContentInfo structure in BER format
It is otherwise identical to the function SMIME_write_CMS_APIName
This function is effectively a version of the i2d_CMS_bio_APIName supporting streaming
The prefix "i2d" is arguably wrong because the function outputs BER format
i2d_CMS_bio_stream_APIName returns 1 for success or 0 for failure
This library implements the Blowfish cipher, which was invented and described by Counterpane (see http://www.counterpane.com/blowfish.html )
Blowfish is a block cipher that operates on 64 bit (8 byte) blocks of data
It uses a variable size key, but typically, 128 bit (16 byte) keys are considered good for strong encryption
Blowfish can be used in the same modes as DES (see des_modes_APIName )
Blowfish is currently one of the faster block ciphers
It is quite a bit faster than DES, and much faster than IDEA or RC2
Blowfish consists of a key setup phase and the actual encryption or decryption phase
BF_set_key_APIName sets up the BF_set_key_APIParam_1 BF_set_key_APIParam_1 using the BF_set_key_APIParam_2 bytes long key at BF_set_key_APIParam_3
BF_ofb64_encrypt_APIName is the OFB mode for Blowfish with 64 bit feedback
It uses the same parameters as BF_cfb64_encrypt_APIName, which must be initialized the same way
BF_encrypt_APIName and BF_decrypt_APIName are the lowest level functions for Blowfish encryption
They encrypt/decrypt the first 64 bits of the vector pointed by BF_encrypt_APIParam_1 BF_decrypt_APIParam_1, using the key BF_encrypt_APIParam_2 BF_decrypt_APIParam_2
These functions should not be used unless you implement 'modes' of Blowfish
The alternative is to use BF_ecb_encrypt_APIName
If you still want to use these functions, you should be aware that they take each 32-bit chunk in host-byte order, which is little-endian on little-endian platforms and big-endian on big-endian ones
None of the functions presented here return any value
Applications should use the higher level functions EVP_EncryptInit_APIName etc instead of calling the blowfish functions directly
Value returned by OPENSSL_ia32cap_loc_APIName is address of a variable containing IA-32 processor capabilities bit vector as it appears in EDX:ECX register pair after executing CPUID instruction with EAX=1 input value (see Intel Application Note #241618)
Naturally it's meaningful on x86 and x86_64 platforms only
The variable is normally set up automatically upon toolkit initialization, but can be manipulated afterwards to modify crypto library behaviour
For the moment of this writing following bits are significant:
For example, clearing bit #26 at run-time disables high-performance SSE2 code present in the crypto library, while clearing bit #24 disables SSE2 code operating on 128-bit XMM register bank
You might have to do the latter if target OpenSSL application is executed on SSE2 capable CPU, but under control of OS that does not enable XMM registers
Even though you can manipulate the value programmatically, you most likely will find the value more appropriate to set up an environment variable with the same name prior starting target application, eg on Intel P4 processor 'env OPENSSL_ia32cap=0x16980010 apps/openssl', or better yet 'env OPENSSL_ia32cap=~0x1000000 apps/openssl' to achieve same effect without modifying the application source code
Alternatively you can reconfigure the toolkit with no-sse2 option and recompile
Less intuitive is clearing bit #28
The truth is that it's not copied from CPUID output verbatim, but is adjusted to reflect whether or not the data cache is actually shared between logical cores
This in turn affects the decision on whether or not expensive countermeasures against cache-timing attacks are applied, most notably in AES assembler module
The vector is further extended with EBX value returned by CPUID with EAX=7 and ECX=0 as input
Following bits are significant:
BN_mod_inverse_APIName returns the BN_mod_inverse_APIParam_1 containing the inverse, and NULL on error
The error codes can be obtained by ERR_get_error_APIName
RIPEMD-160 is a cryptographic hash function with a 160 bit output
RIPEMD160_APIName computes the RIPEMD-160 message digest of the RIPEMD160_APIParam_2 bytes at RIPEMD160_APIParam_1 and places it in RIPEMD160_Final_APIParam_1 (which must have space for RIPEMD160_DIGEST_LENGTH == 20 bytes of output)
If RIPEMD160_Final_APIParam_1 is NULL, the digest is placed in a static array
The following functions may be used if the message is not completely stored in memory:
RIPEMD160_Init_APIName initializes a RIPEMD160_Init_APIParam_1 structure
RIPEMD160_Final_APIName places the message digest in RIPEMD160_Final_APIParam_1, which must have space for RIPEMD160_DIGEST_LENGTH == 20 bytes of output, and erases the RIPEMD160_Final_APIParam_2
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly
RIPEMD160_APIName returns a pointer to the hash value
RIPEMD160_Init_APIName, RIPEMD160_Update_APIName and RIPEMD160_Final_APIName return 1 for success, 0 otherwise
X509_NAME_add_entry_by_txt_APIName, X509_NAME_add_entry_by_OBJ_APIName and X509_NAME_add_entry_by_NID_APIName add a field whose name is defined by a string X509_NAME_add_entry_by_txt_APIParam_2, an object X509_NAME_add_entry_by_OBJ_APIParam_2 or a NID X509_NAME_add_entry_by_NID_APIParam_2 respectively
The field value to be added is in X509_NAME_add_entry_by_txt_APIParam_4 X509_NAME_add_entry_by_OBJ_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_4 of length X509_NAME_add_entry_by_txt_APIParam_5 X509_NAME_add_entry_by_OBJ_APIParam_5 X509_NAME_add_entry_by_NID_APIParam_5
If X509_NAME_add_entry_by_txt_APIParam_5 X509_NAME_add_entry_by_OBJ_APIParam_5 X509_NAME_add_entry_by_NID_APIParam_5 is -1 then the field length is calculated internally using strlen(bytes)
X509_NAME_add_entry_APIName adds a copy of X509_NAME_add_entry_APIParam_2 structure X509_NAME_add_entry_APIParam_2 to X509_NAME_add_entry_APIParam_1
The new entry is added to a position determined by X509_NAME_add_entry_APIParam_3 and X509_NAME_add_entry_APIParam_4
Since a copy of X509_NAME_add_entry_APIParam_2 is added, X509_NAME_add_entry_APIParam_2 must be freed up after the call
X509_NAME_delete_entry_APIName deletes an entry from X509_NAME_delete_entry_APIParam_1 at position X509_NAME_delete_entry_APIParam_2
The deleted entry is returned and must be freed up
If instead an ASN1 type is used ,no checks are performed and the supplied data in X509_NAME_add_entry_by_txt_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_4 X509_NAME_add_entry_by_OBJ_APIParam_4 is used directly
In X509_NAME_add_entry_by_txt_APIName the X509_NAME_add_entry_by_txt_APIParam_2 string represents the field name using OBJ_txt2obj(field, 0)
The X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 and X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 parameters determine where a new entry should be added
For almost all applications X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 can be set to -1 and X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 to 0
This adds a new entry to the end of X509_NAME_add_entry_by_txt_APIParam_1 X509_NAME_add_entry_APIParam_1 X509_NAME_add_entry_by_NID_APIParam_1 X509_NAME_delete_entry_APIParam_1 X509_NAME_add_entry_by_OBJ_APIParam_1 as a single valued RelativeDistinguishedName (RDN)
X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 actually determines the index where the new entry is inserted: if the new entry is -1 the new entry is appended
X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 determines how the new type is added
If it is zero ,a new RDN is created
If X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 is -1 or 1 it is added to the previous or next RDN structure respectively
This will then be a multivalued RDN: since multivalues RDNs are very seldom used X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 is almost always set to zero
X509_NAME_add_entry_by_txt_APIName, X509_NAME_add_entry_by_OBJ_APIName, X509_NAME_add_entry_by_NID_APIName and X509_NAME_add_entry_APIName return 1 for success of 0 if an error occurred
X509_NAME_delete_entry_APIName returns either the deleted X509_NAME_delete_entry_APIParam_0 structure of NULL if an error occurred
RAND_egd_APIName queries the entropy gathering daemon EGD on socket RAND_egd_APIParam_1
RAND_egd_APIName queries 255 bytes and uses RAND_add_APIName to seed the OpenSSL built-in PRNG
RAND_egd(path) is a wrapper for RAND_egd_bytes(path, 255);
RAND_egd_bytes_APIName queries the entropy gathering daemon EGD on socket RAND_egd_bytes_APIParam_1 RAND_egd_APIParam_1
RAND_egd_bytes_APIName queries RAND_egd_bytes_APIParam_2 bytes and uses RAND_add_APIName to seed the OpenSSL built-in PRNG
This function is more flexible than RAND_egd_APIName
When only one secret key must be generated, only one secret key is not necessary to request the full amount 255 bytes from the EGD socket
This can be advantageous, since the amount of entropy that can be retrieved from EGD over time is limited
RAND_query_egd_bytes_APIName performs the actual query of the EGD daemon on socket RAND_query_egd_bytes_APIParam_1
If RAND_query_egd_bytes_APIParam_2 is given, RAND_query_egd_bytes_APIParam_3 bytes are queried and written into RAND_query_egd_bytes_APIParam_2
If RAND_query_egd_bytes_APIParam_2 is NULL, RAND_query_egd_bytes_APIParam_3 bytes are queried and used to seed the OpenSSL built-in PRNG using RAND_add_APIName
On systems without /dev/*random devices providing entropy from the kernel, the EGD entropy gathering daemon can be used to collect entropy
the EGD entropy gathering daemon provides a socket interface through which entropy can be gathered in chunks up to 255 bytes
Several chunks can be queried during one connection
Alternatively, the EGD-interface compatible daemon PRNGD can be used
It is available from http://prngd.sourceforge.net/
PRNGD does employ an internal PRNG itself and can therefore never run out of entropy
OpenSSL automatically queries EGD when entropy is requested via RAND_bytes_APIName or the status is checked via RAND_status_APIName for the first time, if the socket is located at /var/run/egd-pool, /dev/egd-pool or /etc/egd-pool
RAND_egd_APIName and RAND_egd_bytes_APIName return the number of bytes read from the daemon on success, and -1 if the connection failed or the daemon did not return enough data to fully seed the PRNG
RAND_query_egd_bytes_APIName returns the number of bytes read from the daemon on success, and -1 if the connection failed
The PRNG state is not considered
SSL_set_connect_state_APIName sets SSL_set_connect_state_APIParam_1 to work in client mode
SSL_set_accept_state_APIName sets SSL_set_accept_state_APIParam_1 to work in server mode
When the SSL_CTX object was created with SSL_CTX_new_APIName , it was either assigned a dedicated client method, a dedicated server method, or a generic method, that can be used for both client and server connections
(The method might have been changed with SSL_CTX_set_ssl_version_APIName or SSL_set_ssl_method_APIName.)
When beginning a new handshake, the SSL engine must know whether it must call the connect (client) or accept (server) routines
Even though it may be clear from the method chosen, whether client or server mode was requested, the handshake routines must be explicitly set
When using the SSL_connect_APIName or SSL_accept_APIName routines, the correct handshake routines are automatically set
When performing a transparent negotiation using SSL_write_APIName or SSL_read_APIName , the handshake routines must be explicitly set in advance using either SSL_set_connect_state_APIName or SSL_set_accept_state_APIName
SSL_set_connect_state_APIName and SSL_set_accept_state_APIName do not return diagnostic information
In both cases the extension type must not be handled by OpenSSL internally or an error occurs
SSL_extension_supported_APIName returns 1 if the extension SSL_extension_supported_APIParam_1 is handled internally by OpenSSL and 0 otherwise
SSL_CTX_add_client_custom_ext_APIName and SSL_CTX_add_server_custom_ext_APIName return 1 for success and 0 for failure
A failure can occur if an attempt is made to add the same SSL_CTX_add_client_custom_ext_APIParam_2 SSL_CTX_add_server_custom_ext_APIParam_2 more than once, if an attempt is made to use an extension type handled internally by OpenSSL or if an internal error occurs (for example a memory allocation failure)
SSL_extension_supported_APIName returns 1 if the extension SSL_extension_supported_APIParam_1 is handled internally by OpenSSL and 0 otherwise
SSL_SESSION_get_time_APIName returns the time at which the session SSL_SESSION_get_time_APIParam_1 was established
The time is given in seconds since the Epoch and therefore compatible to the time delivered by the time_APIName call
SSL_SESSION_set_time_APIName replaces the creation time of the session SSL_SESSION_set_time_APIParam_1 with the chosen value SSL_SESSION_set_time_APIParam_2
SSL_SESSION_get_timeout_APIName returns the timeout value set for session SSL_SESSION_get_timeout_APIParam_1 in seconds
SSL_SESSION_set_timeout_APIName sets the timeout value for session SSL_SESSION_set_timeout_APIParam_1 in seconds to SSL_SESSION_set_timeout_APIParam_2
The SSL_get_time_APIName, SSL_set_time_APIName, SSL_get_timeout_APIName, and SSL_set_timeout_APIName functions are synonyms for the SSL_SESSION_*_APIName counterparts
Sessions are expired by examining the creation time and the timeout value
Both are set at creation time of the session to the actual time and the default timeout value at creation, respectively, as set by SSL_CTX_set_timeout_APIName
Using these functions it is possible to extend or shorten the lifetime of the session
SSL_SESSION_get_time_APIName and SSL_SESSION_get_timeout_APIName return the currently valid values
SSL_SESSION_set_time_APIName and SSL_SESSION_set_timeout_APIName return 1 on success
If any of the function is passed the NULL pointer for the session SSL_set_time_APIParam_1 SSL_SESSION_set_timeout_APIParam_1 SSL_SESSION_get_time_APIParam_1 SSL_SESSION_set_time_APIParam_1 SSL_set_timeout_APIParam_1 SSL_SESSION_get_timeout_APIParam_1 SSL_get_time_APIParam_1 SSL_get_timeout_APIParam_1, 0 is returned
BN_num_bytes_APIName returns the size of a BN_num_bytes_APIParam_1 in bytes
BN_num_bits_APIName returns the number of significant bits in a BN_num_bits_APIParam_1, following the same principle as BN_num_bits_word_APIName
BN_num_bytes_APIName is a macro
BIO_s_mem_APIName return the memory BIO method function
A memory BIO is a source/sink BIO which uses memory for its I/O
Data written to a memory BIO is stored in a BUF_MEM structure which is extended as appropriate to accommodate the stored data
Any data written to a memory BIO can be recalled by reading from it
Unless the memory BIO is read only any data read from it is deleted from the BIO
Memory BIOs support BIO_gets_APIName and BIO_puts_APIName
If the BIO_CLOSE flag is set when a memory BIO is freed ,then the underlying BUF_MEM structure is also freed
Calling BIO_reset_APIName on a read write memory BIO clears any data in it
On a read only BIO it restores the BIO to its original state and the read only data can be read again
BIO_eof_APIName is true if no data is in the BIO
BIO_ctrl_pending_APIName returns the number of bytes currently stored
BIO_set_mem_eof_return_APIName sets the behaviour of memory BIO BIO_set_mem_eof_return_APIParam_1 when it is empty
If the BIO_set_mem_eof_return_APIParam_2 is zero then an empty memory BIO will return EOF (that is it will return zero and BIO_should_retry(b) will be false
If BIO_set_mem_eof_return_APIParam_2 is non zero then it will return BIO_set_mem_eof_return_APIParam_2 when it is empty and it will set the read retry flag (that is BIO_read_retry(b) is true)
To avoid ambiguity with a normal positive return value BIO_set_mem_eof_return_APIParam_2 should be set to a negative value, typically -1
BIO_get_mem_data_APIName sets *BIO_get_mem_data_APIParam_2 to a pointer to the start of the memory BIOs data and returns the total amount of data available
It is implemented as a macro
BIO_set_mem_buf_APIName sets the internal BUF_MEM structure to BIO_set_mem_buf_APIParam_2 and sets the close flag to BIO_set_mem_buf_APIParam_3, that is BIO_set_mem_buf_APIParam_3 should be either BIO_CLOSE or BIO_NOCLOSE
It is a macro
BIO_get_mem_ptr_APIName places the underlying BUF_MEM structure in *BIO_get_mem_ptr_APIParam_2
It is a macro
Writes to memory BIOs will always succeed if memory is available: that is their size can grow indefinitely
Every read from a read write memory BIO will remove the data just read with an internal copy operation, if a BIO contains a lot of data and it is read in small chunks ,the operation can be very slow
The use of a read only memory BIO avoids this problem
If the BIO must be read write then adding a buffering BIO to the chain will speed up the process
There should be an option to set the maximum size of a memory BIO
There should be a way to "rewind" a read write BIO without destroying BIO contents
The copying operation should not occur after every small read of a large BIO to improve efficiency
SSL_CTX_sess_set_new_cb_APIName sets the callback function, which is automatically called whenever a new session was negotiated
SSL_CTX_sess_set_remove_cb_APIName sets the callback function, which is automatically called whenever a session is removed by the SSL engine, because it is considered faulty or the session has become obsolete because of exceeding the timeout value
SSL_CTX_sess_set_get_cb_APIName sets the callback function which is called, whenever a SSL/TLS client proposed to resume a session but the session could not be found in the internal session cache (see SSL_CTX_set_session_cache_mode_APIName )
(SSL/TLS server only.)
SSL_CTX_sess_get_new_cb_APIName, SSL_CTX_sess_get_remove_cb_APIName, and SSL_CTX_sess_get_get_cb_APIName allow to retrieve the function pointers of the provided callback functions
If a callback function has not been set, the NULL pointer is returned
In order to allow external session caching, synchronization with the internal session cache is realized via callback functions
Inside these callback functions, session can be saved to disk or put into a database using the d2i_SSL_SESSION_APIName interface
SSL_set_bio_APIName connects the BIOs SSL_set_bio_APIParam_2 and SSL_set_bio_APIParam_3 for the read and write operations of the TLS/SSL (encrypted) side of SSL_set_bio_APIParam_1
The SSL engine inherits the behaviour of SSL_set_bio_APIParam_2 and SSL_set_bio_APIParam_3, respectively
If a BIO is non-blocking, the SSL_set_bio_APIParam_1 will also have non-blocking behaviour
If there was already a BIO connected to SSL_set_bio_APIParam_1, BIO_free_APIName will be called (for both the reading and writing side, if different)
SSL_set_bio_APIName cannot fail
SSL_get_fd_APIName returns the file descriptor which is linked to SSL_get_fd_APIParam_1 SSL_get_rfd_APIParam_1 SSL_get_wfd_APIParam_1 SSL_get_fd_APIParam_1
SSL_get_rfd_APIName and SSL_get_wfd_APIName return the file descriptors for the read or the write channel, which can be different
If the read and the write channel are different, SSL_get_fd_APIName will return the file descriptor of the read channel
The following return values can occur:
The operation failed, because the underlying BIO is not of the correct type (suitable for file descriptors)
The file descriptor linked to SSL_get_fd_APIParam_1 SSL_get_rfd_APIParam_1 SSL_get_wfd_APIParam_1
A X.509 certificate is a structured grouping of information about an individual, a device, or anything one can imagine
A X.509 CRL (certificate revocation list) is a tool to help determine if a certificate is still valid
The exact definition of those can be found in the X.509 document from ITU-T, or in RFC3280 from PKIX
In OpenSSL, the type X509 is used to express such a certificate, and the type X509_CRL is used to express a CRL
A related structure is a certificate request, defined in PKCS#10 from RSA Security, Inc, also reflected in RFC2896
In OpenSSL, the type X509_REQ is used to express such a certificate request
To handle some complex parts of a certificate, there are the types X509_NAME (to express a certificate name), X509_ATTRIBUTE (to express a certificate attributes), X509_EXTENSION (to express a certificate extension) and a few more
Finally, there's the supertype X509_INFO, which can contain a CRL, a certificate and a corresponding private key
d2i_RSAPublicKey_APIName and i2d_RSAPublicKey_APIName decode and encode a PKCS#1 RSAPublicKey structure
d2i_RSA_PUBKEY_APIName and i2d_RSA_PUBKEY_APIName decode and encode an RSA public key using a SubjectPublicKeyInfo (certificate public key) structure
d2i_RSAPrivateKey_APIName, i2d_RSAPrivateKey_APIName decode and encode a PKCS#1 RSAPrivateKey structure
d2i_Netscape_RSA_APIName, i2d_Netscape_RSA_APIName decode and encode an RSA private key in NET format
The usage of all of these functions is similar to the d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
The i2d_RSAPrivateKey_APIParam_1 i2d_RSA_PUBKEY_APIParam_1 d2i_RSAPublicKey_APIParam_1 d2i_RSAPrivateKey_APIParam_1 d2i_RSA_PUBKEY_APIParam_1 i2d_RSAPublicKey_APIParam_1 structure passed to the private key encoding functions should have all the PKCS#1 private key components present
The data encoded by the private key functions is unencrypted and therefore offers no private key security
The NET format functions are present to provide compatibility with certain very old software
This format has some severe security weaknesses and should be avoided if possible
RSA_public_encrypt_APIName encrypts the RSA_public_encrypt_APIParam_1 bytes at RSA_public_encrypt_APIParam_2 (usually a session key) using the public key RSA_public_encrypt_APIParam_4 and stores the ciphertext in RSA_public_encrypt_APIParam_3
RSA_public_encrypt_APIParam_3 must point to RSA_size(RSA_public_encrypt_APIParam_4) bytes of memory
RSA_private_decrypt_APIParam_5 RSA_public_encrypt_APIParam_5 denotes one of the following modes:
PKCS #1 v1.5 padding
This currently is the most widely used mode
EME-OAEP as defined in PKCS #1 v2.0 with SHA-1, MGF1 and an empty encoding parameter
This mode is recommended for all new applications
PKCS #1 v1.5 padding with an SSL-specific modification that denotes that the server is SSL3 capable
RSA_public_encrypt_APIParam_1 must be less than RSA_size(RSA_public_encrypt_APIParam_4) - 11 for the PKCS #1 v1.5 based padding modes, less than RSA_size(RSA_public_encrypt_APIParam_4) - 41 for RSA_PKCS1_OAEP_PADDING and exactly RSA_size(RSA_public_encrypt_APIParam_4) for RSA_NO_PADDING
The random number generator must be seeded prior to calling RSA_public_encrypt_APIName
RSA_private_decrypt_APIName decrypts the RSA_private_decrypt_APIParam_1 bytes at RSA_private_decrypt_APIParam_2 using the private key RSA_private_decrypt_APIParam_4 and stores the plaintext in RSA_private_decrypt_APIParam_3
RSA_private_decrypt_APIParam_3 must point to a memory section large enough to hold the decrypted data (which is smaller than RSA_size(RSA_private_decrypt_APIParam_4))
RSA_private_decrypt_APIParam_5 is the padding mode that was used to encrypt the data
RSA_public_encrypt_APIName returns the size of the encrypted data (ie, RSA_size(RSA_public_encrypt_APIParam_4 RSA_private_decrypt_APIParam_4))
RSA_private_decrypt_APIName returns the size of the recovered plaintext
On error, -1 is returned; the error codes can be obtained by ERR_get_error_APIName
Decryption failures in the RSA_PKCS1_PADDING mode leak information which can potentially be used to mount a Bleichenbacher padding oracle attack
This is an inherent weakness in the PKCS #1 v1.5 padding design
The function SSL_CONF_CTX_new_APIName allocates and initialises an SSL_CONF_CTX_new_APIParam_0 structure for use with the SSL_CONF functions
The function SSL_CONF_CTX_free_APIName frees up the context SSL_CONF_CTX_free_APIParam_1
SSL_CONF_CTX_new_APIName returns either the newly allocated SSL_CONF_CTX_new_APIParam_0 structure or NULL if an error occurs
SSL_CONF_CTX_free_APIName does not return a value
Since error queue data structures are allocated automatically for new threads, they must be freed when threads are terminated in order to avoid memory leaks
ERR_remove_thread_state and ERR_remove_state_APIName return no value
SSL_get_SSL_CTX_APIName returns a pointer to the SSL_CTX object, from which SSL_get_SSL_CTX_APIParam_1 was created with SSL_new_APIName
The pointer to the SSL_CTX object is returned
SSL_set_fd_APIName sets the file descriptor SSL_set_fd_APIParam_2 as the input/output facility for the TLS/SSL (encrypted) side of SSL_set_fd_APIParam_1
SSL_set_fd_APIParam_2 will typically be the socket file descriptor of a network connection
If there was already a BIO connected to SSL_set_fd_APIParam_1 SSL_set_rfd_APIParam_1 SSL_set_wfd_APIParam_1, BIO_free_APIName will be called (for both the reading and writing side, if different)
SSL_set_rfd_APIName and SSL_set_wfd_APIName perform the respective action, but only for the read channel or the write channel, which can be set independently
The following return values can occur:
The operation failed
Check the error stack to find out why
The operation succeeded
BN_rand_APIName generates a cryptographically strong pseudo-random number of BN_rand_APIParam_2 in length and stores it in BN_rand_APIParam_1
If BN_rand_APIParam_2 is less than zero, or too small to accomodate the requirements specified by the BN_rand_APIParam_3 and BN_rand_APIParam_4 parameters, an error is returned
If BN_rand_APIParam_3 is -1, the most significant bit of the random number can be zero
If BN_rand_APIParam_3 is 0, it is set to 1, and if BN_rand_APIParam_3 is 1, the two most significant bits of the number will be set to 1, so that the product of two such random numbers will always have 2*BN_rand_APIParam_2 length
If BN_rand_APIParam_4 is true, the number will be odd
The value of BN_rand_APIParam_2 must be zero or greater
If BN_rand_APIParam_2 is 1 then BN_rand_APIParam_3 cannot also be 1
BN_pseudo_rand_APIName does the same, but pseudo-random numbers generated by this function are not necessarily unpredictable
pseudo-random numbers generated by this function can be used for non-cryptographic purposes and for certain purposes in cryptographic protocols, but usually not for key generation etc
BN_rand_range_APIName generates a cryptographically strong pseudo-random number BN_rand_range_APIParam_1 BN_pseudo_rand_range_APIParam_1 BN_pseudo_rand_APIParam_1 in the range 0 <= BN_rand_range_APIParam_1 BN_pseudo_rand_range_APIParam_1 BN_pseudo_rand_APIParam_1 < BN_rand_range_APIParam_2 BN_pseudo_rand_range_APIParam_2
BN_pseudo_rand_range_APIName does the same, but is based on BN_pseudo_rand_APIName, and hence numbers generated by it are not necessarily unpredictable
The PRNG must be seeded prior to calling BN_rand_APIName or BN_rand_range_APIName
The functions return 1 on success, 0 on error
The error codes can be obtained by ERR_get_error_APIName
These functions generate the ASN1 encoding of a string in an ASN1_generate_v3_APIParam_0 ASN1_generate_nconf_APIParam_0 structure
ASN1_generate_v3_APIParam_1 ASN1_generate_nconf_APIParam_1 contains the string to encode ASN1_generate_nconf_APIParam_2 or ASN1_generate_v3_APIParam_2 contains the optional configuration information where additional strings will be read from
ASN1_generate_nconf_APIParam_2 will typically come from a config file wherease ASN1_generate_v3_APIParam_2 is obtained from an ASN1_generate_v3_APIParam_2 structure which will typically be used by X509 v3 certificate extension functions
ASN1_generate_v3_APIParam_2 or ASN1_generate_nconf_APIParam_2 can be set to NULL if no additional configuration will be used
ASN1_generate_nconf_APIName and ASN1_generate_v3_APIName return the encoded data as an ASN1_generate_nconf_APIParam_0 ASN1_generate_v3_APIParam_0 structure or NULL if an error occurred
The error codes that can be obtained by ERR_get_error_APIName
The DSA_sign_APIParam_1 DSA_verify_APIParam_1 parameter is ignored
The PRNG must be seeded before DSA_sign_APIName (or DSA_sign_setup_APIName) is called
DSA_sign_APIName and DSA_sign_setup_APIName return 1 on success, 0 on error
DSA_verify_APIName returns 1 for a valid signature, 0 for an incorrect signature and -1 on error
The error codes can be obtained by ERR_get_error_APIName
The EVP_PKEY_CTX_new_APIName function allocates public key algorithm context using the algorithm specified in EVP_PKEY_CTX_new_APIParam_1 and ENGINE EVP_PKEY_CTX_new_APIParam_2
The EVP_PKEY_CTX_new_id_APIName function allocates public key algorithm context using the algorithm specified by EVP_PKEY_CTX_new_id_APIParam_1 and ENGINE EVP_PKEY_CTX_new_id_APIParam_2
The EVP_PKEY_CTX_new_id_APIName function is normally used when no EVP_PKEY_CTX_new_id_APIParam_0 structure is associated with the operations, for example during parameter generation of key genration for some algorithms
EVP_PKEY_CTX_dup_APIName duplicates the context EVP_PKEY_CTX_dup_APIParam_1
EVP_PKEY_CTX_free_APIName frees up the context EVP_PKEY_CTX_free_APIParam_1
EVP_PKEY_CTX_new_APIName, EVP_PKEY_CTX_new_id_APIName, EVP_PKEY_CTX_dup_APIName returns either the newly allocated EVP_PKEY_CTX_dup_APIParam_1 structure of NULL if an error occurred
EVP_PKEY_CTX_free_APIName does not return a value
The function SSL_CONF_CTX_set1_prefix_APIName sets the command prefix of SSL_CONF_CTX_set1_prefix_APIParam_1 to SSL_CONF_CTX_set1_prefix_APIParam_2
If SSL_CONF_CTX_set1_prefix_APIParam_2 is NULL it is restored to the default value
Command prefixes alter the commands recognised by subsequent SSL_CTX_cmd_APIName calls
For example for files, if the prefix "SSL" is set ,then command names such as "SSLProtocol", "SSLOptions" etc are recognised instead of "Protocol" and "Options"
Similarly for command lines if the prefix is "--ssl-" then "--ssl-no_tls1_2" is recognised instead of "-no_tls1_2"
SSL_CONF_CTX_set1_prefix_APIName returns 1 for success and 0 for failure
BN_BLINDING_new_APIName allocates a new BN_BLINDING_new_APIParam_0 structure and copies the BN_BLINDING_new_APIParam_1 and BN_BLINDING_new_APIParam_2 values into the newly created BN_BLINDING_new_APIParam_0 object
BN_BLINDING_free_APIName frees the BN_BLINDING_free_APIParam_1 structure
BN_BLINDING_update_APIName updates the BN_BLINDING_update_APIParam_1 parameters by squaring the BN_BLINDING_new_APIParam_1 and BN_BLINDING_new_APIParam_2 or, after specific number of uses and if the necessary parameters are set, by re-creating the blinding parameters
BN_BLINDING_convert_APIName and BN_BLINDING_invert_APIName are wrapper functions for BN_BLINDING_convert_ex_APIName and BN_BLINDING_invert_ex_APIName with BN_BLINDING_convert_ex_APIParam_2 BN_BLINDING_invert_ex_APIParam_2 set to NULL
BN_BLINDING_thread_id_APIName provides access to the BN_BLINDING_thread_id_APIParam_0 object within the BN_BLINDING_thread_id_APIParam_1 structure
This is to help users provide proper locking if needed for multi-threaded use
The "thread id" object of a newly allocated BN_BLINDING_thread_id_APIParam_1 structure is initialised to the thread id in which BN_BLINDING_new_APIName was called
BN_BLINDING_new_APIName returns the newly allocated BN_BLINDING_new_APIParam_0 structure or NULL in case of an error
BN_BLINDING_update_APIName, BN_BLINDING_convert_APIName, BN_BLINDING_invert_APIName, BN_BLINDING_convert_ex_APIName and BN_BLINDING_invert_ex_APIName return 1 on success and 0 if an error occurred
BN_BLINDING_thread_id_APIName returns a pointer to the thread id object within a BN_BLINDING_thread_id_APIParam_1 object
BN_BLINDING_get_flags_APIName returns the currently set BN_BLINDING_get_flags_APIParam_1 flags (a BN_BLINDING_get_flags_APIParam_0 value)
BN_BLINDING_create_param_APIName returns the newly created BN_BLINDING_create_param_APIParam_1 parameters or NULL on error
The EVP digest routines are a high level interface to message digests
EVP_MD_CTX_init_APIName initializes digest context EVP_MD_CTX_init_APIParam_1
EVP_MD_CTX_create_APIName allocates, initializes and returns a digest context
EVP_DigestInit_ex_APIName sets up digest context EVP_DigestInit_ex_APIParam_1 to use a digest EVP_DigestInit_ex_APIParam_2 from ENGINE EVP_DigestInit_ex_APIParam_3
EVP_DigestInit_ex_APIParam_1 must be initialized before calling this function
EVP_DigestInit_ex_APIParam_2 will typically be supplied by a functionsuch as EVP_sha1_APIName
If EVP_DigestInit_ex_APIParam_3 is NULL then the default implementation of digest EVP_DigestInit_ex_APIParam_2 is used
EVP_DigestUpdate_APIName hashes EVP_DigestUpdate_APIParam_3 bytes of data at EVP_DigestUpdate_APIParam_2 into the digest context EVP_DigestUpdate_APIParam_1
This function can be called several times on the same EVP_DigestUpdate_APIParam_1 to hash additional data
EVP_MD_CTX_cleanup_APIName cleans up digest context EVP_MD_CTX_cleanup_APIParam_1, EVP_MD_CTX_cleanup_APIName should be called after a digest context is no longer needed
EVP_MD_CTX_destroy_APIName cleans up digest context EVP_MD_CTX_destroy_APIParam_1 and frees up the space allocated to EVP_MD_CTX_destroy_APIName, EVP_MD_CTX_destroy_APIName should be called only on a context created using EVP_MD_CTX_create_APIName
EVP_MD_CTX_copy_ex_APIName can be used to copy the message digest state from EVP_MD_CTX_copy_ex_APIParam_2 to EVP_MD_CTX_copy_ex_APIParam_1
This is useful if large amounts of data are to be hashed which only differ in the last few bytes
EVP_MD_CTX_copy_ex_APIParam_1 must be initialized before calling this function
EVP_DigestInit_APIName behaves in the same way as EVP_DigestInit_ex_APIName except the passed context EVP_DigestInit_APIParam_1 EVP_DigestInit_ex_APIParam_1 does not have to be initialized, and it always uses the default digest implementation
EVP_DigestFinal_APIName is similar to EVP_DigestFinal_ex_APIName except the digest context EVP_DigestFinal_APIParam_1 EVP_DigestFinal_ex_APIParam_1 is automatically cleaned up
EVP_MD_CTX_copy_APIName is similar to EVP_MD_CTX_copy_ex_APIName except the destination EVP_MD_CTX_copy_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 does not have to be initialized
EVP_MD_size_APIName and EVP_MD_CTX_size_APIName return the size of the message digest when passed an EVP_MD_size_APIParam_1 or an EVP_MD_CTX_destroy_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_md_APIParam_1 EVP_DigestInit_ex_APIParam_1 EVP_MD_CTX_copy_APIParam_1 EVP_MD_CTX_cleanup_APIParam_1 structure, ie the size of the hash
EVP_MD_block_size_APIName and EVP_MD_CTX_block_size_APIName return the block size of the message digest when passed an EVP_MD_block_size_APIParam_1 or an EVP_MD_CTX_destroy_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_md_APIParam_1 EVP_DigestInit_ex_APIParam_1 EVP_MD_CTX_copy_APIParam_1 EVP_MD_CTX_cleanup_APIParam_1 structure
EVP_MD_CTX_md_APIName returns the EVP_MD_CTX_md_APIParam_1 structure corresponding to the passed EVP_MD_CTX_md_APIParam_1
EVP_md2_APIName, EVP_md5_APIName, EVP_sha_APIName, EVP_sha1_APIName, EVP_sha224_APIName, EVP_sha256_APIName, EVP_sha384_APIName, EVP_sha512_APIName, EVP_mdc2_APIName and EVP_ripemd160_APIName return EVP_md2_APIParam_0 EVP_md5_APIParam_0 EVP_sha_APIParam_0 EVP_sha1_APIParam_0 EVP_sha224_APIParam_0 EVP_sha256_APIParam_0 EVP_sha384_APIParam_0 EVP_sha512_APIParam_0 EVP_mdc2_APIParam_0 EVP_ripemd160_APIParam_0 structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 and RIPEMD160 digest algorithms respectively
EVP_dss_APIName and EVP_dss1_APIName return EVP_dss_APIParam_0 EVP_dss1_APIParam_0 structures for SHA and SHA1 digest algorithms but using DSS (DSA) for the signature algorithm
Note: there is no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are however retained for compatibility
EVP_md_null_APIName is a "null" message digest that does nothing: ie the hash it returns is of zero length
EVP_get_digestbyname_APIName, EVP_get_digestbynid_APIName and EVP_get_digestbyobj_APIName return an EVP_get_digestbyname_APIParam_0 structure when passed a digest name, a digest NID or an ASN1_OBJECT structure respectively
The digest table must be initialized using, for example, OpenSSL_add_all_digests_APIName for these functions to work
EVP_DigestInit_ex_APIName, EVP_DigestUpdate_APIName and EVP_DigestFinal_ex_APIName return 1 for success and 0 for failure
EVP_MD_CTX_copy_ex_APIName returns 1 if successful or 0 for failure
EVP_MD_type_APIName, EVP_MD_pkey_type_APIName and EVP_MD_type_APIName return the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none exists
EVP_MD_size_APIName, EVP_MD_block_size_APIName, EVP_MD_CTX_size_APIName and EVP_MD_CTX_block_size_APIName return the digest or block size in bytes
EVP_md_null_APIName, EVP_md2_APIName, EVP_md5_APIName, EVP_sha_APIName, EVP_sha1_APIName, EVP_dss_APIName, EVP_dss1_APIName, EVP_mdc2_APIName and EVP_ripemd160_APIName return pointers to the corresponding EVP_MD structures
EVP_get_digestbyname_APIName, EVP_get_digestbynid_APIName and EVP_get_digestbyobj_APIName return either an EVP_get_digestbyname_APIParam_0 structure or NULL if an error occurs
The EVP_MD_CTX_destroy_APIParam_1 EVP_MD_block_size_APIParam_1 EVP_MD_size_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_md_APIParam_1 EVP_DigestInit_ex_APIParam_1 EVP_MD_pkey_type_APIParam_1 EVP_MD_CTX_copy_APIParam_1 EVP_MD_CTX_cleanup_APIParam_1 EVP_MD_type_APIParam_1 interface to message digests should almost always be used in preference to the low level interfaces
This is because the code then becomes transparent to the digest used and much more flexible
New applications should use the SHA2 digest algorithms such as SHA256
The other digest algorithms are still in common use
For most applications the EVP_DigestInit_ex_APIParam_3 parameter to EVP_DigestInit_ex_APIName will be set to NULL to use the default digest implementation
The functions EVP_DigestInit_APIName, EVP_DigestFinal_APIName and EVP_MD_CTX_copy_APIName are obsolete but are retained to maintain compatibility with existing code
New applications should use EVP_DigestInit_ex_APIName, EVP_DigestFinal_ex_APIName and EVP_MD_CTX_copy_ex_APIName because they can efficiently reuse a digest context instead of initializing and cleaning it up on each call and allow non default implementations of digests to be specified
In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use memory leaks will occur
Stack allocation of EVP_MD_CTX structures is common, for example:
This will cause binary compatibility issues if the size of EVP_MD_CTX structure changes (this will only happen with a major release of OpenSSL)
Applications wishing to avoid this should use EVP_MD_CTX_create_APIName instead:
SSL_alert_type_string_APIName returns a one letter string indicating the type of the alert specified by SSL_alert_type_string_APIParam_1
SSL_alert_type_string_long_APIName returns a string indicating the type of the alert specified by SSL_alert_type_string_long_APIParam_1
SSL_alert_desc_string_APIName returns a two letter string as a short form describing the reason of the alert specified by SSL_alert_desc_string_APIParam_1
SSL_alert_desc_string_long_APIName returns a string describing the reason of the alert specified by SSL_alert_desc_string_long_APIParam_1
When one side of an SSL/TLS communication wants to inform the peer about a special situation, it sends an alert
The alert is sent as a special message and does not influence the normal data stream (unless its contents results in the communication being canceled)
A warning alert is sent, when a non-fatal error condition occurs
The "close notify" alert is sent as a warning alert
Other examples for non-fatal errors are certificate errors ("certificate expired", "unsupported certificate"), for which a warning alert may be sent
(The sending party may however decide to send a fatal error.)
The receiving side may cancel the connection on reception of a warning alert on it discretion
Several alert messages must be sent as fatal alert messages as specified by the TLS RFC
A fatal alert always leads to a connection abort
The following strings can occur for SSL_alert_type_string_APIName or SSL_alert_type_string_long_APIName:
This indicates that no support is available for this alert type
Probably SSL_alert_type_string_APIParam_1 SSL_alert_desc_string_APIParam_1 SSL_alert_desc_string_long_APIParam_1 SSL_alert_type_string_long_APIParam_1 does not contain a correct alert message
The following strings can occur for SSL_alert_desc_string_APIName or SSL_alert_desc_string_long_APIName:
The connection shall be closed
This is a warning alert
An inappropriate message was received
This alert is always fatal and should never be observed in communication between proper implementations
This alert is returned if a record is received with an incorrect MAC
This message is always fatal
The decompression function received improper input (eg data that would expand to excessive length)
This message is always fatal
Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available
This is a fatal error
A client, that was asked to send a certificate, does not send a certificate (SSLv3 only)
A certificate was corrupt, contained signatures that did not verify correctly, etc
A certificate was of an unsupported type
A certificate was revoked by A certificate signer
A certificate has expired or is not currently valid
Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable
A field in the handshake was out of range or inconsistent with other fields
This is always fatal
A TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length or its padding values, when checked, weren't correct
This message is always fatal
A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes
This message is always fatal
A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA
This message is always fatal
A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation
This message is always fatal
A message could not be decoded because some field was out of the specified range or the length of the message was incorrect
This message is always fatal
A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message
A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method
This message is always fatal
The protocol version the client has attempted to negotiate is recognized, but not supported
(For example, old protocol versions might be avoided for security reasons)
This message is always fatal
Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client
This message is always fatal
An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure)
This message is always fatal
This handshake is being canceled for some reason unrelated to a protocol failure
If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate
This alert should be followed by a close_notify
This message is generally a warning
Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking
Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection
One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc) at startup and it might be difficult to communicate changes to these parameters after that point
This message is always a warning
Sent by the server to indicate that the server does not recognize a PSK identity or an SRP identity
This indicates that no description is available for this alert type
Probably SSL_alert_type_string_APIParam_1 SSL_alert_desc_string_APIParam_1 SSL_alert_desc_string_long_APIParam_1 SSL_alert_type_string_long_APIParam_1 does not contain a correct alert message
These functions decode and encode an ASN1 OBJECT IDENTIFIER
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
These functions create, manipulate, and use cryptographic modules in the form of ENGINE_set_default_DH_APIParam_1 ENGINE_set_ECDSA_APIParam_1 ENGINE_set_default_APIParam_1 ENGINE_set_default_string_APIParam_1 ENGINE_get_ciphers_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_1 ENGINE_unregister_ECDSA_APIParam_1 ENGINE_get_flags_APIParam_1 ENGINE_get_prev_APIParam_1 ENGINE_register_STORE_APIParam_1 ENGINE_remove_APIParam_1 ENGINE_get_finish_function_APIParam_1 ENGINE_set_flags_APIParam_1 ENGINE_add_APIParam_1 ENGINE_up_ref_APIParam_1 ENGINE_set_ex_data_APIParam_1 ENGINE_register_RAND_APIParam_1 ENGINE_load_public_key_APIParam_1 ENGINE_set_init_function_APIParam_1 ENGINE_set_default_RAND_APIParam_1 ENGINE_get_DSA_APIParam_1 ENGINE_set_ECDH_APIParam_1 ENGINE_register_DSA_APIParam_1 ENGINE_set_default_DSA_APIParam_1 ENGINE_get_ex_data_APIParam_1 ENGINE_unregister_DH_APIParam_1 ENGINE_ctrl_cmd_APIParam_1 ENGINE_unregister_RAND_APIParam_1 ENGINE_set_ciphers_APIParam_1 ENGINE_set_DH_APIParam_1 ENGINE_finish_APIParam_1 ENGINE_set_id_APIParam_1 ENGINE_set_default_RSA_APIParam_1 ENGINE_register_ECDSA_APIParam_1 ENGINE_get_STORE_APIParam_1 ENGINE_set_default_ciphers_APIParam_1 ENGINE_set_destroy_function_APIParam_1 ENGINE_load_private_key_APIParam_1 ENGINE_get_ctrl_function_APIParam_1 ENGINE_get_load_privkey_function_APIParam_1 ENGINE_set_name_APIParam_1 ENGINE_get_next_APIParam_1 ENGINE_get_ECDSA_APIParam_1 ENGINE_get_id_APIParam_1 ENGINE_cmd_is_executable_APIParam_1 ENGINE_register_digests_APIParam_1 ENGINE_init_APIParam_1 ENGINE_unregister_ciphers_APIParam_1 ENGINE_unregister_DSA_APIParam_1 ENGINE_set_RSA_APIParam_1 ENGINE_get_cipher_APIParam_1 ENGINE_register_ECDH_APIParam_1 ENGINE_register_DH_APIParam_1 ENGINE_get_ECDH_APIParam_1 ENGINE_get_destroy_function_APIParam_1 ENGINE_register_ciphers_APIParam_1 ENGINE_get_RSA_APIParam_1 ENGINE_set_RAND_APIParam_1 ENGINE_unregister_STORE_APIParam_1 ENGINE_get_name_APIParam_1 ENGINE_set_default_ECDH_APIParam_1 ENGINE_get_DH_APIParam_1 ENGINE_set_DSA_APIParam_1 ENGINE_unregister_ECDH_APIParam_1 ENGINE_register_RSA_APIParam_1 ENGINE_unregister_RSA_APIParam_1 ENGINE_free_APIParam_1 ENGINE_unregister_digests_APIParam_1 ENGINE_set_STORE_APIParam_1 ENGINE_register_complete_APIParam_1 ENGINE_set_default_digests_APIParam_1 ENGINE_set_default_ECDSA_APIParam_1 ENGINE_set_load_privkey_function_APIParam_1 ENGINE_set_cmd_defns_APIParam_1 ENGINE_ctrl_cmd_string_APIParam_1 ENGINE_get_cmd_defns_APIParam_1 ENGINE_set_finish_function_APIParam_1 ENGINE_get_init_function_APIParam_1 ENGINE_get_RAND_APIParam_1 ENGINE_get_digests_APIParam_1 ENGINE_set_digests_APIParam_1 ENGINE_set_load_pubkey_function_APIParam_1 ENGINE_get_digest_APIParam_1 ENGINE_set_ctrl_function_APIParam_1 objects
These objects act as containers for implementations of cryptographic algorithms, and support a reference-counted mechanism to allow them to be dynamically loaded in and out of the running application
The cryptographic functionality that can be provided by an ENGINE_set_default_DH_APIParam_1 ENGINE_set_ECDSA_APIParam_1 ENGINE_set_default_APIParam_1 ENGINE_set_default_string_APIParam_1 ENGINE_get_ciphers_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_1 ENGINE_unregister_ECDSA_APIParam_1 ENGINE_get_flags_APIParam_1 ENGINE_get_prev_APIParam_1 ENGINE_register_STORE_APIParam_1 ENGINE_remove_APIParam_1 ENGINE_get_finish_function_APIParam_1 ENGINE_set_flags_APIParam_1 ENGINE_add_APIParam_1 ENGINE_up_ref_APIParam_1 ENGINE_set_ex_data_APIParam_1 ENGINE_register_RAND_APIParam_1 ENGINE_load_public_key_APIParam_1 ENGINE_set_init_function_APIParam_1 ENGINE_set_default_RAND_APIParam_1 ENGINE_get_DSA_APIParam_1 ENGINE_set_ECDH_APIParam_1 ENGINE_register_DSA_APIParam_1 ENGINE_set_default_DSA_APIParam_1 ENGINE_get_ex_data_APIParam_1 ENGINE_unregister_DH_APIParam_1 ENGINE_ctrl_cmd_APIParam_1 ENGINE_unregister_RAND_APIParam_1 ENGINE_set_ciphers_APIParam_1 ENGINE_set_DH_APIParam_1 ENGINE_finish_APIParam_1 ENGINE_set_id_APIParam_1 ENGINE_set_default_RSA_APIParam_1 ENGINE_register_ECDSA_APIParam_1 ENGINE_get_STORE_APIParam_1 ENGINE_set_default_ciphers_APIParam_1 ENGINE_set_destroy_function_APIParam_1 ENGINE_load_private_key_APIParam_1 ENGINE_get_ctrl_function_APIParam_1 ENGINE_get_load_privkey_function_APIParam_1 ENGINE_set_name_APIParam_1 ENGINE_get_next_APIParam_1 ENGINE_get_ECDSA_APIParam_1 ENGINE_get_id_APIParam_1 ENGINE_cmd_is_executable_APIParam_1 ENGINE_register_digests_APIParam_1 ENGINE_init_APIParam_1 ENGINE_unregister_ciphers_APIParam_1 ENGINE_unregister_DSA_APIParam_1 ENGINE_set_RSA_APIParam_1 ENGINE_get_cipher_APIParam_1 ENGINE_register_ECDH_APIParam_1 ENGINE_register_DH_APIParam_1 ENGINE_get_ECDH_APIParam_1 ENGINE_get_destroy_function_APIParam_1 ENGINE_register_ciphers_APIParam_1 ENGINE_get_RSA_APIParam_1 ENGINE_set_RAND_APIParam_1 ENGINE_unregister_STORE_APIParam_1 ENGINE_get_name_APIParam_1 ENGINE_set_default_ECDH_APIParam_1 ENGINE_get_DH_APIParam_1 ENGINE_set_DSA_APIParam_1 ENGINE_unregister_ECDH_APIParam_1 ENGINE_register_RSA_APIParam_1 ENGINE_unregister_RSA_APIParam_1 ENGINE_free_APIParam_1 ENGINE_unregister_digests_APIParam_1 ENGINE_set_STORE_APIParam_1 ENGINE_register_complete_APIParam_1 ENGINE_set_default_digests_APIParam_1 ENGINE_set_default_ECDSA_APIParam_1 ENGINE_set_load_privkey_function_APIParam_1 ENGINE_set_cmd_defns_APIParam_1 ENGINE_ctrl_cmd_string_APIParam_1 ENGINE_get_cmd_defns_APIParam_1 ENGINE_set_finish_function_APIParam_1 ENGINE_get_init_function_APIParam_1 ENGINE_get_RAND_APIParam_1 ENGINE_get_digests_APIParam_1 ENGINE_set_digests_APIParam_1 ENGINE_set_load_pubkey_function_APIParam_1 ENGINE_get_digest_APIParam_1 ENGINE_set_ctrl_function_APIParam_1 implementation includes the following abstractions;
Due to the modular nature of the ENGINE API, pointers to ENGINEs need to be treated as handles - ie not only as pointers, but also as references to the underlying ENGINE object
one should obtain a new reference when making copies of an ENGINE pointer if the copies will be used (and released) independently
This basic type of reference is used for instantiating new ENGINEs, iterating across OpenSSL's internal linked-list of loaded ENGINEs, reading information about an ENGINE, etc Essentially a structural reference is sufficient if you only need to query or manipulate the data of an ENGINE implementation rather than use an ENGINE implementation functionality
The ENGINE_new_APIName function returns a structural reference to a new (empty) ENGINE object
There are other ENGINE API functions that return structural references such as; ENGINE_by_id_APIName, ENGINE_get_first_APIName, ENGINE_get_last_APIName, ENGINE_get_next_APIName, ENGINE_get_prev_APIName
All structural references should be released by a corresponding to call to the ENGINE_free_APIName function
The ENGINE object itself will only actually be cleaned up and deallocated when the last structural reference is released
It should also be noted that many ENGINE API function calls that accept a structural reference will internally obtain another reference - typically this happens whenever the supplied ENGINE will be needed by OpenSSL after the function has returned
the function to add a new ENGINE to OpenSSL's internal list is ENGINE_add_APIName - if this function returns success, then OpenSSL will have stored a new structural reference internally so the caller is still responsible for freeing their own reference with ENGINE_free_APIName when they are finished with it
In a similar way, some functions will automatically release the structural reference passed to it if part of the function's job is to do so
the ENGINE_get_next_APIName and ENGINE_get_prev_APIName functions are used for iterating across the internal ENGINE list - they will return a new structural reference to the next (or previous) ENGINE in the list or NULL if at the end (or beginning) of the list, but in either case the structural reference passed to the function is released on behalf of the caller
To clarify a particular function's handling of references, one should always consult that function's documentation "man" page, or failing that the openssl/engine.h header file includes some hints
As mentioned, functional references exist when the cryptographic functionality of an ENGINE is required to be available
A functional reference can be obtained in one of two ways; from an existing structural reference to the required ENGINE, or by asking OpenSSL for the default operational ENGINE for a given cryptographic purpose
The second way to get a functional reference is by asking OpenSSL for a default implementation for a given task, eg by ENGINE_get_default_RSA_APIName, ENGINE_get_default_cipher_engine_APIName, etc These are discussed in the next section, though they are not usually required by application programmers as they are used automatically when creating and using the relevant algorithm-specific types in OpenSSL, such as RSA, DSA, EVP_CIPHER_CTX, etc
For each supported abstraction, the ENGINE code maintains an internal table of state to control which implementations are available for a given abstraction and which should be used by default
These implementations are registered in the tables and indexed by an 'nid' value, because abstractions like EVP_CIPHER and EVP_DIGEST support many distinct algorithms and modes, and ENGINEs can support arbitrarily many of them
In the case of other abstractions like RSA, DSA, etc, there is only one "algorithm" so all implementations implicitly register using the same 'nid' index
When a default ENGINE is requested for a given abstraction/algorithm/mode, (eg when calling RSA_new_method(NULL)), a "get_default" call will be made to the ENGINE subsystem to process the corresponding state table and return a functional reference to an initialised ENGINE whose implementation should be used
If no ENGINE should (or can) be used, it will return NULL and the caller will operate with a NULL ENGINE handle - this usually equates to using the conventional software implementation
In the latter case, OpenSSL will from then on behave the way it used to before the ENGINE API existed
Each state table has a flag to note whether it has processed this "get_default" query since the table was last modified, because to process this question it must iterate across all the registered ENGINEs in the table trying to initialise each of them in turn, in case one of them is operational
If it returns a functional reference to an ENGINE, it will also cache another reference to speed up processing future queries (without needing to iterate across the table)
Likewise, it will cache a NULL response if no ENGINE was available so that future queries won't repeat the same iteration unless the state table changes
This behaviour can also be changed; if the ENGINE_TABLE_FLAG_NOINIT flag is set (using ENGINE_set_table_flags_APIName), no attempted initialisations will take place, instead the only way for the state table to return a non-NULL ENGINE to the "get_default" query will be if one is expressly set in the table
ENGINE_set_default_RSA_APIName does the same job as ENGINE_register_RSA_APIName except that it also sets the state table's cached response for the "get_default" query
In the case of abstractions like EVP_CIPHER, where implementations are indexed by 'nid', these flags and cached-responses are distinct for each 'nid' value
This section will explain the basic things an application programmer should support to make the most useful elements of the ENGINE functionality available to the user
The first thing to consider is whether the programmer wishes to make alternative ENGINE modules available to the application and user
OpenSSL maintains an internal linked list of "visible" ENGINEs from which it has to operate - at start-up, this list is empty and in fact if an application does not call any ENGINE API calls and it uses static linking against openssl, then the resulting application binary will not contain any alternative ENGINE code at all
So the first consideration is whether any/all available ENGINE implementations should be made visible to OpenSSL - this is controlled by calling the various "load" functions, eg
Having called any of these functions, ENGINE objects would have been dynamically allocated and populated with these implementations and linked into OpenSSL's internal linked list
At this point it is important to mention an important API function;
If no ENGINE API functions are called at all in an application, then there are no inherent memory leaks to worry about from the ENGINE functionality, however if any ENGINEs are loaded, even if they are never registered or used, it is necessary to use the ENGINE_cleanup_APIName function to correspondingly cleanup before program exit, if the caller wishes to avoid memory leaks
This mechanism uses an internal callback registration table so that any ENGINE API functionality that knows it requires cleanup can register its cleanup details to be called during ENGINE_cleanup_APIName
This approach allows ENGINE_cleanup_APIName to clean up after any ENGINE functionality at all that your program uses, yet doesn't automatically create linker dependencies to all possible ENGINE functionality - only the cleanup callbacks required by the functionality you do use will be required by the linker
The fact that ENGINEs are made visible to OpenSSL (and thus are linked into the program and loaded into memory at run-time) does not mean they are "registered" or called into use by OpenSSL automatically - that behaviour is something for the application to control
Some applications will want to allow the user to specify exactly which ENGINE they want used if any is to be used at all
Others may prefer to load all support and have OpenSSL automatically use at run-time any ENGINE that is able to successfully initialise - ie to assume that this corresponds to acceleration hardware attached to the machine or some such thing
There are probably numerous other ways in which applications may prefer to handle things, so we will simply illustrate the consequences as they apply to a couple of simple cases and leave developers to consider these and the source code to openssl's builtin utilities as guides
Here we'll assume an application has been configured by its user or admin to want to use the "ACME" ENGINE if it is available in the version of OpenSSL the application was compiled with
If it is available, it should be used by default for all RSA, DSA, and symmetric cipher operations, otherwise OpenSSL should use its builtin software as per usual
The following code illustrates how to approach this;
Here we'll assume we want to load and register all ENGINE implementations bundled with OpenSSL, such that for any cryptographic algorithm required by OpenSSL - if there is an ENGINE that implements it and can be initialised, it should be used
The following code illustrates how this can work;
That's all that's required
the next time OpenSSL tries to set up an RSA key, any bundled ENGINEs that implement RSA_METHOD will be passed to ENGINE_init_APIName and if any of those succeed, that ENGINE will be set as the default for RSA use from then on
There is a mechanism supported by the ENGINE framework that allows each ENGINE implementation to define an arbitrary set of configuration "commands" and expose them to OpenSSL and any applications based on OpenSSL
This mechanism is entirely based on the use of name-value pairs and assumes ASCII input (no unicode or UTF for now!
), so it is ideal if applications want to provide a transparent way for users to provide arbitrary configuration "directives" directly to such ENGINEs
It is also possible for the application to dynamically interrogate the loaded ENGINE implementations for the names, descriptions, and input flags of their available "control commands", providing a more flexible configuration scheme
However, if the user is expected to know which ENGINE device he/she is using (in the case of specialised hardware, this goes without saying) then applications may not need to concern themselves with discovering the supported control commands and simply prefer to pass settings into ENGINEs exactly as they are provided by the user
Let's illustrate by example; a function for which the caller supplies the name of the ENGINE it wishes to use, a table of string-pairs for use before initialisation, and another table for use after initialisation
Note that the string-pairs used for control commands consist of a command "name" followed by the command "parameter" - the parameter could be NULL in some cases but the name can not
This function should initialise the ENGINE (issuing the "pre" commands beforehand and the "post" commands afterwards) and set it as the default for everything except RAND and then return a boolean success or failure
Note that ENGINE_ctrl_cmd_string_APIName accepts a boolean argument that can relax the semantics of the function - if set non-zero ,it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn't support the command name ,it will simply return success without doing anything
In this case we assume the user is only supplying commands specific to the given ENGINE so we set this to FALSE
It is possible to discover at run-time the names, numerical-ids, descriptions and input parameters of the control commands supported by an ENGINE using a structural reference
Note that some control commands are defined by OpenSSL itself and it will intercept and handle these control commands on behalf of the ENGINE, ie the ENGINE's ctrl_APIName handler is not used for the control command
openssl/engine.h defines an index, ENGINE_CMD_BASE, that all control commands implemented by ENGINEs should be numbered from
Any command value lower than this symbol is considered a "generic" command is handled directly by the OpenSSL core routines
It is using these "core" control commands that one can discover the the control commands implemented by a given ENGINE, specifically the commands;
Whilst these commands are automatically processed by the OpenSSL framework code, they use various properties exposed by each ENGINE to process these queries
An ENGINE has 3 properties it exposes that can affect how this behaves; it can supply a ctrl_APIName handler, it can specify ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE's flags, and it can expose an array of control command descriptions
If an ENGINE specifies the ENGINE_FLAGS_MANUAL_CMD_CTRL flag, then it will simply pass all these "core" control commands directly to the ENGINE's ctrl_APIName handler (and thus, it must have supplied one), so it is up to the ENGINE to reply to these "discovery" commands itself
If that flag is not set, then the OpenSSL framework code will work with the following rules;
If the ENGINE's array of control commands is empty ,then all other commands will fail, otherwise; ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier of the first command supported by the ENGINE, ENGINE_GET_NEXT_CMD_TYPE takes the identifier of a command supported by the ENGINE and returns the next command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes a string name for a command and returns the corresponding identifier or fails if no such command name exists, and the remaining commands take a command identifier and return properties of the corresponding commands
All except ENGINE_CTRL_GET_FLAGS return the string length of a command name or description, or populate a supplied character buffer with a copy of the command name or description
ENGINE_CTRL_GET_FLAGS returns a bitwise-OR'd mask of the following possible values;
If the ENGINE_CMD_FLAG_INTERNAL flag is set, then any other flags are purely informational to the caller - this flag will prevent the command being usable for any higher-level ENGINE functions such as ENGINE_ctrl_cmd_string_APIName
"INTERNAL" commands are not intended to be exposed to text-based configuration by applications, administrations, users, etc These can support arbitrary operations via ENGINE_ctrl_APIName, including passing to and/or from the control commands data of any arbitrary type
These commands are supported in the discovery mechanisms simply to allow applications determinie if an ENGINE supports certain specific commands it might want to use (eg application "foo" might query various ENGINEs to see if they implement "FOO_GET_VENDOR_LOGO_GIF" - and ENGINE could therefore decide whether or not to support this "foo"-specific extension)
The ENGINE API and internal architecture is currently being reviewed
Slated for possible release in 0.9.8 is support for transparent loading of "dynamic" ENGINEs (built as self-contained shared-libraries)
This would allow ENGINE implementations to be provided independently of OpenSSL libraries and/or OpenSSL-based applications, and would also remove any requirement for applications to explicitly use the "dynamic" ENGINE to bind to shared-library implementations
DH_generate_key_APIName performs the first step of a Diffie-Hellman key exchange by generating private and public DH values
By calling DH_compute_key_APIName, these are combined with the other party's public value to compute the shared key
DH_generate_key_APIName returns 1 on success, 0 otherwise
DH_compute_key_APIName returns the size of the shared secret on success, -1 on error
The error codes can be obtained by ERR_get_error_APIName
PEM_write_bio_PKCS7_stream_APIName outputs a PKCS7 structure in PEM format
It is otherwise identical to the function SMIME_write_PKCS7_APIName
This function is effectively a version of the PEM_write_bio_PKCS7_APIName supporting streaming
PEM_write_bio_PKCS7_stream_APIName returns 1 for success or 0 for failure
RAND_add_APIName mixes the RAND_add_APIParam_2 bytes at RAND_add_APIParam_1 into the PRNG state
Thus, if the data at RAND_add_APIParam_1 are unpredictable to an adversary, this increases the uncertainty about the state and makes the PRNG output less predictable
Suitable input comes from user interaction (random key presses, mouse movements) and certain hardware events
The RAND_add_APIParam_3 argument is (the lower bound of) an estimate of how much randomness is contained in RAND_add_APIParam_1, measured in bytes
Details about sources of randomness and how to estimate their entropy can be found in the literature, eg RFC 1750
RAND_add_APIName may be called with sensitive data such as user entered passwords
The seed values cannot be recovered from the PRNG output
The RAND_screen_APIName function is available for the convenience of Windows programmers
It adds the current contents of the screen to the PRNG
For applications that can catch Windows events, seeding the PRNG by calling RAND_event_APIName is a significantly better source of randomness
It should be noted that both methods cannot be used on servers that run without user interaction
RAND_status_APIName and RAND_event_APIName return 1 if the PRNG has been seeded with enough data, 0 otherwise
The other functions do not return values
The CMS_uncompress_APIParam_2 parameter is used in the rare case where the compressed content is detached
The CMS_uncompress_APIParam_2 parameter will normally be set to NULL
The only currently supported compression algorithm is zlib: if the structure indicates the use of any other algorithm ,an error is returned
If zlib support is not compiled into OpenSSL ,then CMS_uncompress_APIName will always return an error
The following flags can be passed in the CMS_uncompress_APIParam_4 parameter
CMS_uncompress_APIName returns either 1 for success or 0 for failure
The error can be obtained from ERR_get_error_APIName
The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify_APIName also applies to CMS_decompress_APIName
The EVP signature routines are a high level interface to digital signatures
EVP_DigestSignUpdate_APIName hashes EVP_DigestSignUpdate_APIParam_3 bytes of data at EVP_DigestSignUpdate_APIParam_2 into the signature context EVP_DigestSignUpdate_APIParam_1
This function can be called several times on the same EVP_DigestSignUpdate_APIParam_1 to include additional data
This function is currently implemented usig a macro
EVP_DigestSignFinal_APIName signs the data in EVP_DigestSignFinal_APIParam_1 places the signature in EVP_DigestSignFinal_APIParam_2
If EVP_DigestSignFinal_APIParam_2 is NULL, then the maximum size of the output buffer is written to the EVP_DigestSignFinal_APIParam_3 parameter
If EVP_DigestSignFinal_APIParam_2 is not NULL ,then before the call the EVP_DigestSignFinal_APIParam_3 parameter should contain the length of the EVP_DigestSignFinal_APIParam_2 buffer, if the call is successful ,the signature is written to EVP_DigestSignFinal_APIParam_2 and the amount of data written to EVP_DigestSignFinal_APIParam_3
EVP_DigestSignInit_APIName EVP_DigestSignUpdate_APIName and EVP_DigestSignaFinal_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
The error codes can be obtained from ERR_get_error_APIName
The EVP_DigestSignFinal_APIParam_1 EVP_DigestSignInit_APIParam_1 EVP_DigestSignUpdate_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces
This is because the code then becomes transparent to the algorithm used and much more flexible
In previous versions of OpenSSL there was a link between message digest types and public key algorithms
This meant that "clone" digests such as EVP_dss1_APIName needed to be used to sign using SHA1 and DSA
This is no longer necessary and the use of clone digest is now discouraged
For some key types and parameters the random number generator must be seeded or the operation will fail
The call to EVP_DigestSignFinal_APIName internally finalizes a copy of the digest context
This means that calls to EVP_DigestSignUpdate_APIName and EVP_DigestSignFinal_APIName can be called later to digest and sign additional data
Since only a copy of the digest context is ever finalized, the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur
The use of EVP_PKEY_size_APIName with these functions is discouraged because some signature operations may have a signature length which depends on the parameters set
As a result EVP_PKEY_size_APIName would have to return a value which indicates the maximum possible signature for any set of parameters
SSL_get_current_cipher_APIName returns a pointer to an SSL_CIPHER object containing the description of the actually used cipher of a connection established with the SSL_get_current_cipher_APIParam_1 object
SSL_get_cipher_APIName and SSL_get_cipher_name_APIName are identical macros to obtain the name of the currently used cipher
SSL_get_cipher_bits_APIName is a macro to obtain the number of secret/algorithm bits used and SSL_get_cipher_version_APIName returns the protocol name
See SSL_CIPHER_get_name_APIName for more details
SSL_get_current_cipher_APIName returns the cipher actually used or NULL, when no session has been established
SSL_CTX_set_timeout_APIName sets the timeout for newly created sessions for SSL_CTX_set_timeout_APIParam_1 to SSL_CTX_set_timeout_APIParam_2
The timeout value SSL_CTX_set_timeout_APIParam_2 must be given in seconds
SSL_CTX_get_timeout_APIName returns the currently set timeout value for SSL_CTX_get_timeout_APIParam_1
Whenever a new session is created, it is assigned a maximum lifetime
This lifetime is specified by storing the creation time of the session and the timeout value valid at this time
If the actual time is later than creation time plus timeout, the session is not reused
Due to this realization, all sessions behave according to the timeout value valid at the time of the session negotiation
Changes of the timeout value do not affect already established sessions
The expiration time of a single session can be modified using the SSL_SESSION_get_time_APIName family of functions
Expired sessions are removed from the internal session cache, whenever SSL_CTX_flush_sessions_APIName is called, either directly by the application or automatically (see SSL_CTX_set_session_cache_mode_APIName )
The default value for session timeout is decided on a per protocol basis, see SSL_get_default_timeout_APIName
All currently supported protocols have the same default timeout value of 300 seconds
SSL_CTX_set_timeout_APIName returns the previously set timeout value
SSL_CTX_get_timeout_APIName returns the currently set timeout value
locking_function(int mode, int n, const char *file, int line) is needed to perform locking on shared data structures
(Note that OpenSSL uses a number of global data structures that will be implicitly shared whenever multiple threads use OpenSSL.)
Multi-threaded applications will crash at random if it is not set
CRYPTO_lock_APIParam_3 and CRYPTO_lock_APIParam_4 are the file number of the function setting the lock
They can be useful for debugging
Once threadid_func_APIName is registered, or if the built-in default implementation is to be used;
CRYPTO_THREADID_current_APIName records the currently-executing thread ID into the given CRYPTO_THREADID_current_APIParam_1 object
CRYPTO_THREADID_cmp_APIName compares two thread IDs (returning zero for equality, ie the same semantics as memcmp_APIName)
CRYPTO_THREADID_cpy_APIName duplicates a thread ID value
CRYPTO_THREADID_hash_APIName returns a numeric value usable as a hash-table key
This is usually the exact numeric or pointer-based thread ID used internally, however this also handles the unusual case where pointers are larger than 'long' variables and the platform's thread IDs are pointer-based - in this case, mixing is done to attempt to produce a unique numeric value even though it is not as wide as the platform's true thread IDs
Additionally, OpenSSL supports dynamic locks, and sometimes, some parts of OpenSSL need it for better performance
To enable this, the following is required:
Three additional callback function, dyn_create_function, dyn_lock_function and dyn_destroy_function
A structure defined with the data that each lock needs to handle
struct CRYPTO_dynlock_value has to be defined to contain whatever structure is needed to handle locks
dyn_create_function(const char *file, int line) is needed to create a lock
Multi-threaded applications might crash at random if it is not set
dyn_lock_function(int mode, CRYPTO_dynlock *l, const char *file, int line) is needed to perform locking off dynamic lock numbered n. Multi-threaded applications might crash at random if it is not set
dyn_destroy_function(CRYPTO_dynlock *l, const char *file, int line) is needed to destroy the lock l. Multi-threaded applications might crash at random if it is not set
CRYPTO_get_new_dynlockid_APIName is used to create locks
CRYPTO_get_new_dynlockid_APIName will call dyn_create_function for the actual creation
CRYPTO_destroy_dynlockid_APIName is used to destroy locks
CRYPTO_destroy_dynlockid_APIName will call dyn_destroy_function for the actual destruction
CRYPTO_lock_APIName is used to lock and unlock the locks
mode is a bitfield describing what should be done with the lock
n is the number of the lock as returned from CRYPTO_get_new_dynlockid_APIName
mode can be combined from 1,2,4,8
These values are pairwise exclusive, with undefined behaviour if misused (for example, CRYPTO_READ and CRYPTO_WRITE should not be used together):
CRYPTO_num_locks_APIName returns the required number of locks
CRYPTO_get_new_dynlockid_APIName returns the index to the newly created lock
The other functions return no values
You can find out if OpenSSL was configured with thread support:
Also, dynamic locks are currently not used internally by OpenSSL, but may do so in the future
X509_NAME_get_index_by_NID_APIName and X509_NAME_get_index_by_OBJ_APIName retrieve the next index matching X509_NAME_get_index_by_NID_APIParam_2 or X509_NAME_get_index_by_OBJ_APIParam_2 after X509_NAME_get_index_by_NID_APIParam_3 X509_NAME_get_index_by_OBJ_APIParam_3
X509_NAME_get_index_by_NID_APIParam_3 X509_NAME_get_index_by_OBJ_APIParam_3 should initially be set to -1
If there are no more entries, -1 is returned
If X509_NAME_get_index_by_NID_APIParam_2 is invalid (doesn't correspond to a valid OID) ,then -2 is returned
X509_NAME_entry_count_APIName returns the total number of entries in X509_NAME_entry_count_APIParam_1
X509_NAME_get_entry_APIName retrieves the X509_NAME_get_entry_APIParam_0 from X509_NAME_get_entry_APIParam_1 corresponding to index X509_NAME_get_entry_APIParam_2
Acceptable values for X509_NAME_get_entry_APIParam_2 run from 0 to (X509_NAME_entry_count(name) - 1)
The value returned is an internal pointer which must not be freed
X509_NAME_get_text_by_NID_APIName, X509_NAME_get_text_by_OBJ_APIName retrieve the "text" from the first entry in X509_NAME_get_text_by_NID_APIParam_1 X509_NAME_get_text_by_OBJ_APIParam_1 which matches X509_NAME_get_text_by_NID_APIParam_2 or X509_NAME_get_text_by_OBJ_APIParam_2, if no such entry exists, -1 is returned
At most X509_NAME_get_text_by_NID_APIParam_4 X509_NAME_get_text_by_OBJ_APIParam_4 bytes will be written and the text written to X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3 will be null terminated
The length of the output string written is returned excluding the terminating null
If X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3 is <NULL> then the amount of space needed in X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3 (excluding the final null) is returned
X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName are legacy functions which have various limitations which make X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName of minimal use in practice
X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName can only find the first matching entry and will copy the contents of the field verbatim: this can be highly confusing if the target is a muticharacter string type like a BMPString or a UTF8String
For a more general solution X509_NAME_get_index_by_NID_APIName or X509_NAME_get_index_by_OBJ_APIName should be used followed by X509_NAME_get_entry_APIName on any matching indices and then the various X509_NAME_get_entry_APIParam_0 utility functions on the result
Applications which could pass invalid NIDs to X509_NAME_get_index_by_NID_APIName should check for the return value of -2
Alternatively the NID validity can be determined first by checking OBJ_nid2obj(nid) is not NULL
X509_NAME_get_index_by_NID_APIName and X509_NAME_get_index_by_OBJ_APIName return the index of the next matching entry or -1 if not found
X509_NAME_get_index_by_NID_APIName can also return -2 if the supplied NID is invalid
X509_NAME_entry_count_APIName returns the total number of entries
X509_NAME_get_entry_APIName returns an X509_NAME_get_entry_APIParam_1 pointer to the requested entry or NULL if the index is invalid
Newer applications should use a more modern algorithm such as PBKDF2 as defined in PKCS#5v2.1 and provided by PKCS5_PBKDF2_HMAC
These functions implement Montgomery multiplication
These functions are used automatically when BN_mod_exp_APIName is called with suitable input, but These functions may be useful when several operations are to be performed using the same modulus
BN_MONT_CTX_new_APIName allocates and initializes a BN_MONT_CTX_init_APIParam_1 structure
BN_MONT_CTX_init_APIName initializes an existing uninitialized BN_MONT_CTX_init_APIParam_1
BN_MONT_CTX_set_APIName sets up the BN_MONT_CTX_set_APIParam_1 structure from the modulus BN_MONT_CTX_set_APIParam_2 by precomputing its inverse and a value R
BN_MONT_CTX_copy_APIName copies the BN_MONT_CTX_copy_APIParam_1 BN_MONT_CTX_copy_APIParam_2 to BN_MONT_CTX_copy_APIParam_1
BN_MONT_CTX_free_APIName frees the components of the BN_MONT_CTX_free_APIParam_1, and, if it was created by BN_MONT_CTX_new_APIName, also the structure itself
BN_mod_mul_montgomery_APIName computes Mont(BN_mod_mul_montgomery_APIParam_2,BN_mod_mul_montgomery_APIParam_3):=BN_mod_mul_montgomery_APIParam_2*BN_mod_mul_montgomery_APIParam_3*R^-1 and places the result in BN_mod_mul_montgomery_APIParam_1
BN_from_montgomery_APIName performs the Montgomery reduction BN_from_montgomery_APIParam_1 = BN_from_montgomery_APIParam_2*R^-1
BN_to_montgomery_APIName computes Mont(BN_to_montgomery_APIParam_2,R^2), ie BN_to_montgomery_APIParam_2*R. Note that BN_to_montgomery_APIParam_2 must be non-negative and smaller than the modulus
For all functions, BN_MONT_CTX_init_APIParam_1 BN_MONT_CTX_set_APIParam_3 is a previously allocated BN_MONT_CTX_set_APIParam_3 used for temporary variables
The BN_MONT_CTX_init_APIParam_1 BN_MONT_CTX_set_APIParam_1 BN_MONT_CTX_copy_APIParam_1 BN_MONT_CTX_free_APIParam_1 BN_to_montgomery_APIParam_3 BN_from_montgomery_APIParam_3 structure is defined as follows:
BN_to_montgomery_APIName is a macro
BN_MONT_CTX_new_APIName returns the newly allocated BN_MONT_CTX_new_APIParam_0, and NULL on error
BN_MONT_CTX_init_APIName and BN_MONT_CTX_free_APIName have no return values
For the other functions, 1 is returned for success, 0 on error
The error codes can be obtained by ERR_get_error_APIName
The inputs must be reduced modulo BN_MONT_CTX_set_APIParam_2, otherwise the result will be outside the expected range
d2i_DSAPublicKey_APIName and i2d_DSAPublicKey_APIName decode and encode the DSA public key components structure
d2i_DSA_PUBKEY_APIName and i2d_DSA_PUBKEY_APIName decode and encode an DSA public key using a SubjectPublicKeyInfo (certificate public key) structure
d2i_DSAPrivateKey_APIName, i2d_DSAPrivateKey_APIName decode and encode the DSA private key components
The usage of all of these functions is similar to the d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
The i2d_DSA_PUBKEY_APIParam_1 d2i_DSAparams_APIParam_1 d2i_DSAPrivateKey_APIParam_1 d2i_DSA_PUBKEY_APIParam_1 i2d_DSA_SIG_APIParam_1 d2i_DSAPublicKey_APIParam_1 d2i_DSA_SIG_APIParam_1 i2d_DSAPublicKey_APIParam_1 i2d_DSAparams_APIParam_1 i2d_DSAPrivateKey_APIParam_1 structure passed to the private key encoding functions should have all the private key components present
The data encoded by the private key functions is unencrypted and therefore offers no private key security
Note: all these functions are implemented using macros
SSL_CTX_set_options_APIName adds the options set via bitmask in SSL_CTX_set_options_APIParam_2 to SSL_CTX_set_options_APIParam_1
Options already set before are not cleared!
SSL_set_options_APIName adds the options set via bitmask in SSL_set_options_APIParam_2 to SSL_set_options_APIParam_1
Options already set before are not cleared!
SSL_CTX_clear_options_APIName clears the options set via bitmask in SSL_CTX_clear_options_APIParam_2 to SSL_CTX_clear_options_APIParam_1
SSL_clear_options_APIName clears the options set via bitmask in SSL_clear_options_APIParam_2 to SSL_clear_options_APIParam_1
SSL_CTX_get_options_APIName returns the options set for SSL_CTX_get_options_APIParam_1
SSL_get_options_APIName returns the options set for SSL_get_options_APIParam_1
SSL_get_secure_renegotiation_support_APIName indicates whether the peer supports secure renegotiation
SSL_CTX_set_options_APIName and SSL_set_options_APIName affect the (external) protocol behaviour of the SSL library
The (internal) behaviour of the API can be changed by using the similar SSL_CTX_set_mode_APIName and SSL_set_mode_APIName functions
During a handshake, the option settings of the SSL object are used
When a new SSL object is created from a context using SSL_new_APIName, the current option setting is copied
Changes to SSL_CTX_set_options_APIParam_1 SSL_CTX_get_options_APIParam_1 SSL_CTX_clear_options_APIParam_1 do not affect already created SSL objects
SSL_clear_APIName does not affect the settings
www.microsoft.com - when talking SSLv2, if session-id reuse is performed, the session-id passed back in the server-finished message is different from the one decided upon
Netscape-Commerce/1.12, when talking SSLv2, accepts a 32 byte challenge but then appears to only use 16 bytes when generating the encryption keys
Using 16 bytes is ok but it should be ok to use 32
According to the SSLv3 spec, one should use 32 bytes for the challenge when operating in SSLv2/v3 compatibility mode, but as mentioned above, this breaks this server so 16 bytes is the way to go
As of OpenSSL 0.9.8q and 1.0.0c, this option has no effect
Don't prefer ECDHE-ECDSA ciphers when the client appears to be Safari on OS X. OS X 10.8..10.8.3 has broken support for ECDHE-ECDSA ciphers
Disables a countermeasure against a SSL 3.0/TLS 1.0 protocol vulnerability affecting CBC ciphers, which cannot be handled by some broken SSL implementations
This option has no effect for connections using other ciphers
Adds a padding extension to ensure the ClientHello size is never between 256 and 511 bytes in length
This is needed as a workaround for some implementations
All of the above bug workarounds
Disable version rollback attack detection
During the client key exchange, the client must send the same information about acceptable SSL/TLS protocol levels as during the first hello
Some clients violate this rule by adapting to the server's answer
(Example: the client sends a SSLv2 hello and accepts up to SSLv3.1=TLSv1, the server only understands up to SSLv3
In this case the client must still use the same SSLv3.1=TLSv1 announcement
Some clients step down to SSLv3 with respect to the server's answer and violate the version rollback protection.)
This option is no longer implemented and is treated as no op
When choosing a cipher, use the server's preferences instead of the client preferences
When not set, the SSL server will always follow the clients preferences
When set, the SSLv3/TLSv1 server will choose following its own preferences
Because of the different protocol, for SSLv2, the server will send its list of preferences to the client and the client chooses
If we accept a netscape connection, demand a client cert, have a non-self-signed CA which does not have its CA in netscape, and the browser has a cert, it will crash/hang
Works for 3.x and 4.xbeta
Do not use the SSLv3 protocol
the SSLv3 protocol is recommended that applications should set this option
Do not use the TLSv1 protocol
Do not use the TLSv1.1 protocol
Do not use the TLSv1.2 protocol
When performing renegotiation as a server, always start a new session (ie, session resumption requests are only accepted in the initial handshake)
This option is not needed for clients
Normally clients and servers will, where possible, transparently make use of RFC4507bis tickets for stateless session resumption
If this option is set this functionality is disabled and tickets will not be used by clients or servers
SSL_CTX_set_options_APIName and SSL_set_options_APIName return the new options bitmask after adding SSL_CTX_set_options_APIParam_2 SSL_set_options_APIParam_2
SSL_CTX_clear_options_APIName and SSL_clear_options_APIName return the new options bitmask after clearing SSL_CTX_clear_options_APIParam_2 SSL_clear_options_APIParam_2
SSL_CTX_get_options_APIName and SSL_get_options_APIName return the current bitmask
SSL_get_secure_renegotiation_support_APIName returns 1 is the peer supports secure renegotiation and 0 if it does not
These functions implement RSA public key encryption and signatures as defined in PKCS #1 v2.0 [RFC 2437]
The RSA_set_ex_data_APIParam_1 RSA_free_APIParam_1 RSA_blinding_on_APIParam_1 RSA_print_fp_APIParam_2 RSA_set_method_APIParam_1 RSA_get_method_APIParam_1 RSA_print_APIParam_2 RSA_check_key_APIParam_1 RSA_set_default_method_APIParam_1 RSA_get_ex_data_APIParam_1 RSA_size_APIParam_1 RSA_blinding_off_APIParam_1 RSA_flags_APIParam_1 structure consists of several BIGNUM components
It can contain public as well as private RSA keys:
In public keys, the private exponent and the related secret values are NULL
Note that RSA keys may use non-standard RSA_set_method_APIParam_2 RSA_set_default_method_APIParam_1 implementations, either directly or by the use of RSA_new_method_APIParam_1 modules
In some cases (eg an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage
For this reason, applications should generally avoid using RSA structure elements directly and instead use API functions to query or modify keys
BIO_s_socket_APIName returns the socket BIO method
This is a wrapper round the platform's socket routines
BIO_read_APIName and BIO_write_APIName read or write the underlying socket
BIO_puts_APIName is supported but BIO_gets_APIName is not
If the close flag is set ,then the socket is shut down and closed when the BIO is freed
BIO_set_fd_APIName sets the socket of BIO BIO_set_fd_APIParam_1 to BIO_set_fd_APIParam_2 and the close flag to BIO_set_fd_APIParam_3
BIO_get_fd_APIName places the socket in BIO_get_fd_APIParam_2 if it is not NULL, it also returns the socket
If BIO_get_fd_APIParam_2 is not NULL it should be of type (int *)
BIO_new_socket_APIName returns a socket BIO using BIO_new_socket_APIParam_1 and BIO_new_socket_APIParam_2
Socket BIOs also support any relevant functionality of file descriptor BIOs
The reason for having separate file descriptor and socket BIOs is that on some platforms sockets are not file descriptors and use distinct I/O routines, Windows is one such platform
Any code mixing the two will not work on all platforms
BIO_set_fd_APIName and BIO_get_fd_APIName are macros
BIO_s_socket_APIName returns the socket BIO method
BIO_set_fd_APIName always returns 1
BIO_get_fd_APIName returns the socket or -1 if the BIO has not been initialized
BIO_new_socket_APIName returns the newly allocated BIO or NULL is an error occurred
SSL_get_ex_data_X509_STORE_CTX_idx_APIName returns the index number under which the pointer to the SSL object is stored into the X509_STORE_CTX object
Whenever a X509_STORE_CTX object is created for the verification of the peers certificate during a handshake, a pointer to the SSL object is stored into the X509_STORE_CTX object to identify the connection affected
To retrieve this pointer the X509_STORE_CTX_get_ex_data_APIName function can be used with the correct index
This index is globally the same for all X509_STORE_CTX objects and can be retrieved using SSL_get_ex_data_X509_STORE_CTX_idx_APIName
The index value is set when SSL_get_ex_data_X509_STORE_CTX_idx_APIName is first called either by the application program directly or indirectly during other SSL setup functions or during the handshake
The value depends on other index values defined for X509_STORE_CTX objects before the SSL index is created
The index value to access the pointer
An error occurred, check the error stack for a detailed error message
These functions determine why a BIO is not able to read or write data
These functions will typically be called after a failed BIO_read_APIName or BIO_write_APIName call
BIO_should_retry_APIName is true if the call that produced this condition should then be retried at a later time
If BIO_should_retry_APIName is false ,then the cause is an error condition
BIO_should_read_APIName is true if the cause of the condition is that a BIO needs to read data
BIO_should_write_APIName is true if the cause of the condition is that a BIO needs to read data
BIO_should_io_special_APIName is true if some "special" condition, that is a reason other than reading or writing is the cause of the condition
BIO_get_retry_BIO_APIName determines the precise reason for the special condition, it returns the BIO that caused this condition and if BIO_get_retry_BIO_APIParam_2 is not NULL it contains the reason code
The meaning of the reason code and the action that should be taken depends on the type of BIO that resulted in this condition
BIO_get_retry_reason_APIName returns the reason for a special condition if passed the relevant BIO, for example as returned by BIO_get_retry_BIO_APIName
If BIO_should_retry_APIName returns false ,then the precise "error condition" depends on the BIO type that caused it and the return code of the BIO operation
For example if a call to BIO_read_APIName on a socket BIO returns 0 and BIO_should_retry_APIName is false then the cause will be that the connection closed
A similar condition on a file BIO will mean that it has reached EOF
Some BIO types may place additional information on the error queue
For more details see the individual BIO type manual pages
If the underlying I/O structure is in a blocking mode ,almost all current BIO types will not request a retry, because the underlying I/O calls will not
If the application knows that the BIO type will never signal a retry then it need not call BIO_should_retry_APIName after a failed BIO I/O call
This is typically done with file BIOs
SSL BIOs are the only current exception to this rule: SSL BIOs can request a retry even if the underlying I/O structure is blocking, if a handshake occurs during a call to BIO_read_APIName
An application can retry the failed call immediately or avoid this situation by setting SSL_MODE_AUTO_RETRY on the underlying SSL structure
While an application may retry a failed non blocking call immediately this is likely to be very inefficient because the call will fail repeatedly until data can be processed or is available
An application will normally wait until the necessary condition is satisfied
How this is done depends on the underlying I/O structure
For example if the cause is ultimately a socket and BIO_should_read_APIName is true then a call to select_APIName may be made to wait until data is available and then retry the BIO operation
By combining the retry conditions of several non blocking BIOs in a single select_APIName call it is possible to service several BIOs in a single thread, though the performance may be poor if SSL BIOs are present because long delays can occur during the initial handshake process
It is possible for a BIO to block indefinitely if the underlying I/O structure cannot process or return any data
This depends on the behaviour of the platforms I/O functions
This is often not desirable: one solution is to use non blocking I/O and use a timeout on the select_APIName (or equivalent) call
The OpenSSL ASN1 functions cannot gracefully deal with non blocking I/O: that is they cannot retry after a partial read or write
This is usually worked around by only passing the relevant data to ASN1 functions when the entire structure can be read or written
PKCS12_create_APIName creates a PKCS#12 structure
These defaults are: 40 bit RC2 encryption for certificates, triple DES encryption for private keys, a key iteration count of PKCS12_DEFAULT_ITER (currently 2048) and a MAC iteration count of 1
SMIME_read_PKCS7_APIName parses a message in S/MIME format
SMIME_read_PKCS7_APIParam_1 is a BIO to read the message from
If cleartext signing is used ,then the content is saved in a memory bio which is written to SMIME_read_PKCS7_APIParam_2, otherwise SMIME_read_PKCS7_APIParam_2 is set to NULL
The parsed PKCS#7 structure is returned or NULL if an error occurred
Otherwise the type of  PKCS7_type_APIParam_0  can be determined using PKCS7_type_APIName
To support future functionality if SMIME_read_PKCS7_APIParam_2 is not NULL SMIME_read_PKCS7_APIParam_2 should be initialized to NULL
The MIME parser used by SMIME_read_PKCS7_APIName is somewhat primitive
While The MIME parser used by SMIME_read_PKCS7_APIName will handle most S/MIME messages more complex compound formats may not work
The parser assumes that the PKCS7 structure is always base64 encoded and will not handle the case where the PKCS7 structure is in binary format or uses quoted printable format
The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints: a streaming single pass option should be available
SMIME_read_PKCS7_APIName returns a valid SMIME_read_PKCS7_APIParam_0 structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure
SSL_SESSION_get_ex_new_index_APIName is used to register a new index for application specific data
SSL_SESSION_set_ex_data_APIName is used to store application data at SSL_SESSION_set_ex_data_APIParam_3 for SSL_SESSION_set_ex_data_APIParam_2 into the SSL_SESSION_set_ex_data_APIParam_1 object
SSL_SESSION_get_ex_data_APIName is used to retrieve the information for SSL_SESSION_get_ex_data_APIParam_2 from SSL_SESSION_get_ex_data_APIParam_1
The application data is only maintained for sessions held in memory
The application data is not included when dumping the session with i2d_SSL_SESSION_APIName (and all functions indirectly calling the dump functions like PEM_write_SSL_SESSION_APIName and PEM_write_bio_SSL_SESSION_APIName) and can therefore not be restored
These functions manipulate the X509_VERIFY_PARAM_set1_ip_asc_APIParam_1 X509_VERIFY_PARAM_set1_policies_APIParam_1 X509_VERIFY_PARAM_set_trust_APIParam_1 X509_VERIFY_PARAM_clear_flags_APIParam_1 X509_VERIFY_PARAM_add1_host_APIParam_1 X509_VERIFY_PARAM_set_hostflags_APIParam_1 X509_VERIFY_PARAM_set_purpose_APIParam_1 X509_VERIFY_PARAM_set_depth_APIParam_1 X509_VERIFY_PARAM_get_depth_APIParam_1 X509_VERIFY_PARAM_set1_host_APIParam_1 X509_VERIFY_PARAM_set_time_APIParam_1 X509_VERIFY_PARAM_add0_policy_APIParam_1 X509_VERIFY_PARAM_set1_email_APIParam_1 X509_VERIFY_PARAM_set_flags_APIParam_1 X509_VERIFY_PARAM_set1_ip_APIParam_1 X509_VERIFY_PARAM_get0_peername_APIParam_1 X509_VERIFY_PARAM_get_flags_APIParam_1 structure associated with a certificate verification operation
X509_VERIFY_PARAM_get_flags_APIName returns the flags in X509_VERIFY_PARAM_get_flags_APIParam_1
X509_VERIFY_PARAM_clear_flags_APIName clears the flags X509_VERIFY_PARAM_set_flags_APIParam_2 in X509_VERIFY_PARAM_clear_flags_APIParam_1
X509_VERIFY_PARAM_set_purpose_APIName sets the verification purpose in X509_VERIFY_PARAM_set_purpose_APIParam_1 to X509_VERIFY_PARAM_set_purpose_APIParam_2
This determines the acceptable purpose of the certificate chain, for example SSL client or SSL server
X509_VERIFY_PARAM_set_trust_APIName sets the trust setting in X509_VERIFY_PARAM_set_trust_APIParam_1 to X509_VERIFY_PARAM_set_trust_APIParam_2
X509_VERIFY_PARAM_set_time_APIName sets the verification time in X509_VERIFY_PARAM_set_time_APIParam_1 to X509_VERIFY_PARAM_set_time_APIParam_2
Normally the current time is used
X509_VERIFY_PARAM_set_depth_APIName sets the maximum verification depth to X509_VERIFY_PARAM_set_depth_APIParam_2
That is the maximum number of untrusted CA certificates that can appear in a chain
X509_VERIFY_PARAM_get0_peername_APIName returns the DNS hostname or subject CommonName from the peer certificate that matched one of the reference identifiers
When wildcard matching is not disabled, or when a reference identifier specifies a parent domain (starts with ".")
rather than a hostname, the peer name may be a wildcard name or a sub-domain of the reference identifier respectively
The return string is allocated by the library and is no longer valid once the associated X509_VERIFY_PARAM_get0_peername_APIParam_1 argument is freed
Applications must not free the return value
X509_VERIFY_PARAM_set1_ip_asc_APIName sets the expected IP address to X509_VERIFY_PARAM_set1_ip_asc_APIParam_2
The X509_VERIFY_PARAM_set1_ip_asc_APIParam_2 argument is a NUL-terminal ASCII string: dotted decimal quad for IPv4 and colon-separated hexadecimal for IPv6
The condensed "::" notation is supported for IPv6 addresses
X509_VERIFY_PARAM_set_flags_APIName, X509_VERIFY_PARAM_clear_flags_APIName, X509_VERIFY_PARAM_set_purpose_APIName, X509_VERIFY_PARAM_set_trust_APIName, X509_VERIFY_PARAM_add0_policy_APIName X509_VERIFY_PARAM_set1_policies_APIName, X509_VERIFY_PARAM_set1_host_APIName, X509_VERIFY_PARAM_set_hostflags_APIName, X509_VERIFY_PARAM_set1_email_APIName, X509_VERIFY_PARAM_set1_ip_APIName and X509_VERIFY_PARAM_set1_ip_asc_APIName return 1 for success and 0 for failure
X509_VERIFY_PARAM_get_flags_APIName returns the current verification flags
X509_VERIFY_PARAM_set_time_APIName and X509_VERIFY_PARAM_set_depth_APIName do not return values
X509_VERIFY_PARAM_get_depth_APIName returns the current verification depth
The above functions should be used to manipulate verification parameters instead of legacy functions which work in specific structures such as X509_STORE_CTX_set_flags_APIName
After the call to EVP_PKEY_verify_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The function EVP_PKEY_verify_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_verify_init_APIName and EVP_PKEY_verify_APIName return 1 if the verification was successful and 0 if it failed
Unlike other functions the return value 0 from EVP_PKEY_verify_APIName only indicates that the signature did not not verify successfully (that is tbs did not match the original data or the signature was of invalid form) it is not an indication of a more serious error
A negative value indicates an error other that signature verification failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
Othewise the functions behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
d2i_AutoPrivateKey_APIName is similar to d2i_PrivateKey_APIName except d2i_AutoPrivateKey_APIName attempts to automatically detect the private key format
These functions are similar to the d2i_X509_APIName functions, and you should refer to that page for a detailed description (see d2i_X509_APIName )
All these functions use DER format and unencrypted keys
Applications wishing to encrypt or decrypt private keys should use other functions such as d2i_PKC8PrivateKey_APIName instead
If the d2i_PrivateKey_APIParam_2 d2i_AutoPrivateKey_APIParam_1 is not NULL when calling d2i_PrivateKey_APIName or d2i_AutoPrivateKey_APIName (ie an existing structure is being reused) and the key format is PKCS#8, then d2i_PrivateKey_APIParam_2 d2i_AutoPrivateKey_APIParam_1 will be freed and replaced on a successful call
i2d_PrivateKey_APIName returns the number of bytes successfully encoded or a negative value if an error occurs
The error code can be obtained by calling ERR_get_error_APIName
OPENSSL_VERSION_NUMBER is a numeric release version identifier:
The status nibble has one of the values 0 for development, 1 to e for betas 1 to 14, and f for release
Versions prior to 0.9.3 have identifiers < 0x0930
Versions between 0.9.3 and 0.9.5 had a version identifier with this interpretation:
Version 0.9.5a had an interim interpretation that is like the current one, except the patch level got the highest bit set, to keep continuity
The number was therefore 0x0090581f
For backward compatibility, SSLEAY_VERSION_NUMBER is also defined
OPENSSL_VERSION_TEXT is the text variant of the version number and the release date
For example, "OpenSSL 1.0.1a 15 Oct 2015"
SSLeay_APIName returns this number
The return value can be compared to the macro to make sure that the correct version of the library has been loaded, especially when using DLLs on Windows systems
SSLeay_version_APIName returns different strings depending on SSLeay_version_APIParam_1:
The text variant of the version number and the release date
For example, "OpenSSL 0.9.5a 1 Apr 2000"
The compiler flags set for the compilation process in the form "compiler: ..." if available or "compiler: information not available" otherwise
The date of the build process in the form "built on: ..." if available or "built on: date not available" otherwise
The "Configure" target of the library build in the form "platform: ..." if available or "platform: information not available" otherwise
The "OPENSSLDIR" setting of the library build in the form "OPENSSLDIR: "..."" if available or "OPENSSLDIR: N/A" otherwise
For an unknown SSLeay_version_APIParam_1, the text "not available" is returned
The version number
EC_POINT_add adds the two points EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 and EC_POINT_add_APIParam_4 EC_POINT_cmp_APIParam_3 and places the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2
Similarly EC_POINT_dbl doubles the point EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 and places the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2
In both cases it is valid for EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2 to be one of EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 or EC_POINT_add_APIParam_4 EC_POINT_cmp_APIParam_3
EC_POINT_invert calculates the inverse of the supplied point EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2
The result is placed back in EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2
The function EC_POINT_is_at_infinity tests whether the supplied point is at infinity or not
EC_POINT_is_on_curve tests whether the supplied point is on the curve or not
EC_POINT_cmp compares the two supplied points and tests whether or not they are equal
The functions EC_POINT_make_affine and EC_POINTs_make_affine force the internal representation of the EC_POINT(s) into the affine co-ordinate system
In the case of EC_POINTs_make_affine the value EC_POINTs_mul_APIParam_4 EC_POINTs_make_affine_APIParam_2 provides the number of points in the array EC_POINTs_make_affine_APIParam_3 to be forced
EC_POINT_mul calculates the value generator * EC_POINTs_mul_APIParam_3 EC_POINT_mul_APIParam_3 + EC_POINT_mul_APIParam_4 * EC_POINTs_mul_APIParam_6 EC_POINT_mul_APIParam_5 and stores the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2
The value EC_POINTs_mul_APIParam_3 EC_POINT_mul_APIParam_3 may be NULL in which case the result is just EC_POINT_mul_APIParam_4 * EC_POINTs_mul_APIParam_6 EC_POINT_mul_APIParam_5
The function EC_GROUP_precompute_mult stores multiples of the generator for faster point multiplication, whilst EC_GROUP_have_precompute_mult tests whether precomputation has already been done
See EC_GROUP_copy_APIName for information about the generator
The following functions return 1 on success or 0 on error: EC_POINT_add, EC_POINT_dbl, EC_POINT_invert, EC_POINT_make_affine, EC_POINTs_make_affine, EC_POINTs_make_affine, EC_POINT_mul, EC_POINTs_mul and EC_GROUP_precompute_mult
EC_POINT_is_at_infinity returns 1 if the point is at infinity, or 0 otherwise
EC_POINT_is_on_curve returns 1 if the point is on the curve, 0 if not, or -1 on error
EC_POINT_cmp returns 1 if the points are not equal, 0 if the points are, or -1 on error
EC_GROUP_have_precompute_mult return 1 if a precomputation has been done, or 0 if not
SSL_CTX_set_quiet_shutdown_APIName sets the "quiet shutdown" flag for SSL_CTX_set_quiet_shutdown_APIParam_1 to be SSL_CTX_set_quiet_shutdown_APIParam_2
SSL objects created from SSL_CTX_set_quiet_shutdown_APIParam_1 inherit the SSL_CTX_set_quiet_shutdown_APIParam_2 valid at the time SSL_new_APIName is called
SSL_CTX_set_quiet_shutdown_APIParam_2 may be 0 or 1
SSL_CTX_get_quiet_shutdown_APIName returns the "quiet shutdown" setting of SSL_CTX_get_quiet_shutdown_APIParam_1
SSL_set_quiet_shutdown_APIName sets the "quiet shutdown" flag for SSL_set_quiet_shutdown_APIParam_1 SSL_set_quiet_shutdown_APIParam_1 to be SSL_set_quiet_shutdown_APIParam_2 SSL_set_quiet_shutdown_APIParam_2
The setting stays valid until SSL_set_quiet_shutdown_APIParam_1 SSL_set_quiet_shutdown_APIParam_1 is removed with SSL_free_APIName or SSL_set_quiet_shutdown_APIName is called again
It is not changed when SSL_clear_APIName is called
SSL_set_quiet_shutdown_APIParam_2 SSL_set_quiet_shutdown_APIParam_2 may be 0 or 1
SSL_get_quiet_shutdown_APIName returns the "quiet shutdown" setting of SSL_get_quiet_shutdown_APIParam_1
Normally when a SSL connection is finished, the parties must send out "close notify" alert messages using SSL_shutdown_APIName for a clean shutdown
When setting the "quiet shutdown" flag to 1, SSL_shutdown_APIName will set the internal flags to SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN
( SSL_shutdown_APIName then behaves like SSL_set_shutdown_APIName called with SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN.)
The session is thus considered to be shutdown, but no "close notify" alert is sent to the peer
This behaviour violates the TLS standard
The default is normal shutdown behaviour as described by the TLS standard
SSL_CTX_set_quiet_shutdown_APIName and SSL_set_quiet_shutdown_APIName do not return diagnostic information
SSL_CTX_get_quiet_shutdown_APIName and SSL_get_quiet_shutdown return the current setting
BN_swap_APIName exchanges the values of BN_swap_APIParam_1 and BN_swap_APIParam_2
SSL_COMP_add_compression_method_APIName adds the compression method SSL_COMP_add_compression_method_APIParam_2 with the identifier SSL_COMP_add_compression_method_APIParam_1 to the list of available compression methods
This list is globally maintained for all SSL operations within this application
It cannot be set for specific SSL_CTX or SSL objects
SSL_COMP_free_compression_methods_APIName frees the internal table of compression methods that were built internally, and possibly augmented by adding SSL_COMP_add_compression_method_APIName
The TLS standard (or SSLv3) allows the integration of compression methods into the communication
The TLS RFC does however not specify compression methods or their corresponding identifiers, so there is currently no compatible way to integrate compression with unknown peers
It is therefore currently not recommended to integrate compression into applications
Applications for non-public use may agree on certain compression methods
Using different compression methods with the same identifier will lead to connection failure
An OpenSSL client speaking a protocol that allows compression (SSLv3, TLSv1) will unconditionally send the list of all compression methods enabled with SSL_COMP_add_compression_method_APIName to the server during the handshake
Unlike the mechanisms to set a cipher list, there is no method available to restrict the list of compression method on a per connection basis
An OpenSSL server will match the identifiers listed by a client against its own compression methods and will unconditionally activate compression when a matching identifier is found
There is no way to restrict the list of compression methods supported on a per connection basis
If enabled during compilation, the OpenSSL library will have the COMP_zlib_APIName compression method available
Once the identities of the compression methods for the TLS protocol have been standardized, the compression API will most likely be changed
Using it in the current state is not recommended
SSL_COMP_add_compression_method_APIName may return the following values:
The operation succeeded
The operation failed
Check the error queue to find out the reason
BN_set_word_APIParam_2 is a macro that will be an unsigned integral type optimied for the most efficient implementation on the local platform
BN_zero_APIName, BN_one_APIName and BN_set_word_APIName set BN_zero_APIParam_1 BN_one_APIParam_1 BN_set_word_APIParam_1 BN_zero_APIParam_1 BN_one_APIParam_1 to the values 0, 1 and BN_set_word_APIParam_2 respectively
BN_zero_APIName and BN_one_APIName are macros
BN_value_one_APIName returns a BN_value_one_APIParam_0 constant of value 1
This constant is useful for use in comparisons and assignment
BN_get_word_APIName returns BN_get_word_APIParam_1, if it can be represented as a BN_get_word_APIParam_0
BN_get_word_APIName returns the value BN_get_word_APIParam_1, or all-bits-set if BN_get_word_APIParam_1 cannot be represented as a BN_get_word_APIParam_0
BN_zero_APIName, BN_one_APIName and BN_set_word_APIName return 1 on success, 0 otherwise
BN_value_one_APIName returns the constant
If a BN_get_word_APIParam_1 is equal to the value of all-bits-set, it will collide with the error condition returned by BN_get_word_APIName which uses that as an error value
BN_set_word_APIParam_2 should probably be a typedef
The EVP_PKEY_new_APIName function allocates an empty EVP_PKEY_new_APIParam_0 structure which is used by OpenSSL to store private keys
EVP_PKEY_free_APIName frees up the private key EVP_PKEY_free_APIParam_1
The EVP_PKEY_free_APIParam_1 structure is used by various OpenSSL functions which require a general private key without reference to any particular algorithm
The structure returned by EVP_PKEY_new_APIName is empty
To add a private key to this empty structure the functions described in EVP_PKEY_set1_RSA_APIName should be used
EVP_PKEY_new_APIName returns either the newly allocated EVP_PKEY_new_APIParam_0 structure of NULL if an error occurred
EVP_PKEY_free_APIName does not return a value
The behaviour of SSL_connect_APIName depends on the underlying BIO
The following return values can occur:
The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established
EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_derive_APIParam_1 EVP_PKEY_meth_get_signctx_APIParam_1 EVP_PKEY_meth_set_verify_APIParam_1 EVP_PKEY_meth_get_decrypt_APIParam_1 EVP_PKEY_meth_set_paramgen_APIParam_1 EVP_PKEY_meth_free_APIParam_1 EVP_PKEY_meth_get_sign_APIParam_1 EVP_PKEY_meth_set_derive_APIParam_1 EVP_PKEY_meth_get_encrypt_APIParam_1 EVP_PKEY_meth_get_verify_APIParam_1 EVP_PKEY_meth_copy_APIParam_1 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_set_signctx_APIParam_1 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_set_decrypt_APIParam_1 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 is a structure which holds a set of methods for a specific public key cryptographic algorithm
Those methods are usually used to perform different jobs, such as generating a key, signing or verifying, encrypting or decrypting, etc
There are two places where the EVP_PKEY_meth_add0_APIParam_1 objects are stored: one is a built-in static array representing the standard methods for different algorithms, and the other one is a stack of user-defined application-specific methods, which can be manipulated by using EVP_PKEY_meth_add0_APIName
The paramgen_init_APIName and paramgen_APIName methods deal with key parameter generation
The paramgen_init_APIName and paramgen_APIName methods are called by EVP_PKEY_paramgen_init_APIName and EVP_PKEY_paramgen_APIName to handle the parameter generation process
The keygen_init_APIName and keygen_APIName methods are used to generate the actual key for the specified algorithm
The keygen_init_APIName and keygen_APIName methods are called by EVP_PKEY_keygen_init_APIName and EVP_PKEY_keygen_APIName
The sign_init_APIName and sign_APIName methods are used to generate the signature of a piece of data using a private key
The sign_init_APIName and sign_APIName methods are called by EVP_PKEY_sign_init_APIName and EVP_PKEY_sign_APIName
The verify_init_APIName and verify_APIName methods are used to verify whether a signature is valid
The verify_init_APIName and verify_APIName methods are called by EVP_PKEY_verify_init_APIName and EVP_PKEY_verify_APIName
The verify_recover_init_APIName and verify_recover_APIName methods are used to verify a signature and then recover the digest from the signature (for instance, a signature that was generated by RSA signing algorithm)
The verify_recover_init_APIName and verify_recover_APIName methods are called by EVP_PKEY_verify_recover_init_APIName and EVP_PKEY_verify_recover_APIName
The encrypt_init_APIName and encrypt_APIName methods are used to encrypt a piece of data
The encrypt_init_APIName and encrypt_APIName methods are called by EVP_PKEY_encrypt_init_APIName and EVP_PKEY_encrypt_APIName
The decrypt_init_APIName and decrypt_APIName methods are used to decrypt a piece of data
The decrypt_init_APIName and decrypt_APIName methods are called by EVP_PKEY_decrypt_init_APIName and EVP_PKEY_decrypt_APIName
The derive_init_APIName and derive_APIName methods are used to derive the shared secret from a public key algorithm (for instance, the DH algorithm)
The derive_init_APIName and derive_APIName methods are called by EVP_PKEY_derive_init_APIName and EVP_PKEY_derive_APIName
The ctrl_APIName and ctrl_str_APIName methods are used to adjust algorithm-specific settings
See EVP_PKEY_CTX_ctrl_APIName and related functions for detail
The digestsign_APIName and digestverify_APIName methods are used to generate or verify a signature in a one-shot mode
The digestsign_APIName and digestverify_APIName methods could be called by EVP_DigetSign_APIName and EVP_DigestVerify_APIName
EVP_PKEY_meth_new_APIName creates and returns a new EVP_PKEY_meth_new_APIParam_0 object, and associates the given EVP_PKEY_meth_new_APIParam_1 and EVP_PKEY_meth_new_APIParam_2
The following flags are supported:
EVP_PKEY_meth_free_APIName frees an existing EVP_PKEY_meth_free_APIParam_1 pointed by EVP_PKEY_meth_free_APIParam_1
EVP_PKEY_meth_copy_APIName copies an EVP_PKEY_meth_copy_APIParam_1 object from EVP_PKEY_meth_copy_APIParam_2 to EVP_PKEY_meth_copy_APIParam_1
EVP_PKEY_meth_find_APIName finds an EVP_PKEY_meth_find_APIParam_0 object with the EVP_PKEY_meth_new_APIParam_1
This function first searches through the user-defined method objects and then the built-in objects
EVP_PKEY_meth_add0_APIName adds EVP_PKEY_meth_add0_APIParam_1 to the user defined stack of methods
The EVP_PKEY_meth_set functions set the corresponding fields of EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_derive_APIParam_1 EVP_PKEY_meth_get_signctx_APIParam_1 EVP_PKEY_meth_set_verify_APIParam_1 EVP_PKEY_meth_get_decrypt_APIParam_1 EVP_PKEY_meth_set_paramgen_APIParam_1 EVP_PKEY_meth_free_APIParam_1 EVP_PKEY_meth_get_sign_APIParam_1 EVP_PKEY_meth_set_derive_APIParam_1 EVP_PKEY_meth_get_encrypt_APIParam_1 EVP_PKEY_meth_get_verify_APIParam_1 EVP_PKEY_meth_copy_APIParam_1 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_set_signctx_APIParam_1 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_set_decrypt_APIParam_1 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 structure with the arguments passed
The EVP_PKEY_meth_get functions get the corresponding fields of EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_derive_APIParam_1 EVP_PKEY_meth_get_signctx_APIParam_1 EVP_PKEY_meth_set_verify_APIParam_1 EVP_PKEY_meth_get_decrypt_APIParam_1 EVP_PKEY_meth_set_paramgen_APIParam_1 EVP_PKEY_meth_free_APIParam_1 EVP_PKEY_meth_get_sign_APIParam_1 EVP_PKEY_meth_set_derive_APIParam_1 EVP_PKEY_meth_get_encrypt_APIParam_1 EVP_PKEY_meth_get_verify_APIParam_1 EVP_PKEY_meth_copy_APIParam_1 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_set_signctx_APIParam_1 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_set_decrypt_APIParam_1 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 structure to the arguments provided
EVP_PKEY_meth_new_APIName returns a pointer to a new EVP_PKEY_meth_new_APIParam_0 object or returns NULL on error
EVP_PKEY_meth_free_APIName and EVP_PKEY_meth_copy_APIName do not return values
EVP_PKEY_meth_find_APIName returns a pointer to the found EVP_PKEY_meth_find_APIParam_0 object or returns NULL if not found
EVP_PKEY_meth_add0_APIName returns 1 if method is added successfully or 0 if an error occurred
All EVP_PKEY_meth_set and EVP_PKEY_meth_get functions have no return values
For the 'get' functions, function pointers are returned by arguments
SSL_SESSION_free_APIName decrements the reference count of SSL_SESSION_free_APIParam_1 and removes the SSL_SESSION_free_APIParam_1 structure pointed to by SSL_SESSION_free_APIParam_1 and frees up the allocated memory, if the reference count has reached 0
SSL_SESSION objects are allocated, when a TLS/SSL handshake operation is successfully completed
Depending on the settings, see SSL_CTX_set_session_cache_mode_APIName , the SSL_SESSION objects are internally referenced by the SSL_CTX and linked into its session cache
SSL objects may be using the SSL_SESSION object; as a session may be reused, several SSL objects may be using one SSL_SESSION object at the same time
It is therefore crucial to keep the reference count (usage information) correct and not delete a SSL_SESSION object that is still used, as this may lead to program failures due to dangling pointers
These failures may also appear delayed, eg when an SSL_SESSION object was completely freed as the reference count incorrectly became 0, but it is still referenced in the internal session cache and the cache list is processed during a SSL_CTX_flush_sessions_APIName operation
SSL_SESSION_free_APIName must only be called for SSL_SESSION objects, for which the reference count was explicitly incremented (eg by calling SSL_get1_session_APIName, see SSL_get_session_APIName ) or when the SSL_SESSION object was generated outside a TLS handshake operation, eg by using d2i_SSL_SESSION_APIName
It must not be called on other SSL_SESSION objects, as this would cause incorrect reference counts and therefore program failures
SSL_SESSION_free_APIName does not provide diagnostic information
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure
SSL_get_ex_new_index_APIName is used to register a new index for application specific data
SSL_set_ex_data_APIName is used to store application data at SSL_set_ex_data_APIParam_3 for SSL_set_ex_data_APIParam_2 into the SSL_set_ex_data_APIParam_1 object
SSL_get_ex_data_APIName is used to retrieve the information for SSL_get_ex_data_APIParam_2 from SSL_get_ex_data_APIParam_1
SSL_get_rbio_APIName and SSL_get_wbio_APIName return pointers to the BIOs for the read or the write channel, which can be different
The reference count of the BIO is not incremented
The following return values can occur:
No BIO was connected to the SSL object
The BIO linked to SSL_get_wbio_APIParam_1 SSL_get_rbio_APIParam_1
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName set the key referenced by EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 to EVP_PKEY_set1_RSA_APIParam_2 EVP_PKEY_set1_DSA_APIParam_2 EVP_PKEY_set1_DH_APIParam_2 EVP_PKEY_set1_EC_KEY_APIParam_2
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key in EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 or NULL if the key is not of the correct type
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName, EVP_PKEY_assign_EC_KEY_APIName, EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName also set the referenced key to EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_POLY1305_APIParam_2 EVP_PKEY_assign_SIPHASH_APIParam_2 however these use the supplied EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_POLY1305_APIParam_2 EVP_PKEY_assign_SIPHASH_APIParam_2 internally and so EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_POLY1305_APIParam_2 EVP_PKEY_assign_SIPHASH_APIParam_2 will be freed when the parent EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_assign_POLY1305_APIParam_1 EVP_PKEY_assign_SIPHASH_APIParam_1 is freed
EVP_PKEY_get0_engine_APIName returns a reference to the ENGINE handling EVP_PKEY_get0_engine_APIParam_1
EVP_PKEY_set_alias_type_APIName allows modifying a EVP_PKEY to use a different set of algorithms than the default
This is currently used to support SM2 keys, which use an identical encoding to ECDSA
In accordance with the OpenSSL naming convention the key obtained from or assigned to the EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get0_DSA_APIParam_1 EVP_PKEY_set1_engine_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get0_poly1305_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set_alias_type_APIParam_1 EVP_PKEY_get0_DH_APIParam_1 EVP_PKEY_get0_engine_APIParam_1 EVP_PKEY_get0_siphash_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_id_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_get0_EC_KEY_APIParam_1 EVP_PKEY_base_id_APIParam_1 EVP_PKEY_assign_SIPHASH_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_POLY1305_APIParam_1 EVP_PKEY_get0_RSA_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_get0_hmac_APIParam_1 using the EVP_PKEY_assign_SIPHASH_APIParam_2 EVP_PKEY_assign_POLY1305_APIParam_2 functions must be freed as well as EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get0_DSA_APIParam_1 EVP_PKEY_set1_engine_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get0_poly1305_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set_alias_type_APIParam_1 EVP_PKEY_get0_DH_APIParam_1 EVP_PKEY_get0_engine_APIParam_1 EVP_PKEY_get0_siphash_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_id_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_get0_EC_KEY_APIParam_1 EVP_PKEY_base_id_APIParam_1 EVP_PKEY_assign_SIPHASH_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_POLY1305_APIParam_1 EVP_PKEY_get0_RSA_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_get0_hmac_APIParam_1
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName, EVP_PKEY_assign_EC_KEY_APIName, EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName are implemented as macros
Most applications wishing to know a key type will simply call EVP_PKEY_base_id_APIName and will not care about the actual type: which will be identical in almost all cases
Previous versions of this document suggested using EVP_PKEY_type(pkey->type) to determine the type of a key
Since EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get0_DSA_APIParam_1 EVP_PKEY_set1_engine_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get0_poly1305_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set_alias_type_APIParam_1 EVP_PKEY_get0_DH_APIParam_1 EVP_PKEY_get0_engine_APIParam_1 EVP_PKEY_get0_siphash_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_id_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_get0_EC_KEY_APIParam_1 EVP_PKEY_base_id_APIParam_1 EVP_PKEY_assign_SIPHASH_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_POLY1305_APIParam_1 EVP_PKEY_get0_RSA_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_get0_hmac_APIParam_1 is now opaque this is no longer possible: the equivalent is EVP_PKEY_base_id(pkey)
EVP_PKEY_set1_engine_APIName is typically used by an ENGINE returning an HSM key as part of its routine to load a private key
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName return 1 for success or 0 for failure
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key or NULL if an error occurred
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName, EVP_PKEY_assign_EC_KEY_APIName, EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName return 1 for success and 0 for failure
EVP_PKEY_set1_engine_APIName returns 1 for success and 0 for failure
EVP_PKEY_set_alias_type_APIName returns 1 for success and 0 for error
The ASN1_OBJECT allocation routines, allocate and free an ASN1_OBJECT structure, which represents an ASN1 OBJECT IDENTIFIER
ASN1_OBJECT_new_APIName allocates and initializes a ASN1_OBJECT structure
ASN1_OBJECT_free_APIName frees up the ASN1_OBJECT_free_APIParam_1 structure ASN1_OBJECT_free_APIParam_1
Although ASN1_OBJECT_new_APIName allocates a new ASN1_OBJECT structure, it is almost never used in applications
The ASN1 object utility functions such as OBJ_nid2obj_APIName are used instead
If the allocation fails, ASN1_OBJECT_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
ASN1_OBJECT_free_APIName returns no value
Several OpenSSL structures can have application specific data attached to them
This has several potential uses, it can be used to cache data associated with a structure (for example the hash of some part of the structure) or some additional data (for example a handle to the data in an external library)
Since the application data can be anything at all it is passed and retrieved as a RSA_set_ex_data_APIParam_3 CRYPTO_EX_free_APIParam_1 CRYPTO_EX_new_APIParam_1 RSA_get_ex_new_index_APIParam_2 CRYPTO_EX_dup_APIParam_3 type
On failure an error code can be obtained from ERR_get_error_APIName
These functions implement the Digital Signature Algorithm (DSA)
The generation of shared DSA parameters is described in DSA_generate_parameters_APIName ; DSA_generate_key_APIName describes how to generate a signature key
Signature generation and verification are described in DSA_sign_APIName
The DSA_size_APIParam_1 d2i_DSAPrivateKey_APIParam_1 d2i_DSAPublicKey_APIParam_1 d2i_DSA_SIG_APIParam_1 i2d_DSAparams_APIParam_1 DSA_set_default_method_APIParam_1 DSA_set_method_APIParam_1 i2d_DSA_SIG_APIParam_1 DSA_get_ex_data_APIParam_1 DSA_sign_setup_APIParam_1 DSA_free_APIParam_1 d2i_DSAparams_APIParam_1 DSAparams_print_fp_APIParam_2 DSA_set_ex_data_APIParam_1 DSA_print_APIParam_2 DSA_SIG_free_APIParam_1 DSA_dup_DH_APIParam_1 DSA_print_fp_APIParam_2 DSA_generate_key_APIParam_1 DSA_do_sign_APIParam_3 i2d_DSAPublicKey_APIParam_1 DSAparams_print_APIParam_2 i2d_DSAPrivateKey_APIParam_1 structure consists of several BIGNUM components
Note that DSA keys may use non-standard DSA_set_default_method_APIParam_1 DSA_set_method_APIParam_2 implementations, either directly or by the use of DSA_new_method_APIParam_1 modules
In some cases (eg an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage
For this reason, applications should generally avoid using DSA structure elements directly and instead use API functions to query or modify keys
The PRNG must be seeded prior to calling DSA_generate_key_APIName
DSA_generate_key_APIName returns 1 on success, 0 otherwise
The error codes can be obtained by ERR_get_error_APIName
These functions perform arithmetic operations on BIGNUMs with unsigned integers
These functions are much more efficient than the normal BIGNUM arithmetic operations
For BN_div_word_APIName and BN_mod_word_APIName, BN_div_word_APIParam_2 BN_mod_word_APIParam_2 must not be 0
BN_add_word_APIName, BN_sub_word_APIName and BN_mul_word_APIName return 1 for success, 0 on error
The error codes can be obtained by ERR_get_error_APIName
SSL_get_peer_cert_chain_APIName returns a pointer to STACK_OF(X509) certificates forming the certificate chain of the peer
If called on the client side, the stack also contains the peer's certificate; if called on the server side, the peer's certificate must be obtained separately using SSL_get_peer_certificate_APIName
If the peer did not present a certificate, NULL is returned
The peer certificate chain is not necessarily available after reusing a session, in which case a NULL pointer is returned
The reference count of the STACK_OF(X509) object is not incremented
If the corresponding session is freed, the pointer must not be used any longer
The following return values can occur:
No certificate was presented by the peer or no connection was established or the certificate chain is no longer available when a session is reused
The return value points to the certificate chain presented by the peer
An EC_POINT represents a point on a curve
A new point is constructed by calling the function EC_POINT_new and providing the EC_POINT_get_affine_coordinates_GF2m_APIParam_1 EC_POINT_get_affine_coordinates_GFp_APIParam_1 EC_POINT_get_Jprojective_coordinates_GFp_APIParam_1 EC_POINT_set_compressed_coordinates_GFp_APIParam_1 EC_POINT_set_compressed_coordinates_GF2m_APIParam_1 EC_POINT_set_Jprojective_coordinates_GFp_APIParam_1 EC_POINT_set_to_infinity_APIParam_1 EC_POINT_set_affine_coordinates_GF2m_APIParam_1 EC_POINT_point2oct_APIParam_1 EC_POINT_set_affine_coordinates_GFp_APIParam_1 EC_POINT_oct2point_APIParam_1 EC_POINT_new_APIParam_1 EC_POINT_dup_APIParam_2 object that the point relates to
EC_POINT_free frees the memory associated with the EC_POINT
EC_POINT_clear_free destroys any sensitive data held within the EC_POINT and then frees the EC_POINT memory
EC_POINT_copy copies the point EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 into EC_POINT_copy_APIParam_1
Both EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 and EC_POINT_copy_APIParam_1 must use the same EC_METHOD
EC_POINT_dup creates a new EC_POINT object and copies the content from EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 to the newly created EC_POINT object
EC_POINT_method_of obtains the EC_METHOD associated with EC_POINT_method_of_APIParam_1 EC_POINT_free_APIParam_1 EC_POINT_set_to_infinity_APIParam_2 EC_POINT_clear_free_APIParam_1
A valid point on a curve is the special point at infinity
A point is set to be at infinity by calling EC_POINT_set_to_infinity
As well as the affine co-ordinates, a point can alternatively be described in terms of its Jacobian projective co-ordinates (for Fp curves only)
Jacobian projective co-ordinates are expressed as three values x, y and z
Working in this co-ordinate system provides more efficient point multiplication operations
A mapping exists between Jacobian projective co-ordinates and affine co-ordinates
A Jacobian projective co-ordinate (x, y, z) can be written as an affine co-ordinate as (x/(z^2), y/(z^3))
Conversion to Jacobian projective to affine co-ordinates is simple
The co-ordinate (x, y) is mapped to (x, y, 1)
To set or get the projective co-ordinates use EC_POINT_set_Jprojective_coordinates_GFp and EC_POINT_get_Jprojective_coordinates_GFp respectively
In addition EC_POINTs can be converted to and from various external representations
Supported representations are octet strings, BIGNUMs and hexadecimal
Octet strings are stored in a buffer along with an associated buffer length
A point held in a BIGNUM is calculated by converting the point to an octet string and then converting that octet string into a BIGNUM integer
Points in hexadecimal format are stored in a NULL terminated character string where each character is one of the printable values 0-9 or A-F (or a-f)
The functions EC_POINT_point2oct, EC_POINT_oct2point, EC_POINT_point2bn, EC_POINT_bn2point, EC_POINT_point2hex and EC_POINT_hex2point convert from and to EC_POINTs for the formats: octet string, BIGNUM and hexadecimal respectively
The function EC_POINT_point2oct must be supplied with a buffer long enough to store the octet string
The return value provides the number of octets stored
Calling the function with a NULL buffer will not perform the conversion but will still return the required buffer length
The function EC_POINT_point2hex_APIName will allocate sufficient memory to store the hexadecimal string
It is the caller's responsibility to free this memory with a subsequent call to OPENSSL_free_APIName
EC_POINT_new and EC_POINT_dup return the newly allocated EC_POINT or NULL on error
The following functions return 1 on success or 0 on error: EC_POINT_copy, EC_POINT_set_to_infinity, EC_POINT_set_Jprojective_coordinates_GFp, EC_POINT_get_Jprojective_coordinates_GFp, EC_POINT_set_affine_coordinates_GFp, EC_POINT_get_affine_coordinates_GFp, EC_POINT_set_compressed_coordinates_GFp, EC_POINT_set_affine_coordinates_GF2m, EC_POINT_get_affine_coordinates_GF2m, EC_POINT_set_compressed_coordinates_GF2m and EC_POINT_oct2point
EC_POINT_method_of returns the EC_METHOD associated with the supplied EC_POINT
EC_POINT_point2oct returns the length of the required buffer, or 0 on error
EC_POINT_point2bn returns the pointer to the BIGNUM supplied, or NULL on error
EC_POINT_bn2point returns the pointer to the EC_POINT supplied, or NULL on error
EC_POINT_point2hex returns a pointer to the hex string, or NULL on error
EC_POINT_hex2point returns the pointer to the EC_POINT supplied, or NULL on error
SSL_new_APIName creates a new SSL_new_APIParam_1 structure which is needed to hold the data for a TLS/SSL connection
The new structure inherits the settings of the underlying context SSL_new_APIParam_1: connection method (SSLv2/v3/TLSv1), options, verification settings, timeout settings
The following return values can occur:
The creation of a new SSL structure failed
Check the error stack to find out the reason
The return value points to an allocated SSL structure
X509_NAME_print_ex_APIName prints a human readable version of X509_NAME_print_ex_APIParam_2 to BIO X509_NAME_print_ex_APIParam_1
Each line (for multiline formats) is indented by X509_NAME_print_ex_APIParam_3 spaces
The output format can be extensively customised by use of the X509_NAME_print_ex_APIParam_4 parameter
X509_NAME_print_ex_fp_APIName is identical to X509_NAME_print_ex_APIName except the output is written to FILE pointer X509_NAME_print_ex_fp_APIParam_1
X509_NAME_oneline_APIName prints an ASCII version of X509_NAME_oneline_APIParam_1 to X509_NAME_oneline_APIParam_2
If X509_NAME_oneline_APIParam_2 is NULL, then a buffer is dynamically allocated and returned, and X509_NAME_oneline_APIParam_3 is ignored
Otherwise, at most X509_NAME_oneline_APIParam_3 bytes will be written, including the ending '\\0', and X509_NAME_oneline_APIParam_2 is returned
X509_NAME_print_APIName prints out X509_NAME_print_APIParam_2 to X509_NAME_print_APIParam_1 indenting each line by X509_NAME_print_APIParam_3 characters
Multiple lines are used if the output (including indent) exceeds 80 characters
The functions X509_NAME_oneline_APIName and X509_NAME_print_APIName are legacy functions which produce a non standard output form, they don't handle multi character fields and have various quirks and inconsistencies
Their use is strongly discouraged in new applications
The complete set of the flags supported by X509_NAME_print_ex_APIName is listed below
Several options can be ored together
Additionally all the options supported by ASN1_STRING_print_ex_APIName can be used to control how each field value is displayed
In addition a number options can be set for commonly used formats
Initially, the default RSA_METHOD is the OpenSSL internal implementation, as returned by RSA_PKCS1_SSLeay_APIName
RSA_get_default_method_APIName returns a pointer to the current default RSA_METHOD
However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended
RSA_set_method_APIName selects RSA_set_method_APIParam_2 to perform all operations using the key RSA_set_method_APIParam_1
This will replace the RSA_METHOD used by the RSA key and if the previous method was supplied by an ENGINE, the handle to that ENGINE will be released during the change
It is possible to have RSA keys that only work with certain RSA_METHOD implementations (eg from an ENGINE module that supports embedded hardware-protected keys), and in such cases attempting to change the RSA_METHOD for the key can have unexpected results
RSA_get_method_APIName returns a pointer to the RSA_METHOD being used by RSA_get_method_APIParam_1 RSA_set_method_APIParam_1
This method may or may not be supplied by an ENGINE implementation, but if it is, the return value can only be guaranteed to be valid as long as the RSA key itself is valid and does not have its implementation changed by RSA_set_method_APIName
RSA_new_method_APIName allocates and initializes an RSA_new_method_APIParam_1 structure so that RSA_new_method_APIParam_1 will be used for the RSA operations
If RSA_new_method_APIParam_1 is NULL, the default method is used
RSA_PKCS1_SSLeay_APIName, RSA_PKCS1_null_method_APIName, RSA_get_default_method_APIName and RSA_get_method_APIName return pointers to the respective RSA_METHODs
RSA_set_default_method_APIName returns no value
RSA_set_method_APIName returns a pointer to the old RSA_METHOD implementation that was replaced
However, this return value should probably be ignored because if it was supplied by an ENGINE, the pointer could be invalidated at any time if the ENGINE is unloaded (in fact it could be unloaded as a result of the RSA_set_method_APIName function releasing its handle to the ENGINE)
For this reason, the return type may be replaced with a RSA_get_default_method_APIParam_1 RSA_null_method_APIParam_1 RSA_PKCS1_SSLeay_APIParam_1 declaration in a future release
RSA_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails
Otherwise it returns a pointer to the newly allocated structure
PKCS12_parse_APIName parses a PKCS12 structure
PKCS12_parse_APIName returns 1 for success and zero if an error occurred
The error can be obtained from ERR_get_error_APIName
Only a single private key and corresponding certificate is returned by this function
More complex PKCS#12 files with multiple private keys will only return the first match
Attributes currently cannot be stored in the private key PKCS12_parse_APIParam_3 structure
The only currently supported compression algorithm is zlib using the NID NID_zlib_compression
If zlib support is not compiled into OpenSSL ,then CMS_compress_APIName will return an error
CMS_compress_APIName returns either a CMS_ContentInfo structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
The EVP_PKEY_derive_set_peer_APIName function sets the peer key: this will normally be a public key
The EVP_PKEY_derive_APIName derives a shared secret using EVP_PKEY_derive_APIParam_1
If EVP_PKEY_derive_APIParam_2 is NULL ,then the maximum size of the output buffer is written to the EVP_PKEY_derive_APIParam_3 parameter
If EVP_PKEY_derive_APIParam_2 is not NULL ,then before the call the EVP_PKEY_derive_APIParam_3 parameter should contain the length of the EVP_PKEY_derive_APIParam_2 buffer, if the call is successful ,the shared secret is written to EVP_PKEY_derive_APIParam_2 and the amount of data written to EVP_PKEY_derive_APIParam_3
After the call to EVP_PKEY_derive_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The function EVP_PKEY_derive_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_derive_init_APIName and EVP_PKEY_derive_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
BIO_next_APIName returns the next BIO in a chain
It can be used to traverse all BIOs in a chain or used in conjunction with BIO_find_type_APIName to find all BIOs of a certain type
BIO_method_type_APIName returns the type of a BIO
BIO_find_type_APIName returns a matching BIO or NULL for no match
BIO_next_APIName returns the next BIO in a chain
BIO_method_type_APIName returns the type of the BIO BIO_find_type_APIParam_1 BIO_next_APIParam_1
BIO_next_APIName was added to OpenSSL 0.9.6 to provide a 'clean' way to traverse a BIO chain or find multiple matches using BIO_find_type_APIName
Previous versions had to use:
BIO_find_type_APIName in OpenSSL 0.9.5a and earlier could not be safely passed a NULL pointer for the BIO_find_type_APIParam_1 argument
Query, whether a reused session was negotiated during the handshake
During the negotiation, a client can propose to reuse a session
The server then looks up the session in its cache
If both client and server agree on the session, it will be reused and a flag is being set that can be queried by the application
The following return values can occur:
A new session was negotiated
A session was reused
ERR_error_string_APIName generates a human-readable string representing the error code ERR_error_string_APIParam_1 ERR_error_string_n_APIParam_1 ERR_error_string_APIParam_1 ERR_error_string_n_APIParam_1, and places it at ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2
ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 must be at least 120 bytes long
If ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 is NULL, the error string is placed in a static buffer
ERR_error_string_n_APIName is a variant of ERR_error_string_APIName that writes at most ERR_error_string_n_APIParam_3 ERR_error_string_n_APIParam_3 characters (including the terminating 0) and truncates the string if necessary
For ERR_error_string_n_APIName, ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 may not be NULL
The string will have the following format:
ERR_lib_error_string_APIName, ERR_func_error_string_APIName and ERR_reason_error_string_APIName return the library name, function name and reason string respectively
The OpenSSL error strings should be loaded by calling ERR_load_crypto_strings_APIName or, for SSL applications, SSL_load_error_strings_APIName first
If there is no text string registered for the given error code, the error string will contain the numeric code
ERR_print_errors_APIName can be used to print all error codes currently in the queue
ERR_lib_error_string_APIName, ERR_func_error_string_APIName and ERR_reason_error_string_APIName return the strings, and NULL if none is registered for the error code
SSL_CTX_set_max_cert_list_APIName sets the maximum size allowed for the peer's certificate chain for all SSL objects created from SSL_CTX_set_max_cert_list_APIParam_1 to be <size> bytes
The SSL objects inherit the setting valid for SSL_CTX_set_max_cert_list_APIParam_1 at the time SSL_new_APIName is being called
SSL_CTX_get_max_cert_list_APIName returns the currently set maximum size for SSL_CTX_get_max_cert_list_APIParam_1
SSL_set_max_cert_list_APIName sets the maximum size allowed for the peer's certificate chain for SSL_set_max_cert_list_APIParam_1 to be <size> bytes
This setting stays valid until a new value is set
SSL_get_max_cert_list_APIName returns the currently set maximum size for SSL_set_max_cert_list_APIParam_1
During the handshake process, the peer may send a certificate chain
The TLS/SSL standard does not give any maximum size of the certificate chain
The OpenSSL library handles incoming data by a dynamically allocated buffer
In order to prevent this buffer from growing without bounds due to data received from a faulty or malicious peer, a maximum size for the certificate chain is set
The default value for the maximum certificate chain size is 100kB (30kB on the 16bit DOS platform)
This should be sufficient for usual certificate chains (OpenSSL's default maximum chain length is 10, see SSL_CTX_set_verify_APIName , and certificates without special extensions have a typical size of 1-2kB)
For special applications it can be necessary to extend the maximum certificate chain size allowed to be sent by the peer, see eg the work on "Internet X.509 Public Key Infrastructure Proxy Certificate Profile" and "TLS Delegation Protocol" at http://www.ietf.org/ and http://www.globus.org/
Under normal conditions it should never be necessary to set a value smaller than the default, as the buffer is handled dynamically and only uses the memory actually required by the data sent by the peer
If the maximum certificate chain size allowed is exceeded, the handshake will fail with a SSL_R_EXCESSIVE_MESSAGE_SIZE error
SSL_CTX_set_max_cert_list_APIName and SSL_set_max_cert_list_APIName return the previously set value
SSL_CTX_get_max_cert_list_APIName and SSL_get_max_cert_list_APIName return the currently set value
The RSA_padding_xxx_xxx_APIName functions are called from the RSA encrypt, decrypt, sign and verify functions
Normally The RSA_padding_xxx_xxx_APIName functions should not be called from application programs
The following encoding methods are implemented:
PKCS #1 v2.0 EMSA-PKCS1-v1_5 (PKCS #1 v1.5 block type 1); used for signatures
PKCS #1 v2.0 EME-PKCS1-v1_5 (PKCS #1 v1.5 block type 2)
PKCS #1 v2.0 EME-OAEP
PKCS #1 EME-PKCS1-v1_5 with SSL-specific modification
simply copy the data
The random number generator must be seeded prior to calling RSA_padding_add_xxx_APIName
The RSA_padding_add_xxx_APIName functions return 1 on success, 0 on error
The RSA_padding_check_xxx_APIName functions return the length of the recovered data, -1 on error
Error codes can be obtained by calling ERR_get_error_APIName
DH_generate_parameters_ex_APIName generates Diffie-Hellman parameters that can be shared among a group of users, and stores them in the provided DH_generate_parameters_ex_APIParam_1 structure
The pseudo-random number generator must be seeded prior to calling DH_generate_parameters_APIName
DH_generate_parameters_ex_APIParam_2 is the length in bits of the safe prime to be generated
DH_generate_parameters_ex_APIParam_3 is a small number > 1, typically 2 or 5
DH_generate_parameters_ex_APIName and DH_check_APIName return 1 if the check could be performed, 0 otherwise
DH_generate_parameters_APIName (deprecated) returns a pointer to the DH structure, or NULL if the parameter generation fails
The error codes can be obtained by ERR_get_error_APIName
DH_generate_parameters_ex_APIName and DH_generate_parameters_APIName may run for several hours before finding a suitable prime
The parameters generated by DH_generate_parameters_ex_APIName and DH_generate_parameters_APIName are not to be used in signature schemes
OPENSSL_Applink is application-side interface which provides a glue between OpenSSL BIO layer and Win32 compiler run-time environment
Even though it appears at application side, it's essentially OpenSSL private interface
For this reason application developers are not expected to implement it, but to compile provided module with compiler of their choice and link it into the target application
The referred module is available as <openssl>/ms/applink.c
These functions implement the Diffie-Hellman key agreement protocol
The generation of shared DH parameters is described in DH_generate_parameters_APIName ; DH_generate_key_APIName describes how to perform a key agreement
The DH_check_APIParam_1 DH_set_method_APIParam_1 DH_get_ex_data_APIParam_1 i2d_DHparams_APIParam_1 DH_generate_key_APIParam_1 DH_set_ex_data_APIParam_1 DH_compute_key_APIParam_3 DH_free_APIParam_1 DHparams_print_APIParam_2 DH_set_default_method_APIParam_1 DH_size_APIParam_1 d2i_DHparams_APIParam_1 DHparams_print_fp_APIParam_2 structure consists of several BIGNUM components
Note that DH keys may use non-standard DH_set_method_APIParam_2 DH_set_default_method_APIParam_1 implementations, either directly or by the use of DH_new_method_APIParam_1 modules
In some cases (eg an ENGINE providing support for hardware-embedded keys), these BIGNUM values will not be used by the implementation or may be used for alternative data storage
For this reason, applications should generally avoid using DH structure elements directly and instead use API functions to query or modify keys
The behaviour of SSL_accept_APIName depends on the underlying BIO
The following return values can occur:
The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established
OBJ_nid2obj_APIName, OBJ_nid2ln_APIName and OBJ_nid2sn_APIName convert the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 to an ASN1_OBJECT structure, the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 long name and the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 short name respectively, or NULL if an error occurred
OBJ_obj2nid_APIName, OBJ_ln2nid_APIName, OBJ_sn2nid_APIName return the corresponding NID for the object OBJ_obj2nid_APIParam_1, the long name <ln> or the short name <sn> respectively or NID_undef if an error occurred
OBJ_txt2nid_APIName returns NID corresponding to text string <s>
OBJ_txt2nid_APIParam_1 can be a long name, a short name or the numerical respresentation of an object
OBJ_txt2obj_APIName converts the text string OBJ_txt2obj_APIParam_1 into an ASN1_OBJECT structure
If OBJ_txt2obj_APIParam_2 is 0 ,then long names and short names will be interpreted as well as numerical forms
If OBJ_txt2obj_APIParam_2 is 1 ,only the numerical form is acceptable
OBJ_obj2txt_APIName converts the OBJ_obj2txt_APIParam_3 OBJ_obj2txt_APIParam_3 into a textual representation
The representation is written as a null terminated string to OBJ_obj2txt_APIParam_1 at most OBJ_obj2txt_APIParam_2 bytes are written, truncating the result if necessary
The total amount of space required is returned
If OBJ_obj2txt_APIParam_4 is 0 then if the object has a long or short name then that will be used, otherwise the numerical form will be used
If OBJ_obj2txt_APIParam_4 is 1 ,then the numerical form will always be used
OBJ_cmp_APIName compares OBJ_cmp_APIParam_1 to OBJ_cmp_APIParam_2
If the two are identical 0 is returned
OBJ_dup_APIName returns a copy of OBJ_dup_APIParam_1
OBJ_create_APIName adds a new object to the internal table
OBJ_create_APIParam_1 is the numerical form of the object, OBJ_create_APIParam_2 the short name and OBJ_create_APIParam_3 the long name
A new NID is returned for the created object
OBJ_cleanup_APIName cleans up OpenSSLs internal object table: this should be called before an application exits if any new objects were added using OBJ_create_APIName
For example the OID for commonName has the following definitions:
New objects can be added by calling OBJ_create_APIName
Table objects have certain advantages over other objects: for example their NIDs can be used in a C language switch statement
They are also static constant structures which are shared: that is there is only a single constant structure for each table object
Objects which are not in the table have the NID value NID_undef
Objects do not need to be in the internal tables to be processed, the functions OBJ_txt2obj_APIName and OBJ_obj2txt_APIName can process the numerical form of an OID
These functions cannot return OBJ_cmp_APIParam_1 OBJ_obj2txt_APIParam_3 OBJ_create_APIParam_1 OBJ_ln2nid_APIParam_1 OBJ_sn2nid_APIParam_1 because an OBJ_cmp_APIParam_1 OBJ_obj2nid_APIParam_1 OBJ_obj2txt_APIParam_3 OBJ_dup_APIParam_1 can represent both an internal, constant, OID and a dynamically-created one
The latter cannot be constant because it needs to be freed after use
OBJ_obj2txt_APIName is awkward and messy to use: OBJ_obj2txt_APIName doesn't follow the convention of other OpenSSL functions where the buffer can be set to NULL to determine the amount of data that should be written
Instead OBJ_obj2txt_APIParam_1 must point to a valid buffer and OBJ_obj2txt_APIParam_2 should be set to a positive value
A buffer length of 80 should be more than enough to handle any OID encountered in practice
OBJ_nid2obj_APIName returns an OBJ_nid2obj_APIParam_0 structure or NULL is an error occurred
OBJ_nid2obj_APIName returns a pointer to an internal table and does not allocate memory; ASN1_OBJECT_free_APIName will have no effect
OBJ_nid2ln_APIName and OBJ_nid2sn_APIName returns a valid string or NULL on error
X509_STORE_set_verify_cb_func_APIName also sets the verification callback but X509_STORE_set_verify_cb_func_APIName is implemented as a macro
The macro version of this function was the only one available before OpenSSL 1.0.0
X509_STORE_set_verify_cb_APIName and X509_STORE_set_verify_cb_func_APIName do not return a value
MDC2 is a method to construct hash functions with 128 bit output from block ciphers
These functions are an implementation of MDC2 with DES
MDC2_APIName computes the MDC2 message digest of the MDC2_APIParam_2 bytes at MDC2_APIParam_1 and places it in MDC2_Final_APIParam_1 (which must have space for MDC2_DIGEST_LENGTH == 16 bytes of output)
If MDC2_Final_APIParam_1 is NULL, the digest is placed in a static array
The following functions may be used if the message is not completely stored in memory:
MDC2_Init_APIName initializes a MDC2_Init_APIParam_1 structure
MDC2_Final_APIName places the message digest in MDC2_Final_APIParam_1, which must have space for MDC2_DIGEST_LENGTH == 16 bytes of output, and erases the MDC2_Final_APIParam_2
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly
MDC2_APIName returns a pointer to the hash value
MDC2_Init_APIName, MDC2_Update_APIName and MDC2_Final_APIName return 1 for success, 0 otherwise
DSA_SIG_new_APIName allocates and initializes a DSA_SIG_new_APIParam_0 structure
DSA_SIG_free_APIName frees the DSA_SIG_free_APIParam_1 structure and its components
The values are erased before the memory is returned to the system
If the allocation fails, DSA_SIG_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
DSA_SIG_free_APIName returns no value
SSL_CTX_add_session_APIName adds the session SSL_CTX_add_session_APIParam_2 to the context SSL_CTX_add_session_APIParam_1
The reference count for session SSL_CTX_add_session_APIParam_2 is incremented by 1
If a session with the same session id already exists, the old session is removed by calling SSL_SESSION_free_APIName
SSL_CTX_remove_session_APIName removes the session SSL_CTX_remove_session_APIParam_2 from the context SSL_CTX_remove_session_APIParam_1
SSL_SESSION_free_APIName is called once for SSL_CTX_remove_session_APIParam_2
SSL_add_session_APIName and SSL_remove_session_APIName are synonyms for their SSL_CTX_*_APIName counterparts
When adding a new session to the internal session cache, it is examined whether a session with the same session id already exists
In this case it is assumed that both sessions are identical
If the same session is stored in a different SSL_SESSION object, The old session is removed and replaced by the new session
If the session is actually identical (the SSL_SESSION object is identical), SSL_CTX_add_session_APIName is a no-op, and the return value is 0
If a server SSL_CTX is configured with the SSL_SESS_CACHE_NO_INTERNAL_STORE flag ,then the internal cache will not be populated automatically by new sessions negotiated by the SSL/TLS implementation, even though the internal cache will be searched automatically for session-resume requests (the latter can be suppressed by SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)
So the application can use SSL_CTX_add_session_APIName directly to have full control over the sessions that can be resumed if desired
The following values are returned by all functions:
ERR_get_error_APIName returns the earliest error code from the thread's error queue and removes the entry
This function can be called repeatedly until there are no more error codes to return
ERR_peek_error_APIName returns the earliest error code from the thread's error queue without modifying it
ERR_peek_last_error_APIName returns the latest error code from the thread's error queue without modifying it
See ERR_GET_LIB_APIName for obtaining information about location and reason of the error, and ERR_error_string_APIName for human-readable error messages
ERR_get_error_line_APIName, ERR_peek_error_line_APIName and ERR_peek_last_error_line_APIName are the same as the above, but ERR_get_error_line_APIName, ERR_peek_error_line_APIName and ERR_peek_last_error_line_APIName additionally store the file name and line number where the error occurred in *ERR_get_error_line_APIParam_1 ERR_peek_error_line_APIParam_1 ERR_peek_last_error_line_APIParam_1 and *ERR_get_error_line_APIParam_2 ERR_peek_error_line_APIParam_2 ERR_peek_last_error_line_APIParam_2, unless these are NULL
The error code, or 0 if there is no error in the queue
The EVP envelope routines are a high level interface to envelope encryption
They generate a random key and IV (if required) then "envelope" it by using public key encryption
Data can then be encrypted using this key
EVP_SealUpdate_APIName and EVP_SealFinal_APIName have exactly the same properties as the EVP_EncryptUpdate_APIName and EVP_EncryptFinal_APIName routines, as documented on the EVP_EncryptInit_APIName manual page
EVP_SealUpdate_APIName and EVP_SealFinal_APIName return 1 for success and 0 for failure
Because a random secret key is generated, the random number generator must be seeded before calling EVP_SealInit_APIName
The public key must be RSA because it is the only OpenSSL public key algorithm that supports key transport
Envelope encryption is the usual method of using public key encryption on large amounts of data, this is because public key encryption is slow but symmetric encryption is fast
So symmetric encryption is used for bulk encryption and the small random symmetric key used is transferred using public key encryption
The BIO_new_APIName function returns a new BIO using method BIO_new_APIParam_1
BIO_set_APIName sets the method of an already existing BIO
BIO_free_APIName frees up a single BIO, BIO_vfree_APIName also frees up a single BIO but it does not return a value
Calling BIO_free_APIName may also have some effect on the underlying I/O structure, for example it may close the file being referred to under certain circumstances
For more details see the individual BIO_METHOD descriptions
BIO_free_all_APIName frees up an entire BIO chain, it does not halt if an error occurs freeing up an individual BIO in the chain
BIO_new_APIName returns a newly created BIO or NULL if the call fails
BIO_set_APIName, BIO_free_APIName return 1 for success and 0 for failure
BIO_free_all_APIName and BIO_vfree_APIName do not return values
Some BIOs (such as memory BIOs) can be used immediately after calling BIO_new_APIName
Others (such as file BIOs) need some additional initialization, and frequently a utility function exists to create and initialize such BIOs
If BIO_free_APIName is called on a BIO chain, it will only free one BIO resulting in a memory leak
Calling BIO_free_all_APIName a single BIO has the same effect as calling BIO_free_APIName on it other than the discarded return value
Normally the BIO_new_APIParam_1 BIO_set_APIParam_2 argument is supplied by a function which returns a pointer to a BIO_METHOD
There is a naming convention for such functions: a source/sink BIO is normally called BIO_s_*_APIName and a filter BIO BIO_f_*_APIName;
UI stands for User Interface, and is general purpose set of routines to prompt the user for text-based information
Through user-written methods (see ui_create_APIName ), prompting can be done in any way imaginable, be it plain text prompting, through dialog boxes or from a cell phone
All the functions work through a context of the type UI
This context contains all the information needed to prompt correctly as well as a reference to a UI_METHOD, which is an ordered vector of functions that carry out the actual prompting
The first thing to do is to create a UI with UI_new_APIName or UI_new_method_APIName, then add information to it with the UI_add or UI_dup functions
Also, user-defined random data can be passed down to the underlying method through calls to UI_add_user_data
The default UI method doesn't care about these data, but other methods might
Finally, use UI_process_APIName to actually perform the prompting and UI_get0_result_APIName to find the result to the prompt
A UI can contain more than one prompt, which are performed in the given sequence
Each prompt gets an index number which is returned by the UI_add and UI_dup functions, and has to be used to get the corresponding result with UI_get0_result_APIName
The functions are as follows:
UI_new_APIName creates a new UI using the default UI method
When done with this UI, it should be freed using UI_free_APIName
UI_new_method_APIName creates a new UI using the given UI method
When done with this UI, it should be freed using UI_free_APIName
UI_OpenSSL_APIName returns the built-in UI method (note: not the default one, since the default can be changed
See further on)
This method is the most machine/OS dependent part of OpenSSL and normally generates the most problems when porting
UI_free_APIName removes a UI from memory, along with all other pieces of memory that's connected to it, like duplicated input strings, results and others
UI_add_input_string_APIName and UI_add_verify_string_APIName add a prompt to the UI, as well as flags and a result buffer and the desired minimum and maximum sizes of the result, not counting the final NUL character
The given information is used to prompt for information, for example a password, and to verify a password (ie having the user enter it twice and check that the same string was entered twice)
UI_add_verify_string_APIName takes and extra argument that should be a pointer to the result buffer of the input string that it's supposed to verify, or verification will fail
UI_add_input_boolean_APIName adds a prompt to the UI that's supposed to be answered in a boolean way, with a single character for yes and a different character for no
A set of characters that can be used to cancel the prompt is given as well
The prompt itself is divided in two, one part being the descriptive text (given through the UI_add_input_boolean_APIParam_2 argument) and one describing the possible answers (given through the UI_add_input_boolean_APIParam_3 argument)
UI_add_info_string_APIName and UI_add_error_string_APIName add strings that are shown at the same time as the prompt for extra information or to show an error string
The difference between the two is only conceptual
With the builtin method, there's no technical difference between them
Other methods may make a difference between them, however
The flags currently supported are UI_INPUT_FLAG_ECHO, which is relevant for UI_add_input_string_APIName and will have the users response be echoed (when prompting for a password, this flag should obviously not be used, and UI_INPUT_FLAG_DEFAULT_PWD, which means that a default password of some sort will be used (completely depending on the application and the UI method)
UI_dup_input_string_APIName, UI_dup_verify_string_APIName, UI_dup_input_boolean_APIName, UI_dup_info_string_APIName and UI_dup_error_string_APIName are basically the same as their UI_add counterparts, except that they make their own copies of all strings
UI_add_user_data_APIName adds a piece of memory for the method to use at any time
The builtin UI method doesn't care about this info
Note that several calls to this function doesn't add data, it replaces the previous blob with the one given as argument
UI_get0_user_data_APIName retrieves the data that has last been given to the UI with UI_add_user_data_APIName
UI_get0_result_APIName returns a pointer to the result buffer associated with the information indexed by UI_get0_result_APIParam_2
UI_process_APIName goes through the information given so far, does all the printing and prompting and returns
UI_ctrl_APIName adds extra control for the application author
For now, it understands two commands: UI_CTRL_PRINT_ERRORS, which makes UI_process_APIName print the OpenSSL error stack as part of processing the UI, and UI_CTRL_IS_REDOABLE, which returns a flag saying if the used UI can be used again or not
UI_set_default_method_APIName changes the default UI method to the one given
UI_get_default_method_APIName returns a pointer to the current default UI method
UI_get_method_APIName returns the UI method associated with a given UI
UI_set_method_APIName changes the UI method associated with a given UI
SSL_CTX_set_ssl_version_APIName sets a new default TLS/SSL SSL_CTX_set_ssl_version_APIParam_2 for SSL objects newly created from this SSL_CTX_set_ssl_version_APIParam_1
SSL objects already created with SSL_new_APIName are not affected, except when SSL_clear_APIName is being called
SSL_set_ssl_method_APIName sets a new TLS/SSL SSL_set_ssl_method_APIParam_2 for a particular SSL_get_ssl_method_APIParam_1 object
It may be reset, when SSL_clear_APIName is called
SSL_get_ssl_method_APIName returns a function pointer to the TLS/SSL method set in SSL_get_ssl_method_APIParam_1
The available SSL_set_ssl_method_APIParam_2 SSL_CTX_set_ssl_version_APIParam_2 choices are described in SSL_CTX_new_APIName
When SSL_clear_APIName is called and no session is connected to an SSL object, the method of the SSL object is reset to the method currently set in the corresponding SSL_CTX object
The following return values can occur for SSL_CTX_set_ssl_version_APIName and SSL_set_ssl_method_APIName:
The new choice failed, check the error stack to find out the reason
The operation succeeded
BN_cmp_APIName compares the numbers BN_cmp_APIParam_1 BN_ucmp_APIParam_1 and BN_cmp_APIParam_2 BN_ucmp_APIParam_2
BN_ucmp_APIName compares their absolute values
BN_is_zero_APIName, BN_is_one_APIName and BN_is_word_APIName test if BN_is_zero_APIParam_1 BN_is_one_APIParam_1 BN_is_word_APIParam_1 BN_is_odd_APIParam_1 equals 0, 1, or BN_is_word_APIParam_2 respectively
BN_is_odd_APIName tests if a is odd
BN_is_zero_APIName, BN_is_one_APIName, BN_is_word_APIName and BN_is_odd_APIName are macros
BN_cmp_APIName returns -1 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 < BN_cmp_APIParam_2 BN_ucmp_APIParam_2, 0 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 == BN_cmp_APIParam_2 BN_ucmp_APIParam_2 and 1 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 > BN_cmp_APIParam_2 BN_ucmp_APIParam_2
BN_ucmp_APIName is the same using the absolute values of BN_cmp_APIParam_1 BN_ucmp_APIParam_1 and BN_cmp_APIParam_2 BN_ucmp_APIParam_2
BN_is_zero_APIName, BN_is_one_APIName BN_is_word_APIName and BN_is_odd_APIName return 1 if the condition is true, 0 otherwise
These functions handle RSA signatures at a low level
RSA_private_encrypt_APIName returns the size of the signature (ie, RSA_size(rsa))
RSA_public_decrypt_APIName returns the size of the recovered message digest
On error, -1 is returned; the error codes can be obtained by ERR_get_error_APIName
SSL_check_chain_APIName returns a bitmap of flags indicating the validity of the chain
SSL_check_chain_APIName must be called in servers after a client hello message or in clients after a certificate request message
It will typically be called in the certificate callback
An application wishing to support multiple certificate chains may call this function on each chain in turn: starting with the one it considers the most secure
It could then use the chain of the first set which returns suitable flags
The validity of a chain is determined by checking if it matches a supported signature algorithm, supported curves and in the case of client authentication certificate types and issuer names
Since the supported signature algorithms extension is only used in TLS 1.2 and DTLS 1.2 the results for earlier versions of TLS and DTLS may not be very useful
Applications may wish to specify a different "legacy" chain for earlier versions of TLS or DTLS
SSL_CONF_cmd_value_type_APIName returns the type of value that SSL_CONF_cmd_value_type_APIParam_2 refers to
The function SSL_CONF_finish_APIName must be called after all configuration operations have been completed
The function SSL_CONF_finish_APIName is used to finalise any operations or to process defaults
The order of operations is significant
This can be used to set either defaults or values which cannot be overridden
For example if an application calls:
it will disable SSLv3 support by default but the user can override it
If however the call sequence is:
By checking the return code of SSL_CTX_cmd_APIName it is possible to query if a given SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is recognised, this is useful is SSL_CTX_cmd_APIName values are mixed with additional application specific operations
For example an application might call SSL_CTX_cmd_APIName and if it returns -2 (unrecognised command) continue with processing of application specific commands
Applications can also use SSL_CTX_cmd_APIName to process command lines though the utility function SSL_CTX_cmd_argv_APIName is normally used instead
One way to do this is to set the prefix to an appropriate value using SSL_CONF_CTX_set1_prefix_APIName, pass the current argument to SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 and the following argument to SSL_CONF_cmd_APIParam_3 (which may be NULL)
In this case if the return value is positive then it is used to skip that number of arguments as they have been processed by SSL_CTX_cmd_APIName
If -2 is returned ,then SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is not recognised and application specific arguments can be checked instead
If -3 is returned ,a required argument is missing and an error is indicated
If 0 is returned ,some other error occurred and this can be reported back to the user
A return value of -2 means SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is not recognised
A return value of -3 means SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is recognised and the command requires a value but SSL_CONF_cmd_APIParam_3 is NULL
A return code of 0 indicates that both SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 and SSL_CONF_cmd_APIParam_3 are valid but an error occurred attempting to perform the operation: for example due to an error in the syntax of SSL_CONF_cmd_APIParam_3 in this case the error queue may provide additional information
SSL_CONF_finish_APIName returns 1 for success and 0 for failure
SSL_get_peer_certificate_APIName returns a pointer to the X509 certificate the peer presented
If the peer did not present a certificate, NULL is returned
Due to the protocol definition, a TLS/SSL server will always send a certificate, if present
A client will only send a certificate when explicitly requested to do so by the server (see SSL_CTX_set_verify_APIName )
If an anonymous cipher is used, no certificates are sent
That a certificate is returned does not indicate information about the verification state, use SSL_get_verify_result_APIName to check the verification state
The reference count of the X509 object is incremented by one, so that it will not be destroyed when the session containing the peer certificate is freed
The X509 object must be explicitly freed using X509_free_APIName
The following return values can occur:
No certificate was presented by the peer or no connection was established
The return value points to the certificate presented by the peer
CONF_modules_free_APIName closes down and frees up all memory allocated by all configuration modules
CONF_modules_unload_APIName finishes and unloads configuration modules
If CONF_modules_unload_APIParam_1 is set to 0 ,only modules loaded from DSOs will be unloads
If CONF_modules_unload_APIParam_1 is 1 all modules, including builtin modules will be unloaded
Normally applications will only call CONF_modules_free_APIName at application to tidy up any configuration performed
None of the functions return a value
BN_CTX_new_APIName allocates and initializes a BN_CTX_new_APIParam_0 structure
BN_CTX_free_APIName frees the components of the BN_CTX_new_APIParam_0, and if it was created by BN_CTX_new_APIName, also the structure itself
If BN_CTX_start_APIName has been used on the BN_CTX_new_APIParam_0, BN_CTX_end_APIName must be called before the BN_CTX_new_APIParam_0 may be freed by BN_CTX_free_APIName
BN_CTX_init_APIName (deprecated) initializes an existing uninitialized BN_CTX_new_APIParam_0
This should not be used for new programs
Use BN_CTX_new_APIName instead
BN_CTX_new_APIName returns a pointer to the BN_CTX_new_APIParam_0
If the allocation fails, the allocation returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
BN_CTX_init_APIName and BN_CTX_free_APIName have no return values
SMIME_write_PKCS7_APIName adds the appropriate MIME headers to a PKCS#7 structure to produce an S/MIME message
SMIME_write_PKCS7_APIParam_1 is the BIO to write the data to
SMIME_write_PKCS7_APIParam_2 is the appropriate SMIME_write_PKCS7_APIParam_2 structure
If streaming is enabled, then the content must be supplied in the SMIME_write_PKCS7_APIParam_3 argument
SMIME_write_PKCS7_APIParam_4 is an optional set of flags
The following flags can be passed in the SMIME_write_PKCS7_APIParam_4 parameter
If streaming is performed, the content is output in BER format using indefinite length constructuted encoding except in the case of signed data with detached content where the content is absent and DER format is used
SMIME_write_PKCS7_APIName always base64 encodes PKCS#7 structures, there should be an option to disable this
SMIME_write_PKCS7_APIName returns 1 for success or 0 for failure
SSL_rstate_string_APIName returns a 2 letter string indicating the current read state of the SSL object SSL_rstate_string_APIParam_1
SSL_rstate_string_long_APIName returns a string indicating the current read state of the SSL object SSL_rstate_string_long_APIParam_1
When performing a read operation, the SSL/TLS engine must parse the record, consisting of header and body
When working in a blocking environment, SSL_rstate_string[_long]_APIName should always return "RD"/"read done"
This function should only seldom be needed in applications
SSL_rstate_string_APIName and SSL_rstate_string_long_APIName can return the following values:
The header of the record is being evaluated
The body of the record is being evaluated
The record has been completely processed
The read state is unknown
This should never happen
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure
SSL_CTX_get_ex_new_index_APIName is used to register a new index for application specific data
SSL_CTX_set_ex_data_APIName is used to store application data at SSL_CTX_set_ex_data_APIParam_3 for SSL_CTX_set_ex_data_APIParam_2 into the SSL_CTX_set_ex_data_APIParam_1 object
SSL_CTX_get_ex_data_APIName is used to retrieve the information for SSL_CTX_get_ex_data_APIParam_2 from SSL_CTX_get_ex_data_APIParam_1
SSL_CIPHER_get_name_APIName returns a pointer to the name of SSL_CIPHER_get_name_APIParam_1
If the argument is the NULL pointer, a pointer to the constant value "NONE" is returned
SSL_CIPHER_get_bits_APIName returns the number of secret bits used for SSL_CIPHER_get_bits_APIParam_1
If SSL_CIPHER_get_bits_APIParam_2 is not NULL, SSL_CIPHER_get_bits_APIParam_2 contains the number of bits processed by the chosen algorithm
If SSL_CIPHER_get_bits_APIParam_1 is NULL, 0 is returned
The number of bits processed can be different from the secret bits
An export cipher like eg EXP-RC4-MD5 has only 40 secret bits
The algorithm does use the full 128 bits (which would be returned for SSL_CIPHER_get_bits_APIParam_2), of which however 88bits are fixed
The search space is hence only 40 bits
The string returned by SSL_CIPHER_description_APIName in case of success consists of cleartext information separated by one or more blanks in the following sequence:
Textual representation of the cipher name
If SSL_CIPHER_description_APIName is called with SSL_CIPHER_description_APIParam_1 being NULL, the library crashes
The standard terminology for ephemeral Diffie-Hellman schemes is DHE (finite field) or ECDHE (elliptic curve)
This version of OpenSSL idiosyncratically reports these schemes as EDH and EECDH, even though This version of OpenSSL also accepts the standard terminology
It is recommended to use the standard terminology (DHE and ECDHE) during configuration (eg via SSL_CTX_set_cipher_list) for clarity of configuration
OpenSSL versions after 1.0.2 will report the standard terms via SSL_CIPHER_get_name and SSL_CIPHER_description
SSL_set_shutdown_APIName sets the shutdown state of SSL_set_shutdown_APIParam_1 to SSL_set_shutdown_APIParam_2
SSL_get_shutdown_APIName returns the shutdown mode of SSL_get_shutdown_APIParam_1
The shutdown state of an ssl connection is a bitmask of:
No shutdown setting, yet
A "close notify" shutdown alert was sent to the peer, the connection is being considered closed and the session is closed and correct
A shutdown alert was received form the peer, either a normal "close notify" or a fatal error
SSL_SENT_SHUTDOWN and SSL_RECEIVED_SHUTDOWN can be set at the same time
The shutdown state of the connection is used to determine the state of the ssl session
If the session is still open, when SSL_clear_APIName or SSL_free_APIName is called, it is considered bad and removed according to RFC2246
The actual condition for a correctly closed session is SSL_SENT_SHUTDOWN (according to the TLS RFC, it is acceptable to only send the "close notify" alert but to not wait for the peer's answer, when the underlying connection is closed)
SSL_set_shutdown_APIName can be used to set this state without sending a close alert to the peer (see SSL_shutdown_APIName )
If a "close notify" was received, SSL_RECEIVED_SHUTDOWN will be set, for setting SSL_SENT_SHUTDOWN the application must however still call SSL_shutdown_APIName or SSL_set_shutdown_APIName itself
SSL_set_shutdown_APIName does not return diagnostic information
SSL_get_shutdown_APIName returns the current setting
RSA_check_key_APIName returns 1 if RSA_check_key_APIParam_1 is a valid RSA key, and 0 otherwise
-1 is returned if an error occurs while checking the key
If the key is invalid or an error occurred, the reason code can be obtained using ERR_get_error_APIName
This function does not work on RSA public keys that have only the modulus and public exponent elements populated
This function performs integrity checks on all the RSA key material, so the RSA key structure must contain all the private key data too
A method of verifying the RSA key using opaque RSA API functions might need to be considered
Right now RSA_check_key_APIName simply uses the RSA structure elements directly, bypassing the RSA_METHOD table altogether (and completely violating encapsulation and object-orientation in the process)
The best fix will probably be to introduce a "check_key_APIName" handler to the RSA_METHOD function table so that alternative implementations can also provide alternative implementations own verifiers
SSL_CTX_set1_curves_APIName sets the supported curves for SSL_CTX_set1_curves_APIParam_1 to SSL_CTX_set1_curves_APIParam_3 curves in the array SSL_CTX_set1_curves_APIParam_2
The array consist of all NIDs of curves in preference order
For a TLS client the curves are used directly in the supported curves extension
For a TLS server the curves are used to determine the set of shared curves
SSL_CTX_set1_curves_list_APIName sets the supported curves for SSL_CTX_set1_curves_list_APIParam_1 to string SSL_CTX_set1_curves_list_APIParam_2
The string is a colon separated list of curve NIDs or names, for example "P-521:P-384:P-256"
SSL_set1_curves_APIName and SSL_set1_curves_list_APIName are similar except SSL_set1_curves_APIName and SSL_set1_curves_list_APIName set supported curves for the SSL structure SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1
SSL_get1_curves_APIName returns the set of supported curves sent by a client in the supported curves extension
It returns the total number of supported curves
The SSL_get1_curves_APIParam_2 parameter can be NULL to simply return the number of curves for memory allocation purposes
The SSL_get1_curves_APIParam_2 array is in the form of a set of curve NIDs in preference order
It can return zero if the client did not send a supported curves extension
SSL_get_shared_curve_APIName returns shared curve SSL_get_shared_curve_APIParam_2 for a server-side SSL SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1
If SSL_get_shared_curve_APIParam_2 is -1 ,then the total number of shared curves is returned, which may be zero
Other than for diagnostic purposes, most applications will only be interested in the first shared curve so SSL_get_shared_curve_APIParam_2 is normally set to zero
If the value SSL_get_shared_curve_APIParam_2 is out of range, NID_undef is returned
SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName set automatic curve selection for server SSL_CTX_set_ecdh_auto_APIParam_1 or SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1 to SSL_CTX_set_ecdh_auto_APIParam_2 SSL_set_ecdh_auto_APIParam_2
If SSL_CTX_set_ecdh_auto_APIParam_2 SSL_set_ecdh_auto_APIParam_2 is 1, then the highest preference curve is automatically used for ECDH temporary keys used during key exchange
All these functions are implemented as macros
If an application wishes to make use of several of these functions for configuration purposes either on a command line or in a file ,it should consider using the SSL_CONF interface instead of manually parsing options
The functions SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName can be used to make a server always choose the most appropriate curve for a client
If set it will override any temporary ECDH parameters set by a server
Previous versions of OpenSSL could effectively only use a single ECDH curve set using a function such as SSL_CTX_set_ecdh_tmp_APIName
Newer applications should just call:
and they will automatically support ECDH using the most appropriate shared curve
SSL_CTX_set1_curves_APIName, SSL_CTX_set1_curves_list_APIName, SSL_set1_curves_APIName, SSL_set1_curves_list_APIName, SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName return 1 for success and 0 for failure
SSL_get1_curves_APIName returns the number of curves, which may be zero
SSL_get_shared_curve_APIName returns the NID of shared curve SSL_get_shared_curve_APIParam_2 or NID_undef if there is no shared curve SSL_get_shared_curve_APIParam_2; or the total number of shared curves if SSL_get_shared_curve_APIParam_2 is -1
When called on a client SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1, SSL_get_shared_curve_APIName has no meaning and returns -1
CMS_add0_cert_APIName and CMS_add1_cert_APIName add certificate CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 to CMS_add0_cert_APIParam_1 CMS_add1_cert_APIParam_1
must be of type signed data or enveloped data
CMS_get1_certs_APIName returns all certificates in CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1
CMS_add0_crl_APIName and CMS_add1_crl_APIName add CRL CMS_add0_crl_APIParam_2 CMS_add1_crl_APIParam_2 to CMS_add0_crl_APIParam_1 CMS_add1_crl_APIParam_1
CMS_get1_crls_APIName returns any CRLs in CMS_add0_crl_APIParam_1 CMS_add1_crl_APIParam_1
The CMS_ContentInfo structure CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1 must be of type signed data or enveloped data or an error will be returned
As the CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 implies CMS_add0_cert_APIName adds CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 internally to CMS_add0_cert_APIParam_1 CMS_add1_cert_APIParam_1 and it must not be freed up after the call as opposed to CMS_add1_cert_APIName where CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 must be freed up
The same certificate or CRL must not be added to the same cms structure more than once
CMS_add0_cert_APIName, CMS_add1_cert_APIName and CMS_add0_crl_APIName and CMS_add1_crl_APIName return 1 for success and 0 for failure
CMS_get1_certs_APIName and CMS_get1_crls_APIName return the STACK of certificates or CRLs or NULL if there are none or an error occurs
The only error which will occur in practice is if the CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1 type is invalid
The function CMS_get0_RecipientInfos_APIName returns all the CMS_RecipientInfo structures associated with a CMS EnvelopedData structure
CMS_RecipientInfo_type_APIName returns the type of CMS_RecipientInfo structure CMS_RecipientInfo_type_APIParam_1
It will currently return CMS_RECIPINFO_TRANS, CMS_RECIPINFO_AGREE, CMS_RECIPINFO_KEK, CMS_RECIPINFO_PASS, or CMS_RECIPINFO_OTHER
CMS_RecipientInfo_ktri_cert_cmp_APIName compares the certificate CMS_RecipientInfo_ktri_cert_cmp_APIParam_2 against the CMS_RecipientInfo structure CMS_RecipientInfo_ktri_cert_cmp_APIParam_1, which must be of type CMS_RECIPINFO_TRANS
It returns zero if the comparison is successful and non zero if not
CMS_RecipientInfo_set0_pkey_APIName associates the private key CMS_RecipientInfo_set0_pkey_APIParam_2 with the CMS_RecipientInfo structure CMS_RecipientInfo_set0_pkey_APIParam_1, which must be of type CMS_RECIPINFO_TRANS
CMS_RecipientInfo_set0_key_APIName associates the symmetric key CMS_RecipientInfo_set0_key_APIParam_2 of length CMS_RecipientInfo_set0_key_APIParam_3 with the CMS_RecipientInfo structure CMS_RecipientInfo_set0_key_APIParam_1, which must be of type CMS_RECIPINFO_KEK
CMS_RecipientInfo_decrypt_APIName attempts to decrypt CMS_RecipientInfo structure CMS_RecipientInfo_decrypt_APIParam_2 in structure CMS_RecipientInfo_decrypt_APIParam_1
A key must have been associated with the structure first
CMS_RecipientInfo_encrypt_APIName attempts to encrypt CMS_RecipientInfo structure CMS_RecipientInfo_encrypt_APIParam_2 CMS_RecipientInfo_decrypt_APIParam_2 in structure CMS_RecipientInfo_encrypt_APIParam_1 CMS_RecipientInfo_decrypt_APIParam_1
A key must have been associated with the structure first and the content encryption key must be available: for example by a previous call to CMS_RecipientInfo_decrypt_APIName
The main purpose of these functions is to enable an application to lookup recipient keys using any appropriate technique when the simpler method of CMS_decrypt_APIName is not appropriate
In typical usage and application will retrieve all CMS_RecipientInfo structures using CMS_get0_RecipientInfos_APIName and check the type of each using CMS_RecpientInfo_type_APIName
Depending on the type the CMS_RecipientInfo structure can be ignored or its key identifier data retrieved using an appropriate function
Then if the corresponding secret or private key can be obtained by any appropriate means it can then associated with the structure and CMS_RecpientInfo_decrypt_APIName called
If successful CMS_decrypt_APIName can be called with a NULL key to decrypt the enveloped content
The CMS_RecipientInfo_encrypt_APIName can be used to add a new recipient to an existing enveloped data structure
Typically an application will first decrypt an appropriate CMS_RecipientInfo structure to make the content encrypt key available, it will then add a new recipient using a function such as CMS_add1_recipient_cert_APIName and finally encrypt the content encryption key using CMS_RecipientInfo_encrypt_APIName
CMS_get0_RecipientInfos_APIName returns all CMS_RecipientInfo structures, or NULL if an error occurs
CMS_RecipientInfo_ktri_get0_signer_id_APIName, CMS_RecipientInfo_set0_pkey_APIName, CMS_RecipientInfo_kekri_get0_id_APIName, CMS_RecipientInfo_set0_key_APIName and CMS_RecipientInfo_decrypt_APIName return 1 for success or 0 if an error occurs
CMS_RecipientInfo_encrypt_APIName return 1 for success or 0 if an error occurs
CMS_RecipientInfo_ktri_cert_cmp_APIName and CMS_RecipientInfo_kekri_cmp_APIName return 0 for a successful comparison and non zero otherwise
Any error can be obtained from ERR_get_error_APIName
ERR_set_mark_APIName sets a mark on the current topmost error record if there is one
ERR_pop_to_mark_APIName will pop the top of the error stack until a mark is found
The mark is then removed
If there is no mark, the whole stack is removed
ERR_set_mark_APIName returns 0 if the error stack is empty, otherwise 1
ERR_pop_to_mark_APIName returns 0 if there was no mark in the error stack, which implies that the stack became empty, otherwise 1
The function OPENSSL_load_builtin_modules_APIName adds all the standard OpenSSL configuration modules to the internal list
They can then be used by the OpenSSL configuration code
ASN1_add_oid_module_APIName adds just the ASN1 OBJECT module
ENGINE_add_conf_module_APIName adds just the ENGINE configuration module
If the simple configuration function OPENSSL_config_APIName is called , then OPENSSL_load_builtin_modules_APIName is called automatically
Applications should call OPENSSL_load_builtin_modules_APIName to load all configuration modules instead of adding modules selectively: otherwise functionality may be missing from the application if an when new modules are added
None of the functions return a value
The EVP_PKEY_get_default_digest_nid_APIName function sets EVP_PKEY_get_default_digest_nid_APIParam_2 to the default message digest NID for the public key signature operations associated with key EVP_PKEY_get_default_digest_nid_APIParam_1
For all current standard OpenSSL public key algorithms SHA1 is returned
The EVP_PKEY_get_default_digest_nid_APIName function returns 1 if the message digest is advisory (that is other digests can be used) and 2 if it is mandatory (other digests can not be used)
It returns 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
SSL_CTX_flush_sessions_APIName causes a run through the session cache of SSL_CTX_flush_sessions_APIParam_1 to remove sessions expired at time SSL_CTX_flush_sessions_APIParam_2
SSL_flush_sessions_APIName is a synonym for SSL_CTX_flush_sessions_APIName
If enabled, the internal session cache will collect all sessions established up to the specified maximum number (see SSL_CTX_sess_set_cache_size_APIName)
As sessions will not be reused ones they are expired, they should be removed from the cache to save resources
This can either be done automatically whenever 255 new sessions were established (see SSL_CTX_set_session_cache_mode_APIName ) or manually by calling SSL_CTX_flush_sessions_APIName
The parameter SSL_CTX_flush_sessions_APIParam_2 SSL_flush_sessions_APIParam_2 specifies the time which should be used for the expiration test, in most cases the actual time given by time_APIName will be used
SSL_CTX_flush_sessions_APIName will only check sessions stored in the internal cache
When a session is found and removed, the remove_session_cb is however called to synchronize with the external cache (see SSL_CTX_sess_set_get_cb_APIName )
The X509_verify_cert_APIName function attempts to discover and validate a certificate chain based on parameters in X509_verify_cert_APIParam_1
A complete description of the process is contained in the verify_APIName manual page
If a complete chain can be built and validated this function returns 1, otherwise it return zero, in exceptional circumstances it can also return a negative code
If the function fails ,additional error information can be obtained by examining X509_verify_cert_APIParam_1 using, for example X509_STORE_CTX_get_error_APIName
Applications rarely call this function directly but this function is used by OpenSSL internally for certificate validation, in both the S/MIME and SSL/TLS code
A negative return value from X509_verify_cert_APIName can occur if it is invoked incorrectly, such as with no certificate set in X509_verify_cert_APIParam_1, or when it is called twice in succession without reinitialising X509_verify_cert_APIParam_1 for the second call
A negative return value can also happen due to internal resource problems or if a retry operation is requested during internal lookups (which never happens with standard lookup methods)
Applications must check for <= 0 return value on error
SSL_CTX_set_cert_verify_callback_APIName does not provide diagnostic information
The OpenSSL library uses your callback function to help implement a common TLS ticket construction state according to RFC5077 Section 4 such that per session state is unnecessary and a small set of cryptographic variables needs to be maintained by the callback function implementation
In order to reuse a session, a TLS client must send the a session ticket extension to the server
The client can only send exactly one session ticket
The server, through the callback function, either agrees to reuse the session ticket information or it starts a full TLS handshake to create a new session ticket
This indicates that it was not possible to set/retrieve a session ticket and the SSL/TLS session will continue by by negiotationing a set of cryptographic parameters or using the alternate SSL/TLS resumption mechanism, session ids
This indicates an error
Session resumption shortcuts the TLS so that the client certificate negiotation don't occur
It makes up for this by storing client certificate an all other negotiated state information encrypted within the ticket
In a resumed session the applications will have all this state information available exactly as if a full negiotation had occured
If an attacker can obtain the key used to encrypt a session ticket, they can obtain the master secret for any ticket using that key and decrypt any traffic using that session: even if the ciphersuite supports forward secrecy
As a result applications may wish to use multiple keys and avoid using long term keys stored in files
Applications can use longer keys to maintain a consistent level of security
For example if a ciphersuite uses 256 bit ciphers but only a 128 bit ticket key the overall security is only 128 bits because breaking the ticket key will enable an attacker to obtain the session keys
returns 0 to indicate the callback function was set
SSL_CTX_set_cert_store_APIName sets/replaces the certificate verification storage of SSL_CTX_set_cert_store_APIParam_1 to/with SSL_CTX_set_cert_store_APIParam_2
If another X509_STORE object is currently set in SSL_CTX_set_cert_store_APIParam_1, it will be X509_STORE_free_APINameed
SSL_CTX_get_cert_store_APIName returns a pointer to the current certificate verification storage
In order to verify the certificates presented by the peer, trusted CA certificates must be accessed
These CA certificates are made available via lookup methods, handled inside the X509_STORE
From the X509_STORE the X509_STORE_CTX used when verifying certificates is created
Typically the trusted certificate store is handled indirectly via using SSL_CTX_load_verify_locations_APIName
Using the SSL_CTX_set_cert_store_APIName and SSL_CTX_get_cert_store_APIName functions it is possible to manipulate the X509_STORE object beyond the SSL_CTX_load_verify_locations_APIName call
Currently no detailed documentation on how to use the X509_STORE object is available
Not all members of the X509_STORE are used when the verification takes place
So will eg the verify_callback_APIName be overridden with the verify_callback_APIName set via the SSL_CTX_set_verify_APIName family of functions
This document must therefore be updated when documentation about the X509_STORE object and its handling becomes available
SSL_CTX_set_cert_store_APIName does not return diagnostic output
SSL_CTX_get_cert_store_APIName returns the current setting
The function CMS_get0_SignerInfos_APIName returns all the CMS_SignerInfo structures associated with a CMS signedData structure
CMS_SignerInfo_get0_signature_APIName retrieves the signature associated with CMS_SignerInfo_get0_signature_APIParam_1 in a pointer to an ASN1_OCTET_STRING structure
This pointer returned corresponds to the internal signature value if CMS_SignerInfo_get0_signature_APIParam_1 so it may be read or modified
CMS_SignerInfo_cert_cmp_APIName compares the certificate CMS_SignerInfo_cert_cmp_APIParam_2 against the signer identifier CMS_SignerInfo_cert_cmp_APIParam_1
It returns zero if the comparison is successful and non zero if not
CMS_SignerInfo_set1_signer_cert_APIName sets the signers certificate of CMS_SignerInfo_set1_signer_cert_APIParam_1 to CMS_SignerInfo_set1_signer_cert_APIParam_2
The main purpose of these functions is to enable an application to lookup signers certificates using any appropriate technique when the simpler method of CMS_verify_APIName is not appropriate
In typical usage and application will retrieve all CMS_SignerInfo structures using CMS_get0_SignerInfo_APIName and retrieve the identifier information using CMS
It will then obtain the signer certificate by some unspecified means (or return and error if it cannot be found) and set it using CMS_SignerInfo_set1_signer_cert_APIName
Once all signer certificates have been set CMS_verify_APIName can be used
CMS_get0_SignerInfos_APIName returns all CMS_SignerInfo structures, or NULL there are no signers or an error occurs
CMS_SignerInfo_get0_signer_id_APIName returns 1 for success and 0 for failure
CMS_SignerInfo_cert_cmp_APIName returns 0 for a successful comparison and non zero otherwise
CMS_SignerInfo_set1_signer_cert_APIName does not return a value
Any error can be obtained from ERR_get_error_APIName
The certificate matching functions are used to check whether a certificate matches a given host name, email address, or IP address
The validity of the certificate and its trust level has to be checked by other means
X509_check_host_APIName checks if the certificate Subject Alternative Name (SAN) or Subject CommonName (CN) matches the specified host name, which must be encoded in the preferred name syntax described in section 3.5 of RFC 1034
By default, wildcards are supported and wildcards match only in the left-most label; but wildcards may match part of that label with an explicit prefix or suffix
For example, by default, the host X509_check_host_APIParam_2 "www.example.com" would match a certificate with a SAN or CN value of "*.example.com", "w*.example.com" or "*w.example.com"
X509_check_email_APIName checks if the certificate matches the specified email X509_check_email_APIParam_2
Only the mailbox syntax of RFC 822 is supported, comments are not allowed, and no attempt is made to normalize quoted characters
The X509_check_email_APIParam_3 argument must be the number of characters in the address string or zero in which case the length is calculated with strlen(X509_check_email_APIParam_2)
X509_check_ip_APIName checks if the certificate matches a specified IPv4 or IPv6 address
The X509_check_ip_APIParam_2 array is in binary format, in network byte order
The length is either 4 (IPv4) or 16 (IPv6)
Only explicitly marked addresses in the certificates are considered; IP addresses stored in DNS names and Common Names are ignored
X509_check_ip_asc_APIName is similar, except that the NUL-terminated string X509_check_ip_asc_APIParam_2 is first converted to the internal representation
The X509_check_ip_asc_APIParam_3 argument is usually 0
The X509_check_ip_asc_APIParam_3 argument can be the bitwise OR of the flags:
X509_check_host return 1 for a successful match, 0 for a failed match and -1 for an internal error: typically a memory allocation failure or an ASN.1 decoding error
All functions can also return -2 if the input is malformed
For example, X509_check_host_APIName returns -2 if the provided X509_check_host_APIParam_2 contains embedded NULs
Applications are encouraged to use X509_VERIFY_PARAM_set1_host_APIName rather than explicitly calling X509_check_host_APIName
Host name checks are out of scope with the DANE-EE_APIName certificate usage, and the internal checks will be suppressed as appropriate when DANE support is added to OpenSSL
If the key does not include all the components indicated by the function, then only those contained in the key will be printed
For example passing a public key to EVP_PKEY_print_private_APIName will only print the public components
These functions all return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
SSL_CTX_set_tlsext_servername_arg_APIName sets a context-specific argument to be passed into the callback for this SSL_CTX_set_tlsext_servername_arg_APIParam_1
SSL_get_servername_APIName returns a servername extension value of the specified type if provided in the Client Hello or NULL
The ALPN and SNI callbacks are both executed during Client Hello processing
The servername callback is executed first, followed by the ALPN callback
SSL_CTX_set_tlsext_servername_callback_APIName and SSL_CTX_set_tlsext_servername_arg_APIName both always return 1 indicating success
This flag is 0 when a protocol message has been received and 1 when a protocol message has been sent
The SSL_set_msg_callback_arg_APIParam_1 SSL_CTX_set_msg_callback_arg_APIParam_1 object that received or sent the message
The user-defined argument optionally defined by SSL_CTX_set_msg_callback_arg_APIName or SSL_set_msg_callback_arg_APIName
Protocol messages are passed to the callback function after decryption and fragment collection where applicable
(Thus record boundaries are not visible.)
If processing a received protocol message results in an error, the callback function may not be called
For example, the callback function will never see messages that are considered too large to be processed
This function returns the Diffie-Hellman size in bytes
This function can be used to determine how much memory must be allocated for the shared secret computed by DH_compute_key_APIName
The size in bytes
DSA_dup_DH_APIName duplicates DSA parameters/keys as DH parameters/keys
q is lost during that conversion, but the resulting DH parameters contain the resulting DH parameters length
DSA_dup_DH_APIName returns the new DSA_dup_DH_APIParam_0 structure, and NULL on error
The error codes can be obtained by ERR_get_error_APIName
Be careful to avoid small subgroup attacks when using this
BIO_f_cipher_APIName returns the cipher BIO method
This is a filter BIO that encrypts any data written through it, and decrypts any data read from it
It is a BIO wrapper for the cipher routines EVP_CipherInit_APIName, EVP_CipherUpdate_APIName and EVP_CipherFinal_APIName
Cipher BIOs do not support BIO_gets_APIName or BIO_puts_APIName
BIO_flush_APIName on an encryption BIO that is being written through is used to signal that no more data is to be encrypted: this is used to flush and possibly pad the final block through the BIO
When reading from an encryption BIO the final block is automatically decrypted and checked when EOF is detected
BIO_get_cipher_status_APIName is a BIO_ctrl_APIName macro which can be called to determine whether the decryption operation was successful
BIO_get_cipher_ctx_APIName is a BIO_ctrl_APIName macro which retrieves the internal BIO cipher context
The retrieved context can be used in conjunction with the standard cipher routines to set it up
This is useful when BIO_set_cipher_APIName is not flexible enough for the applications needs
When decrypting an error on the final block is signalled by a zero return value from the read operation
A successful decrypt followed by EOF will also return zero for the final read
BIO_get_cipher_status_APIName should be called to determine if the decrypt was successful
As always, if BIO_gets_APIName or BIO_puts_APIName support is needed ,then it can be achieved by preceding the cipher BIO with a buffering BIO
BIO_f_cipher_APIName returns the cipher BIO method
BIO_set_cipher_APIName does not return a value
BIO_get_cipher_status_APIName returns 1 for a successful decrypt and 0 for failure
BIO_get_cipher_ctx_APIName currently always returns 1
SSL_want_APIName returns state information for the SSL object SSL_want_APIParam_1
The other SSL_want_*_APIName calls are shortcuts for the possible states returned by SSL_want_APIName
SSL_want_APIName examines the internal state information of the SSL object
Its return values are similar to that of SSL_get_error_APIName
Unlike SSL_get_error_APIName , which also evaluates the error queue, the results are obtained by examining an internal state flag only
The information must therefore only be used for normal operation under non-blocking I/O
Error conditions are not handled and must be treated using SSL_get_error_APIName
The result returned by SSL_want_APIName should always be consistent with the result of SSL_get_error_APIName
The following return values can currently occur for SSL_want_APIName:
There is no data to be written or to be read
The operation did not complete because an application callback set by SSL_CTX_set_client_cert_cb_APIName has asked to be called again
A call to SSL_get_error_APIName should return SSL_ERROR_WANT_X509_LOOKUP
SSL_want_nothing_APIName, SSL_want_read_APIName, SSL_want_write_APIName, SSL_want_x509_lookup_APIName return 1, when the corresponding condition is true or 0 otherwise
BN_is_bit_set_APIName tests if bit BN_is_bit_set_APIParam_2 in BN_is_bit_set_APIParam_1 is set
For the shift functions, BN_rshift1_APIParam_1 BN_lshift1_APIParam_1 BN_rshift_APIParam_1 BN_lshift_APIParam_1 and BN_rshift1_APIParam_2 BN_clear_bit_APIParam_1 BN_mask_bits_APIParam_1 BN_lshift1_APIParam_2 BN_is_bit_set_APIParam_1 BN_rshift_APIParam_2 BN_lshift_APIParam_2 BN_set_bit_APIParam_1 may be the same variable
BN_is_bit_set_APIName returns 1 if the bit is set, 0 otherwise
All other functions return 1 for success, 0 on error
The error codes can be obtained by ERR_get_error_APIName
The ECPrivateKey encode and decode routines encode and parse an EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1 EC_KEY_set_enc_flags_APIParam_1 structure into a binary format (ASN.1 DER) and back again
These functions are similar to the d2i_X509_APIName functions, and you should refer to that page for a detailed description (see d2i_X509_APIName )
The format of the external representation of the public key written by i2d_ECPrivateKey (such as whether it is stored in a compressed form or not) is described by the point_conversion_form
See EC_GROUP_copy_APIName for a description of point_conversion_form
When reading a private key encoded without an associated public key (eg if EC_PKEY_NO_PUBKEY has been used - see below), then d2i_ECPrivateKey generates the missing public key automatically
Private keys encoded without parameters (eg if EC_PKEY_NO_PARAMETERS has been used - see below) cannot be loaded using d2i_ECPrivateKey
The functions EC_KEY_get_enc_flags and EC_KEY_set_enc_flags get and set the value of the encoding flags for the EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1
There are two encoding flags currently defined - EC_PKEY_NO_PARAMETERS and EC_PKEY_NO_PUBKEY
These flags define the behaviour of how the EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1 is converted into ASN1 in a call to i2d_ECPrivateKey
If EC_PKEY_NO_PARAMETERS is set ,then the public parameters for the curve are not encoded along with the private key
If EC_PKEY_NO_PUBKEY is set ,then the public key is not encoded along with the private key
d2i_ECPrivateKey_APIName returns a valid d2i_ECPrivateKey_APIParam_1 structure or NULL if an error occurs
The error code that can be obtained by ERR_get_error_APIName
i2d_ECPrivateKey_APIName returns the number of bytes successfully encoded or a negative value if an error occurs
The error code can be obtained by ERR_get_error_APIName
EC_KEY_get_enc_flags returns the value of the current encoding flags for the EC_KEY
The CMS_add1_ReceiptRequest_APIName function adds a signed receipt request CMS_add1_ReceiptRequest_APIParam_2 to SignerInfo structure CMS_add1_ReceiptRequest_APIParam_1
int CMS_get1_ReceiptRequest_APIName looks for a signed receipt request in CMS_get1_ReceiptRequest_APIParam_1, if any is found it is decoded and written to CMS_get1_ReceiptRequest_APIParam_2
For more details of the meaning of the fields see RFC2634
The contents of a signed receipt should only be considered meaningful if the corresponding CMS_ContentInfo structure can be successfully verified using CMS_verify_APIName
CMS_ReceiptRequest_create0_APIName returns a signed receipt request structure or NULL if an error occurred
CMS_add1_ReceiptRequest_APIName returns 1 for success or 0 if an error occurred
CMS_get1_ReceiptRequest_APIName returns 1 is a signed receipt request is found and decoded
It returns 0 if a signed receipt request is not present and -1 if it is present but malformed
RSA_verify_ASN1_OCTET_STRING_APIParam_1 RSA_sign_ASN1_OCTET_STRING_APIParam_1 is ignored
The random number generator must be seeded prior to calling RSA_sign_ASN1_OCTET_STRING_APIName
RSA_sign_ASN1_OCTET_STRING_APIName returns 1 on success, 0 otherwise
RSA_verify_ASN1_OCTET_STRING_APIName returns 1 on successful verification, 0 otherwise
The error codes can be obtained by ERR_get_error_APIName
These functions serve no recognizable purpose
These functions decode and encode an X509 CRL (certificate revocation list)
Othewise the functions behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
BIO_s_null_APIName returns the null sink BIO method
Data written to the null sink is discarded, reads return EOF
A null sink BIO behaves in a similar manner to the Unix /dev/null device
A null bio can be placed on the end of a chain to discard any data passed through it
A null sink is useful if, for example, an application wishes to digest some data by writing through a digest bio but not send the digested data anywhere
Since a BIO chain must normally include a source/sink BIO, this can be achieved by adding a null sink BIO to the end of the chain
BIO_s_null_APIName returns the null sink BIO method
HMAC is a MAC (message authentication code), ie a keyed hash function used for message authentication, which is based on a hash function
HMAC_APIName computes the message authentication code of the HMAC_APIParam_1 bytes at HMAC_APIParam_2 using the hash function HMAC_APIParam_1 and the key HMAC_APIParam_2 which is HMAC_Init_APIParam_3 HMAC_Init_ex_APIParam_3 bytes long
HMAC_APIParam_1 can be EVP_sha1_APIName, EVP_ripemd160_APIName etc
HMAC_CTX_init_APIName initialises a HMAC_CTX_init_APIParam_1 before first use
It must be called
HMAC_CTX_cleanup_APIName erases the key and other data from the HMAC_CTX_cleanup_APIParam_1 and releases any associated resources
It must be called when an HMAC_CTX_cleanup_APIParam_1 is no longer required
HMAC_cleanup_APIName is an alias for HMAC_CTX_cleanup_APIName included for back compatibility with 0.9.6b, it is deprecated
The following functions may be used if the message is not completely stored in memory:
HMAC_Init_APIName initializes a HMAC_Init_APIParam_1 structure to use the hash function HMAC_APIParam_1 and the key HMAC_Init_APIParam_2 which is HMAC_Init_APIParam_3 bytes long
It is deprecated and only included for backward compatibility with OpenSSL 0.9.6b
NB: if HMAC_Init_ex_APIName is called with HMAC_Init_ex_APIParam_2 NULL and HMAC_APIParam_1 is not the same as the previous digest used by HMAC_Init_ex_APIParam_1 ,then an error is returned because reuse of an existing key with a different digest is not supported
HMAC_Update_APIName can be called repeatedly with chunks of the message to be authenticated (HMAC_Update_APIParam_3 bytes at HMAC_Update_APIParam_2)
HMAC_Final_APIName places the message authentication code in HMAC_Final_APIParam_2, which must have space for the hash function output
HMAC_APIName returns a pointer to the message authentication code or NULL if an error occurred
HMAC_Init_ex_APIName, HMAC_Update_APIName and HMAC_Final_APIName return 1 for success or 0 if an error occurred
HMAC_CTX_init_APIName and HMAC_CTX_cleanup_APIName do not return values
Some of the newer functions follow a naming convention using the numbers 0 and 1
For example the functions:
PKCS7_decrypt_APIName extracts and decrypts the content from a PKCS#7 envelopedData structure
PKCS7_decrypt_APIParam_2 is the private key of the recipient, PKCS7_decrypt_APIParam_3 is the recipients certificate, PKCS7_decrypt_APIParam_4 is a BIO to write the content to and PKCS7_decrypt_APIParam_5 is an optional set of flags
OpenSSL_add_all_algorithms_APIName (or equivalent) should be called before using this function or errors about unknown algorithms will occur
Although the recipients certificate is not needed to decrypt the data, the recipients certificate is needed to locate the appropriate (of possible several) recipients in the PKCS#7 structure
The following flags can be passed in the PKCS7_decrypt_APIParam_5 parameter
PKCS7_decrypt_APIName returns either 1 for success or 0 for failure
The error can be obtained from ERR_get_error_APIName
PKCS7_decrypt_APIName must be passed the correct recipient key and certificate
It would be better if it could look up the correct key and certificate from a database
The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign_APIName also applies to PKCS7_verify_APIName
At first the library must be initialized; see SSL_library_init_APIName
Then the TLS/SSL handshake is performed using SSL_accept_APIName or SSL_connect_APIName respectively
SSL_read_APIName and SSL_write_APIName are used to read and write data on the TLS/SSL connection
SSL_shutdown_APIName can be used to shut down the TLS/SSL connection
The X509 ASN1 allocation routines, allocate and free an X509 structure, which represents an X509 certificate
X509_new_APIName allocates and initializes a X509 structure
X509_free_APIName frees up the X509_free_APIParam_1 structure X509_free_APIParam_1
If the allocation fails, X509_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
X509_free_APIName returns no value
SSL_CTX_sessions_APIName returns a pointer to the lhash databases containing the internal session cache for SSL_CTX_sessions_APIParam_1
The sessions in the internal session cache are kept in an lhash_APIName type database
It is possible to directly access this database eg for searching
In parallel, the sessions form a linked list which is maintained separately from the lhash_APIName operations, so that the database must not be modified directly but by using the SSL_CTX_add_session_APIName family of functions
BIO_f_base64_APIName returns the base64 BIO method
This is a filter BIO that base64 encodes any data written through it and decodes any data read through it
Base64 BIOs do not support BIO_gets_APIName or BIO_puts_APIName
BIO_flush_APIName on a base64 BIO that is being written through is used to signal that no more data is to be encoded: this is used to flush the final block through the BIO
The flag BIO_FLAGS_BASE64_NO_NL can be set with BIO_set_flags_APIName to encode the data all on one line or expect the data to be all on one line
Because of the format of base64 encoding, the end of the encoded block cannot always be reliably determined
BIO_f_base64_APIName returns the base64 BIO method
The ambiguity of EOF in base64 encoded data can cause additional data following the base64 encoded block to be misinterpreted
There should be some way of specifying a test that the BIO can perform to reliably determine EOF (for example a MIME boundary)
SSL_CTX_sess_number_APIName returns the current number of sessions in the internal session cache
SSL_CTX_sess_connect_APIName returns the number of started SSL/TLS handshakes in client mode
SSL_CTX_sess_connect_good_APIName returns the number of successfully established SSL/TLS sessions in client mode
SSL_CTX_sess_connect_renegotiate_APIName returns the number of start renegotiations in client mode
SSL_CTX_sess_accept_APIName returns the number of started SSL/TLS handshakes in server mode
SSL_CTX_sess_accept_good_APIName returns the number of successfully established SSL/TLS sessions in server mode
SSL_CTX_sess_accept_renegotiate_APIName returns the number of start renegotiations in server mode
SSL_CTX_sess_hits_APIName returns the number of successfully reused sessions
In client mode a session set with SSL_set_session_APIName successfully reused is counted as a hit
In server mode a session successfully retrieved from internal or external cache is counted as a hit
SSL_CTX_sess_cb_hits_APIName returns the number of successfully retrieved sessions from the external session cache in server mode
SSL_CTX_sess_misses_APIName returns the number of sessions proposed by clients that were not found in the internal session cache in server mode
SSL_CTX_sess_timeouts_APIName returns the number of sessions proposed by clients and either found in the internal or external session cache in server mode, but that were invalid due to timeout
These sessions are not included in the SSL_CTX_sess_hits_APIName count
SSL_CTX_sess_cache_full_APIName returns the number of sessions that were removed because the maximum session cache size was exceeded
The functions return the values indicated in the DESCRIPTION section
These functions decode and encode an CMS ContentInfo structure
Otherwise they behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
The error code returned by ERR_get_error_APIName consists of a library number, function code and reason code
ERR_GET_LIB_APIName, ERR_GET_FUNC_APIName and ERR_GET_REASON_APIName can be used to extract these
The library number and function code describe where the error occurred, the reason code is the information about what went wrong
Each sub-library of OpenSSL has a unique library number; function and reason codes are unique within each sub-library
Note that different libraries may use the same value to signal different functions and reasons
ERR_GET_LIB_APIName, ERR_GET_FUNC_APIName and ERR_GET_REASON_APIName are macros
The library number, function code and reason code respectively
The EVP signature routines are a high level interface to digital signatures
EVP_DigestVerifyUpdate_APIName hashes EVP_DigestVerifyUpdate_APIParam_3 bytes of data at EVP_DigestVerifyUpdate_APIParam_2 into the verification context EVP_DigestVerifyUpdate_APIParam_1
This function can be called several times on the same EVP_DigestVerifyUpdate_APIParam_1 to include additional data
This function is currently implemented using a macro
EVP_DigestVerifyFinal_APIName verifies the data in EVP_DigestVerifyFinal_APIParam_1 against the signature in EVP_DigestVerifyFinal_APIParam_2 of length EVP_DigestVerifyFinal_APIParam_3
EVP_DigestVerifyInit_APIName and EVP_DigestVerifyUpdate_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
EVP_DigestVerifyFinal_APIName returns 1 for success; any other value indicates failure
A return value of zero indicates that the signature did not verify successfully (that is, tbs did not match the original data or the signature had an invalid form), while other values indicate a more serious error (and sometimes also indicate an invalid signature form)
The error codes can be obtained from ERR_get_error_APIName
The EVP_DigestVerifyUpdate_APIParam_1 EVP_DigestVerifyFinal_APIParam_1 EVP_DigestVerifyInit_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces
This is because the code then becomes transparent to the algorithm used and much more flexible
In previous versions of OpenSSL there was a link between message digest types and public key algorithms
This meant that "clone" digests such as EVP_dss1_APIName needed to be used to sign using SHA1 and DSA
This is no longer necessary and the use of clone digest is now discouraged
For some key types and parameters the random number generator must be seeded or the operation will fail
The call to EVP_DigestVerifyFinal_APIName internally finalizes a copy of the digest context
This means that EVP_VerifyUpdate_APIName and EVP_VerifyFinal_APIName can be called later to digest and verify additional data
Since only a copy of the digest context is ever finalized, the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur
The verification callback can be used to customise the operation of certificate verification, either by overriding error conditions or logging errors for debugging purposes
The verification callback can be set and inherited from the parent structure performing the operation
In some cases (such as S/MIME verification) the X509_STORE_CTX_set_verify_cb_APIParam_1 structure is created and destroyed internally and the only way to set a custom verification callback is by inheriting it from the associated X509_STORE_CTX_set_verify_cb_APIParam_1
X509_STORE_CTX_set_verify_cb_APIName does not return a value
PKCS7_sign_add_signer_APIName adds a signer with certificate PKCS7_sign_add_signer_APIParam_2 and private key PKCS7_sign_add_signer_APIParam_3 using message digest PKCS7_sign_add_signer_APIParam_4 to a PKCS7 signed data structure PKCS7_sign_add_signer_APIParam_1
If the PKCS7_sign_add_signer_APIParam_4 parameter is NULL ,then the default digest for the public key algorithm will be used
The main purpose of this function is to provide finer control over a PKCS#7 signed data structure where the simpler PKCS7_sign_APIName function defaults are not appropriate
For example if multiple signers or non default digest algorithms are needed
Any of the following flags (ored together) can be passed in the PKCS7_sign_add_signer_APIParam_5 parameter
If present the SMIMECapabilities attribute indicates support for the following algorithms: triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2
If any of these algorithms is disabled, then it will not be included
PKCS7_sign_add_signers_APIName returns an internal pointer to the PKCS7_SIGNER_INFO structure just added, this can be used to set additional attributes before it is finalized
PKCS7_sign_add_signers_APIName returns an internal pointer to the PKCS7_SIGNER_INFO structure just added or NULL if an error occurs
SSL_CTX_add_extra_chain_cert_APIName adds the certificate SSL_CTX_add_extra_chain_cert_APIParam_2 to the extra chain certificates associated with SSL_CTX_add_extra_chain_cert_APIParam_1
Several certificates can be added one after another
SSL_CTX_clear_extra_chain_certs_APIName clears all extra chain certificates associated with SSL_CTX_clear_extra_chain_certs_APIParam_1
These functions are implemented as macros
When sending a certificate chain, extra chain certificates are sent in order following the end entity certificate
If no chain is specified, the library will try to complete the chain from the available CA certificates in the trusted CA storage, see SSL_CTX_load_verify_locations_APIName
SSL_CTX_add_extra_chain_cert_APIName and SSL_CTX_clear_extra_chain_certs_APIName return 1 on success and 0 for failure
Check out the error stack to find out the reason for failure
SSL_get_ciphers_APIName returns the stack of available SSL_CIPHERs for SSL_get_cipher_list_APIParam_1, sorted by preference
If SSL_get_cipher_list_APIParam_1 is NULL or no ciphers are available, NULL is returned
SSL_get_cipher_list_APIName returns a pointer to the name of the SSL_CIPHER listed for SSL_get_cipher_list_APIParam_1 with SSL_get_cipher_list_APIParam_2
If SSL_get_cipher_list_APIParam_1 is NULL, no ciphers are available, or there are less ciphers than SSL_get_cipher_list_APIParam_2 available, NULL is returned
SSL_get_shared_ciphers_APIName creates a colon separated and NUL terminated list of SSL_CIPHER names that are available in both the client and the server
SSL_get_shared_ciphers_APIParam_2 is the buffer that should be populated with the list of names and SSL_get_shared_ciphers_APIParam_3 is the size of that buffer
A pointer to SSL_get_shared_ciphers_APIParam_2 is returned on success or NULL on error
If the supplied buffer is not large enough to contain the complete list of names then a truncated list of names will be returned
Note that just because a ciphersuite is available (ie it is configured in the cipher list) and shared by both the client and the server it does not mean that it is enabled (for example some ciphers may not be usable by a server if there is not a suitable certificate configured)
This function will return available shared ciphersuites whether or not they are enabled
This is a server side function only and must only be called after the completion of the initial handshake
The details of the ciphers obtained by SSL_get_ciphers_APIName can be obtained using the SSL_CIPHER_get_name_APIName family of functions
Call SSL_get_cipher_list_APIName with SSL_get_cipher_list_APIParam_2 starting from 0 to obtain the sorted list of available ciphers, until NULL is returned
SMIME_read_CMS_APIName parses a message in S/MIME format
SMIME_read_CMS_APIParam_1 is a BIO to read the message from
If cleartext signing is used ,then the content is saved in a memory bio which is written to SMIME_read_CMS_APIParam_2, otherwise SMIME_read_CMS_APIParam_2 is set to NULL
The parsed CMS_ContentInfo structure is returned or NULL if an error occurred
Otherwise the type of  CMS_get0_type_APIParam_0  can be determined using CMS_get0_type_APIName
To support future functionality if SMIME_read_CMS_APIParam_2 is not NULL SMIME_read_CMS_APIParam_2 should be initialized to NULL
The MIME parser used by SMIME_read_CMS_APIName is somewhat primitive
While The MIME parser used by SMIME_read_CMS_APIName will handle most S/MIME messages more complex compound formats may not work
The parser assumes that the CMS_ContentInfo structure is always base64 encoded and will not handle the case where the CMS_ContentInfo structure is in binary format or uses quoted printable format
The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints: a streaming single pass option should be available
SMIME_read_CMS_APIName returns a valid SMIME_read_CMS_APIParam_0 structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
These functions handle application specific data in DH structures
These functions usage is identical to that of RSA_get_ex_new_index_APIName, RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName
Normally an application is only interested in whether a signature verification operation is successful in those cases the EVP_verify_APIName function should be used
Sometimes however it is useful to obtain the data originally signed using a signing operation
Only certain public key algorithms can recover a signature in this way (for example RSA in PKCS padding mode)
After the call to EVP_PKEY_verify_recover_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The function EVP_PKEY_verify_recover_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_verify_recover_init_APIName and EVP_PKEY_verify_recover_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
BN_copy_APIName copies BN_copy_APIParam_2 BN_dup_APIParam_1 to BN_copy_APIParam_1
BN_dup_APIName creates a new BN_copy_APIParam_1 BN_dup_APIParam_1 containing the value BN_copy_APIParam_2 BN_dup_APIParam_1
BN_copy_APIName returns BN_copy_APIParam_1 on success, NULL on error
BN_dup_APIName returns the new BN_copy_APIParam_1 BN_dup_APIParam_1, and NULL on error
The error codes can be obtained by ERR_get_error_APIName
SSL_library_init_APIName registers the available SSL/TLS ciphers and digests
OpenSSL_add_ssl_algorithms_APIName and SSLeay_add_ssl_algorithms_APIName are synonyms for SSL_library_init_APIName
SSL_library_init_APIName must be called before any other action takes place
SSL_library_init_APIName is not reentrant
SSL_library_init_APIName adds ciphers and digests used directly and indirectly by SSL/TLS
SSL_library_init_APIName always returns "1", so it is safe to discard the return value
d2i_SSL_SESSION_APIName transforms the external ASN1 representation of an SSL/TLS session, stored as binary data at location d2i_SSL_SESSION_APIParam_2 with length d2i_SSL_SESSION_APIParam_3, into an SSL_SESSION object
i2d_SSL_SESSION_APIName transforms the SSL_SESSION object i2d_SSL_SESSION_APIParam_1 into the ASN1 representation and stores it into the memory location pointed to by i2d_SSL_SESSION_APIParam_2
The length of the resulting ASN1 representation is returned
If i2d_SSL_SESSION_APIParam_2 is the NULL pointer, only the length is calculated and returned
The SSL_SESSION object is built from several malloc_APINameed parts, The SSL_SESSION object can therefore not be moved, copied or stored directly
In order to store session data on disk or into a database, The SSL_SESSION object must be transformed into a binary ASN1 representation
When using d2i_SSL_SESSION_APIName, the SSL_SESSION object is automatically allocated
The reference count is 1, so that the session must be explicitly removed using SSL_SESSION_free_APIName , unless the SSL_SESSION object is completely taken over, when being called inside the get_session_cb_APIName (see SSL_CTX_sess_set_get_cb_APIName )
SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache
One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object)
d2i_SSL_SESSION_APIName returns a pointer to the newly allocated SSL_SESSION object
In case of failure the NULL-pointer is returned and the error message can be retrieved from the error stack
i2d_SSL_SESSION_APIName returns the size of the ASN1 representation in bytes
When the session is not valid, 0 is returned and no operation is performed
ERR_load_strings_APIName registers error strings for library number ERR_load_strings_APIParam_1
ERR_load_strings_APIParam_2 is an array of error string data:
The last entry in the array is {0,0}
ERR_get_next_error_library_APIName can be used to assign library numbers to user libraries at runtime
ERR_load_strings_APIName returns no value
ERR_PACK_APIName return the error code
ERR_get_next_error_library_APIName returns a new library number
SSL_CTX_set0_verify_cert_store_APIName and SSL_CTX_set1_verify_cert_store_APIName set the certificate store used for certificate verification to SSL_CTX_set0_verify_cert_store_APIParam_2 SSL_CTX_set1_verify_cert_store_APIParam_2
SSL_CTX_set0_chain_cert_store_APIName and SSL_CTX_set1_chain_cert_store_APIName set the certificate store used for certificate chain building to SSL_CTX_set0_chain_cert_store_APIParam_2 SSL_CTX_set1_chain_cert_store_APIParam_2
The stores pointers associated with an SSL_CTX structure are copied to any SSL structures when SSL_new_APIName is called
As a result SSL structures will not be affected if the parent SSL_CTX store pointer is set to a new value
The verification store is used to verify the certificate chain sent by the peer: that is an SSL/TLS client will use the verification store to verify the server's certificate chain and a SSL/TLS server will use it to verify any client certificate chain
The chain store is used to build the certificate chain
If the chain or the verification store is not set ,then the store associated with the parent SSL_CTX is used instead to retain compatibility with previous versions of OpenSSL
All these functions return 1 for success and 0 for failure
RSA is vulnerable to timing attacks
In a setup where attackers can measure the time of RSA decryption or signature operations, blinding must be used to protect the RSA operation from that attack
RSA_blinding_on_APIName turns blinding on for key RSA_blinding_on_APIParam_1 RSA_blinding_on_APIParam_1 and generates a random blinding factor
RSA_blinding_on_APIParam_2 RSA_blinding_on_APIParam_2 is NULL or a pre-allocated and initialized RSA_blinding_on_APIParam_2 RSA_blinding_on_APIParam_2
The random number generator must be seeded prior to calling RSA_blinding_on_APIName
RSA_blinding_off_APIName turns blinding off and frees the memory used for the blinding factor
RSA_blinding_on_APIName returns 1 on success, and 0 if an error occurred
RSA_blinding_off_APIName returns no value
SSL_set_session_APIName sets SSL_set_session_APIParam_2 SSL_set_session_APIParam_2 to be used when the TLS/SSL connection is to be established
SSL_set_session_APIName is only useful for TLS/SSL clients
When the session is set, the reference count of SSL_set_session_APIParam_2 SSL_set_session_APIParam_2 is incremented by 1
If the session is not reused, the reference count is decremented again during SSL_connect_APIName
Whether the session was reused can be queried with the SSL_session_reused_APIName call
If there is already a session set inside SSL_set_session_APIParam_1 (because it was set with SSL_set_session_APIName before or because the same SSL_set_session_APIParam_1 was already used for a connection), SSL_SESSION_free_APIName will be called for that session
SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache
One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object)
The following return values can occur:
The operation failed; check the error stack to find out the reason
The operation succeeded
The DES library contained a few routines to prompt for passwords
These aren't necessarely dependent on DES, and have therefore become part of the UI compatibility library
des_read_pw_APIName writes the string specified by des_read_pw_APIParam_4 des_read_pw_APIParam_4 to standard output turns echo off and reads an input string from the terminal
The string is returned in des_read_pw_APIParam_1 des_read_pw_APIParam_1, which must have spac for at least des_read_pw_APIParam_3 des_read_pw_APIParam_3 bytes
If des_read_pw_APIParam_5 des_read_pw_APIParam_5 is set, the user is asked for the password twice and unless the two copies match, an error is returned
The second password is stored in des_read_pw_APIParam_2 des_read_pw_APIParam_2, which must therefore also be at least des_read_pw_APIParam_3 des_read_pw_APIParam_3 bytes
A return code of -1 indicates a system error, 1 failure due to use interaction, and 0 is success
All other functions described here use des_read_pw_APIName to do the work
des_read_pw_string_APIName is a variant of des_read_pw_APIName that provides a buffer for you if des_read_pw_string_APIParam_4 des_read_pw_APIParam_5 is set
des_read_password_APIName calls des_read_pw_APIName and converts the password to a DES key by calling DES_string_to_key_APIName; des_read_2password_APIName operates in the same way as des_read_password_APIName except that it generates two keys by using the DES_string_to_2key_APIName function
des_read_pw_string_APIName is available in the MIT Kerberos library as well, and is also available under the name EVP_read_pw_string_APIName
SSL_CTX_set_default_read_ahead is a synonym for SSL_CTX_set_read_ahead, and SSL_CTX_get_default_read_ahead is a synonym for SSL_CTX_get_read_ahead
SSL_CTX_get_read_ahead_APIName and SSL_get_read_ahead_APIName indicate whether reading ahead has been set or not
These functions have no impact when used with DTLS
The return values for SSL_CTX_get_read_head_APIName and SSL_get_read_ahead_APIName are undefined for DTLS
SSL_get_read_ahead and SSL_CTX_get_read_ahead return 0 if reading ahead is off, and non zero otherwise
SSL_CTX_set_mode_APIName adds the mode set via bitmask in SSL_CTX_set_mode_APIParam_2 to SSL_CTX_set_mode_APIParam_1
Options already set before are not cleared
SSL_set_mode_APIName adds the mode set via bitmask in SSL_set_mode_APIParam_2 to SSL_set_mode_APIParam_1
Options already set before are not cleared
SSL_CTX_get_mode_APIName returns the mode set for SSL_CTX_get_mode_APIParam_1
SSL_get_mode_APIName returns the mode set for SSL_get_mode_APIParam_1
The following mode changes are available:
Allow SSL_write(..., n) to return r with 0 < r < n (ie report success when just a single record has been written)
When not set (the default), SSL_write_APIName will only report success once the complete chunk was written
Once SSL_write_APIName returns with r, r bytes have been successfully written and the next call to SSL_write_APIName must only send the n-r bytes left, imitating the behaviour of write_APIName
Make it possible to retry SSL_write_APIName with changed buffer location (the buffer contents must stay the same)
This is not the default to avoid the misconception that non-blocking SSL_write_APIName behaves like non-blocking write_APIName
Never bother the application with retries if the transport is blocking
If a renegotiation take place during normal operation, a SSL_read_APIName or SSL_write_APIName would return with -1 and indicate the need to retry with SSL_ERROR_WANT_READ
In a non-blocking environment applications must be prepared to handle incomplete read/write operations
In a blocking environment, applications are not always prepared to deal with read/write operations returning without success report
The flag SSL_MODE_AUTO_RETRY will cause read/write operations to only return after the handshake and successful completion
When we no longer need a read buffer or a write buffer for a given SSL, then release the memory we were using to hold it
Released memory is either appended to a list of unused RAM chunks on the SSL_CTX, or simply freed if the list of unused chunks would become longer than SSL_CTX->freelist_max_len, which defaults to 32
Using this flag can save around 34k per idle SSL connection
This flag has no effect on SSL v2 connections, or on DTLS connections
Send TLS_FALLBACK_SCSV in the ClientHello
To be set only by applications that reconnect with a downgraded protocol version; see draft-ietf-tls-downgrade-scsv-00 for details
DO NOT ENABLE THIS if your application attempts a normal handshake
Only use this in explicit fallback retries, following the guidance in draft-ietf-tls-downgrade-scsv-00
SSL_CTX_set_mode_APIName and SSL_set_mode_APIName return the new mode bitmask after adding SSL_CTX_set_mode_APIParam_2 SSL_set_mode_APIParam_2
SSL_CTX_get_mode_APIName and SSL_get_mode_APIName return the current bitmask
Since the introduction of the ENGINE API, the recommended way of controlling default implementations is by using the ENGINE API functions
The default RAND_set_rand_method_APIParam_1, as set by RAND_set_rand_method_APIName and returned by RAND_get_rand_method_APIName, is only used if no ENGINE has been set as the default "rand" implementation
Hence, these two functions are no longer the recommended way to control defaults
If an alternative RAND_set_rand_method_APIParam_1 implementation is being used (either set directly or as provided by an ENGINE module), then it is entirely responsible for the generation and management of a cryptographically secure PRNG stream
The mechanisms described below relate solely to the software PRNG implementation built in to OpenSSL and used by default
These functions implement a cryptographically secure pseudo-random number generator (PRNG)
It is used by other library functions for example to generate random keys, and applications can use it when they need randomness
A cryptographic PRNG must be seeded with unpredictable data such as mouse movements or keys pressed at random by the user
This is described in RAND_add_APIName
Its state can be saved in a seed file (see RAND_load_file_APIName ) to avoid having to go through the seeding process whenever the application is started
RAND_bytes_APIName describes how to obtain random data from the PRNG
SSL_CTX_get_verify_mode_APIName returns the verification mode currently set in SSL_CTX_get_verify_mode_APIParam_1
SSL_get_verify_mode_APIName returns the verification mode currently set in SSL_get_verify_mode_APIParam_1
SSL_CTX_get_verify_depth_APIName returns the verification depth limit currently set in SSL_CTX_get_verify_depth_APIParam_1
If no limit has been explicitly set, -1 is returned and the default value will be used
SSL_get_verify_depth_APIName returns the verification depth limit currently set in SSL_get_verify_depth_APIParam_1
If no limit has been explicitly set, -1 is returned and the default value will be used
SSL_CTX_get_verify_callback_APIName returns a function pointer to the verification callback currently set in SSL_CTX_get_verify_mode_APIParam_1 SSL_CTX_get_verify_depth_APIParam_1
If no callback was explicitly set, the NULL pointer is returned and the default callback will be used
SSL_get_verify_callback_APIName returns a function pointer to the verification callback currently set in SSL_get_verify_depth_APIParam_1 SSL_get_verify_mode_APIParam_1
If no callback was explicitly set, the NULL pointer is returned and the default callback will be used
ERR_clear_error_APIName empties the current thread's error queue
ERR_clear_error_APIName has no return value
DH_new_APIName allocates and initializes a DH_new_APIParam_0 structure
DH_free_APIName frees the DH_free_APIParam_1 structure and its components
The values are erased before the memory is returned to the system
If the allocation fails, DH_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
DH_free_APIName returns no value
The EVP library provides a high-level interface to cryptographic functions
The EVP_PKEY functions support the full range of asymmetric algorithm operations:
The EVP_BytesToKey_APIName function provides some limited support for password based encryption
Careful selection of the parameters will provide a PKCS#5 PBKDF1 compatible implementation
However, new applications should not typically use this (preferring, for example, PBKDF2 from PCKS#5)
Algorithms are loaded with OpenSSL_add_all_algorithms_APIName
All the symmetric algorithms (ciphers), digests and asymmetric algorithms (public key algorithms) can be replaced by ENGINE modules providing alternative implementations
If ENGINE implementations of ciphers or digests are registered as defaults, then the various EVP functions will automatically use those implementations automatically in preference to built in software implementations
For more information, consult the engine_APIName man page
Although low level algorithm specific functions exist for many algorithms, their use is discouraged
They cannot be used with an ENGINE and ENGINE versions of new algorithms cannot be accessed using the low level functions
Also makes code harder to adapt to new algorithms and some options are not cleanly supported at the low level and some operations are more efficient using the high level interface
The function ASN1_TIME_set_APIName sets the ASN1_TIME structure ASN1_TIME_set_APIParam_1 to the time represented by the time_t value ASN1_TIME_set_APIParam_2
If ASN1_TIME_set_APIParam_1 is NULL , a new ASN1_TIME structure is allocated and returned
ASN1_TIME_set_string_APIName sets ASN1_TIME structure ASN1_TIME_set_string_APIParam_1 to the time represented by string ASN1_TIME_set_string_APIParam_2 which must be in appropriate ASN.1 time format (for example YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ)
ASN1_TIME_check_APIName checks the syntax of ASN1_TIME structure ASN1_TIME_check_APIParam_1
ASN1_TIME_print_APIName prints out the time ASN1_TIME_print_APIParam_2 to BIO ASN1_TIME_print_APIParam_1 in human readable format
It will be of the format MMM DD HH:MM:SS YYYY [GMT], for example "Feb 3 00:55:52 2015 GMT" it does not include a newline
If the time structure has invalid format, it prints out "Bad time value" and returns an error
The ASN1_TIME structure is represented as an ASN1_STRING internally and can be freed up using ASN1_STRING_free_APIName
The ASN1_TIME structure can represent years from 0000 to 9999 but no attempt is made to correct ancient calendar changes (for example from Julian to Gregorian calendars)
ASN1_TIME_print_APIName currently does not print out the time zone: it either prints out "GMT" or nothing
But all certificates complying with RFC5280 et al use GMT anyway
ASN1_TIME_set_APIName and ASN1_TIME_adj_APIName return a pointer to an ASN1_TIME structure or NULL if an error occurred
ASN1_TIME_set_string_APIName returns 1 if the time value is successfully set and 0 otherwise
ASN1_TIME_check_APIName returns 1 if the structure is syntactically correct and 0 otherwise
ASN1_TIME_print_APIName returns 1 if the time is successfully printed out and 0 if an error occurred (I/O error or invalid time format)
ASN1_TIME_diff_APIName returns 1 for sucess and 0 for failure
It can fail if the pass ASN1_TIME structure has invalid syntax for example
RAND_load_file_APIName reads a number of bytes from file RAND_load_file_APIParam_1 and adds them to the PRNG
If RAND_load_file_APIParam_2 is non-negative, up to to RAND_load_file_APIParam_2 are read; starting with OpenSSL 0.9.5, if RAND_load_file_APIParam_2 is -1, the complete file is read
RAND_write_file_APIName writes a number of random bytes (currently 1024) to file RAND_write_file_APIParam_1 RAND_load_file_APIParam_1 which can be used to initialize the PRNG by calling RAND_load_file_APIName in a later session
RAND_load_file_APIName returns the number of bytes read
RAND_write_file_APIName returns the number of bytes written, and -1 if the bytes written were generated without appropriate seed
RAND_file_name_APIName returns a pointer to RAND_file_name_APIParam_1 on success, and NULL on error
BIO_s_bio_APIName returns the method for a BIO pair
A BIO pair is a pair of source/sink BIOs where data written to either half of the pair is buffered and can be read from the other half
Both halves must usually by handled by the same application thread since no locking is done on the internal data structures
Since BIO chains typically end in a source/sink BIO, it is possible to make this one half of a BIO pair and have all the data processed by the chain under application control
One typical use of BIO pairs is to place TLS/SSL I/O under application control, this can be used when the application wishes to use a non standard transport for TLS/SSL or the normal socket routines are inappropriate
Calls to BIO_read_APIName will read data from the buffer or request a retry if no data is available
Calls to BIO_write_APIName will place data in the buffer or request a retry if the buffer is full
The standard calls BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName can be used to determine the amount of pending data in the read or write buffer
BIO_reset_APIName clears any data in the write buffer
BIO_make_bio_pair_APIName joins two separate BIOs into a connected pair
BIO_destroy_pair_APIName destroys the association between two connected BIOs
Freeing up any half of the pair will automatically destroy the association
BIO_shutdown_wr_APIName is used to close down a BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1
After this call no further writes on BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 are allowed (they will return an error)
Reads on the other half of the pair will return any pending data or EOF when all pending data has been read
BIO_set_write_buf_size_APIName sets the write buffer size of BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 to BIO_new_bio_pair_APIParam_2
If the size is not initialized ,a default value is used
This is currently 17K, sufficient for a maximum size TLS record
BIO_get_write_buf_size_APIName returns the size of the write buffer
BIO_new_bio_pair_APIName combines the calls to BIO_new_APIName, BIO_make_bio_pair_APIName and BIO_set_write_buf_size_APIName to create a connected pair of BIOs BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1, BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 with write buffer sizes BIO_new_bio_pair_APIParam_2 BIO_new_bio_pair_APIParam_2 and BIO_new_bio_pair_APIParam_4 BIO_new_bio_pair_APIParam_4
If either size is zero then the default size is used
BIO_new_bio_pair_APIName does not check whether BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1 or BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 do point to some other BIO, the values are overwritten, BIO_free_APIName is not called
BIO_get_write_guarantee_APIName and BIO_ctrl_get_write_guarantee_APIName return the maximum length of data that can be currently written to the BIO
Writes larger than this value will return a value from BIO_write_APIName less than the amount requested or if the buffer is full request a retry
BIO_ctrl_get_write_guarantee_APIName is a function whereas BIO_get_write_guarantee_APIName is a macro
BIO_ctrl_reset_read_request_APIName can also be used to reset the value returned by BIO_get_read_request_APIName to zero
Both halves of a BIO pair should be freed
That is even if one half is implicit freed due to a BIO_free_all_APIName or SSL_free_APIName call the other half needs to be freed
When used in bidirectional applications (such as TLS/SSL) care should be taken to flush any data in the write buffer
This can be done by calling BIO_pending_APIName on the other half of the pair and, if any data is pending, reading it and sending it to the underlying transport
This must be done before any normal processing (such as calling select_APIName ) due to a request and BIO_should_read_APIName being true
To see why this is important consider a case where a request is sent using BIO_write_APIName and a response read with BIO_read_APIName, this can occur during an TLS/SSL handshake for example
BIO_write_APIName will succeed and place data in the write buffer
BIO_read_APIName will initially fail and BIO_should_read_APIName will be true
If the application then waits for data to be available on the underlying transport before flushing the write buffer ,it will never succeed because the request was never sent!
BIO_eof_APIName is true if no data is in the peer BIO and the peer BIO has been shutdown
BIO_new_bio_pair_APIName returns 1 on success, with the new BIOs available in BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3, or 0 on failure, with NULL pointers stored into the locations for BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3
Check the error stack for more information
[XXXXX: More return values need to be added here]
As the data is buffered, SSL_operation_APIName may return with a ERROR_SSL_WANT_READ condition, but there is still data in the write buffer
An application must not rely on the error value of SSL_operation_APIName but must assure that the write buffer is always flushed first
Otherwise a deadlock may occur as the peer might be waiting for the data before being able to continue
Applications will not normally call EVP_PKEY_CTX_ctrl_APIName directly but will instead call one of the algorithm specific macros below
All the remaining "functions" are implemented as macros
The EVP_PKEY_CTX_set_signature_md_APIName macro sets the message digest type used in a signature
The EVP_PKEY_CTX_set_signature_md_APIName macro can be used with any public key algorithm supporting signature operations
The macro EVP_PKEY_CTX_set_rsa_padding_APIName sets the RSA padding mode for EVP_PKEY_CTX_set_rsa_padding_APIParam_1
The EVP_PKEY_CTX_set_rsa_padding_APIParam_2 parameter can take the value RSA_PKCS1_PADDING for PKCS#1 padding, RSA_SSLV23_PADDING for SSLv23 padding, RSA_NO_PADDING for no padding, RSA_PKCS1_OAEP_PADDING for OAEP padding (encrypt and decrypt only), RSA_X931_PADDING for X9.31 padding (signature operations only) and RSA_PKCS1_PSS_PADDING (sign and verify only)
Two RSA padding modes behave differently if EVP_PKEY_CTX_set_signature_md_APIName is used
If this macro is called for PKCS#1 padding ,the plaintext buffer is an actual digest value and is encapsulated in a DigestInfo structure according to PKCS#1 when signing and this structure is expected (and stripped off) when verifying
If this control is not used with RSA and PKCS#1 padding then the supplied data is used directly and not encapsulated
In the case of X9.31 padding for RSA the algorithm identifier byte is added or checked and removed if this control is called
If it is not called then the first byte of the plaintext buffer is expected to be the algorithm identifier byte
The EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIName macro sets the public exponent value for RSA key generation to EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIParam_2 currently it should be an odd integer
The EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIParam_2 pointer is used internally by this function so it should not be modified or free after the call
If this macro is not called then 65537 is used
The EVP_PKEY_CTX_set_dh_paramgen_generator_APIName macro sets DH generator to EVP_PKEY_CTX_set_dh_paramgen_generator_APIParam_2 for DH parameter generation
If not specified 2 is used
The EVP_PKEY_CTX_set_ec_paramgen_curve_nid_APIName sets the EC curve for EC parameter generation to EVP_PKEY_CTX_set_ec_paramgen_curve_nid_APIParam_2
For EC parameter generation this macro must be called or an error occurs because there is no default curve
EVP_PKEY_CTX_ctrl_APIName and its macros return a positive value for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
CMS_add1_signer_APIName adds a signer with certificate CMS_add1_signer_APIParam_2 and private key CMS_add1_signer_APIParam_3 using message digest CMS_add1_signer_APIParam_4 to CMS_ContentInfo SignedData structure CMS_add1_signer_APIParam_1
If the CMS_add1_signer_APIParam_4 parameter is NULL ,then the default digest for the public key algorithm will be used
Any of the following flags (ored together) can be passed in the CMS_add1_signer_APIParam_5 parameter
If present the SMIMECapabilities attribute indicates support for the following algorithms in preference order: 256 bit AES, Gost R3411-94, Gost 28147-89, 192 bit AES, 128 bit AES, triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2
If any of these algorithms is not available then it will not be included: for example the GOST algorithms will not be included if the GOST ENGINE is not loaded
CMS_add1_signer_APIName returns an internal pointer to the CMS_SignerInfo structure just added, this can be used to set additional attributes before it is finalized
CMS_add1_signer_APIName returns an internal pointer to the CMS_SignerInfo structure just added or NULL if an error occurs
After the call to EVP_PKEY_encrypt_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The function EVP_PKEY_encrypt_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_encrypt_init_APIName and EVP_PKEY_encrypt_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
RAND_cleanup_APIName erases the memory used by the PRNG
RAND_cleanup_APIName returns no value
These functions handle application specific data in X509_STORE_CTX structures
These functions usage is identical to that of RSA_get_ex_new_index_APIName, RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName
The EVP cipher routines are a high level interface to certain symmetric ciphers
EVP_CIPHER_CTX_init_APIName initializes cipher contex EVP_EncryptUpdate_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1
If padding is disabled, then EVP_EncryptFinal_ex_APIName will not encrypt any more data and it will return an error if any data remains in a partial block: that is if the total data length is not a multiple of the block size
EVP_CIPHER_CTX_cleanup_APIName clears all information from a cipher context and free up any allocated memory associate with EVP_CIPHER_CTX_cleanup_APIName
EVP_CIPHER_CTX_cleanup_APIName should be called after all operations using a cipher are complete so sensitive information does not remain in memory
EVP_EncryptInit_APIName, EVP_DecryptInit_APIName and EVP_CipherInit_APIName behave in a similar way to EVP_EncryptInit_ex_APIName, EVP_DecryptInit_ex and EVP_CipherInit_ex_APIName except the EVP_EncryptInit_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_CipherInit_APIParam_1 EVP_EncryptInit_ex_APIParam_1 EVP_CipherInit_ex_APIParam_1 parameter does not need to be initialized and they always use the default cipher implementation
EVP_EncryptFinal_APIName, EVP_DecryptFinal_APIName and EVP_CipherFinal_APIName are identical to EVP_EncryptFinal_ex_APIName, EVP_DecryptFinal_ex_APIName and EVP_CipherFinal_ex_APIName
In previous releases they also cleaned up the EVP_EncryptFinal_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_CipherFinal_ex_APIParam_1, but this is no longer done and EVP_CIPHER_CTX_clean_APIName must be called to free any context resources
EVP_get_cipherbyname_APIName, EVP_get_cipherbynid_APIName and EVP_get_cipherbyobj_APIName return an EVP_CIPHER structure when passed a cipher name, a NID or an ASN1_OBJECT structure
EVP_CIPHER_nid_APIName and EVP_CIPHER_CTX_nid_APIName return the NID of a cipher when passed an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 or EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 structure
The actual NID value is an internal value which may not have a corresponding OBJECT IDENTIFIER
EVP_CIPHER_CTX_set_key_length_APIName sets the key length of the cipher ctx
If the cipher is a fixed length cipher ,then attempting to set the key length to any value other than the fixed value is an error
EVP_CIPHER_CTX_cipher_APIName returns the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 structure when passed an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 structure
EVP_CIPHER_mode_APIName and EVP_CIPHER_CTX_mode_APIName return the block cipher mode: EVP_CIPH_ECB_MODE, EVP_CIPH_CBC_MODE, EVP_CIPH_CFB_MODE or EVP_CIPH_OFB_MODE
If the cipher is a stream cipher ,then EVP_CIPH_STREAM_CIPHER is returned
EVP_CIPHER_CTX_ctrl_APIName allows various cipher specific parameters to be determined and set
EVP_EncryptInit_ex_APIName, EVP_EncryptUpdate_APIName and EVP_EncryptFinal_ex_APIName return 1 for success and 0 for failure
EVP_DecryptInit_ex_APIName and EVP_DecryptUpdate_APIName return 1 for success and 0 for failure
EVP_DecryptFinal_ex_APIName returns 0 if the decrypt failed or 1 for success
EVP_CipherInit_ex_APIName and EVP_CipherUpdate_APIName return 1 for success and 0 for failure
EVP_CipherFinal_ex_APIName returns 0 for a decryption failure or 1 for success
EVP_CIPHER_CTX_cleanup_APIName returns 1 for success and 0 for failure
EVP_get_cipherbyname_APIName, EVP_get_cipherbynid_APIName and EVP_get_cipherbyobj_APIName return an EVP_get_cipherbyname_APIParam_0 structure or NULL on error
EVP_CIPHER_nid_APIName and EVP_CIPHER_CTX_nid_APIName return a NID
EVP_CIPHER_block_size_APIName and EVP_CIPHER_CTX_block_size_APIName return the block size
EVP_CIPHER_key_length_APIName and EVP_CIPHER_CTX_key_length_APIName return the key length
EVP_CIPHER_CTX_set_padding_APIName always returns 1
EVP_CIPHER_iv_length_APIName and EVP_CIPHER_CTX_iv_length_APIName return the IV length or zero if the cipher does not use an IV
EVP_CIPHER_type_APIName and EVP_CIPHER_CTX_type_APIName return the NID of the cipher's OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER
EVP_CIPHER_CTX_cipher_APIName returns an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 structure
EVP_CIPHER_param_to_asn1_APIName and EVP_CIPHER_asn1_to_param_APIName return 1 for success or zero for failure
Where possible the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 interface to symmetric ciphers should be used in preference to the low level interfaces
This is because the code then becomes transparent to the cipher used and much more flexible
Additionally, the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_CipherFinal_ex_APIParam_1 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_DecryptUpdate_APIParam_1 EVP_EncryptFinal_APIParam_1 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 interface will ensure the use of platform specific cryptographic acceleration such as AES-NI (the low level interfaces do not provide the guarantee)
PKCS padding works by adding EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CIPHER_CTX_ctrl_APIParam_2 EVP_CIPHER_type_APIParam_1 EVP_EncryptFinal_ex_APIParam_2 EVP_CipherFinal_APIParam_2 EVP_CipherFinal_ex_APIParam_2 EVP_DecryptUpdate_APIParam_2 EVP_EncryptFinal_APIParam_2 EVP_EncryptInit_APIParam_2 EVP_CipherUpdate_APIParam_2 EVP_EncryptInit_ex_APIParam_2 padding bytes of value EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CIPHER_CTX_ctrl_APIParam_2 EVP_CIPHER_type_APIParam_1 EVP_EncryptFinal_ex_APIParam_2 EVP_CipherFinal_APIParam_2 EVP_CipherFinal_ex_APIParam_2 EVP_DecryptUpdate_APIParam_2 EVP_EncryptFinal_APIParam_2 EVP_EncryptInit_APIParam_2 EVP_CipherUpdate_APIParam_2 EVP_EncryptInit_ex_APIParam_2 to make the total length of the encrypted data a multiple of the block size
Padding is always added so if the data is already a multiple of the block size EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CIPHER_CTX_ctrl_APIParam_2 EVP_CIPHER_type_APIParam_1 EVP_EncryptFinal_ex_APIParam_2 EVP_CipherFinal_APIParam_2 EVP_CipherFinal_ex_APIParam_2 EVP_DecryptUpdate_APIParam_2 EVP_EncryptFinal_APIParam_2 EVP_EncryptInit_APIParam_2 EVP_CipherUpdate_APIParam_2 EVP_EncryptInit_ex_APIParam_2 will equal the block size
For example if the block size is 8 and 11 bytes are to be encrypted then 5 padding bytes of value 5 will be added
When decrypting the final block is checked to see if the final block has the correct form
Although the decryption operation can produce an error if padding is enabled, it is not a strong test that the input data or key is correct
A random block has better than 1 in 256 chance of being of the correct format and problems with the input data earlier on will not produce a final decrypt error
If padding is disabled ,then the decryption operation will always succeed if the total amount of data decrypted is a multiple of the block size
The functions EVP_EncryptInit_APIName, EVP_EncryptFinal_APIName, EVP_DecryptInit_APIName, EVP_CipherInit_APIName and EVP_CipherFinal_APIName are obsolete but are retained for compatibility with existing code
New code should use EVP_EncryptInit_ex_APIName, EVP_EncryptFinal_ex_APIName, EVP_DecryptInit_ex_APIName, EVP_DecryptFinal_ex_APIName, EVP_CipherInit_ex_APIName and EVP_CipherFinal_ex_APIName because they can reuse an existing context without allocating and freeing it up on each call
For RC5 the number of rounds can currently only be set to 8, 12 or 16
This is a limitation of the current RC5 code rather than the EVP interface
EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with default key lengths
If custom ciphers exceed these values, the results are unpredictable
This is because it has become standard practice to define a generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH bytes
The ASN1 code is incomplete (and sometimes inaccurate) The ASN1 code has only been tested for certain common S/MIME ciphers (RC2, DES, triple DES) in CBC mode
The BIO_push_APIName function appends the BIO BIO_push_APIParam_2 to BIO_push_APIParam_1, it returns BIO_push_APIParam_1
BIO_pop_APIName removes the BIO BIO_pop_APIParam_1 from a chain and returns the next BIO in the chain, or NULL if there is no next BIO
The removed BIO then becomes a single BIO with no association with the original chain, it can thus be freed or attached to a different chain
The names of these functions are perhaps a little misleading
BIO_push_APIName joins two BIO chains whereas BIO_pop_APIName deletes a single BIO from a chain, the deleted BIO does not need to be at the end of a chain
The process of calling BIO_push_APIName and BIO_pop_APIName on a BIO may have additional consequences (a control call is made to the affected BIOs) any effects will be noted in the descriptions of individual BIOs
BIO_push_APIName returns the end of the chain, BIO_push_APIParam_1
BIO_pop_APIName returns the next BIO in the chain, or NULL if there is no next BIO
SSL_pending_APIName returns the number of bytes which are available inside SSL_pending_APIParam_1 for immediate read
Data are received in blocks from the peer
Therefore data can be buffered inside SSL_pending_APIParam_1 and are ready for immediate retrieval with SSL_read_APIName
The number of bytes pending is returned
Up to OpenSSL 0.9.6, SSL_pending_APIName does not check if the record type of pending data is application data
This library performs arithmetic operations on integers of arbitrary size
It was written for use in public key cryptography, such as RSA and Diffie-Hellman
It uses dynamic memory allocation for storing its data structures
That means that there is no limit on the size of the numbers manipulated by these functions, but return values must always be checked in case a memory allocation error has occurred
The basic object in this library is a BN_init_APIParam_1
It is used to hold a single large integer
This type should be considered opaque and fields should not be modified or accessed directly
The creation of BN_add_APIParam_1 BN_cmp_APIParam_1 BN_zero_APIParam_1 BN_rand_APIParam_1 BN_generate_prime_APIParam_1 BN_set_bit_APIParam_1 BN_bn2bin_APIParam_1 objects is described in BN_new_APIName ; BN_add_APIName describes most of the arithmetic operations
Comparison is described in BN_cmp_APIName ; BN_zero_APIName describes certain assignments, BN_rand_APIName the generation of random numbers, BN_generate_prime_APIName deals with prime numbers and BN_set_bit_APIName with bit operations
The conversion of BN_add_APIParam_1 BN_cmp_APIParam_1 BN_zero_APIParam_1 BN_rand_APIParam_1 BN_generate_prime_APIParam_1 BN_set_bit_APIParam_1 BN_bn2bin_APIParam_1s to external formats is described in BN_bn2bin_APIName
SSL_CTX_set_client_CA_list_APIName and SSL_set_client_CA_list_APIName do not return diagnostic information
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName have the following return values:
The PEM functions read or write structures in PEM format
In this sense PEM format is simply base64 encoded data surrounded by header lines
PEM_write_bio_PKCS8PrivateKey_nid_APIName and PEM_write_PKCS8PrivateKey_nid_APIName also write out a private key as a PKCS#8 EncryptedPrivateKeyInfo however it uses PKCS#5 v1.5 or PKCS#12 encryption algorithms instead
The algorithm to use is specified in the PEM_write_bio_PKCS8PrivateKey_nid_APIParam_3 PEM_write_PKCS8PrivateKey_nid_APIParam_3 parameter and should be the NID of the corresponding OBJECT IDENTIFIER (see NOTES section)
The PEM_write_X509_REQ_NEW_APIParam_2 PEM_read_bio_X509_AUX_APIParam_2 PEM_read_X509_REQ_APIParam_2 PEM_read_bio_X509_REQ_APIParam_2 PEM_write_bio_X509_AUX_APIParam_2 PEM_write_bio_X509_REQ_NEW_APIParam_2 PEM_write_X509_CRL_APIParam_2 PEM_write_bio_X509_REQ_APIParam_2 PEM_write_X509_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_write_X509_AUX_APIParam_2 PEM_write_X509_REQ_APIParam_2 PEM_read_bio_X509_APIParam_2 PEM_read_X509_AUX_APIParam_2 PEM_read_X509_CRL_APIParam_2 PEM_read_bio_X509_CRL_APIParam_2 PEM_write_bio_X509_APIParam_2 PEM_read_X509_APIParam_2 functions process an X509 certificate using an X509 structure
They will also process a trusted X509 certificate but any trust settings are discarded
The PEM_write_X509_CRL_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_read_X509_CRL_APIParam_2 PEM_read_bio_X509_CRL_APIParam_2 functions process an X509 CRL using an X509_CRL structure
The PEM_read_PKCS7_APIParam_2 PEM_read_bio_PKCS7_APIParam_2 PEM_write_PKCS7_APIParam_2 PEM_write_bio_PKCS7_APIParam_2 functions process a PKCS#7 ContentInfo using a PKCS7 structure
The PEM_write_bio_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_NETSCAPE_CERT_SEQUENCE_APIParam_2 functions process a Netscape Certificate Sequence using a NETSCAPE_CERT_SEQUENCE structure
A frequent cause of problems is attempting to use the PEM routines like this:
this is a bug because an attempt will be made to reuse the data at PEM_read_PrivateKey_APIParam_2 PEM_read_DHparams_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_2 PEM_read_bio_RSAPrivateKey_APIParam_2 PEM_read_bio_X509_AUX_APIParam_2 PEM_read_X509_REQ_APIParam_2 PEM_read_bio_X509_REQ_APIParam_2 PEM_read_RSAPrivateKey_APIParam_2 PEM_read_bio_PrivateKey_APIParam_2 PEM_read_PKCS7_APIParam_2 PEM_read_bio_PUBKEY_APIParam_2 PEM_write_bio_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_DSA_PUBKEY_APIParam_2 PEM_write_DSAparams_APIParam_2 PEM_write_PKCS8PrivateKey_APIParam_2 PEM_write_bio_X509_AUX_APIParam_2 PEM_write_bio_DSA_PUBKEY_APIParam_2 PEM_write_bio_PKCS8PrivateKey_APIParam_2 PEM_write_bio_RSAPrivateKey_APIParam_2 PEM_write_PUBKEY_APIParam_2 PEM_write_bio_X509_REQ_NEW_APIParam_2 PEM_write_X509_CRL_APIParam_2 PEM_write_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_RSAPublicKey_APIParam_2 PEM_write_bio_X509_REQ_APIParam_2 PEM_write_X509_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_write_bio_DSAparams_APIParam_2 PEM_read_bio_PKCS7_APIParam_2 PEM_write_X509_AUX_APIParam_2 PEM_read_RSA_PUBKEY_APIParam_2 PEM_read_PUBKEY_APIParam_2 PEM_read_bio_DSA_PUBKEY_APIParam_2 PEM_write_bio_RSA_PUBKEY_APIParam_2 PEM_read_bio_DSAPrivateKey_APIParam_2 PEM_read_RSAPublicKey_APIParam_2 PEM_write_DHparams_APIParam_2 PEM_write_X509_REQ_APIParam_2 PEM_read_bio_DHparams_APIParam_2 PEM_write_bio_PKCS8PrivateKey_nid_APIParam_2 PEM_read_bio_X509_APIParam_2 PEM_write_bio_PrivateKey_APIParam_2 PEM_read_DSA_PUBKEY_APIParam_2 PEM_write_bio_RSAPublicKey_APIParam_2 PEM_read_X509_AUX_APIParam_2 PEM_write_RSAPrivateKey_APIParam_2 PEM_write_bio_DHparams_APIParam_2 PEM_write_PKCS7_APIParam_2 PEM_write_PKCS8PrivateKey_nid_APIParam_2 PEM_write_bio_DSAPrivateKey_APIParam_2 PEM_write_bio_PUBKEY_APIParam_2 PEM_write_DSAPrivateKey_APIParam_2 PEM_read_DSAparams_APIParam_2 PEM_read_bio_RSAPublicKey_APIParam_2 PEM_write_RSA_PUBKEY_APIParam_2 PEM_read_bio_DSAparams_APIParam_2 PEM_read_X509_CRL_APIParam_2 PEM_read_bio_X509_CRL_APIParam_2 PEM_write_bio_X509_APIParam_2 PEM_write_bio_PKCS7_APIParam_2 PEM_read_X509_APIParam_2 PEM_write_PrivateKey_APIParam_2 PEM_read_bio_RSA_PUBKEY_APIParam_2 PEM_read_DSAPrivateKey_APIParam_2 which is an uninitialised pointer
The PEM read routines in some versions of OpenSSL will not correctly reuse an existing structure
Therefore the following:
where PEM_read_PrivateKey_APIParam_2 PEM_read_DHparams_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_2 PEM_read_bio_RSAPrivateKey_APIParam_2 PEM_read_bio_X509_AUX_APIParam_2 PEM_read_X509_REQ_APIParam_2 PEM_read_bio_X509_REQ_APIParam_2 PEM_read_RSAPrivateKey_APIParam_2 PEM_read_bio_PrivateKey_APIParam_2 PEM_read_PKCS7_APIParam_2 PEM_read_bio_PUBKEY_APIParam_2 PEM_write_bio_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_DSA_PUBKEY_APIParam_2 PEM_write_DSAparams_APIParam_2 PEM_write_PKCS8PrivateKey_APIParam_2 PEM_write_bio_X509_AUX_APIParam_2 PEM_write_bio_DSA_PUBKEY_APIParam_2 PEM_write_bio_PKCS8PrivateKey_APIParam_2 PEM_write_bio_RSAPrivateKey_APIParam_2 PEM_write_PUBKEY_APIParam_2 PEM_write_bio_X509_REQ_NEW_APIParam_2 PEM_write_X509_CRL_APIParam_2 PEM_write_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_RSAPublicKey_APIParam_2 PEM_write_bio_X509_REQ_APIParam_2 PEM_write_X509_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_write_bio_DSAparams_APIParam_2 PEM_read_bio_PKCS7_APIParam_2 PEM_write_X509_AUX_APIParam_2 PEM_read_RSA_PUBKEY_APIParam_2 PEM_read_PUBKEY_APIParam_2 PEM_read_bio_DSA_PUBKEY_APIParam_2 PEM_write_bio_RSA_PUBKEY_APIParam_2 PEM_read_bio_DSAPrivateKey_APIParam_2 PEM_read_RSAPublicKey_APIParam_2 PEM_write_DHparams_APIParam_2 PEM_write_X509_REQ_APIParam_2 PEM_read_bio_DHparams_APIParam_2 PEM_write_bio_PKCS8PrivateKey_nid_APIParam_2 PEM_read_bio_X509_APIParam_2 PEM_write_bio_PrivateKey_APIParam_2 PEM_read_DSA_PUBKEY_APIParam_2 PEM_write_bio_RSAPublicKey_APIParam_2 PEM_read_X509_AUX_APIParam_2 PEM_write_RSAPrivateKey_APIParam_2 PEM_write_bio_DHparams_APIParam_2 PEM_write_PKCS7_APIParam_2 PEM_write_PKCS8PrivateKey_nid_APIParam_2 PEM_write_bio_DSAPrivateKey_APIParam_2 PEM_write_bio_PUBKEY_APIParam_2 PEM_write_DSAPrivateKey_APIParam_2 PEM_read_DSAparams_APIParam_2 PEM_read_bio_RSAPublicKey_APIParam_2 PEM_write_RSA_PUBKEY_APIParam_2 PEM_read_bio_DSAparams_APIParam_2 PEM_read_X509_CRL_APIParam_2 PEM_read_bio_X509_CRL_APIParam_2 PEM_write_bio_X509_APIParam_2 PEM_write_bio_PKCS7_APIParam_2 PEM_read_X509_APIParam_2 PEM_write_PrivateKey_APIParam_2 PEM_read_bio_RSA_PUBKEY_APIParam_2 PEM_read_DSAPrivateKey_APIParam_2 already contains a valid certificate, may not work, whereas:
is guaranteed to work
The function EVP_PKEY_missing_parameters_APIName returns 1 if the public key parameters of EVP_PKEY_missing_parameters_APIParam_1 are missing and 0 if they are present or the algorithm doesn't use parameters
The function EVP_PKEY_copy_parameters_APIName copies the parameters from key EVP_PKEY_copy_parameters_APIParam_2 to key EVP_PKEY_copy_parameters_APIParam_1
An error is returned if the parameters are missing in EVP_PKEY_copy_parameters_APIParam_2 or present in both EVP_PKEY_copy_parameters_APIParam_2 and EVP_PKEY_copy_parameters_APIParam_1 and mismatch
If the parameters in EVP_PKEY_copy_parameters_APIParam_2 and EVP_PKEY_copy_parameters_APIParam_1 are both present and match this function has no effect
The function EVP_PKEY_cmp_parameters_APIName compares the parameters of keys EVP_PKEY_cmp_parameters_APIParam_1 and EVP_PKEY_cmp_parameters_APIParam_2
The function EVP_PKEY_cmp_APIName compares the public key components and paramters (if present) of keys EVP_PKEY_cmp_APIParam_1 and EVP_PKEY_cmp_APIParam_2
The main purpose of the functions EVP_PKEY_missing_parameters_APIName and EVP_PKEY_copy_parameters_APIName is to handle public keys in certificates where the parameters are sometimes omitted from a public key if they are inherited from the CA that signed it
Since OpenSSL private keys contain public key components too the function EVP_PKEY_cmp_APIName can also be used to determine if a private key matches a public key
The function EVP_PKEY_missing_parameters_APIName returns 1 if the public key parameters of EVP_PKEY_missing_parameters_APIParam_1 are missing and 0 if they are present or the algorithm doesn't use parameters
These functions EVP_PKEY_copy_parameters_APIName returns 1 for success and 0 for failure
The function EVP_PKEY_cmp_parameters_APIName and EVP_PKEY_cmp_APIName return 1 if the keys match, 0 if they don't match, -1 if the key types are different and -2 if the operation is not supported
One of these functions should be called before generating textual error messages
However, this is not required when memory usage is an issue
ERR_free_strings_APIName frees all previously loaded error strings
ERR_load_crypto_strings_APIName, SSL_load_error_strings_APIName and ERR_free_strings_APIName return no values
A DH_set_method_APIParam_2 DH_set_default_method_APIParam_1 specifies the functions that OpenSSL uses for Diffie-Hellman operations
By modifying the method, alternative implementations such as hardware accelerators may be used
IMPORTANT: See the NOTES section for important information about how these DH API functions are affected by the use of DH_new_method_APIParam_1 API calls
Initially, the default DH_METHOD is the OpenSSL internal implementation, as returned by DH_OpenSSL_APIName
DH_get_default_method_APIName returns a pointer to the current default DH_METHOD
However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended
DH_set_method_APIName selects DH_set_method_APIParam_2 to perform all operations using the key DH_set_method_APIParam_1
This will replace the DH_METHOD used by the DH key and if the previous method was supplied by an ENGINE, the handle to that ENGINE will be released during the change
It is possible to have DH keys that only work with certain DH_METHOD implementations (eg from an ENGINE module that supports embedded hardware-protected keys), and in such cases attempting to change the DH_METHOD for the key can have unexpected results
DH_new_method_APIName allocates and initializes a DH structure so that DH_new_method_APIParam_1 will be used for the DH operations
If DH_new_method_APIParam_1 is NULL, the default ENGINE for DH operations is used, and if no default ENGINE is set, the DH_METHOD controlled by DH_set_default_method_APIName is used
DH_OpenSSL_APIName and DH_get_default_method_APIName return pointers to the respective DH_OpenSSL_APIParam_0 DH_get_default_method_APIParam_0s
DH_set_default_method_APIName returns no value
DH_set_method_APIName returns non-zero if the provided DH_set_method_APIParam_2 was successfully set as the method for DH_set_method_APIParam_1 (including unloading the ENGINE handle if the previous method was supplied by an ENGINE)
DH_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails
Otherwise it returns a pointer to the newly allocated structure
As of version 0.9.7, DH_METHOD implementations are grouped together with other algorithmic APIs (eg RSA_METHOD, EVP_CIPHER, etc) in DH_new_method_APIParam_1 modules
If a default ENGINE is specified for DH functionality using an ENGINE API function, that will override any DH defaults set using the DH API (ie DH_set_default_method_APIName)
For this reason, the ENGINE API is the recommended way to control default implementations for use in DH and other cryptographic algorithms
SSL_CTX_get0_param_APIName and SSL_get0_param_APIName retrieve an internal pointer to the verification parameters for SSL_CTX_get0_param_APIParam_1 or SSL_get0_param_APIParam_1 respectively
The returned pointer must not be freed by the calling application
SSL_CTX_set1_param_APIName and SSL_set1_param_APIName set the verification parameters to SSL_CTX_set1_param_APIParam_2 SSL_set1_param_APIParam_2 for SSL_CTX_set1_param_APIParam_1 or SSL_set1_param_APIParam_1
Typically parameters are retrieved from an SSL_CTX_get0_param_APIParam_1 or SSL_CTX_get0_param_APIParam_1 SSL_get0_param_APIParam_1 structure using SSL_CTX_get0_param_APIName or SSL_get0_param_APIName and an application modifies SSL_CTX_get0_param_APIName or SSL_get0_param_APIName to suit an application needs: for example to add a hostname check
SSL_CTX_get0_param_APIName and SSL_get0_param_APIName return a pointer to an SSL_CTX_get0_param_APIParam_0 SSL_get0_param_APIParam_0 structure
SSL_CTX_set1_param_APIName and SSL_set1_param_APIName return 1 for success and 0 for failure
i2d_PKCS7_bio_stream_APIName outputs a PKCS7 structure in BER format
It is otherwise identical to the function SMIME_write_PKCS7_APIName
This function is effectively a version of the d2i_PKCS7_bio_APIName supporting streaming
The prefix "i2d" is arguably wrong because the function outputs BER format
i2d_PKCS7_bio_stream_APIName returns 1 for success or 0 for failure
X509_cmp_time_APIName compares the ASN1_TIME in X509_cmp_time_APIParam_1 with the time in <cmp_time>
X509_cmp_time_APIParam_1 must satisfy the ASN1_TIME format mandated by RFC 5280, ie, X509_cmp_time_APIParam_1 format must be either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ
If X509_cmp_time_APIParam_2 is NULL, the current time is used
Unlike many standard comparison functions, X509_cmp_time returns 0 on error
X509_cmp_time_APIName returns -1 if X509_cmp_time_APIParam_1 is earlier than, or equal to, X509_cmp_time_APIParam_2, and 1 otherwise
It returns 0 on error
An EC_KEY represents a public key and (optionaly) an associated private key
A new EC_KEY (with no associated curve) can be constructed by calling EC_KEY_new
The reference count for the newly created EC_KEY is initially set to 1
A curve can be associated with the EC_KEY by calling EC_KEY_set_group
Alternatively a new EC_KEY can be constructed by calling EC_KEY_new_by_curve_name and supplying the nid of the associated curve
Refer to EC_GROUP_new_APIName for a description of curve names
This function simply wraps calls to EC_KEY_new and EC_GROUP_new_by_curve_name
Calling EC_KEY_free decrements the reference count for the EC_KEY object, and if it has dropped to zero ,then frees the memory associated with it
EC_KEY_up_ref increments the reference count associated with the EC_KEY object
EC_KEY_generate_key generates a new public and private key for the supplied EC_KEY_set_asn1_flag_APIParam_1 EC_KEY_set_conv_form_APIParam_1 object
EC_KEY_set_asn1_flag_APIParam_1 EC_KEY_set_conv_form_APIParam_1 must have an EC_GROUP object associated with it before calling this function
The private key is a random integer (0 < priv_key < order, where order is the order of the EC_GROUP object)
The public key is an EC_POINT on the curve calculated by multiplying the generator for the curve by the private key
EC_KEY_check_key performs various sanity checks on the EC_KEY object to confirm that it is valid
EC_KEY_set_public_key_affine_coordinates sets the public key for EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_free_APIParam_1 EC_KEY_clear_flags_APIParam_1 EC_KEY_check_key_APIParam_1 EC_KEY_insert_key_method_data_APIParam_1 EC_KEY_get0_group_APIParam_1 EC_KEY_get0_public_key_APIParam_1 EC_KEY_get_flags_APIParam_1 EC_KEY_set_public_key_affine_coordinates_APIParam_1 based on its affine co-ordinates, ie it constructs an EC_POINT object based on the supplied EC_KEY_set_public_key_affine_coordinates_APIParam_2 and EC_KEY_set_public_key_affine_coordinates_APIParam_3 values and sets the public key to be this EC_POINT
It will also performs certain sanity checks on the key to confirm that it is valid
The functions EC_KEY_get0_group, EC_KEY_set_group, EC_KEY_get0_private_key, EC_KEY_set_private_key, EC_KEY_get0_public_key, and EC_KEY_set_public_key get and set the EC_GROUP object, the private key and the EC_POINT public key for the EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_free_APIParam_1 EC_KEY_clear_flags_APIParam_1 EC_KEY_check_key_APIParam_1 EC_KEY_insert_key_method_data_APIParam_1 EC_KEY_get0_group_APIParam_1 EC_KEY_get0_public_key_APIParam_1 EC_KEY_get_flags_APIParam_1 EC_KEY_set_public_key_affine_coordinates_APIParam_1 respectively
The functions EC_KEY_get_conv_form and EC_KEY_set_conv_form get and set the point_conversion_form for the EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_free_APIParam_1 EC_KEY_clear_flags_APIParam_1 EC_KEY_check_key_APIParam_1 EC_KEY_insert_key_method_data_APIParam_1 EC_KEY_get0_group_APIParam_1 EC_KEY_get0_public_key_APIParam_1 EC_KEY_get_flags_APIParam_1 EC_KEY_set_public_key_affine_coordinates_APIParam_1
For a description of point_conversion_forms please refer to EC_POINT_new_APIName
EC_KEY_insert_key_method_data and EC_KEY_get_key_method_data enable the caller to associate arbitrary additional data specific to the elliptic curve scheme being used with the EC_KEY object
This data is treated as a "black box" by the ec library
The data to be stored by EC_KEY_insert_key_method_data is provided in the EC_KEY_insert_key_method_data_APIParam_2 parameter, which must have associated functions for duplicating, freeing and "clear_freeing" the data item
If a subsequent EC_KEY_get_key_method_data call is issued, the functions for duplicating, freeing and "clear_freeing" the data item must be provided again, and they must be the same as they were when the data item was inserted
EC_KEY_set_flags sets the flags in the EC_KEY_set_flags_APIParam_2 EC_KEY_clear_flags_APIParam_2 parameter on the EC_KEY object
Any flags that are already set are left set
The currently defined standard flags are EC_FLAG_NON_FIPS_ALLOW and EC_FLAG_FIPS_CHECKED
In addition there is the flag EC_FLAG_COFACTOR_ECDH which is specific to ECDH and is defined in ecdh.h
EC_KEY_get_flags returns the current flags that are set for this EC_KEY
EC_KEY_clear_flags clears the flags indicated by the EC_KEY_set_flags_APIParam_2 EC_KEY_clear_flags_APIParam_2 parameter
All other flags are left in their existing state
EC_KEY_set_asn1_flag sets the asn1_flag on the underlying EC_GROUP object (if set)
Refer to EC_GROUP_copy_APIName for further information on the asn1_flag
EC_KEY_precompute_mult stores multiples of the underlying EC_GROUP generator for faster point multiplication
See also EC_POINT_add_APIName
EC_KEY_new, EC_KEY_new_by_curve_name and EC_KEY_dup return a pointer to the newly created EC_KEY object, or NULL on error
EC_KEY_get_flags returns the flags associated with the EC_KEY object as an integer
EC_KEY_copy returns a pointer to the destination key, or NULL on error
EC_KEY_up_ref, EC_KEY_set_group, EC_KEY_set_private_key, EC_KEY_set_public_key, EC_KEY_precompute_mult, EC_KEY_generate_key, EC_KEY_check_key and EC_KEY_set_public_key_affine_coordinates return 1 on success or 0 on error
EC_KEY_get0_group returns the EC_GROUP associated with the EC_KEY
EC_KEY_get0_private_key returns the private key associated with the EC_KEY
EC_KEY_get_conv_form return the point_conversion_form for the EC_KEY
RC4 is a stream cipher with variable key length
Typically, 128 bit (16 byte) keys are used for strong encryption, but shorter insecure key sizes have been widely used due to export restrictions
RC4 consists of a key setup phase and the actual encryption or decryption phase
RC4_set_key_APIName sets up the RC4_set_key_APIParam_1 RC4_set_key_APIParam_1 using the RC4_set_key_APIParam_2 bytes long key at RC4_set_key_APIParam_3
Since RC4 is a stream cipher (the input is XORed with a pseudo-random key stream to produce the output), decryption uses the same function calls as encryption
Applications should use the higher level functions EVP_EncryptInit_APIName etc instead of calling the RC4 functions directly
RC4_set_key_APIName and RC4_APIName do not return values
Certain conditions have to be observed to securely use stream ciphers
It is not permissible to perform multiple encryptions using the same key stream
SSL_get_verify_result_APIName returns the result of the verification of the X509 certificate presented by the peer, if any
SSL_get_verify_result_APIName can only return one error code while the verification of a certificate can fail because of many reasons at the same time
Only the last verification error that occurred during the processing is available from SSL_get_verify_result_APIName
The verification result is part of the established session and is restored when a session is reused
If no peer certificate was presented, the returned result code is X509_V_OK
This is because no verification error occurred, it does however not indicate success
SSL_get_verify_result_APIName is only useful in connection with SSL_get_peer_certificate_APIName
The following return values can currently occur:
The verification succeeded or no peer certificate was presented
Documented in verify_APIName
Only RSA keys are supported in PKCS#7 and envelopedData so the recipient certificates supplied to this function must all contain RSA public keys, though they do not have to be signed using the RSA algorithm
EVP_des_ede3_cbc_APIName (triple DES) is the algorithm of choice for S/MIME use because most clients will support it
Some old "export grade" clients may only support weak encryption using 40 or 64 bit RC2
These can be used by passing EVP_rc2_40_cbc_APIName and EVP_rc2_64_cbc_APIName respectively
Many browsers implement a "sign and encrypt" option which is simply an S/MIME envelopedData containing an S/MIME signed message
This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to PKCS7_encrypt_APIName
PKCS7_encrypt_APIName returns either a PKCS7 structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
BIO_s_file_APIName returns the BIO file method
As BIO_s_file_APIName name implies BIO_s_file_APIName is a wrapper round the stdio FILE structure and BIO_s_file_APIName is a source/sink BIO
Calls to BIO_read_APIName and BIO_write_APIName read and write data to the underlying stream
BIO_gets_APIName and BIO_puts_APIName are supported on file BIOs
BIO_flush_APIName on a file BIO calls the fflush_APIName function on the wrapped stream
BIO_reset_APIName attempts to change the file pointer to the start of file using fseek(stream, 0, 0)
BIO_eof_APIName calls feof_APIName
Setting the BIO_CLOSE flag calls fclose_APIName on the stream when the BIO is freed
BIO_new_fp_APIName creates a file BIO wrapping BIO_new_fp_APIParam_1
Flags can be: BIO_CLOSE, BIO_NOCLOSE (the close flag) BIO_FP_TEXT (sets the underlying stream to text mode, default is binary: this only has any effect under Win32)
BIO_set_fp_APIName set the fp of a file BIO to BIO_set_fp_APIParam_2
BIO_set_fp_APIParam_3 BIO_new_fp_APIParam_2 has the same meaning as in BIO_new_fp_APIName, BIO_set_fp_APIParam_3 BIO_new_fp_APIParam_2 is a macro
BIO_get_fp_APIName retrieves the fp of a file BIO, it is a macro
BIO_tell_APIName returns the value of the position pointer
BIO_read_filename_APIName, BIO_write_filename_APIName, BIO_append_filename_APIName and BIO_rw_filename_APIName set the file BIO BIO_read_filename_APIParam_1 BIO_write_filename_APIParam_1 BIO_append_filename_APIParam_1 BIO_rw_filename_APIParam_1 to use file BIO_read_filename_APIParam_2 BIO_write_filename_APIParam_2 BIO_append_filename_APIParam_2 BIO_rw_filename_APIParam_2 for reading, writing, append or read write respectively
When wrapping stdout, stdin or stderr the underlying stream should not normally be closed so the BIO_NOCLOSE flag should be set
Because the file BIO calls the underlying stdio functions, any quirks in stdio behaviour will be mirrored by the corresponding BIO
On Windows BIO_new_files reserves for the filename argument to be UTF-8 encoded
In other words if you have to make it work in multi- lingual environment, encode file names in UTF-8
BIO_s_file_APIName returns the file BIO method
BIO_new_file_APIName and BIO_new_fp_APIName return a file BIO or NULL if an error occurred
BIO_set_fp_APIName and BIO_get_fp_APIName return 1 for success or 0 for failure (although the current implementation never return 0)
BIO_seek_APIName returns the same value as the underlying fseek_APIName function: 0 for success or -1 for failure
BIO_tell_APIName returns the current file position
BIO_read_filename_APIName, BIO_write_filename_APIName, BIO_append_filename_APIName and BIO_rw_filename_APIName return 1 for success or 0 for failure
BIO_reset_APIName and BIO_seek_APIName are implemented using fseek_APIName on the underlying stream
The return value for fseek_APIName is 0 for success or -1 if an error occurred this differs from other types of BIO which will typically return 1 for success and a non positive value if an error occurred
PEM_write_bio_CMS_stream_APIName outputs a CMS_ContentInfo structure in PEM format
It is otherwise identical to the function SMIME_write_CMS_APIName
This function is effectively a version of the PEM_write_bio_CMS_APIName supporting streaming
PEM_write_bio_CMS_stream_APIName returns 1 for success or 0 for failure
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly
SHA-1 (Secure Hash Algorithm) is a cryptographic hash function with a 160 bit output
The following functions may be used if the message is not completely stored in memory:
SHA1_Init_APIName initializes a SHA1_Init_APIParam_1 structure
SHA1_Update_APIName can be called repeatedly with chunks of the message to be hashed (SHA1_Update_APIParam_3 bytes at SHA1_Update_APIParam_2)
SHA1_Final_APIName places the message digest in SHA1_Final_APIParam_1, which must have space for SHA_DIGEST_LENGTH == 20 bytes of output, and erases the SHA1_Final_APIParam_2
The SHA224, SHA256, SHA384 and SHA512 families of functions operate in the same way as for the SHA1 functions
Note that SHA224 and SHA256 use a SHA256_Final_APIParam_2 SHA256_Update_APIParam_1 SHA224_Final_APIParam_2 SHA224_Init_APIParam_1 SHA224_Update_APIParam_1 SHA256_Init_APIParam_1 object instead of SHA1_Final_APIParam_2 SHA1_Init_APIParam_1 SHA1_Update_APIParam_1
SHA384 and SHA512 use SHA512_Init_APIParam_1 SHA512_Final_APIParam_2 SHA384_Update_APIParam_1 SHA512_Update_APIParam_1 SHA384_Init_APIParam_1 SHA384_Final_APIParam_2
The buffer SHA512_Final_APIParam_1 SHA256_Final_APIParam_1 SHA1_Final_APIParam_1 SHA224_Final_APIParam_1 SHA384_Final_APIParam_1 must have space for the output from the SHA variant being used (defined by SHA224_DIGEST_LENGTH, SHA256_DIGEST_LENGTH, SHA384_DIGEST_LENGTH and SHA512_DIGEST_LENGTH)
Also note that, as for the SHA1_APIName function above, the SHA224_APIName, SHA256_APIName, SHA384_APIName and SHA512_APIName functions are not thread safe if SHA512_Final_APIParam_1 SHA256_Final_APIParam_1 SHA1_Final_APIParam_1 SHA224_Final_APIParam_1 SHA384_Final_APIParam_1 is NULL
The predecessor of SHA-1, SHA, is also implemented, but it should be used only when backward compatibility is required
SHA1_APIName, SHA224_APIName, SHA256_APIName, SHA384_APIName and SHA512_APIName return a pointer to the hash value
SHA1_Init_APIName, SHA1_Update_APIName and SHA1_Final_APIName and equivalent SHA224, SHA256, SHA384 and SHA512 functions return 1 for success, 0 otherwise
Reset SSL_clear_APIParam_1 to allow another connection
All settings (method, ciphers, BIOs) are kept
If a session was closed cleanly, the session object will be kept and all settings corresponding
This explicitly means, that eg the special method used during the session will be kept for the next handshake
So if the session was a TLSv1 session, a SSL client object will use a TLSv1 client method for the next handshake and a SSL server object will use a TLSv1 server method, even if SSLv23_*_methods were chosen on startup
This will might lead to connection failures (see SSL_new_APIName ) for a description of the method's properties
SSL_clear_APIName resets the SSL object to allow for another connection
The reset operation however keeps several settings of the last sessions (some of these settings were made automatically during the last handshake)
It only makes sense for a new connection with the exact same peer that shares these settings, and may fail if that peer changes its settings between connections
Use the sequence SSL_get_session_APIName ; SSL_new_APIName ; SSL_set_session_APIName ; SSL_free_APIName instead to avoid such failures (or simply SSL_free_APIName ; SSL_new_APIName if session reuse is not desired)
The following return values can occur:
The SSL_clear_APIName operation could not be performed
Check the error stack to find out the reason
The SSL_clear_APIName operation was successful
SSL_new_APIName , SSL_free_APIName , SSL_shutdown_APIName , SSL_set_shutdown_APIName , SSL_CTX_set_options_APIName , ssl_APIName , SSL_CTX_set_client_cert_cb_APIName
The buffer library handles simple character arrays
Buffers are used for various purposes in the library, most notably memory BIOs
BUF_MEM_new_APIName allocates a new buffer of zero size
BUF_MEM_free_APIName frees up an already existing buffer
The data is zeroed before freeing up in case the buffer contains sensitive data
BUF_MEM_grow_APIName changes the size of an already existing buffer to BUF_MEM_grow_APIParam_2
Any data already in the buffer is preserved if it increases in size
BUF_strdup_APIName, BUF_strndup_APIName, BUF_memdup_APIName, BUF_strlcpy_APIName, BUF_strlcat_APIName and BUF_strnlen are equivalents of the standard C library functions
The dup_APIName functions use OPENSSL_malloc_APIName underneath and so should be used in preference to the standard library for memory leak checking or replacing the malloc_APIName function
Memory allocated from these functions should be freed up using the OPENSSL_free_APIName function
BUF_strndup makes the explicit guarantee that BUF_strndup will never read past the first BUF_strndup_APIParam_2 BUF_memdup_APIParam_2 bytes of BUF_strndup_APIParam_1 BUF_strnlen_APIParam_1 BUF_strdup_APIParam_1 BUF_MEM_grow_APIParam_1
BUF_MEM_new_APIName returns the buffer or NULL on error
BUF_MEM_free_APIName has no return value
BUF_MEM_grow_APIName returns zero on error or the new size (ie BUF_MEM_grow_APIParam_2)
SSL_get_version_APIName returns the name of the protocol used for the connection SSL_get_version_APIParam_1
It should only be called after the initial handshake has been completed
Prior to that the results returned from this function may be unreliable
The following strings can be returned:
The connection uses the SSLv2 protocol
The connection uses the SSLv3 protocol
The connection uses the TLSv1.0 protocol
The connection uses the TLSv1.1 protocol
The connection uses the TLSv1.2 protocol
This indicates an unknown protocol version
While a random prime number is generated, a random prime number is called as described in BN_generate_prime_APIName
RSA_generate_key is deprecated (new applications should use RSA_generate_key_ex instead)
RSA_generate_key works in the same way as RSA_generate_key_ex except it uses "old style" call backs
See BN_generate_prime_APIName for further details
If key generation fails, RSA_generate_key_APIName returns NULL
The error codes can be obtained by ERR_get_error_APIName
RSA_generate_key_APIName goes into an infinite loop for illegal input values
ASN1_STRING_new_APIName returns an allocated ASN1_STRING_new_APIParam_0 structure
ASN1_STRING_new_APIName type is undefined
ASN1_STRING_type_new_APIName returns an allocated ASN1_STRING_type_new_APIParam_0 structure of type ASN1_STRING_type_new_APIParam_1
ASN1_STRING_free_APIName frees up ASN1_STRING_free_APIParam_1
Other string types call the ASN1_STRING_free_APIParam_1 functions
For example ASN1_OCTET_STRING_new_APIName calls ASN1_STRING_type(V_ASN1_OCTET_STRING)
ASN1_STRING_new_APIName and ASN1_STRING_type_new_APIName return a valid ASN1_STRING structure or NULL if an error occurred
ASN1_STRING_free_APIName does not return a value
CMS_add1_recipient_cert_APIName adds recipient CMS_add1_recipient_cert_APIParam_2 to CMS_ContentInfo enveloped data structure CMS_add1_recipient_cert_APIParam_1 as a KeyTransRecipientInfo structure
CMS_add0_recipient_key_APIName adds symmetric key CMS_add0_recipient_key_APIParam_3 of length CMS_add0_recipient_key_APIParam_4 using wrapping algorithm CMS_add0_recipient_key_APIParam_2, identifier CMS_add0_recipient_key_APIParam_5 of length CMS_add0_recipient_key_APIParam_6 and optional values CMS_add0_recipient_key_APIParam_7, CMS_add0_recipient_key_APIParam_8 and CMS_add0_recipient_key_APIParam_9 to CMS_ContentInfo enveloped data structure CMS_add0_recipient_key_APIParam_1 as a KEKRecipientInfo structure
The main purpose of this function is to provide finer control over a CMS enveloped data structure where the simpler CMS_encrypt_APIName function defaults are not appropriate
For example if one or more KEKRecipientInfo structures need to be added
New attributes can also be added using  CMS_encrypt_APIParam_0  and the CMS attribute utility functions
CMS_add1_recipient_cert_APIName and CMS_add0_recipient_key_APIName return an internal pointer to the CMS_RecipientInfo structure just added or NULL if an error occurs
SSL_CTX_set_tmp_dh_APIName sets DH parameters to be used to be SSL_CTX_set_tmp_dh_APIParam_2
The key is inherited by all SSL_set_tmp_dh_APIParam_1 objects created from SSL_CTX_set_tmp_dh_APIParam_1
SSL_set_tmp_dh_callback_APIName sets the callback only for SSL_set_tmp_dh_APIParam_1
SSL_set_tmp_dh_APIName sets the parameters only for SSL_set_tmp_dh_APIParam_1
These functions apply to SSL/TLS servers only
When using a cipher with RSA authentication, an ephemeral DH key exchange can take place
Ciphers with DSA keys always use ephemeral DH keys as well
In these cases, the session data are negotiated using the ephemeral/temporary DH key and the key supplied and certified by the certificate chain is only used for signing
Anonymous ciphers (without a permanent server key) also use ephemeral DH keys
Using ephemeral DH key exchange yields forward secrecy, as the connection can only be decrypted, when the DH key is known
By generating a temporary DH key inside the server application that is lost when the application is left, it becomes impossible for an attacker to decrypt past sessions, even if he gets hold of the normal (certified) key, as this key was only used for signing
In order to perform a DH key exchange, the server must use a DH group (DH parameters) and generate a DH key
The server will always generate a new DH key during the negotiation
As generating DH parameters is extremely time consuming, an application should not generate the parameters on the fly but supply the parameters
DH parameters can be reused, as the actual key is newly generated during the negotiation
The risk in reusing DH parameters is that an attacker may specialize on a very often used DH group
Applications should therefore generate their own DH parameters during the installation process using the openssl dhparam_APIName application
This application guarantees that "strong" primes are used
An application may either directly specify the DH parameters or can supply the DH parameters via a callback function
SSL_CTX_set_tmp_dh_callback_APIName and SSL_set_tmp_dh_callback_APIName do not return diagnostic output
SSL_CTX_set_tmp_dh_APIName and SSL_set_tmp_dh_APIName do return 1 on success and 0 on failure
Check the error queue to find out the reason of failure
Chain verification should arguably be performed using the signing time rather than the current time
However since the signing time is supplied by the signer it cannot be trusted without additional evidence (such as a trusted timestamp)
PKCS7_verify_APIName returns one for a successful verification and zero if an error occurs
PKCS7_get0_signers_APIName returns all signers or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign_APIName also applies to PKCS7_verify_APIName
BIO_f_buffer_APIName returns the buffering BIO method
Data written to a buffering BIO is buffered and periodically written to the next BIO in the chain
Data read from a buffering BIO comes from an internal buffer which is filled from the next BIO in the chain
Both BIO_gets_APIName and BIO_puts_APIName are supported
Calling BIO_reset_APIName on a buffering BIO clears any buffered data
BIO_get_buffer_num_lines_APIName returns the number of lines currently buffered
Buffering BIOs implement BIO_gets_APIName by using BIO_read_APIName operations on the next BIO in the chain
By prepending a buffering BIO to a chain it is therefore possible to provide BIO_gets_APIName functionality if the following BIOs do not support it (for example SSL BIOs)
Data is only written to the next BIO in the chain when the write buffer fills or when BIO_flush_APIName is called
It is therefore important to call BIO_flush_APIName whenever any pending data should be written such as when removing a buffering BIO using BIO_pop_APIName
BIO_flush_APIName may need to be retried if the ultimate source/sink BIO is non blocking
BIO_f_buffer_APIName returns the buffering BIO method
BIO_get_buffer_num_lines_APIName returns the number of lines buffered (may be 0)
BIO_set_read_buffer_size_APIName, BIO_set_write_buffer_size_APIName and BIO_set_buffer_size_APIName return 1 if the buffer was successfully resized or 0 for failure
BIO_set_buffer_read_data_APIName returns 1 if the data was set correctly or 0 if there was an error
SSL_get_psk_identity_hint_APIName is used to retrieve the PSK identity hint used during the connection setup related to SSL object SSL_get_psk_identity_hint_APIParam_1 SSL_get_psk_identity_APIParam_1
Similarly, SSL_get_psk_identity_APIName is used to retrieve the PSK identity used during the connection setup
If non-NULL, SSL_get_psk_identity_hint_APIName returns the PSK identity hint and SSL_get_psk_identity_APIName returns the PSK identity
Both are NULL-terminated
SSL_get_psk_identity_hint_APIName may return NULL if no PSK identity hint was used during the connection setup
Note that the return value is valid only during the lifetime of the SSL object SSL_get_psk_identity_APIParam_1 SSL_get_psk_identity_hint_APIParam_1
A DSA_set_method_APIParam_2 DSA_set_default_method_APIParam_1 specifies the functions that OpenSSL uses for DSA operations
By modifying the method, alternative implementations such as hardware accelerators may be used
IMPORTANT: See the NOTES section for important information about how these DSA API functions are affected by the use of DSA_new_method_APIParam_1 API calls
Initially, the default DSA_METHOD is the OpenSSL internal implementation, as returned by DSA_OpenSSL_APIName
DSA_get_default_method_APIName returns a pointer to the current default DSA_METHOD
However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended
DSA_new_method_APIName allocates and initializes a DSA structure so that DSA_new_method_APIParam_1 will be used for the DSA operations
If DSA_new_method_APIParam_1 is NULL, the default engine for DSA operations is used, and if no default ENGINE is set, the DSA_METHOD controlled by DSA_set_default_method_APIName is used
DSA_OpenSSL_APIName and DSA_get_default_method_APIName return pointers to the respective DSA_OpenSSL_APIParam_0 DSA_get_default_method_APIParam_0s
DSA_set_default_method_APIName returns no value
DSA_set_method_APIName returns non-zero if the provided DSA_set_method_APIParam_2 was successfully set as the method for DSA_set_method_APIParam_1 (including unloading the ENGINE handle if the previous method was supplied by an ENGINE)
DSA_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails
Otherwise it returns a pointer to the newly allocated structure
As of version 0.9.7, DSA_METHOD implementations are grouped together with other algorithmic APIs (eg RSA_METHOD, EVP_CIPHER, etc) in DSA_new_method_APIParam_1 modules
If a default ENGINE is specified for DSA functionality using an ENGINE API function, that will override any DSA defaults set using the DSA API (ie DSA_set_default_method_APIName)
For this reason, the ENGINE API is the recommended way to control default implementations for use in DSA and other cryptographic algorithms
SSLeay_version_APIName returns a pointer to a constant string describing the version of the OpenSSL library or giving information about the library build
The following SSLeay_version_APIParam_1 values are supported:
The version of the OpenSSL library including the release date
The compiler flags set for the compilation process in the form "compiler: ..." if available or "compiler: information not available" otherwise
The date of the build process in the form "built on: ..." if available or "built on: date not available" otherwise
The "Configure" target of the library build in the form "platform: ..." if available or "platform: information not available" otherwise
The "OPENSSLDIR" setting of the library build in the form "OPENSSLDIR: "..."" if available or "OPENSSLDIR: N/A" otherwise
The following return values can occur:
An invalid value for SSLeay_version_APIParam_1 was given
SSL_CTX_sess_set_cache_size_APIName sets the size of the internal session cache of context SSL_CTX_sess_set_cache_size_APIParam_1 to SSL_CTX_sess_set_cache_size_APIParam_2
This value is a hint and not an absolute; see the notes below
SSL_CTX_sess_get_cache_size_APIName returns the currently valid session cache size
The internal session cache size is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT, currently 1024*20, so that up to 20000 sessions can be held
This size can be modified using the SSL_CTX_sess_set_cache_size_APIName call
A special case is the size 0, which is used for unlimited size
If adding the session makes the cache exceed its size, then unused sessions are dropped from the end of the cache
Cache space may also be reclaimed by calling SSL_CTX_flush_sessions_APIName to remove expired sessions
If the size of the session cache is reduced and more sessions are already in the session cache, old session will be removed at the next time a session shall be added
This removal is not synchronized with the expiration of sessions
SSL_CTX_sess_set_cache_size_APIName returns the previously valid size
SSL_CTX_sess_get_cache_size_APIName returns the currently valid size
A client application must provide a callback function which is called when the client is sending the ClientKeyExchange message to the server
The purpose of the callback function is to select the PSK identity and the pre-shared key to use during the connection setup phase
Return values from the client callback are interpreted as follows:
Otherwise or on errors callback should return 0
In this case the connection setup fails
SSL_read_APIName tries to read SSL_read_APIParam_3 bytes from the specified SSL_read_APIParam_1 into the buffer SSL_read_APIParam_2
If necessary, SSL_read_APIName will negotiate a TLS/SSL session, if not already explicitly performed by SSL_connect_APIName or SSL_accept_APIName
If the peer requests a re-negotiation, it will be performed transparently during the SSL_read_APIName operation
The behaviour of SSL_read_APIName depends on the underlying BIO
For the transparent negotiation to succeed, the SSL_read_APIParam_1 must have been initialized to client or server mode
This is being done by calling SSL_set_connect_state_APIName or SSL_set_accept_state_APIName before the first call to an SSL_read_APIName or SSL_write_APIName function
SSL_read_APIName works based on the SSL/TLS records
The data are received in records (with a maximum record size of 16kB for SSLv3/TLSv1)
Only when a record has been completely received, it can be processed (decryption and check of integrity)
Therefore data that was not retrieved at the last call of SSL_read_APIName can still be buffered inside the SSL layer and will be retrieved on the next call to SSL_read_APIName
If SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 is higher than the number of bytes buffered, SSL_read_APIName will return with the bytes buffered
If no more bytes are in the buffer, SSL_read_APIName will trigger the processing of the next record
Only when the record has been received and processed completely, SSL_read_APIName will return reporting success
At most the contents of the record will be returned
As the size of an SSL/TLS record may exceed the maximum packet size of the underlying transport (eg TCP), it may be necessary to read several packets from the transport layer before the record is complete and SSL_read_APIName can succeed
SSL_pending_APIName can be used to find out whether there are buffered bytes available for immediate retrieval
In this case SSL_read_APIName can be called without blocking or actually receiving new data from the underlying socket
The following return values can occur:
The read operation was successful
The return value is the number of bytes actually read from the TLS/SSL connection
SSLv2 (deprecated) does not support a shutdown alert protocol, so it can only be detected, whether the underlying connection was closed
It cannot be checked, whether the closure was initiated by the peer or by something else
Old documentation indicated a difference between 0 and -1, and that -1 was retryable
You should instead call SSL_get_error_APIName to find out if it's retryable
The response returned by the server can be obtained via a call to SSL_get_tlsext_status_ocsp_resp_APIName
The value SSL_get_tlsext_status_ocsp_resp_APIParam_2 SSL_get_tlsext_status_ocsp_resp_APIParam_2 will be updated to point to the OCSP response data and the return value will be the length of that data
Typically a callback would obtain an OCSP_RESPONSE object from this data via a call to the d2i_OCSP_RESPONSE_APIName function
If the server has not provided any response data then SSL_get_tlsext_status_ocsp_resp_APIParam_2 SSL_get_tlsext_status_ocsp_resp_APIParam_2 will be NULL and the return value from SSL_get_tlsext_status_ocsp_resp_APIName will be -1
A server application must also call the SSL_CTX_set_tlsext_status_cb_APIName function if A server application wants to be able to provide clients with OCSP Certificate Status responses
Typically the server callback would obtain the server certificate that is being sent back to the client via a call to SSL_get_certificate_APIName; obtain the OCSP response to be sent back; and then set that response data by calling SSL_set_tlsext_status_ocsp_resp_APIName
A pointer to the response data should be provided in the SSL_set_tlsext_status_ocsp_resp_APIParam_2 argument, and the length of that data should be in the SSL_set_tlsext_status_ocsp_resp_APIParam_3 argument
The callback when used on the client side should return a negative value on error; 0 if the response is not acceptable (in which case the handshake will fail) or a positive value if it is acceptable
The callback when used on the server side should return with either SSL_TLSEXT_ERR_OK (meaning that the OCSP response that has been set should be returned), SSL_TLSEXT_ERR_NOACK (meaning that an OCSP response should not be returned) or SSL_TLSEXT_ERR_ALERT_FATAL (meaning that a fatal error has occurred)
SSL_CTX_set_tlsext_status_cb_APIName, SSL_CTX_set_tlsext_status_arg_APIName, SSL_set_tlsext_status_type_APIName and SSL_set_tlsext_status_ocsp_resp_APIName return 0 on error or 1 on success
SSL_get_tlsext_status_ocsp_resp_APIName returns the length of the OCSP response data or -1 if there is no OCSP response data
CONF_modules_load_APIName is idential to CONF_modules_load_file_APIName except CONF_modules_load_APIName reads configuration information from CONF_modules_load_APIParam_1
Applications should call these functions after loading builtin modules using OPENSSL_load_builtin_modules_APIName, any ENGINEs for example using ENGINE_load_builtin_engines_APIName, any algorithms for example OPENSSL_add_all_algorithms_APIName and (if the application uses libssl) SSL_library_init_APIName
Errors during configuration may also be handled differently by different applications
For example in some cases an error may simply print out a warning message and the application continue
In other cases an application might consider a configuration file error as fatal and exit immediately
Applications can use the CONF_modules_load_APIName function if Applications wish to load a configuration file Applications and have finer control over how errors are treated
These functions return 1 for success and a zero or negative value for failure
If module errors are not ignored ,the return code will reflect the return value of the failing module (this will always be zero or negative)
A BIO is an I/O abstraction, it hides many of the underlying I/O details from an application
If an application uses a BIO for its I/O ,it can transparently handle SSL connections, unencrypted network connections and file I/O
There are two type of BIO, a source/sink BIO and a filter BIO
As its name implies a source/sink BIO is a source and/or sink of data, examples include a socket BIO and a file BIO
A filter BIO takes data from one BIO and passes it through to another, or the application
The data may be left unmodified (for example a message digest BIO) or translated (for example an encryption BIO)
The effect of a filter BIO may change according to the I/O operation it is performing: for example an encryption BIO will encrypt data if it is being written to and decrypt data if it is being read from
BIOs can be joined together to form a chain (a single BIO is a chain with one component)
A chain normally consist of one source/sink BIO and one or more filter BIOs
Data read from or written to the first BIO then traverses the chain to the end (normally a source/sink BIO)
SSL_CONF_CTX_set_ssl_ctx_APIName sets the context associated with SSL_CONF_CTX_set_ssl_ctx_APIParam_1 to the SSL_CONF_CTX_set_ssl_ctx_APIParam_2 structure SSL_CONF_CTX_set_ssl_ctx_APIParam_2
Any previous SSL_CONF_CTX_set_ssl_ctx_APIParam_1 or SSL_CONF_CTX_set_ssl_ctx_APIParam_2 associated with SSL_CONF_CTX_set_ssl_ctx_APIParam_1 is cleared
Subsequent calls to SSL_CONF_cmd_APIName will be sent to SSL_CONF_CTX_set_ssl_ctx_APIParam_2
SSL_CONF_CTX_set_ssl_APIName sets the context associated with SSL_CONF_CTX_set_ssl_APIParam_1 to the SSL_CONF_CTX_set_ssl_APIParam_1 structure SSL_CONF_CTX_set_ssl_APIParam_2
Any previous SSL_CONF_CTX_set_ssl_APIParam_1 or SSL_CONF_CTX_set_ssl_ctx_APIParam_2 associated with SSL_CONF_CTX_set_ssl_APIParam_1 is cleared
Subsequent calls to SSL_CONF_cmd_APIName will be sent to SSL_CONF_CTX_set_ssl_APIParam_2
The context need not be set or The context can be set to NULL in which case only syntax checking of commands is performed, where possible
SSL_CONF_CTX_set_ssl_ctx_APIName and SSL_CTX_set_ssl_APIName do not return a value
After the call to EVP_PKEY_decrypt_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The function EVP_PKEY_decrypt_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_decrypt_init_APIName and EVP_PKEY_decrypt_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
These functions are typically called after X509_verify_cert_APIName has indicated an error or in a verification callback to determine the nature of an error
X509_STORE_CTX_set_error_APIName sets the error code of X509_STORE_CTX_set_error_APIParam_1 to X509_STORE_CTX_set_error_APIParam_2
For example it might be used in a verification callback to set an error based on additional checks
X509_STORE_CTX_get_current_cert_APIName returns the certificate in X509_STORE_CTX_get_current_cert_APIParam_1 which caused the error or NULL if no certificate is relevant
X509_verify_cert_error_string_APIName returns a human readable error string for verification error X509_verify_cert_error_string_APIParam_1
X509_STORE_CTX_get_error_depth_APIName returns a non-negative error depth
X509_STORE_CTX_get_current_cert_APIName returns the cerificate which caused the error or NULL if no certificate is relevant to the error
X509_verify_cert_error_string_APIName returns a human readable error string for verification error X509_verify_cert_error_string_APIParam_1
In versions of OpenSSL before 1.0 the current certificate returned by X509_STORE_CTX_get_current_cert_APIName was never NULL
Applications should check the return value before printing out any debugging information relating to the current certificate
If an unrecognised error code is passed to X509_verify_cert_error_string_APIName, the numerical value of the unknown code is returned in a static buffer
This is not thread safe but will never happen unless an invalid code is passed
SSL_CTX_add_client_CA_APIName adds the CA name extracted from SSL_CTX_add_client_CA_APIParam_2 to the list of CAs sent to the client when requesting a client certificate for SSL_CTX_add_client_CA_APIParam_1
SSL_add_client_CA_APIName adds the CA name extracted from SSL_add_client_CA_APIParam_2 to the list of CAs sent to the client when requesting a client certificate for the chosen SSL_add_client_CA_APIParam_1, overriding the setting valid for SSL_add_client_CA_APIParam_1's SSL_CTX object
If the list of acceptable CAs is compiled in a file, the SSL_load_client_CA_file_APIName function can be used to help importing the necessary data
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName can be used to add additional items the list of client CAs
If no list was specified before using SSL_CTX_set_client_CA_list_APIName or SSL_set_client_CA_list_APIName, a new client CA list for SSL_CTX_add_client_CA_APIParam_1 or SSL_add_client_CA_APIParam_1 (as appropriate) is opened
These functions are only useful for TLS/SSL servers
SSL_CTX_set_client_CA_list_APIName and SSL_set_client_CA_list_APIName do not return diagnostic information
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName have the following return values:
A failure while manipulating the STACK_OF(X509_NAME) object occurred or the X509_NAME could not be extracted from SSL_add_client_CA_APIParam_2 SSL_CTX_add_client_CA_APIParam_2
Check the error stack to find out the reason
The operation succeeded
The function SSL_CONF_CTX_set_flags_APIName sets SSL_CONF_CTX_set_flags_APIParam_2 in the context SSL_CONF_CTX_set_flags_APIParam_1
The function SSL_CONF_CTX_clear_flags_APIName clears SSL_CONF_CTX_clear_flags_APIParam_2 in the context SSL_CONF_CTX_clear_flags_APIParam_1
The flags set affect how subsequent calls to SSL_CONF_cmd_APIName or SSL_CONF_argv_APIName behave
Currently the following SSL_CONF_CTX_clear_flags_APIParam_2 SSL_CONF_CTX_set_flags_APIParam_2 values are recognised:
recognise options intended for command line or configuration file use
At least one of these flags must be set
recognise options intended for use in SSL/TLS clients or servers
One or both of these flags must be set
recognise certificate and private key options
indicate errors relating to unrecognised options or missing arguments in the error queue
If this option isn't set such errors are only reflected in the return values of SSL_CONF_set_cmd_APIName or SSL_CONF_set_argv_APIName
SSL_CONF_CTX_set_flags_APIName and SSL_CONF_CTX_clear_flags_APIName returns the new flags value after setting or clearing flags
X509_check_private_key_APIName function checks the consistency of private key X509_check_private_key_APIParam_2 with the public key in X509_check_private_key_APIParam_1
X509_REQ_check_private_key_APIName is equivalent to X509_check_private_key_APIName except that X509_REQ_check_private_key_APIParam_1 X509_check_private_key_APIParam_1 represents a certificate request of structure X509_REQ_check_private_key_APIParam_1
X509_check_private_key_APIName and X509_REQ_check_private_key_APIName return 1 if the keys match each other, and 0 if not
If the key is invalid or an error occurred, the reason code can be obtained using ERR_get_error_APIName
ERR_print_errors_APIName is a convenience function that prints the error strings for all errors that OpenSSL has recorded to ERR_print_errors_APIParam_1, thus emptying the error queue
ERR_print_errors_fp_APIName is the same, except that the output goes to a ERR_print_errors_fp_APIParam_1
The error strings will have the following format:
If there is no text string registered for the given error code, the error string will contain the numeric code
ERR_print_errors_APIName and ERR_print_errors_fp_APIName return no values
The ECPKParameters encode and decode routines encode and parse the public parameters for an ECPKParameters_print_APIParam_2 i2d_ECPKParameters_APIParam_1 d2i_ECPKParameters_APIParam_1 ECPKParameters_print_fp_APIParam_2 structure, which represents a curve
d2i_ECPKParameters_APIName attempts to decode d2i_ECPKParameters_APIParam_3 bytes at d2i_ECPKParameters_APIParam_2
If successful a pointer to the d2i_ECPKParameters_APIParam_1 structure is returned
If an error occurred ,then NULL is returned
If d2i_ECPKParameters_APIParam_1 is not NULL , d2i_ECPKParameters_APIParam_0  is written to d2i_ECPKParameters_APIParam_1 If d2i_ECPKParameters_APIParam_1 is not NULL, then it is assumed that d2i_ECPKParameters_APIParam_1 contains a valid d2i_ECPKParameters_APIParam_1 structure and an attempt is made to reuse it
If the call is successful, d2i_ECPKParameters_APIParam_2 is incremented to the byte following the parsed data
i2d_ECPKParameters_APIName encodes the structure pointed to by i2d_ECPKParameters_APIParam_1 into DER format
If i2d_ECPKParameters_APIParam_2 is not NULL is writes the DER encoded data to the buffer at i2d_ECPKParameters_APIParam_2, and increments it to point after the data just written
If the return value is negative an error occurred, otherwise it returns the length of the encoded data
If i2d_ECPKParameters_APIParam_2 is NULL ,memory will be allocated for a buffer and the encoded data written to it
In this case i2d_ECPKParameters_APIParam_2 is not incremented and it points to the start of the data just written
d2i_ECPKParameters_bio_APIName is similar to d2i_ECPKParameters_APIName except d2i_ECPKParameters_bio_APIName attempts to parse data from BIO ECPKParameters_print_APIParam_1
d2i_ECPKParameters_fp_APIName is similar to d2i_ECPKParameters_APIName except d2i_ECPKParameters_fp_APIName attempts to parse data from FILE pointer ECPKParameters_print_fp_APIParam_1
i2d_ECPKParameters_bio_APIName is similar to i2d_ECPKParameters_APIName except it writes the encoding of the structure i2d_ECPKParameters_APIParam_1 to BIO ECPKParameters_print_APIParam_1 and it returns 1 for success and 0 for failure
i2d_ECPKParameters_fp_APIName is similar to i2d_ECPKParameters_APIName except it writes the encoding of the structure i2d_ECPKParameters_APIParam_1 to BIO ECPKParameters_print_APIParam_1 and it returns 1 for success and 0 for failure
These functions are very similar to the X509 functions described in d2i_X509_APIName , where further notes and examples are available
The ECPKParameters_print and ECPKParameters_print_fp functions print a human-readable output of the public parameters of the EC_GROUP to ECPKParameters_print_APIParam_1 or ECPKParameters_print_fp_APIParam_1
The output lines are indented by ECPKParameters_print_APIParam_3 ECPKParameters_print_fp_APIParam_3 spaces
d2i_ECPKParameters_APIName, d2i_ECPKParameters_bio_APIName and d2i_ECPKParameters_fp_APIName return a valid d2i_ECPKParameters_APIParam_1 structure or NULL if an error occurs
i2d_ECPKParameters_APIName returns the number of bytes successfully encoded or a negative value if an error occurs
i2d_ECPKParameters_bio_APIName, i2d_ECPKParameters_fp_APIName, ECPKParameters_print and ECPKParameters_print_fp return 1 for success and 0 if an error occurs
CMS_final_APIName finalises the structure CMS_final_APIParam_1
It's purpose is to perform any operations necessary on CMS_final_APIParam_1 (digest computation for example) and set the appropriate fields
The parameter CMS_final_APIParam_2 contains the content to be processed
The CMS_final_APIParam_3 parameter contains a BIO to write content to after processing: this is only used with detached data and will usually be set to NULL
CMS_final_APIName returns 1 for success or 0 for failure
The EVP envelope routines are a high level interface to envelope decryption
The EVP envelope routines decrypt a public key encrypted symmetric key and then decrypt data using a public key encrypted symmetric key
EVP_OpenUpdate_APIName and EVP_OpenFinal_APIName have exactly the same properties as the EVP_DecryptUpdate_APIName and EVP_DecryptFinal_APIName routines, as documented on the EVP_EncryptInit_APIName manual page
If the cipher passed in the EVP_OpenInit_APIParam_2 parameter is a variable length cipher ,then the key length will be set to the value of the recovered key length
If the cipher is a fixed length cipher then the recovered key length must match the fixed cipher length
EVP_OpenInit_APIName returns 0 on error or a non zero integer (actually the recovered secret key size) if successful
EVP_OpenUpdate_APIName returns 1 for success or 0 for failure
EVP_OpenFinal_APIName returns 0 if the decrypt failed or 1 for success
These functions initialise an X509_STORE_CTX_init_APIParam_1 X509_STORE_CTX_set_default_APIParam_1 X509_STORE_CTX_set0_param_APIParam_1 X509_STORE_CTX_free_APIParam_1 X509_STORE_CTX_set_cert_APIParam_1 X509_STORE_CTX_get0_param_APIParam_1 X509_STORE_CTX_cleanup_APIParam_1 structure for subsequent use by X509_verify_cert_APIName
X509_STORE_CTX_new_APIName returns a newly initialised X509_STORE_CTX_new_APIParam_0 structure
X509_STORE_CTX_cleanup_APIName internally cleans up an X509_STORE_CTX_cleanup_APIParam_1 X509_STORE_CTX_init_APIParam_1 structure
The context can then be reused with an new call to X509_STORE_CTX_init_APIName
X509_STORE_CTX_free_APIName completely frees up X509_STORE_CTX_free_APIParam_1
After this call X509_STORE_CTX_free_APIParam_1 is no longer valid
X509_STORE_CTX_set_cert_APIName sets the certificate to be vertified in X509_STORE_CTX_set_cert_APIParam_1 to X509_STORE_CTX_set_cert_APIParam_2
X509_VERIFY_PARAM *X509_STORE_CTX_get0_param_APIName retrieves an intenal pointer to the verification parameters associated with X509_STORE_CTX_get0_param_APIParam_1
X509_STORE_CTX_set0_param_APIName sets the intenal verification parameter pointer to X509_STORE_CTX_set0_param_APIParam_2
After this call X509_STORE_CTX_set0_param_APIParam_2 should not be used
X509_STORE_CTX_set_default_APIName looks up and sets the default verification method to X509_STORE_CTX_set_default_APIParam_2
This uses the function X509_VERIFY_PARAM_lookup_APIName to find an appropriate set of parameters from X509_STORE_CTX_set_default_APIParam_2
X509_STORE_CTX_new_APIName returns an newly allocates context or NULL is an error occurred
X509_STORE_CTX_init_APIName returns 1 for success or 0 if an error occurred
X509_STORE_CTX_get0_param_APIName returns a pointer to an X509_STORE_CTX_get0_param_APIParam_0 structure or NULL if an error occurred
X509_STORE_CTX_cleanup_APIName, X509_STORE_CTX_free_APIName, X509_STORE_CTX_trusted_stack_APIName, X509_STORE_CTX_set_cert_APIName, X509_STORE_CTX_set_chain_APIName, X509_STORE_CTX_set0_crls_APIName and X509_STORE_CTX_set0_param_APIName do not return values
X509_STORE_CTX_set_default_APIName returns 1 for success or 0 if an error occurred
The ECDSA_SIG_free_APIParam_1 d2i_ECDSA_SIG_APIParam_1 i2d_ECDSA_SIG_APIParam_1 structure consists of two BIGNUMs for the r and s value of a ECDSA signature (see X9.62 or FIPS 186-2)
ECDSA_SIG_new_APIName allocates a new ECDSA_SIG_new_APIParam_0 structure (note: this function also allocates the BIGNUMs) and initialize it
ECDSA_SIG_free_APIName frees the ECDSA_SIG_free_APIParam_1 structure ECDSA_SIG_free_APIParam_1
ECDSA_size_APIName returns the maximum length of a DER encoded ECDSA signature created with the private EC key ECDSA_size_APIParam_1
ECDSA_do_verify_APIName verifies that the signature ECDSA_do_verify_APIParam_1 is a valid ECDSA signature of the hash value ECDSA_do_verify_APIParam_1 of size ECDSA_do_verify_APIParam_2 using the public key ECDSA_size_APIParam_1 ECDSA_sign_setup_APIParam_1 ECDSA_set_method_APIParam_1
ECDSA_SIG_new_APIName returns NULL if the allocation fails
ECDSA_size_APIName returns the maximum length signature or 0 on error
ECDSA_sign_setup_APIName and ECDSA_sign_APIName return 1 if successful or 0 on error
ECDSA_verify_APIName and ECDSA_do_verify_APIName return 1 for a valid signature, 0 for an invalid signature and -1 on error
The error codes can be obtained by ERR_get_error_APIName
BIO_f_ssl_APIName returns the SSL BIO method
This is a filter BIO which is a wrapper round the OpenSSL SSL routines adding a BIO "flavour" to SSL I/O
I/O performed on an SSL BIO communicates using the SSL protocol with the SSLs read and write BIOs
If an SSL connection is not established ,then an attempt is made to establish one on the first I/O call
If a BIO is appended to an SSL BIO using BIO_push_APIName ,a BIO is automatically used as the SSL BIOs read and write BIOs
Calling BIO_reset_APIName on an SSL BIO closes down any current SSL connection by calling SSL_shutdown_APIName
BIO_reset_APIName is then sent to the next BIO in the chain: this will typically disconnect the underlying transport
The SSL BIO is then reset to the initial accept or connect state
If the close flag is set when an SSL BIO is freed ,then the internal SSL structure is also freed using SSL_free_APIName
BIO_get_ssl_APIName retrieves the SSL pointer of BIO BIO_ctrl_APIParam_1, BIO_get_ssl_APIName can then be manipulated using the standard SSL library functions
BIO_set_ssl_mode_APIName sets the SSL BIO mode to BIO_new_ssl_APIParam_2
If BIO_new_ssl_APIParam_2 is 1 client mode is set
If BIO_new_ssl_APIParam_2 is 0 ,server mode is set
BIO_set_ssl_renegotiate_bytes_APIName sets the renegotiate byte count to BIO_ctrl_APIParam_3
When set after every BIO_ctrl_APIParam_3 bytes of I/O (read and write) the SSL session is automatically renegotiated
BIO_ctrl_APIParam_3 must be at least 512 bytes
BIO_get_num_renegotiates_APIName returns the total number of session renegotiations due to I/O or timeout
BIO_new_ssl_APIName allocates an SSL BIO using SSL_CTX BIO_new_ssl_APIParam_1 and using client mode if BIO_new_ssl_APIParam_2 is non zero
BIO_new_ssl_connect_APIName creates a new BIO chain consisting of an SSL BIO (using BIO_new_ssl_connect_APIParam_1) followed by a connect BIO
BIO_new_buffer_ssl_connect_APIName creates a new BIO chain consisting of a buffering BIO, an SSL BIO (using BIO_new_buffer_ssl_connect_APIParam_1) and a connect BIO
BIO_ssl_copy_session_id_APIName copies an SSL session id between BIO chains BIO_ssl_copy_session_id_APIParam_2 and BIO_ssl_copy_session_id_APIParam_1
It does this by locating the SSL BIOs in each chain and calling SSL_copy_session_id_APIName on the internal SSL pointer
BIO_ssl_shutdown_APIName closes down an SSL connection on BIO chain BIO_ssl_shutdown_APIParam_1
It does this by locating the SSL BIO in the chain and calling SSL_shutdown_APIName on its internal SSL pointer
BIO_do_handshake_APIName attempts to complete an SSL handshake on the supplied BIO and establish the SSL connection
It returns 1 if the connection was established successfully
A zero or negative value is returned if the connection could not be established, the call BIO_should_retry_APIName should be used for non blocking connect BIOs to determine if the call should be retried
If an SSL connection has already been established ,this call has no effect
SSL BIOs are exceptional in that if the underlying transport is non blocking SSL BIOs can still request a retry in exceptional circumstances
Specifically this will happen if a session renegotiation takes place during a BIO_read_APIName operation, one case where this happens is when step up occurs
In OpenSSL 0.9.6 and later the SSL flag SSL_AUTO_RETRY can be set to disable this behaviour
That is when this flag is set an SSL BIO using a blocking transport will never request a retry
Since unknown BIO_ctrl_APIName operations are sent through filter BIOs, the servers name and port can be set using BIO_set_host_APIName on the BIO returned by BIO_new_ssl_connect_APIName without having to locate the connect BIO first
Applications do not have to call BIO_do_handshake_APIName but may wish to do so to separate the handshake process from other I/O processing
In OpenSSL versions before 1.0.0 the BIO_pop_APIName call was handled incorrectly, the I/O BIO reference count was incorrectly incremented (instead of decremented) and dissociated with the SSL BIO even if the SSL BIO was not explicitly being popped (eg a pop higher up the chain)
Applications which included workarounds for this bug (eg freeing BIOs more than once) should be modified to handle this fix or they may free up an already freed BIO
BN_mod_APIName corresponds to BN_div_APIName with BN_div_APIParam_1 set to NULL
BN_nnmod_APIName reduces BN_nnmod_APIParam_2 modulo BN_nnmod_APIParam_3 and places the non-negative remainder in BN_nnmod_APIParam_1
BN_mod_add_APIName adds BN_mod_add_APIParam_2 to BN_mod_add_APIParam_3 modulo BN_mod_add_APIParam_4 and places the non-negative result in BN_mod_add_APIParam_1
BN_mod_sub_APIName subtracts BN_mod_sub_APIParam_3 from BN_mod_sub_APIParam_2 modulo BN_mod_sub_APIParam_4 and places the non-negative result in BN_mod_sub_APIParam_1
BN_mod_sqr_APIName takes the square of BN_mod_sqr_APIParam_2 modulo BN_mod_sqr_APIParam_3 and places the result in BN_mod_sqr_APIParam_1
BN_gcd_APIName computes the greatest common divisor of BN_gcd_APIParam_2 and BN_gcd_APIParam_3 and places the result in BN_gcd_APIParam_1
BN_gcd_APIParam_1 may be the same BN_gcd_APIParam_1 as BN_gcd_APIParam_2 or BN_gcd_APIParam_3
For all functions, BN_nnmod_APIParam_4 BN_sqr_APIParam_3 BN_mod_APIParam_4 BN_exp_APIParam_4 BN_mul_APIParam_4 BN_mod_sqr_APIParam_4 BN_gcd_APIParam_4 is a previously allocated BN_nnmod_APIParam_4 BN_sqr_APIParam_3 BN_mod_APIParam_4 BN_exp_APIParam_4 BN_mul_APIParam_4 BN_mod_sqr_APIParam_4 BN_gcd_APIParam_4 used for temporary variables; see BN_CTX_new_APIName
Unless noted otherwise, the result BN_nnmod_APIParam_1 BN_mod_mul_APIParam_1 BN_mod_sub_APIParam_1 BN_add_APIParam_1 BN_sqr_APIParam_1 BN_sub_APIParam_1 BN_mod_add_APIParam_1 BN_mod_APIParam_1 BN_exp_APIParam_1 BN_mul_APIParam_1 BN_mod_sqr_APIParam_1 BN_gcd_APIParam_1 BN_mod_exp_APIParam_1 BN_div_APIParam_1 must be different from the arguments
SSL_CTX_set_generate_session_id_APIName sets the callback function for generating new session ids for SSL/TLS sessions for SSL_CTX_set_generate_session_id_APIParam_1 to be SSL_CTX_set_generate_session_id_APIParam_2
SSL_set_generate_session_id_APIName sets the callback function for generating new session ids for SSL/TLS sessions for SSL_set_generate_session_id_APIParam_1 to be SSL_set_generate_session_id_APIParam_3
When a new session is established between client and server, the server generates a session id
The session id is an arbitrary sequence of bytes
The length of the session id is 16 bytes for SSLv2 sessions and between 1 and 32 bytes for SSLv3/TLSv1
The session id is not security critical but must be unique for the server
Additionally, the session id is transmitted in the clear when reusing the session so it must not contain sensitive information
Without a callback being set, an OpenSSL server will generate a unique session id from pseudo random numbers of the maximum possible length
Using the callback function, the session id can be changed to contain additional information like eg a host id in order to improve load balancing or external caching techniques
SSL_has_matching_session_id_APIName will only query the internal session cache, not the external one
Since the session id is generated before the handshake is completed, the handshake is not immediately added to the cache
If another thread is using the same internal session cache, a race condition can occur in that another thread generates the same session id
Collisions can also occur when using an external session cache, since the external cache is not tested with SSL_has_matching_session_id_APIName and the same race condition applies
The callback must return 0 if The callback cannot generate a session id for whatever reason and return 1 on success
SSL_CTX_set_generate_session_id_APIName and SSL_set_generate_session_id_APIName always return 1
SSL_has_matching_session_id_APIName returns 1 if another session with the same id is already in the cache
If present the SMIMECapabilities attribute indicates support for the following algorithms in preference order: 256 bit AES, Gost R3411-94, Gost 28147-89, 192 bit AES, 128 bit AES, triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2
If any of these algorithms is not available then it will not be included: for example the GOST algorithms will not be included if the GOST ENGINE is not loaded
Some attributes such as counter signatures are not supported
CMS_sign_APIName returns either a valid CMS_ContentInfo structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
The return values of the SSL*_ctrl_APIName functions depend on the command supplied via the SSL_ctrl_APIParam_2 SSL_CTX_ctrl_APIParam_2 parameter
BN_new_APIName allocates and initializes a BN_init_APIParam_1 structure
BN_init_APIName initializes an existing uninitialized BN_init_APIParam_1
BN_clear_APIName is used to destroy sensitive data such as keys when they are no longer needed
It erases the memory used by BN_clear_APIParam_1 and sets it to the value 0
BN_free_APIName frees the components of the BN_free_APIParam_1 BN_clear_free_APIParam_1, and if it was created by BN_new_APIName, also the structure itself
BN_clear_free_APIName additionally overwrites the data before the memory is returned to the system
If BN_free_APIParam_1 BN_clear_free_APIParam_1 is NULL, nothing is done
BN_new_APIName returns a pointer to the BN_new_APIParam_0 initialised to the value 0
If the allocation fails, the allocation returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
BN_init_APIName, BN_clear_APIName, BN_free_APIName and BN_clear_free_APIName have no return values
BIO_ctrl_APIName, BIO_callback_ctrl_APIName, BIO_ptr_ctrl_APIName and BIO_int_ctrl_APIName are BIO "control" operations taking arguments of various types
These functions are not normally called directly, various macros are used instead
The standard macros are described below, macros specific to a particular type of BIO are described in the specific BIOs manual page as well as any special features of the standard calls
BIO_reset_APIName typically resets a BIO to some initial state, in the case of file related BIOs for example it rewinds the file pointer to the start of the file
BIO_seek_APIName resets a file related BIO's (that is file descriptor and FILE BIOs) file position pointer to BIO_seek_APIParam_2 bytes from start of file
BIO_tell_APIName returns the current file position of a file related BIO
BIO_flush_APIName normally writes out any internally buffered data, in some cases BIO_flush_APIName is used to signal EOF and that no more data will be written
BIO_eof_APIName returns 1 if the BIO has read EOF, the precise meaning of "EOF" varies according to the BIO type
BIO_set_close_APIName sets the BIO BIO_set_close_APIParam_1 close flag to BIO_set_close_APIParam_2
BIO_set_close_APIParam_2 can take the value BIO_CLOSE or BIO_NOCLOSE
Typically BIO_CLOSE is used in a source/sink BIO to indicate that the underlying I/O stream should be closed when the BIO is freed
BIO_get_close_APIName returns the BIOs close flag
BIO_pending_APIName, BIO_ctrl_pending_APIName, BIO_wpending_APIName and BIO_ctrl_wpending_APIName return the number of pending characters in the BIOs read and write buffers
Not all BIOs support these calls
BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName return a size_t type and are functions, BIO_pending_APIName and BIO_wpending_APIName are macros which call BIO_ctrl_APIName
BIO_reset_APIName normally returns 1 for success and 0 or -1 for failure
File BIOs are an exception, they return 0 for success and -1 for failure
BIO_seek_APIName and BIO_tell_APIName both return the current file position on success and -1 for failure, except file BIOs which for BIO_seek_APIName always return 0 for success and -1 for failure
BIO_flush_APIName returns 1 for success and 0 or -1 for failure
BIO_eof_APIName returns 1 if EOF has been reached 0 otherwise
BIO_set_close_APIName always returns 1
BIO_get_close_APIName returns the close flag value: BIO_CLOSE or BIO_NOCLOSE
BIO_pending_APIName, BIO_ctrl_pending_APIName, BIO_wpending_APIName and BIO_ctrl_wpending_APIName return the amount of pending data
BIO_flush_APIName, because it can write data may return 0 or -1 indicating that the call should be retried later in a similar manner to BIO_write_APIName
The BIO_should_retry_APIName call should be used and appropriate action taken is the call fails
The return values of BIO_pending_APIName and BIO_wpending_APIName may not reliably determine the amount of pending data in all cases
For example in the case of a file BIO some data may be available in the FILE structures internal buffers but it is not possible to determine this in a portably way
For other types of BIO they may not be supported
Filter BIOs if they do not internally handle a particular BIO_ctrl_APIName operation usually pass the operation to the next BIO in the chain
This often means there is no need to locate the required BIO for a particular operation, it can be called on a chain and it will be automatically passed to the relevant BIO
However this can cause unexpected results: for example no current filter BIOs implement BIO_seek_APIName, but this may still succeed if the chain ends in a FILE or file descriptor BIO
Source/sink BIOs return an 0 if they do not recognize the BIO_ctrl_APIName operation
Some of the return values are ambiguous and care should be taken
In particular a return value of 0 can be returned if an operation is not supported, if an error occurred, if EOF has not been reached and in the case of BIO_seek_APIName on a file BIO for a successful operation
SSL_do_handshake_APIName will wait for a SSL/TLS handshake to take place
If the connection is in client mode, the handshake will be started
The handshake routines may have to be explicitly set in advance using either SSL_set_connect_state_APIName or SSL_set_accept_state_APIName
The behaviour of SSL_do_handshake_APIName depends on the underlying BIO
The following return values can occur:
The TLS/SSL handshake was successfully completed, a TLS/SSL connection has been established
X509_getm_notBefore_APIName and X509_getm_notAfter_APIName are similar to X509_get0_notBefore_APIName and X509_get0_notAfter_APIName except X509_getm_notBefore_APIName and X509_getm_notAfter_APIName return non-constant mutable references to the associated date field of the certificate
X509_get0_notBefore_APIName, X509_get0_notAfter_APIName and X509_CRL_get0_lastUpdate_APIName return a pointer to an X509_get0_notBefore_APIParam_0 X509_get0_notAfter_APIParam_0 X509_CRL_get0_lastUpdate_APIParam_0 structure
X509_set1_notBefore_APIName, X509_set1_notAfter_APIName, X509_CRL_set1_lastUpdate_APIName and X509_CRL_set1_nextUpdate_APIName return 1 for success or 0 for failure
DSA_new_APIName allocates and initializes a DSA_new_APIParam_0 structure
It is equivalent to calling DSA_new_method(NULL)
DSA_free_APIName frees the DSA_free_APIParam_1 structure and its components
The values are erased before the memory is returned to the system
If the allocation fails, DSA_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
DSA_free_APIName returns no value
SSL_CTX_set_cipher_list_APIName sets the list of available ciphers for SSL_CTX_set_cipher_list_APIParam_1 using the control string SSL_CTX_set_cipher_list_APIParam_2
The format of the string is described in ciphers_APIName
The list of ciphers is inherited by all SSL_set_cipher_list_APIParam_1 objects created from SSL_CTX_set_cipher_list_APIParam_1
SSL_set_cipher_list_APIName sets the list of ciphers only for SSL_set_cipher_list_APIParam_1
The control string SSL_set_cipher_list_APIParam_2 SSL_CTX_set_cipher_list_APIParam_2 should be universally usable and not depend on details of the library configuration (ciphers compiled in)
Thus no syntax checking takes place
Items that are not recognized, because the corresponding ciphers are not compiled in or because the corresponding ciphers are mistyped, are simply ignored
Failure is only flagged if no ciphers could be collected at all
It should be noted, that inclusion of a cipher to be used into the list is a necessary condition
On the client side, the inclusion into the list is also sufficient
On the server side, additional restrictions apply
All ciphers have additional requirements
ADH ciphers don't need a certificate, but DH-parameters must have been set
All other ciphers need a corresponding certificate and key
A RSA cipher can only be chosen, when a RSA certificate is available
RSA export ciphers with a keylength of 512 bits for the RSA key require a temporary 512 bit RSA key, as typically the supplied key has a length of 1024 bit (see SSL_CTX_set_tmp_rsa_callback_APIName )
RSA ciphers using DHE need a certificate and key and additional DH-parameters (see SSL_CTX_set_tmp_dh_callback_APIName )
A DSA cipher can only be chosen, when a DSA certificate is available
DSA ciphers always use DH key exchange and therefore need DH-parameters (see SSL_CTX_set_tmp_dh_callback_APIName )
When these conditions are not met for any cipher in the list (eg a client only supports export RSA ciphers with a asymmetric key length of 512 bits and the server is not configured to use temporary RSA keys), the "no shared cipher" (SSL_R_NO_SHARED_CIPHER) error is generated and the handshake will fail
If the cipher list does not contain any SSLv2 cipher suites (this is the default), then SSLv2 is effectively disabled and neither clients nor servers will attempt to use SSLv2
SSL_CTX_set_cipher_list_APIName and SSL_set_cipher_list_APIName return 1 if any cipher could be selected and 0 on complete failure
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName set the key referenced by EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 to EVP_PKEY_set1_RSA_APIParam_2 EVP_PKEY_set1_DSA_APIParam_2 EVP_PKEY_set1_DH_APIParam_2 EVP_PKEY_set1_EC_KEY_APIParam_2
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key in EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 or NULL if the key is not of the correct type
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName also set the referenced key to EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 however these use the supplied EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 internally and so EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 will be freed when the parent EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 is freed
EVP_PKEY_type_APIName returns the type of key corresponding to the value EVP_PKEY_type_APIParam_1
The type of a key can be obtained with EVP_PKEY_type(pkey->type)
The return value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the corresponding key types or NID_undef if the key type is unassigned
In accordance with the OpenSSL naming convention the key obtained from or assigned to the EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 using the 1 functions must be freed as well as EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_set1_DH_APIParam_1
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName are implemented as macros
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName return 1 for success or 0 for failure
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key or NULL if an error occurred
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName return 1 for success and 0 for failure
SSL_get_default_timeout_APIName returns the default timeout value assigned to SSL_SESSION objects negotiated for the protocol valid for SSL_get_default_timeout_APIParam_1
Whenever a new session is negotiated, a new session is assigned a timeout value, after which a new session will not be accepted for session reuse
If the timeout value was not explicitly set using SSL_CTX_set_timeout_APIName , the hardcoded default timeout for the protocol will be used
SSL_get_default_timeout_APIName return this hardcoded value, which is 300 seconds for all currently supported protocols (SSLv2, SSLv3, and TLSv1)
BIO_s_bio_APIName returns the method for a BIO pair
A BIO pair is a pair of source/sink BIOs where data written to either half of the pair is buffered and can be read from the other half
Both halves must usually by handled by the same application thread since no locking is done on the internal data structures
Since BIO chains typically end in a source/sink BIO, it is possible to make this one half of a BIO pair and have all the data processed by the chain under application control
One typical use of BIO pairs is to place TLS/SSL I/O under application control, this can be used when the application wishes to use a non standard transport for TLS/SSL or the normal socket routines are inappropriate
Calls to BIO_read_APIName will read data from the buffer or request a retry if no data is available
Calls to BIO_write_APIName will place data in the buffer or request a retry if the buffer is full
The standard calls BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName can be used to determine the amount of pending data in the read or write buffer
BIO_reset_APIName clears any data in the write buffer
BIO_make_bio_pair_APIName joins two separate BIOs into a connected pair
BIO_destroy_pair_APIName destroys the association between two connected BIOs
Freeing up any half of the pair will automatically destroy the association
BIO_shutdown_wr_APIName is used to close down a BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1
After this call no further writes on BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 are allowed (they will return an error)
Reads on the other half of the pair will return any pending data or EOF when all pending data has been read
BIO_set_write_buf_size_APIName sets the write buffer size of BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 to BIO_new_bio_pair_APIParam_2
If the size is not initialized ,a default value is used
This is currently 17K, sufficient for a maximum size TLS record
BIO_get_write_buf_size_APIName returns the size of the write buffer
BIO_new_bio_pair_APIName combines the calls to BIO_new_APIName, BIO_make_bio_pair_APIName and BIO_set_write_buf_size_APIName to create a connected pair of BIOs BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1, BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 with write buffer sizes BIO_new_bio_pair_APIParam_2 BIO_new_bio_pair_APIParam_2 and BIO_new_bio_pair_APIParam_4 BIO_new_bio_pair_APIParam_4
If either size is zero then the default size is used
BIO_new_bio_pair_APIName does not check whether BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1 or BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 do point to some other BIO, the values are overwritten, BIO_free_APIName is not called
BIO_get_write_guarantee_APIName and BIO_ctrl_get_write_guarantee_APIName return the maximum length of data that can be currently written to the BIO
Writes larger than this value will return a value from BIO_write_APIName less than the amount requested or if the buffer is full request a retry
BIO_ctrl_get_write_guarantee_APIName is a function whereas BIO_get_write_guarantee_APIName is a macro
BIO_ctrl_reset_read_request_APIName can also be used to reset the value returned by BIO_get_read_request_APIName to zero
Both halves of a BIO pair should be freed
That is even if one half is implicit freed due to a BIO_free_all_APIName or SSL_free_APIName call the other half needs to be freed
When used in bidirectional applications (such as TLS/SSL) care should be taken to flush any data in the write buffer
This can be done by calling BIO_pending_APIName on the other half of the pair and, if any data is pending, reading it and sending it to the underlying transport
This must be done before any normal processing (such as calling select_APIName ) due to a request and BIO_should_read_APIName being true
To see why this is important consider a case where a request is sent using BIO_write_APIName and a response read with BIO_read_APIName, this can occur during an TLS/SSL handshake for example
BIO_write_APIName will succeed and place data in the write buffer
BIO_read_APIName will initially fail and BIO_should_read_APIName will be true
If the application then waits for data to be available on the underlying transport before flushing the write buffer ,it will never succeed because the request was never sent!
BIO_eof_APIName is true if no data is in the peer BIO and the peer BIO has been shutdown
BIO_new_bio_pair_APIName returns 1 on success, with the new BIOs available in BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3, or 0 on failure, with NULL pointers stored into the locations for BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3
Check the error stack for more information
[XXXXX: More return values need to be added here]
As the data is buffered, SSL_operation_APIName may return with a ERROR_SSL_WANT_READ condition, but there is still data in the write buffer
An application must not rely on the error value of SSL_operation_APIName but must assure that the write buffer is always flushed first
Otherwise a deadlock may occur as the peer might be waiting for the data before being able to continue
These functions handle application specific data in DSA structures
These functions usage is identical to that of RSA_get_ex_new_index_APIName, RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName
EVP_PKEY_sign_APIName does not hash the data to be signed, and therefore is normally used to sign digests
For signing arbitrary messages, see the EVP_DigestSignInit_APIName and EVP_SignInit_APIName signing interfaces instead
After the call to EVP_PKEY_sign_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation (see EVP_PKEY_CTX_ctrl_APIName )
The function EVP_PKEY_sign_APIName can be called more than once on the same context if several operations are performed using the same parameters
EVP_PKEY_sign_init_APIName and EVP_PKEY_sign_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
X509_NAME_ENTRY_get_object_APIName retrieves the field name of X509_NAME_ENTRY_get_object_APIParam_1 in and X509_NAME_ENTRY_get_object_APIParam_0 structure
X509_NAME_ENTRY_get_data_APIName retrieves the field value of X509_NAME_ENTRY_get_data_APIParam_1 in and X509_NAME_ENTRY_get_data_APIParam_0 structure
X509_NAME_ENTRY_set_object_APIName sets the field name of X509_NAME_ENTRY_set_object_APIParam_1 to X509_NAME_ENTRY_set_object_APIParam_2
X509_NAME_ENTRY_set_data_APIName sets the field value of X509_NAME_ENTRY_set_data_APIParam_1 to string type X509_NAME_ENTRY_set_data_APIParam_2 and value determined by X509_NAME_ENTRY_set_data_APIParam_3 and X509_NAME_ENTRY_set_data_APIParam_4
X509_NAME_ENTRY_create_by_txt_APIName, X509_NAME_ENTRY_create_by_NID_APIName and X509_NAME_ENTRY_create_by_OBJ_APIName create and return an X509_NAME_ENTRY_create_by_txt_APIParam_1 X509_NAME_ENTRY_create_by_NID_APIParam_1 X509_NAME_ENTRY_create_by_OBJ_APIParam_1 structure
X509_NAME_ENTRY_get_object_APIName and X509_NAME_ENTRY_get_data_APIName can be used to examine an X509_NAME_ENTRY_get_object_APIParam_1 X509_NAME_ENTRY_get_data_APIParam_1 function as returned by X509_NAME_get_entry_APIName for example
X509_NAME_ENTRY_create_by_txt_APIName, X509_NAME_ENTRY_create_by_OBJ_APIName, X509_NAME_ENTRY_create_by_NID_APIName and X509_NAME_ENTRY_set_data_APIName are seldom used in practice because X509_NAME_ENTRY_create_by_txt_APIParam_1 X509_NAME_ENTRY_create_by_OBJ_APIParam_1 X509_NAME_ENTRY_create_by_NID_APIParam_1 X509_NAME_ENTRY_set_data_APIParam_1 structures are almost always part of X509_NAME_ENTRY_create_by_txt_APIParam_1 X509_NAME_ENTRY_create_by_OBJ_APIParam_1 X509_NAME_ENTRY_create_by_NID_APIParam_1 X509_NAME_ENTRY_set_data_APIParam_1 structures and the corresponding X509_NAME_ENTRY_create_by_txt_APIParam_1 X509_NAME_ENTRY_create_by_OBJ_APIParam_1 X509_NAME_ENTRY_create_by_NID_APIParam_1 X509_NAME_ENTRY_set_data_APIParam_1 functions are typically used to create and add new entries in a single operation
SSL_write_APIName writes SSL_write_APIParam_3 bytes from the buffer SSL_write_APIParam_2 into the specified SSL_write_APIParam_1 connection
If necessary, SSL_write_APIName will negotiate a TLS/SSL session, if not already explicitly performed by SSL_connect_APIName or SSL_accept_APIName
If the peer requests a re-negotiation, it will be performed transparently during the SSL_write_APIName operation
The behaviour of SSL_write_APIName depends on the underlying BIO
For the transparent negotiation to succeed, the SSL_write_APIParam_1 must have been initialized to client or server mode
This is being done by calling SSL_set_connect_state_APIName or SSL_set_accept_state_APIName before the first call to an SSL_read_APIName or SSL_write_APIName function
SSL_write_APIName will only return with success, when the complete contents of SSL_write_APIParam_2 SSL_write_APIParam_2 SSL_write_APIParam_2 SSL_write_APIParam_2 of length SSL_write_APIParam_3 SSL_write_APIParam_3 SSL_write_APIParam_3 SSL_write_APIParam_3 has been written
This default behaviour can be changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of SSL_CTX_set_mode_APIName
When this flag is set, SSL_write_APIName will also return with success, when a partial write has been successfully completed
In this case the SSL_write_APIName operation is considered completed
The bytes are sent and a new SSL_write_APIName operation with a new buffer (with the already sent bytes removed) must be started
A partial write is performed with the size of a message block, which is 16kB for SSLv3/TLSv1
When calling SSL_write_APIName with num=0 bytes to be sent the behaviour is undefined
The following return values can occur:
The write operation was successful, the return value is the number of bytes actually written to the TLS/SSL connection
SSLv2 (deprecated) does not support a shutdown alert protocol, so it can only be detected, whether the underlying connection was closed
It cannot be checked, why the closure happened
Old documentation indicated a difference between 0 and -1, and that -1 was retryable
You should instead call SSL_get_error_APIName to find out if it's retryable
OpenSSL keeps an internal table of digest algorithms and ciphers
OpenSSL uses this table to lookup ciphers via functions such as EVP_get_cipher_byname_APIName
OpenSSL_add_all_digests_APIName adds all digest algorithms to the table
OpenSSL_add_all_algorithms_APIName adds all algorithms to the table (digests and ciphers)
OpenSSL_add_all_ciphers_APIName adds all encryption algorithms to the table including password based encryption algorithms
EVP_cleanup_APIName removes all ciphers and digests from the table
None of the functions return a value
A typical application will call OpenSSL_add_all_algorithms_APIName initially and EVP_cleanup_APIName before exiting
An application does not need to add algorithms to use them explicitly, for example by EVP_sha1_APIName
It just needs to add them if it (or any of the functions it calls) needs to lookup algorithms
The cipher and digest lookup functions are used in many parts of the library
If the table is not initialized, several functions will misbehave and complain several functions cannot find algorithms
This includes the PEM, PKCS#12, SSL and S/MIME libraries
This is a common query in the OpenSSL mailing lists
Calling OpenSSL_add_all_algorithms_APIName links in all algorithms: as a result a statically linked executable can be quite large
If this is important, it is possible to just add the required ciphers and digests
Although the functions do not return error codes, it is possible for them to fail
This will only happen as a result of a memory allocation failure so this is not too much of a problem in practice
BIO_s_fd_APIName returns the file descriptor BIO method
This is a wrapper round the platforms file descriptor routines such as read_APIName and write_APIName
BIO_read_APIName and BIO_write_APIName read or write the underlying descriptor
BIO_puts_APIName is supported but BIO_gets_APIName is not
If the close flag is set ,then then close_APIName is called on the underlying file descriptor when the BIO is freed
BIO_reset_APIName attempts to change the file pointer to the start of file using lseek(fd, 0, 0)
BIO_tell_APIName returns the current file position by calling lseek(fd, 0, 1)
BIO_new_fd_APIName returns a file descriptor BIO using BIO_new_fd_APIParam_1 and BIO_new_fd_APIParam_2
The behaviour of BIO_read_APIName and BIO_write_APIName depends on the behavior of the platforms read_APIName and write_APIName calls on the descriptor
If the underlying file descriptor is in a non blocking mode ,then the BIO will behave in the manner described in the BIO_read_APIName and BIO_should_retry_APIName manual pages
File descriptor BIOs should not be used for socket I/O
Use socket BIOs instead
BIO_s_fd_APIName returns the file descriptor BIO method
BIO_reset_APIName returns zero for success and -1 if an error occurred
BIO_seek_APIName and BIO_tell_APIName return the current file position or -1 if an error occurred
These values reflect the underlying lseek_APIName behaviour
BIO_set_fd_APIName always returns 1
BIO_get_fd_APIName returns the file descriptor or -1 if the BIO has not been initialized
BIO_new_fd_APIName returns the newly allocated BIO or NULL is an error occurred
BN_bn2bin_APIName converts the absolute value of BN_bn2bin_APIParam_1 into big-endian form and stores BN_bn2bin_APIParam_1 at BN_bn2bin_APIParam_2
BN_bn2bin_APIParam_2 must point to BN_num_bytes(BN_bn2bin_APIParam_1) bytes of memory
BN_bin2bn_APIName converts the positive integer in big-endian form of length BN_bin2bn_APIParam_2 at BN_bin2bn_APIParam_1 into a BN_bin2bn_APIParam_3 and places it in BN_bin2bn_APIParam_3
If BN_bin2bn_APIParam_3 is NULL, a new BN_bin2bn_APIParam_3 is created
BN_bn2hex_APIName and BN_bn2dec_APIName return printable strings containing the hexadecimal and decimal encoding of BN_bn2hex_APIParam_1 BN_bn2dec_APIParam_1 respectively
For negative numbers, the string is prefaced with a leading '-'
The string must be freed later using OPENSSL_free_APIName
BN_hex2bn_APIName converts the string BN_hex2bn_APIParam_2 BN_dec2bn_APIParam_2 containing a hexadecimal number to a BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 and stores it in **BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1
If *BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 is NULL, a new BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 is created
If BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 is NULL, it only computes the number's length in hexadecimal digits
If the string starts with '-', the number is negative
A "negative zero" is converted to zero
BN_dec2bn_APIName is the same using the decimal system
BN_print_APIName and BN_print_fp_APIName write the hexadecimal encoding of BN_print_APIParam_2 BN_print_fp_APIParam_2, with a leading '-' for negative numbers, to the BN_print_APIParam_1 or BN_print_fp_APIParam_1 BN_print_APIParam_1 BN_print_fp_APIParam_1
BN_bn2mpi_APIName and BN_mpi2bn_APIName convert BN_bn2mpi_APIParam_1 BN_mpi2bn_APIParam_3s from and to a format that consists of the number's length in bytes represented as a 4-byte big-endian number, and the number itself in big-endian format, where the most significant bit signals a negative number (the representation of numbers with the MSB set is prefixed with null byte)
BN_bn2mpi_APIName stores the representation of BN_bn2mpi_APIParam_1 at BN_bn2mpi_APIParam_2, where BN_bn2mpi_APIParam_2 must be large enough to hold the result
The size can be determined by calling BN_bn2mpi(BN_bn2mpi_APIParam_1, NULL)
BN_mpi2bn_APIName converts the BN_mpi2bn_APIParam_2 bytes long representation at BN_mpi2bn_APIParam_1 to a BN_mpi2bn_APIParam_3 and stores it at BN_mpi2bn_APIParam_3, or in a newly allocated BN_mpi2bn_APIParam_3 if BN_mpi2bn_APIParam_3 is NULL
BN_bn2bin_APIName returns the length of the big-endian number placed at BN_bn2bin_APIParam_2
BN_bin2bn_APIName returns the BN_bn2bin_APIParam_1 BN_bin2bn_APIParam_3, NULL on error
BN_bn2hex_APIName and BN_bn2dec_APIName return a null-terminated string, or NULL on error
BN_hex2bn_APIName and BN_dec2bn_APIName return the number of characters used in parsing, or 0 on error, in which case no new BN_bn2hex_APIParam_1 BN_bn2dec_APIParam_1 BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 will be created
BN_print_fp_APIName and BN_print_APIName return 1 on success, 0 on write errors
BN_bn2mpi_APIName returns the length of the representation
BN_mpi2bn_APIName returns the BN_bn2mpi_APIParam_1 BN_mpi2bn_APIParam_3, and NULL on error
The error codes can be obtained by ERR_get_error_APIName
The EVP encode routines provide a high level interface to base 64 encoding and decoding
Base 64 encoding converts binary data into a printable form that uses the characters A-Z, a-z, 0-9, "+" and "/" to represent the data
For every 3 bytes of binary data provided 4 bytes of base 64 encoded data will be produced plus some occasional newlines (see below)
If the input data length is not a multiple of 3 then the output data will be padded at the end using the "=" character
Encoding of binary data is performed in blocks of 48 input bytes (or less for the final block)
For each 48 byte input block encoded 64 bytes of base 64 data is output plus an additional newline character (ie 65 bytes in total)
The final block (which may be less than 48 bytes) will output 4 bytes for every 3 bytes of input
If the data length is not divisible by 3 ,then a full 4 bytes is still output for the final 1 or 2 bytes of input
Similarly a newline character will also be output
EVP_EncodeInit_APIName initialises EVP_EncodeInit_APIParam_1 for the start of a new encoding operation
EVP_EncodeFinal_APIName must be called at the end of an encoding operation
EVP_EncodeFinal_APIName will process any partial block of data remaining in the EVP_EncodeFinal_APIParam_1 object
The output data will be stored in EVP_EncodeFinal_APIParam_2 and the length of the data written will be stored in EVP_EncodeFinal_APIParam_3
It is the caller's responsibility to ensure that EVP_EncodeFinal_APIParam_2 is sufficiently large to accommodate the output data which will never be more than 65 bytes plus an additional NUL terminator (ie 66 bytes in total)
EVP_DecodeInit_APIName initialises EVP_DecodeInit_APIParam_1 for the start of a new decoding operation
EVP_DecodeFinal_APIName must be called at the end of a decoding operation
If there is any unprocessed data still in EVP_DecodeFinal_APIParam_1, then the input data must not have been a multiple of 4 and therefore an error has occurred
The function will return -1 in this case
Otherwise the function returns 1 on success
EVP_DecodeBlock_APIName will decode the block of EVP_DecodeBlock_APIParam_3 characters of base 64 data contained in EVP_DecodeBlock_APIParam_2 and store the result in EVP_DecodeBlock_APIParam_1
Any leading whitespace will be trimmed as will any trailing whitespace, newlines, carriage returns or EOF characters
After such trimming the length of the data in EVP_DecodeBlock_APIParam_2 must be divisbile by 4
For every 4 input bytes exactly 3 output bytes will be produced
The output will be padded with 0 bits if necessary to ensure that the output is always 3 bytes for every 4 input bytes
This function will return the length of the data decoded or -1 on error
EVP_EncodeBlock_APIName returns the number of bytes encoded excluding the NUL terminator
EVP_DecodeUpdate_APIName returns -1 on error and 0 or 1 on success
If 0 is returned then no more non-padding base 64 characters are expected
EVP_DecodeFinal_APIName returns -1 on error or 1 on success
EVP_DecodeBlock_APIName returns the length of the data decoded or -1 on error
When setting up a connection and during use, it is possible to obtain state information from the SSL/TLS engine
When set, an information callback function is called whenever the state changes, an alert appears, or an error occurs
Callback has been called to indicate state change inside a loop
Callback has been called to indicate error exit of a handshake function
(May be soft error with retry option for non-blocking setups.)
Callback has been called during read operation
Callback has been called during write operation
Callback has been called due to an alert being sent or received
Callback has been called because a new handshake is started
Callback has been called because a handshake is finished
The current state information can be obtained using the SSL_state_string_APIName family of functions
SSL_set_info_callback_APIName does not provide diagnostic information
SSL_get_info_callback_APIName returns the current setting
OBJ_nid2obj_APIName, OBJ_nid2ln_APIName and OBJ_nid2sn_APIName convert the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 to an ASN1_OBJECT structure, the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 long name and the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 short name respectively, or NULL if an error occurred
OBJ_obj2nid_APIName, OBJ_ln2nid_APIName, OBJ_sn2nid_APIName return the corresponding NID for the object OBJ_obj2nid_APIParam_1, the long name <ln> or the short name <sn> respectively or NID_undef if an error occurred
OBJ_txt2nid_APIName returns NID corresponding to text string <s>
OBJ_txt2nid_APIParam_1 can be a long name, a short name or the numerical representation of an object
OBJ_txt2obj_APIName converts the text string OBJ_txt2obj_APIParam_1 into an ASN1_OBJECT structure
If OBJ_txt2obj_APIParam_2 is 0 ,then long names and short names will be interpreted as well as numerical forms
If OBJ_txt2obj_APIParam_2 is 1 ,only the numerical form is acceptable
OBJ_obj2txt_APIName converts the OBJ_obj2txt_APIParam_3 OBJ_obj2txt_APIParam_3 into a textual representation
The representation is written as a null terminated string to OBJ_obj2txt_APIParam_1 at most OBJ_obj2txt_APIParam_2 bytes are written, truncating the result if necessary
The total amount of space required is returned
If OBJ_obj2txt_APIParam_4 is 0 then if the object has a long or short name then that will be used, otherwise the numerical form will be used
If OBJ_obj2txt_APIParam_4 is 1 ,then the numerical form will always be used
i2t_ASN1_OBJECT_APIName is the same as OBJ_obj2txt_APIName with the OBJ_obj2txt_APIParam_4 set to zero
OBJ_cmp_APIName compares OBJ_cmp_APIParam_1 to OBJ_cmp_APIParam_2
If the two are identical 0 is returned
OBJ_dup_APIName returns a copy of OBJ_dup_APIParam_1
OBJ_create_APIName adds a new object to the internal table
OBJ_create_APIParam_1 is the numerical form of the object, OBJ_create_APIParam_2 the short name and OBJ_create_APIParam_3 the long name
A new NID is returned for the created object in case of success and NID_undef in case of failure
OBJ_length_APIName returns the size of the content octets of OBJ_length_APIParam_1
OBJ_cleanup_APIName releases any resources allocated by creating new objects
For example the OID for commonName has the following definitions:
New objects can be added by calling OBJ_create_APIName
Table objects have certain advantages over other objects: for example their NIDs can be used in a C language switch statement
They are also static constant structures which are shared: that is there is only a single constant structure for each table object
Objects which are not in the table have the NID value NID_undef
Objects do not need to be in the internal tables to be processed, the functions OBJ_txt2obj_APIName and OBJ_obj2txt_APIName can process the numerical form of an OID
These functions cannot return OBJ_cmp_APIParam_1 OBJ_obj2txt_APIParam_3 i2t_ASN1_OBJECT_APIParam_3 OBJ_create_APIParam_1 OBJ_ln2nid_APIParam_1 OBJ_sn2nid_APIParam_1 OBJ_length_APIParam_1 because an OBJ_cmp_APIParam_1 OBJ_obj2txt_APIParam_3 i2t_ASN1_OBJECT_APIParam_3 OBJ_dup_APIParam_1 OBJ_obj2nid_APIParam_1 OBJ_length_APIParam_1 can represent both an internal, constant, OID and a dynamically-created one
The latter cannot be constant because it needs to be freed after use
OBJ_nid2obj_APIName returns an OBJ_nid2obj_APIParam_0 structure or NULL is an error occurred
OBJ_nid2ln_APIName and OBJ_nid2sn_APIName returns a valid string or NULL on error
OBJ_obj2txt_APIName is awkward and messy to use: OBJ_obj2txt_APIName doesn't follow the convention of other OpenSSL functions where the buffer can be set to NULL to determine the amount of data that should be written
Instead OBJ_obj2txt_APIParam_1 must point to a valid buffer and OBJ_obj2txt_APIParam_2 should be set to a positive value
A buffer length of 80 should be more than enough to handle any OID encountered in practice
RSA_sign_APIName returns 1 on success, 0 otherwise
RSA_verify_APIName returns 1 on successful verification, 0 otherwise
The error codes can be obtained by ERR_get_error_APIName
Certain signatures with an improper algorithm identifier are accepted for compatibility with SSLeay 0.4.5 :-)
SSL_get_session_APIName returns a pointer to the SSL_get_session_APIParam_0 actually used in SSL_get_session_APIParam_1
The reference count of the SSL_get_session_APIParam_0 is not incremented, so that the pointer can become invalid by other operations
SSL_get0_session_APIName is the same as SSL_get_session_APIName
SSL_get1_session_APIName is the same as SSL_get_session_APIName, but the reference count of the SSL_get1_session_APIParam_0 SSL_get_session_APIParam_0 is incremented by one
The ssl session contains all information required to re-establish the connection without a new handshake
A session will be automatically removed from the session cache and marked as non-resumable if the connection is not closed down cleanly, eg if a fatal error occurs on the connection or SSL_shutdown_APIName is not called prior to SSL_free_APIName
SSL_get0_session_APIName returns a pointer to the actual session
As the reference counter is not incremented, the pointer is only valid while the connection is in use
If SSL_clear_APIName or SSL_free_APIName is called, the session may be removed completely (if considered bad), and the pointer obtained will become invalid
Even if the session is valid, it can be removed at any time due to timeout during SSL_CTX_flush_sessions_APIName
If the data is to be kept, SSL_get1_session_APIName will increment the reference count, so that the session will not be implicitly removed by other operations but stays in memory
In order to remove the session, SSL_SESSION_free_APIName must be explicitly called once to decrement the reference count again
SSL_SESSION objects keep internal link information about the session cache list, when being inserted into one SSL_CTX object's session cache
One SSL_SESSION object, regardless of its reference count, must therefore only be used with one SSL_CTX object (and the SSL objects created from this SSL_CTX object)
The following return values can occur:
There is no session available in SSL_get0_session_APIParam_1 SSL_get_session_APIParam_1 SSL_get1_session_APIParam_1
The return value points to the data of an SSL session
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
Within the library there are two forms of elliptic curve that are of interest
The first form is those defined over the prime field Fp
The elements of Fp are the integers 0 to p-1, where p is a prime number
This gives us a revised elliptic curve equation as follows:
y^2 mod p = x^3 +ax + b mod p
The second form is those defined over a binary field F2^m where the elements of the field are integers of length at most m bits
For this form the elliptic curve equation is modified to:
y^2 + xy = x^3 + ax^2 + b (where b != 0)
A new curve can be constructed by calling EC_GROUP_new, using the implementation provided by EC_GROUP_new_APIParam_1 (see EC_GFp_simple_method_APIName )
It is then necessary to call either EC_GROUP_set_curve_GFp or EC_GROUP_set_curve_GF2m as appropriate to create a curve defined over Fp or over F2^m respectively
EC_GROUP_set_curve_GFp sets the curve parameters EC_GROUP_set_curve_GFp_APIParam_2 EC_GROUP_new_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GFp_APIParam_2 EC_GROUP_new_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_2, EC_GROUP_set_curve_GFp_APIParam_3 EC_GROUP_new_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GF2m_APIParam_3 EC_GROUP_get_curve_GFp_APIParam_3 EC_GROUP_new_curve_GFp_APIParam_2 EC_GROUP_set_curve_GF2m_APIParam_3 and EC_GROUP_set_curve_GFp_APIParam_4 EC_GROUP_new_curve_GF2m_APIParam_3 EC_GROUP_get_curve_GF2m_APIParam_4 EC_GROUP_get_curve_GFp_APIParam_4 EC_GROUP_new_curve_GFp_APIParam_3 EC_GROUP_set_curve_GF2m_APIParam_4 for a curve over Fp stored in EC_GROUP_clear_free_APIParam_1 EC_GROUP_set_curve_GFp_APIParam_1 EC_GROUP_free_APIParam_1 EC_GROUP_get_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_1
EC_group_get_curve_GFp obtains the previously set curve parameters
EC_GROUP_set_curve_GF2m sets the equivalent curve parameters for a curve over F2^m
In this case EC_GROUP_set_curve_GFp_APIParam_2 EC_GROUP_new_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GFp_APIParam_2 EC_GROUP_new_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_2 represents the irreducible polybnomial - each bit represents a term in the polynomial
Therefore there will either be three or five bits set dependant on whether the polynomial is a trinomial or a pentanomial
EC_group_get_curve_GF2m obtains the previously set curve parameters
The functions EC_GROUP_new_curve_GFp and EC_GROUP_new_curve_GF2m are shortcuts for calling EC_GROUP_new and the appropriate EC_group_set_curve function
An appropriate default implementation method will be used
Whilst the library can be used to create any curve using the functions described above, there are also a number of predefined curves that are available
In order to obtain a list of all of the predefined curves, call the function EC_get_builtin_curves
The parameter EC_get_builtin_curves_APIParam_1 should be an array of EC_builtin_curve structures of size EC_get_builtin_curves_APIParam_2
The function will populate the EC_get_builtin_curves_APIParam_1 array with information about the builtin curves
If EC_get_builtin_curves_APIParam_2 is less than the total number of curves available, then the first EC_get_builtin_curves_APIParam_2 curves will be returned
Otherwise the total number of curves will be provided
The return value is the total number of curves available (whether that number has been populated in EC_get_builtin_curves_APIParam_1 or not)
Passing a NULL EC_get_builtin_curves_APIParam_1, or setting EC_get_builtin_curves_APIParam_2 to 0 will do nothing other than return the total number of curves available
The EC_builtin_curve structure is defined as follows:
Each EC_builtin_curve item has a unique integer id (EC_GROUP_new_by_curve_name_APIParam_1), and a human readable comment string describing the curve
In order to construct a builtin curve, use the function EC_GROUP_new_by_curve_name and provide the EC_GROUP_new_by_curve_name_APIParam_1 of the curve to be constructed
EC_GROUP_free frees the memory associated with the EC_GROUP
EC_GROUP_clear_free destroys any sensitive data held within the EC_GROUP and then frees its memory
All EC_GROUP_new* functions return a pointer to the newly constructed group, or NULL on error
EC_get_builtin_curves returns the number of builtin curves that are available
EC_GROUP_set_curve_GFp, EC_GROUP_get_curve_GFp, EC_GROUP_set_curve_GF2m, EC_GROUP_get_curve_GF2m return 1 on success or 0 on error
SSL_CTX_set_verify_depth_APIName sets the maximum SSL_CTX_set_verify_depth_APIParam_2 for the certificate chain verification that shall be allowed for SSL_CTX_set_verify_depth_APIParam_1
(See the BUGS section.)
The verification of certificates can be controlled by a set of logically or'ed SSL_CTX_set_verify_APIParam_2 SSL_set_verify_APIParam_2 flags:
Exactly one of the SSL_CTX_set_verify_APIParam_2 SSL_set_verify_APIParam_2 flags SSL_VERIFY_NONE and SSL_VERIFY_PEER must be set at any time
The actual verification procedure is performed either using the built-in verification procedure or using another application provided verification function set with SSL_CTX_set_cert_verify_callback_APIName
The following descriptions apply in the case of the built-in procedure
An application provided procedure also has access to the verify depth information and the verify_callback_APIName function, but the way this information is used may be different
SSL_CTX_set_verify_depth_APIName and SSL_set_verify_depth_APIName set the limit up to which depth certificates in a chain are used during the verification procedure
If the certificate chain is longer than allowed, the certificates above the limit are ignored
Error messages are generated as if these certificates would not be present, most likely a X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY will be issued
The depth count is "level 0:peer certificate", "level 1: CA certificate", "level 2: higher level CA certificate", and so on
Setting the maximum depth to 2 allows the levels 0, 1, and 2
The default depth limit is 100, allowing for the peer certificate and additional 100 CA certificates
In client mode, it is not checked whether the SSL_VERIFY_PEER flag is set, but whether SSL_VERIFY_NONE is not set
This can lead to unexpected behaviour, if the SSL_VERIFY_PEER and SSL_VERIFY_NONE are not used as required (exactly one must be set at any time)
The certificate verification depth set with SSL[_CTX]_verify_depth_APIName stops the verification at a certain depth
The error message produced will be that of an incomplete certificate chain and not X509_V_ERR_CERT_CHAIN_TOO_LONG as may be expected
The SSL*_set_verify*_APIName functions do not provide diagnostic information
SSL_CTX_set_session_cache_mode_APIName enables/disables session caching by setting the operational mode for SSL_CTX_set_session_cache_mode_APIParam_1 to <mode>
SSL_CTX_get_session_cache_mode_APIName returns the currently used cache mode
The OpenSSL library can store/retrieve SSL/TLS sessions for later reuse
The sessions can be held in memory for each SSL_CTX_set_session_cache_mode_APIParam_1 SSL_CTX_get_session_cache_mode_APIParam_1, if more than one SSL_CTX object is being maintained, the sessions are unique for each SSL_CTX object
In order to reuse a session, a client must send the session's id to the server
It can only send exactly one id
The server then either agrees to reuse the session or it starts a full handshake (to create a new session)
A server will look up the session in its internal session storage
If the session is not found in internal storage or lookups for the internal storage have been deactivated (SSL_SESS_CACHE_NO_INTERNAL_LOOKUP), the server will try the external storage if available
Since a client may try to reuse a session intended for use in a different context, the session id context must be set by the server (see SSL_CTX_set_session_id_context_APIName )
The following session cache modes and modifiers are available:
No session caching for client or server takes place
Client sessions are added to the session cache
As there is no reliable way for the OpenSSL library to know whether a session should be reused or which session to choose (due to the abstract BIO layer the SSL engine does not have details about the connection), the application must select the session to be reused by using the SSL_set_session_APIName function
This option is not activated by default
Server sessions are added to the session cache
When a client proposes a session to be reused, the server looks for the corresponding session in (first) the internal session cache (unless SSL_SESS_CACHE_NO_INTERNAL_LOOKUP is set), then (second) in the external cache if available
If the session is found, the server will try to reuse the session
This is the default
Enable both SSL_SESS_CACHE_CLIENT and SSL_SESS_CACHE_SERVER at the same time
Normally the session cache is checked for expired sessions every 255 connections using the SSL_CTX_flush_sessions_APIName function
Since this may lead to a delay which cannot be controlled, the automatic flushing may be disabled and SSL_CTX_flush_sessions_APIName can be called explicitly by the application
By setting this flag, session-resume operations in an SSL/TLS server will not automatically look up sessions in the internal cache, even if sessions are automatically stored there
If external session caching callbacks are in use, this flag guarantees that all lookups are directed to the external cache
As automatic lookup only applies for SSL/TLS servers, the flag has no effect on clients
Depending on the presence of SSL_SESS_CACHE_CLIENT and/or SSL_SESS_CACHE_SERVER, sessions negotiated in an SSL/TLS handshake may be cached for possible reuse
Normally a new session is added to the internal cache as well as any external session caching (callback) that is configured for the SSL_CTX
This flag will prevent sessions being stored in the internal cache (though the application can add them manually using SSL_CTX_add_session_APIName )
Note: in any SSL/TLS servers where external caching is configured, any successful session lookups in the external cache (ie for session-resume requests) would normally be copied into the local cache before processing continues - this flag prevents these additions to the internal cache as well
Enable both SSL_SESS_CACHE_NO_INTERNAL_LOOKUP and SSL_SESS_CACHE_NO_INTERNAL_STORE at the same time
The default mode is SSL_SESS_CACHE_SERVER
SSL_CTX_set_session_cache_mode_APIName returns the previously set cache mode
SSL_CTX_get_session_cache_mode_APIName returns the currently set cache mode
These functions are implemented in C and for several platforms in assembly language:
bn_mul_words(bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3, mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4) operates on the bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word arrays bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1 and bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, and returns the high word (carry)
bn_mul_add_words(bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3, mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4) operates on the bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word arrays bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1 and bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4 + bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, and returns the high word (carry)
bn_sqr_words(bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3) operates on the bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word array bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 and the 2*bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word array bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 word-wise, and places the low and high bytes of the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1
bn_div_words(bn_div_words_APIParam_1, bn_div_words_APIParam_2 bn_mul_high_APIParam_4, bn_div_words_APIParam_3 bn_dump_APIParam_1) divides the two word number (bn_div_words_APIParam_1,bn_div_words_APIParam_2 bn_mul_high_APIParam_4) by bn_div_words_APIParam_3 bn_dump_APIParam_1 and returns the result
bn_add_words(bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_sub_words_APIParam_3 bn_add_words_APIParam_3, bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3) operates on the bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word arrays bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_sub_words_APIParam_3 bn_add_words_APIParam_3 and bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 + bn_sub_words_APIParam_3 bn_add_words_APIParam_3, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, and returns the high word (carry)
bn_sub_words(bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_sub_words_APIParam_3 bn_add_words_APIParam_3, bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3) operates on the bn_mul_words_APIParam_3 bn_mul_add_words_APIParam_3 bn_sqr_words_APIParam_3 word arrays bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, bn_sub_words_APIParam_3 bn_add_words_APIParam_3 and bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 - bn_sub_words_APIParam_3 bn_add_words_APIParam_3, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_add_words_APIParam_1 bn_sqr_words_APIParam_1, and returns the carry (1 if bn_sub_words_APIParam_3 bn_add_words_APIParam_3 > bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2, 0 otherwise)
bn_mul_comba4(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3) operates on the 4 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and the 8 word array bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
It computes bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1*bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and places the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
bn_mul_comba8(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3) operates on the 8 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and the 16 word array bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
It computes bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1*bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and places the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
bn_sqr_comba4(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3) operates on the 4 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and the 8 word array bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
bn_sqr_comba8(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3) operates on the 8 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and the 16 word array bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
The following functions are implemented in C:
bn_cmp_words(bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3, bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3) operates on the bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3
It returns 1, 0 and -1 if bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 is greater than, equal and less than bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3
bn_mul_low_normal(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3, bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3) operates on the bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 word arrays bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3
It computes the bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 low words of bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1*bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and places the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
bn_mul_low_recursive(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3, bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4, bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4) operates on the bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4 word arrays bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1 and bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4 and the bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4/2 word arrays bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3
bn_mul_high(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3, bn_div_words_APIParam_2 bn_mul_high_APIParam_4, bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4, bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4) operates on the bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4 word arrays bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and bn_div_words_APIParam_2 bn_mul_high_APIParam_4 (?)
and the 3*bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4 word array bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4
bn_sqr_normal(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3, bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4) operates on the bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 word array bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and the 2*bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 word arrays bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4 and bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1
mul(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4, mul_APIParam_4 mul_add_APIParam_4) computes mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4*bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1+mul_APIParam_4 mul_add_APIParam_4 and places the low word of the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1 and the high word in mul_APIParam_4 mul_add_APIParam_4
mul_add(bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1, mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4, mul_APIParam_4 mul_add_APIParam_4) computes mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4*bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1+bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1+mul_APIParam_4 mul_add_APIParam_4 and places the low word of the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 mul_add_APIParam_1 bn_sqr_recursive_APIParam_1 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1 and the high word in mul_APIParam_4 mul_add_APIParam_4
sqr(sqr_APIParam_1, sqr_APIParam_2, bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1) computes bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1*bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 bn_mul_low_recursive_APIParam_2 bn_mul_normal_APIParam_2 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 bn_mul_recursive_APIParam_2 bn_mul_low_normal_APIParam_2 sqr_APIParam_3 bn_expand2_APIParam_1 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 and places the low word of the result in sqr_APIParam_1 and the high word in sqr_APIParam_2
bn_expand_APIName ensures that bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 has enough space for a bn_expand_APIParam_2 bit number
bn_wexpand_APIName ensures that bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 has enough space for an bn_wexpand_APIParam_2 bn_expand2_APIParam_2 word number
If the number has to be expanded, both macros call bn_expand2_APIName, which allocates a new bn_div_words_APIParam_3 bn_dump_APIParam_1 array and copies the data
both macros return NULL on error, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 otherwise
bn_print_APIName prints bn_print_APIParam_1 to stderr
bn_dump_APIName prints bn_dump_APIParam_2 words at bn_dump_APIParam_1 (in reverse order, ie most significant word first) to stderr
An application will typically call SSL_use_certificate_APIName and SSL_use_PrivateKey_APIName to set the end entity certificate and private key
It can add intermediate and optionally the root CA certificates using SSL_add1_chain_cert_APIName
A more advanced callback might examine the handshake parameters and set whatever chain is appropriate
For example a legacy client supporting only TLS v1.0 might receive a certificate chain signed using SHA1 whereas a TLS v1.2 client which advertises support for SHA256 could receive a chain using SHA256
CMS_sign_receipt_APIName returns either a valid CMS_ContentInfo structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
OPENSSL_instrument_bus performs OPENSSL_instrument_bus2_APIParam_2 OPENSSL_instrument_bus_APIParam_2 probes and records the number of oscillator cycles every probe took
Return value of 0 indicates that CPU is not capable of performing the benchmark, either because oscillator counter or 'flush cache line' is not available on current platform
For reference, on x86 'flush cache line' was introduced with the SSE2 extensions
Otherwise number of recorded values is returned
SSL_set_verify_result_APIName sets SSL_set_verify_result_APIParam_2 of the object SSL_set_verify_result_APIParam_1 to be the result of the verification of the X509 certificate presented by the peer, if any
SSL_set_verify_result_APIName overrides the verification result
It only changes the verification result of the SSL_set_verify_result_APIParam_1 object
It does not become part of the established session, so if the session is to be reused later, the original value will reappear
The valid codes for SSL_set_verify_result_APIParam_2 are documented in verify_APIName
SSL_set_verify_result_APIName does not provide a return value
The EVP_PKEY_keygen_APIName function performs a key generation operation, the generated key is written to EVP_PKEY_keygen_APIParam_2
The functions EVP_PKEY_paramgen_init_APIName and EVP_PKEY_paramgen_APIName are similar except parameters are generated
The function EVP_PKEY_set_cb_APIName sets the key or parameter generation callback to EVP_PKEY_CTX_get_cb_APIParam_0
The function EVP_PKEY_CTX_get_cb_APIName returns the key or parameter generation callback
The function EVP_PKEY_CTX_get_keygen_info_APIName returns parameters associated with the generation operation
If EVP_PKEY_CTX_get_keygen_info_APIParam_2 is -1 the total number of parameters available is returned
Any non negative value returns the value of that parameter
EVP_PKEY_CTX_gen_keygen_info_APIName with a non-negative value for EVP_PKEY_CTX_get_keygen_info_APIParam_2 should only be called within the generation callback
If the callback returns 0, then the key genration operation is aborted and an error occurs
This might occur during a time consuming operation where a user clicks on a "cancel" button
The functions EVP_PKEY_CTX_set_app_data_APIName and EVP_PKEY_CTX_get_app_data_APIName set and retrieve an opaque pointer
This can be used to set some application defined value which can be retrieved in the callback: for example a handle which is used to update a "progress dialog"
After the call to EVP_PKEY_keygen_init_APIName or EVP_PKEY_paramgen_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation
The functions EVP_PKEY_keygen_APIName and EVP_PKEY_paramgen_APIName can be called more than once on the same context if several operations are performed using the same parameters
The meaning of the parameters passed to the callback will depend on the algorithm and the specifiic implementation of the algorithm
Some might not give any useful information at all during key or parameter generation
Others might not even call the callback
The operation performed by key or parameter generation depends on the algorithm used
In some cases (eg EC with a supplied named curve) the "generation" option merely sets the appropriate fields in an EVP_PKEY structure
In OpenSSL an EVP_PKEY structure containing a private key also contains the public key components and parameters (if any)
An OpenSSL private key is equivalent to what some libraries call a "key pair"
A private key can be used in functions which require the use of a public key or parameters
EVP_PKEY_keygen_init_APIName, EVP_PKEY_paramgen_init_APIName, EVP_PKEY_keygen_APIName and EVP_PKEY_paramgen_APIName return 1 for success and 0 or a negative value for failure
In particular a return value of -2 indicates the operation is not supported by the public key algorithm
The function SSL_CONF_cmd_argv_APIName processes at most two command line arguments from SSL_CONF_cmd_argv_APIParam_3 and SSL_CONF_cmd_argv_APIParam_2
The values of SSL_CONF_cmd_argv_APIParam_3 and SSL_CONF_cmd_argv_APIParam_2 are updated to reflect the number of command options processed
The SSL_CONF_cmd_argv_APIParam_2 argument can be set to NULL is The SSL_CONF_cmd_argv_APIParam_2 argument is not used
SSL_CONF_cmd_argv_APIName returns the number of command arguments processed: 0, 1, 2 or a negative error code
If -2 is returned ,then an argument for a command is missing
If -1 is returned ,the command is recognised but couldn't be processed due to an error: for example a syntax error in the argument
SSL_load_client_CA_file_APIName reads a file of PEM formatted certificates and extracts the X509_NAMES of the certificates found
While the name suggests the specific usage as support function for SSL_CTX_set_client_CA_list_APIName , it is not limited to CA certificates
The following return values can occur:
The operation failed, check out the error stack for the reason
Pointer to the subject names of the successfully read certificates
RSA_new_APIName allocates and initializes an RSA_new_APIParam_0 structure
It is equivalent to calling RSA_new_method(NULL)
RSA_free_APIName frees the RSA_free_APIParam_1 structure and its components
The key is erased before the memory is returned to the system
If the allocation fails, RSA_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName
Otherwise it returns a pointer to the newly allocated structure
RSA_free_APIName returns no value
BN_generate_prime_ex_APIName generates a pseudo-random prime number of bit length BN_generate_prime_ex_APIParam_2
If BN_generate_prime_ex_APIParam_1 is not NULL, BN_generate_prime_ex_APIParam_1 will be used to store the number
If BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 is not NULL, BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 is used as follows:
The prime may have to fulfill additional requirements for use in Diffie-Hellman key exchange:
If BN_generate_prime_ex_APIParam_3 is true, BN_generate_prime_ex_APIParam_3 will be a safe prime (ie a prime p so that (p-1)/2 is also prime)
The PRNG must be seeded prior to calling BN_generate_prime_ex_APIName
The prime number generation has a negligible error probability
BN_is_prime_ex_APIName and BN_is_prime_fasttest_ex_APIName test if the number BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 is prime
The following tests are performed until one of them shows that BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 is composite; if BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 passes all these tests, it is considered prime
When the source of the prime is not random or not trusted, the number of checks needs to be much higher to reach the same level of assurance: It should equal half of the targeted security level in bits (rounded up to the next integer if necessary)
For instance, to reach the 128 bit security level, BN_is_prime_ex_APIParam_2 BN_is_prime_fasttest_ex_APIParam_2 should be set to 64
BN_GENCB_call calls the callback function held in the BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 structure and passes the ints BN_GENCB_call_APIParam_2 BN_is_prime_fasttest_APIParam_1 and BN_GENCB_call_APIParam_3 as arguments
There are two types of BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 structure that are supported: "new" style and "old" style
New programs should prefer the "new" style, whilst the "old" style is provided for backwards compatibility purposes
BN_generate_prime_ex_APIName return 1 on success or 0 on error
BN_is_prime_ex_APIName, BN_is_prime_fasttest_ex_APIName, BN_is_prime_APIName and BN_is_prime_fasttest_APIName return 0 if the number is composite, 1 if the number is prime with an error probability of less than 0.25^BN_is_prime_ex_APIParam_2 BN_is_prime_fasttest_ex_APIParam_2, and -1 on error
BN_generate_prime_APIName returns the prime number on success, NULL otherwise
Callback functions should return 1 on success or 0 on error
The error codes can be obtained by ERR_get_error_APIName
The protocol-lists must be in wire-format, which is defined as a vector of non-empty, 8-bit length-prefixed, byte strings
The length-prefix byte is not included in the length
Each string is limited to 255 bytes
A byte-string length of 0 is invalid
A truncated byte-string is invalid
The length of the vector is not in the vector itself, but in a separate variable
The ALPN callback is executed after the servername callback; as that servername callback may update the SSL_CTX, and subsequently, the ALPN callback
If there is no ALPN proposed in the ClientHello, the ALPN callback is not invoked
SSL_CTX_set_alpn_protos_APIName and SSL_set_alpn_protos_APIName return 0 on success, and non-0 on failure
WARNING: these functions reverse the return value convention
SSL_select_next_proto_APIName returns one of the following:
A match was found and is returned in SSL_select_next_proto_APIParam_1, SSL_select_next_proto_APIParam_2
ALPN protocol selected
ALPN protocol not selected
SSL_state_string_APIName returns a 6 letter string indicating the current state of the SSL object SSL_state_string_APIParam_1
SSL_state_string_long_APIName returns a string indicating the current state of the SSL object SSL_state_string_long_APIParam_1
During its use, an SSL objects passes several states
The state is internally maintained
Querying the state information is not very informative before or when a connection has been established
the state information however can be of significant interest during the handshake
When using non-blocking sockets, the function call performing the handshake may return with SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition, so that SSL_state_string[_long]_APIName may be called
For both blocking or non-blocking sockets, the details state information can be used within the info_callback function set with the SSL_set_info_callback_APIName call
Detailed description of possible states to be included later
The EVP signature verification routines are a high level interface to digital signatures
EVP_VerifyInit_ex_APIName sets up verification context EVP_VerifyInit_ex_APIParam_1 to use digest EVP_VerifyInit_ex_APIParam_2 from ENGINE EVP_VerifyInit_ex_APIParam_3
EVP_VerifyInit_ex_APIParam_1 must be initialized by calling EVP_MD_CTX_init_APIName before calling this function
EVP_VerifyUpdate_APIName hashes EVP_VerifyUpdate_APIParam_3 bytes of data at EVP_VerifyUpdate_APIParam_2 into the verification context EVP_VerifyUpdate_APIParam_1
This function can be called several times on the same EVP_VerifyUpdate_APIParam_1 to include additional data
EVP_VerifyFinal_APIName verifies the data in EVP_VerifyFinal_APIParam_1 using the public key EVP_VerifyFinal_APIParam_4 and against the EVP_VerifyFinal_APIParam_3 bytes at EVP_VerifyFinal_APIParam_2
EVP_VerifyInit_APIName initializes verification context EVP_VerifyInit_APIParam_1 to use the default implementation of digest EVP_VerifyInit_APIParam_2
EVP_VerifyInit_ex_APIName and EVP_VerifyUpdate_APIName return 1 for success and 0 for failure
EVP_VerifyFinal_APIName returns 1 for a correct signature, 0 for failure and -1 if some other error occurred
The error codes can be obtained by ERR_get_error_APIName
The EVP_VerifyInit_APIParam_1 EVP_VerifyUpdate_APIParam_1 EVP_VerifyFinal_APIParam_1 EVP_VerifyInit_ex_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces
This is because the code then becomes transparent to the algorithm used and much more flexible
Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type
A list of algorithms and associated public key algorithms appears in EVP_DigestInit_APIName
The call to EVP_VerifyFinal_APIName internally finalizes a copy of the digest context
This means that calls to EVP_VerifyUpdate_APIName and EVP_VerifyFinal_APIName can be called later to digest and verify additional data
Since only a copy of the digest context is ever finalized, the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur
Older versions of this documentation wrongly stated that calls to EVP_VerifyUpdate_APIName could not be made after calling EVP_VerifyFinal_APIName
Since the public key is passed in the call to EVP_SignFinal_APIName, any error relating to the private key (for example an unsuitable key and digest combination) will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate_APIName
It is not possible to change the signing parameters using these function
The previous two bugs are fixed in the newer EVP_VerifyDigest*_APIName function
SSL_CTX_set_default_passwd_cb_APIName sets the default password callback called when loading/storing a PEM certificate with encryption
SSL_CTX_set_default_passwd_cb_userdata_APIName sets a pointer to pem_passwd_cb_APIParam_4 which will be provided to the password callback on invocation
The pem_passwd_cb_APIName, which must be provided by the application, hands back the password to be used during decryption
On invocation a pointer to pem_passwd_cb_APIParam_4 is provided
The pem_passwd_cb must write the password into the provided buffer pem_passwd_cb_APIParam_1 which is of size pem_passwd_cb_APIParam_2
The actual length of the password must be returned to the calling function
pem_passwd_cb_APIParam_3 indicates whether the callback is used for reading/decryption (rwflag=0) or writing/encryption (rwflag=1)
When loading or storing private keys, a password might be supplied to protect the private key
The way this password can be supplied may depend on the application
If only one private key is handled, it can be practical to have pem_passwd_cb_APIName handle the password dialog interactively
If several keys have to be handled, it can be practical to ask for the password once, then keep it in memory and use it several times
In the last case, the password could be stored into the pem_passwd_cb_APIParam_4 pem_passwd_cb_APIParam_4 storage and the pem_passwd_cb_APIName only returns the password already stored
When asking for the password interactively, pem_passwd_cb_APIName can use pem_passwd_cb_APIParam_3 to check, whether an item shall be encrypted (rwflag=1)
In this case the password dialog may ask for the same password twice for comparison in order to catch typos, that would make decryption impossible
Other items in PEM formatting (certificates) can also be encrypted, it is however not usual, as certificate information is considered public
SSL_CTX_set_default_passwd_cb_APIName and SSL_CTX_set_default_passwd_cb_userdata_APIName do not provide diagnostic information
DSA_generate_parameters_ex_APIName generates primes p and q and a generator g for use in the DSA and stores the result in DSA_generate_parameters_ex_APIParam_1
DSA_generate_parameters_ex_APIParam_2 DSA_generate_parameters_APIParam_1 is the length of the prime to be generated; the DSS allows a maximum of 1024 bits
DSA_generate_parameters_ex_APIName places the iteration count in *DSA_generate_parameters_APIParam_0 and a counter used for finding a generator in *DSA_generate_parameters_APIParam_0, unless these are NULL
A callback function may be used to provide feedback about the progress of the key generation
If DSA_generate_parameters_APIParam_0 is not NULL, DSA_generate_parameters_APIParam_0 will be called as shown below
For information on the BN_GENCB structure and the BN_GENCB_call function discussed below, refer to BN_generate_prime_APIName
DSA_generate_parameters_APIName (deprecated) works in much the same way as for DSA_generate_parameters_ex, except that no DSA_generate_parameters_ex_APIParam_1 parameter is passed and instead a newly allocated DSA_generate_parameters_APIParam_0 structure is returned
Additionally "old style" callbacks are used instead of the newer BN_GENCB based approach
Refer to BN_generate_prime_APIName for further information
DSA_generate_parameters_ex_APIName returns a 1 on success, or 0 otherwise
DSA_generate_parameters_APIName returns a pointer to the DSA structure, or NULL if the parameter generation fails
The error codes can be obtained by ERR_get_error_APIName
Seed lengths > 20 are not supported
These functions decode and encode PKCS#3 DH parameters using the DHparameter structure described in PKCS#3
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
SSL_CTX_add0_chain_cert_APIName and SSL_CTX_add1_chain_cert_APIName append the single certificate SSL_CTX_add0_chain_cert_APIParam_2 SSL_CTX_add1_chain_cert_APIParam_2 to the chain associated with the current certificate of SSL_CTX_add0_chain_cert_APIParam_1 SSL_CTX_add1_chain_cert_APIParam_1
SSL_CTX_get0_chain_certs_APIName retrieves the chain associated with the current certificate of SSL_CTX_build_cert_chain_APIParam_1 SSL_CTX_clear_chain_certs_APIParam_1 SSL_CTX_add0_chain_cert_APIParam_1 SSL_CTX_add1_chain_cert_APIParam_1 SSL_CTX_set_current_cert_APIParam_1 SSL_CTX_select_current_cert_APIParam_1
SSL_CTX_select_current_cert_APIName selects SSL_CTX_select_current_cert_APIParam_2 as the current end entity certificate, but only if SSL_CTX_select_current_cert_APIParam_2 has already been loaded into SSL_CTX_select_current_cert_APIParam_1 using a function such as SSL_CTX_use_certificate_APIName
SSL_set0_chain_APIName, SSL_set1_chain_APIName, SSL_add0_chain_cert_APIName, SSL_add1_chain_cert_APIName, SSL_get0_chain_certs_APIName, SSL_clear_chain_certs_APIName, SSL_build_cert_chain_APIName, SSL_select_current_cert_APIName and SSL_set_current_cert_APIName are similar except they apply to SSL structure SSL_add0_chain_cert_APIParam_1 SSL_add1_chain_cert_APIParam_1 SSL_clear_chain_certs_APIParam_1 SSL_build_cert_chain_APIParam_1 SSL_select_current_cert_APIParam_1 SSL_set_current_cert_APIParam_1
The chains associate with an SSL_CTX structure are copied to any SSL structures when SSL_new_APIName is called
SSL structures will not be affected by any chains subsequently changed in the parent SSL_CTX
One chain can be set for each key type supported by a server
So, for example, an RSA and a DSA certificate can (and often will) have different chains
The functions SSL_CTX_build_cert_chain_APIName and SSL_build_cert_chain_APIName can be used to check application configuration and to ensure any necessary subordinate CAs are sent in the correct order
Misconfigured applications sending incorrect certificate chains often cause problems with peers
Calling SSL_CTX_build_cert_chain_APIName or SSL_build_cert_chain_APIName is more efficient than the automatic chain building as it is only performed once
Automatic chain building is performed on each new session
If any certificates are added using these functions ,no certificates added using SSL_CTX_add_extra_chain_cert_APIName will be used
All other functions return 1 for success and 0 for failure
These functions load "serverinfo" TLS ServerHello Extensions into the SSL_CTX
A "serverinfo" extension is returned in response to an empty ClientHello Extension
SSL_CTX_use_serverinfo_APIName loads one or more serverinfo extensions from a byte array into SSL_CTX_use_serverinfo_APIParam_1
The extensions must be concatenated into a sequence of bytes
Each extension must consist of a 2-byte Extension Type, a 2-byte length, and then length bytes of extension_data
SSL_CTX_use_serverinfo_file_APIName loads one or more serverinfo extensions from SSL_CTX_use_serverinfo_file_APIParam_2 into SSL_CTX_use_serverinfo_file_APIParam_1
The extensions must be in PEM format
Each extension must consist of a 2-byte Extension Type, a 2-byte length, and then length bytes of extension_data
Each PEM extension name must begin with the phrase "BEGIN SERVERINFO FOR "
On success, the functions return 1
On failure, the functions return 0
Check out the error stack to find out the reason
SMIME_write_CMS_APIName adds the appropriate MIME headers to a CMS structure to produce an S/MIME message
SMIME_write_CMS_APIParam_1 is the BIO to write the data to
SMIME_write_CMS_APIParam_2 is the appropriate SMIME_write_CMS_APIParam_2 structure
If streaming is enabled then the content must be supplied in the SMIME_write_CMS_APIParam_3 argument
SMIME_write_CMS_APIParam_4 is an optional set of flags
The following flags can be passed in the SMIME_write_CMS_APIParam_4 parameter
If streaming is performed, the content is output in BER format using indefinite length constructed encoding except in the case of signed data with detached content where the content is absent and DER format is used
SMIME_write_CMS_APIName always base64 encodes CMS structures, there should be an option to disable this
SMIME_write_CMS_APIName returns 1 for success or 0 for failure
CMS_get0_type_APIName returns the content type of a CMS_ContentInfo structure as and ASN1_OBJECT pointer
An application can then decide how to process the CMS_ContentInfo structure based on this value
ASN1_OBJECT *CMS_get0_eContentType_APIName returns a pointer to the embedded content type
CMS_get0_content_APIName returns a pointer to the CMS_get0_content_APIParam_0 pointer containing the embedded content
The return value of CMS_get0_content_APIName is a pointer to the CMS_get0_content_APIParam_0 content pointer
That means that for example:
CMS_get0_type_APIName and CMS_get0_eContentType_APIName return and ASN1_OBJECT structure
CMS_set1_eContentType_APIName returns 1 for success or 0 if an error occurred
The error can be obtained from ERR_get_error_APIName
RAND_bytes_APIName puts RAND_bytes_APIParam_2 cryptographically strong pseudo-random bytes into RAND_bytes_APIParam_1
Always check the error return value of RAND_bytes_APIName and RAND_priv_bytes_APIName and do not take randomness for granted: an error occurs if the CSPRNG has not been seeded with enough randomness to ensure an unpredictable byte sequence
RAND_bytes_APIName and RAND_priv_bytes_APIName return 1 on success, -1 if not supported by the current RAND method, or 0 on other failure
The error code can be obtained by ERR_get_error_APIName
SSL_CTX_use_psk_identity_hint_APIName sets the given NULL-terminated PSK identity hint SSL_CTX_use_psk_identity_hint_APIParam_2 SSL_use_psk_identity_hint_APIParam_2 to SSL context object SSL_CTX_use_psk_identity_hint_APIParam_1
SSL_use_psk_identity_hint_APIName sets the given NULL-terminated PSK identity hint SSL_CTX_use_psk_identity_hint_APIParam_2 SSL_use_psk_identity_hint_APIParam_2 to SSL connection object SSL_use_psk_identity_hint_APIParam_1
If SSL_CTX_use_psk_identity_hint_APIParam_2 SSL_use_psk_identity_hint_APIParam_2 is NULL the current hint from SSL_CTX_use_psk_identity_hint_APIParam_1 or SSL_use_psk_identity_hint_APIParam_1 is deleted
In the case where PSK identity hint is NULL, the server does not send the ServerKeyExchange message to the client
SSL_CTX_use_psk_identity_hint_APIName and SSL_use_psk_identity_hint_APIName return 1 on success, 0 otherwise
Return values from the server callback are interpreted as follows:
PSK identity was not found
An "unknown_psk_identity" alert message will be sent and the connection setup fails
BIO_s_accept_APIName returns the accept BIO method
This is a wrapper round the platform's TCP/IP socket accept routines
Using accept BIOs, TCP/IP connections can be accepted and data transferred using only BIO routines
In this way any platform specific operations are hidden by the BIO abstraction
Read and write operations on an accept BIO will perform I/O on the underlying connection
If no connection is established and the port (see below) is set up properly ,then the BIO waits for an incoming connection
Accept BIOs support BIO_puts_APIName but not BIO_gets_APIName
If the close flag is set on an accept BIO ,then any active connection on that chain is shutdown and the socket closed when the BIO is freed
Calling BIO_reset_APIName on a accept BIO will close any active connection and reset the BIO into a state where it awaits another incoming connection
BIO_get_fd_APIName and BIO_set_fd_APIName can be called to retrieve or set the accept socket
BIO_set_accept_port_APIName uses the string BIO_set_accept_port_APIParam_2 to set the accept port
The port is represented as a string of the form "host:port", where "host" is the interface to use and "port" is the port
The host can be can be "*" which is interpreted as meaning any interface; "port" has the same syntax as the port specified in BIO_set_conn_port_APIName for connect BIOs, that is it can be a numerical port string or a string to lookup using getservbyname_APIName and a string table
BIO_new_accept_APIName combines BIO_new_APIName and BIO_set_accept_port_APIName into a single call: that is it creates a new accept BIO with port BIO_new_accept_APIParam_1
BIO_set_nbio_accept_APIName sets the accept socket to blocking mode (the default) if BIO_set_nbio_accept_APIParam_2 is 0 or non blocking mode if BIO_set_nbio_accept_APIParam_2 is 1
BIO_set_accept_bios_APIName can be used to set a chain of BIOs which will be duplicated and prepended to the chain when an incoming connection is received
This is useful if, for example, a buffering or SSL BIO is required for each connection
The chain of BIOs must not be freed after this call, they will be automatically freed when the accept BIO is freed
BIO_set_bind_mode_APIName and BIO_get_bind_mode_APIName set and retrieve the current bind mode
If BIO_BIND_NORMAL (the default) is set ,then another socket cannot be bound to the same port
If BIO_BIND_REUSEADDR is set then other sockets can bind to the same port
If BIO_BIND_REUSEADDR_IF_UNUSED is set ,then and attempt is first made to use BIO_BIN_NORMAL, if this fails and the port is not in use ,then a second attempt is made using BIO_BIND_REUSEADDR
BIO_do_accept_APIName serves two functions
When it is first called, after the accept BIO has been setup, it will attempt to create the accept socket and bind an address to it
Second and subsequent calls to BIO_do_accept_APIName will await an incoming connection, or request a retry in non blocking mode
When an accept BIO is at the end of a chain it will await an incoming connection before processing I/O calls
When an accept BIO is not at then end of a chain it passes I/O calls to the next BIO in the chain
When a connection is established a new socket BIO is created for the connection and appended to the chain
That is the chain is now accept->socket
This effectively means that attempting I/O on an initial accept socket will await an incoming connection then perform I/O on an incoming connection
If any additional BIOs have been set using BIO_set_accept_bios_APIName ,then any additional BIOs are placed between the socket and the accept BIO, that is the chain will be accept->otherbios->socket
If a server wishes to process multiple connections (as is normally the case) ,then the accept BIO must be made available for further incoming connections
This can be done by waiting for a connection and then calling:
If only a single connection will be processed ,it is possible to perform I/O using the accept BIO itself
This is often undesirable however because the accept BIO will still accept additional incoming connections
This can be resolved by using BIO_pop_APIName (see above) and freeing up the accept BIO after the initial connection
If the underlying accept socket is non-blocking and BIO_do_accept_APIName is called to await an incoming connection, it is possible for BIO_should_io_special_APIName with the reason BIO_RR_ACCEPT
If this happens then it is an indication that an accept attempt would block: the application should take appropriate action to wait until the underlying socket has accepted a connection and retry the call
BIO_set_accept_port_APIName, BIO_get_accept_port_APIName, BIO_set_nbio_accept_APIName, BIO_set_accept_bios_APIName, BIO_set_bind_mode_APIName, BIO_get_bind_mode_APIName and BIO_do_accept_APIName are macros
SSL_shutdown_APIName shuts down an active TLS/SSL connection
SSL_shutdown_APIName sends the "close notify" shutdown alert to the peer
SSL_shutdown_APIName tries to send the "close notify" shutdown alert to the peer
Whether the operation succeeds or not, the SSL_SENT_SHUTDOWN flag is set and a currently open session is considered closed and good and will be kept in the session cache for further reuse
Note that SSL_shutdown_APIName must not be called if a previous fatal error has occurred on a connection ie if SSL_get_error_APIName has returned SSL_ERROR_SYSCALL or SSL_ERROR_SSL
The shutdown procedure consists of 2 steps: the sending of the "close notify" shutdown alert and the reception of the peer's "close notify" shutdown alert
According to the TLS standard, it is acceptable for an application to only send its shutdown alert and then close the underlying connection without waiting for the peer's response (this way resources can be saved, as the process can already terminate or serve another connection)
When the underlying connection shall be used for more communications, the complete shutdown procedure (bidirectional "close notify" alerts) must be performed, so that the peers stay synchronized
SSL_shutdown_APIName supports both uni- and bidirectional shutdown by SSL_shutdown_APIName 2 step behaviour
It is therefore recommended, to check the return value of SSL_shutdown_APIName and call SSL_shutdown_APIName again, if the bidirectional shutdown is not yet complete (return value of the first call is 0)
As the shutdown is not specially handled in the SSLv2 protocol, SSL_shutdown_APIName will succeed on the first call
The behaviour of SSL_shutdown_APIName additionally depends on the underlying BIO
SSL_shutdown_APIName can be modified to only set the connection to "shutdown" state but not actually send the "close notify" alert messages, see SSL_CTX_set_quiet_shutdown_APIName
When "quiet shutdown" is enabled, SSL_shutdown_APIName will always succeed and return 1
The following return values can occur:
The shutdown is not yet finished
Call SSL_shutdown_APIName for a second time, if a bidirectional shutdown shall be performed
The output of SSL_get_error_APIName may be misleading, as an erroneous SSL_ERROR_SYSCALL may be flagged even though no error occurred
The shutdown was successfully completed
The "close notify" alert was sent and the peer's "close notify" alert was received
BN_mod_mul_reciprocal_APIName can be used to perform an efficient BN_mod_mul_APIName operation when the operation will be performed repeatedly with the same modulus
It computes BN_mod_mul_reciprocal_APIParam_1=(BN_mod_mul_reciprocal_APIParam_2*BN_mod_mul_reciprocal_APIParam_3)%BN_RECP_CTX_set_APIParam_2 using BN_RECP_CTX_set_APIParam_1 BN_RECP_CTX_init_APIParam_1 BN_RECP_CTX_free_APIParam_1 BN_div_recp_APIParam_4=1/BN_RECP_CTX_set_APIParam_2, which is set as described below
BN_RECP_CTX_set_APIParam_3 is a previously allocated BN_RECP_CTX_set_APIParam_3 used for temporary variables
BN_RECP_CTX_new_APIName allocates and initializes a BN_RECP_CTX_init_APIParam_1 structure
BN_RECP_CTX_init_APIName initializes an existing uninitialized BN_RECP_CTX_init_APIParam_1
BN_RECP_CTX_free_APIName frees the components of the BN_RECP_CTX_free_APIParam_1, and, if it was created by BN_RECP_CTX_new_APIName, also the structure itself
BN_RECP_CTX_set_APIName stores BN_RECP_CTX_set_APIParam_2 in BN_RECP_CTX_set_APIParam_1 and sets it up for computing 1/BN_RECP_CTX_set_APIParam_2 and shifting it left by BN_num_bits(BN_RECP_CTX_set_APIParam_2)+1 to make it an integer
The result and the number of bits it was shifted left will later be stored in BN_RECP_CTX_set_APIParam_1
BN_div_recp_APIName divides BN_div_recp_APIParam_3 by BN_RECP_CTX_set_APIParam_2 using BN_div_recp_APIParam_4
It places the quotient in BN_div_recp_APIParam_1 and the remainder in BN_div_recp_APIParam_2
The BN_RECP_CTX_set_APIParam_1 BN_div_recp_APIParam_4 BN_RECP_CTX_init_APIParam_1 BN_RECP_CTX_free_APIParam_1 structure is defined as follows:
It cannot be shared between threads
BN_RECP_CTX_new_APIName returns the newly allocated BN_RECP_CTX_new_APIParam_0, and NULL on error
BN_RECP_CTX_init_APIName and BN_RECP_CTX_free_APIName have no return values
For the other functions, 1 is returned for success, 0 on error
The error codes can be obtained by ERR_get_error_APIName
During the creation of a TLS or DTLS connection shared keying material is established between the two endpoints
The function SSL_export_keying_material_APIName enables an application to use some of this keying material for The function SSL_export_keying_material_APIName own purposes in accordance with RFC5705
An application may need to securely establish the context within which this keying material will be used
For example this may include identifiers for the application session, application algorithms or parameters, or the lifetime of the context
The context value is left to the application but must be the same on both sides of the communication
Note that this function is only defined for TLSv1.0 and above, and DTLSv1.0 and above
Attempting to use this function in SSLv3 will result in an error
SSL_export_keying_material_APIName returns 0 or -1 on failure or 1 on success
Only certificates carrying RSA, Diffie-Hellman or EC keys are supported by this function
EVP_des_ede3_cbc_APIName (triple DES) is the algorithm of choice for S/MIME use because most clients will support it
Many browsers implement a "sign and encrypt" option which is simply an S/MIME envelopedData containing an S/MIME signed message
This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to CMS_encrypt_APIName
CMS_encrypt_APIName returns either a CMS_ContentInfo structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
SSL_free_APIName decrements the reference count of SSL_free_APIParam_1, and removes the SSL structure pointed to by SSL_free_APIParam_1 and frees up the allocated memory if the reference count has reached 0
The ssl session has reference counts from two users: the SSL object, for which the reference count is removed by SSL_free_APIName and the internal session cache
If the session is considered bad, because SSL_shutdown_APIName was not called for the connection and SSL_set_shutdown_APIName was not used to set the SSL_SENT_SHUTDOWN state, the session will also be removed from the session cache as required by RFC2246
SSL_free_APIName does not provide diagnostic information
SSL_new_APIName , SSL_clear_APIName , SSL_shutdown_APIName , SSL_set_shutdown_APIName , ssl_APIName
BIO_new_CMS_APIName returns a streaming filter BIO chain based on BIO_new_CMS_APIParam_2
The output of the filter is written to BIO_new_CMS_APIParam_1
Any data written to the chain is automatically translated to a BER format CMS structure of the appropriate type
The chain returned by this function behaves like a standard filter BIO
It supports non blocking I/O
Content is processed and streamed on the fly and not all held in memory at once: so it is possible to encode very large structures
After all content has been written through the chain BIO_flush_APIName must be called to finalise the structure
If an application wishes to write additional data to BIO_new_CMS_APIParam_1 ,BIOs should be removed from the chain using BIO_pop_APIName and freed with BIO_free_APIName until BIO_new_CMS_APIParam_1 is reached
If no additional data needs to be written ,BIO_free_all_APIName can be called to free up the whole chain
Any content written through the filter is used verbatim: no canonical translation is performed
It is possible to chain multiple BIOs to, for example, create a triple wrapped signed, enveloped, signed structure
In this case it is the applications responsibility to set the inner content type of any outer CMS_ContentInfo structures
Large numbers of small writes through the chain should be avoided as this will produce an output consisting of lots of OCTET STRING structures
Prepending a BIO_f_buffer_APIName buffering BIO will prevent this
There is currently no corresponding inverse BIO: ie one which can decode a CMS structure on the fly
BIO_new_CMS_APIName returns a BIO chain when successful or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
These functions allow an ASN1_STRING_to_UTF8_APIParam_2 ASN1_STRING_set_APIParam_1 ASN1_STRING_dup_APIParam_1 ASN1_STRING_data_APIParam_1 ASN1_STRING_length_APIParam_1 ASN1_STRING_type_APIParam_1 ASN1_STRING_cmp_APIParam_1 structure to be manipulated
ASN1_STRING_length_APIName returns the length of the content of ASN1_STRING_length_APIParam_1
ASN1_STRING_dup_APIName returns a copy of the structure ASN1_STRING_dup_APIParam_1
ASN1_STRING_cmp_APIName compares ASN1_STRING_cmp_APIParam_1 and ASN1_STRING_cmp_APIParam_2 returning 0 if the two are identical
The string types and content are compared
ASN1_STRING_set_APIName sets the data of string ASN1_STRING_set_APIParam_1 to the buffer ASN1_STRING_set_APIParam_2 or length ASN1_STRING_set_APIParam_3
The supplied data is copied
If ASN1_STRING_set_APIParam_3 is -1 then the length is determined by strlen(data)
ASN1_STRING_to_UTF8_APIName converts the string ASN1_STRING_to_UTF8_APIParam_2 to UTF8 format, the converted data is allocated in a buffer in ASN1_STRING_to_UTF8_APIParam_1
The length of ASN1_STRING_to_UTF8_APIParam_1 is returned or a negative error code
The buffer ASN1_STRING_to_UTF8_APIParam_1 should be free using OPENSSL_free_APIName
In general it cannot be assumed that the data returned by ASN1_STRING_data_APIName is null terminated or does not contain embedded nulls
The actual format of the data will depend on the actual string type itself: for example for an IA5String the data will be ASCII, for a BMPString two bytes per character in big endian format, and for an UTF8String it will be in UTF8 format
Similar care should be take to ensure the data is in the correct format when calling ASN1_STRING_set_APIName
BIO_read_APIName attempts to read BIO_read_APIParam_3 bytes from BIO BIO_read_APIParam_1 and places the data in BIO_read_APIParam_2
BIO_gets_APIName performs the BIOs "gets" operation and places the data in BIO_gets_APIParam_2 BIO_gets_APIParam_2 BIO_gets_APIParam_2
Usually this operation will attempt to read a line of data from the BIO of maximum length BIO_write_APIParam_3 BIO_read_APIParam_3
There are exceptions to this however, for example BIO_gets_APIName on a digest BIO will calculate and return the digest and other BIOs may not support BIO_gets_APIName at all
BIO_write_APIName attempts to write BIO_write_APIParam_3 bytes from BIO_write_APIParam_2 to BIO BIO_write_APIParam_1
BIO_puts_APIName attempts to write a null terminated string BIO_puts_APIParam_2 to BIO BIO_puts_APIParam_1
All these functions return either the amount of data successfully read or written (if the return value is positive) or that no data was successfully read or written if the result is 0 or -1
If the return value is -2 then the operation is not implemented in the specific BIO type
A 0 or -1 return is not necessarily an indication of an error
In particular when the source/sink is non-blocking or of a certain type the source/sink may merely be an indication that no data is currently available and that the application should retry the operation later
See BIO_should_retry_APIName for details of how to determine the cause of a retry and other I/O issues
If the BIO_gets_APIName function is not supported by a BIO ,then it possible to work around this by adding a buffering BIO BIO_f_buffer_APIName to the chain
The PKCS#8 functions encode and decode private keys in PKCS#8 format using both PKCS#5 v1.5 and PKCS#5 v2.0 password based encryption algorithms
Before using these functions OpenSSL_add_all_algorithms_APIName should be called to initialize the internal algorithm lookup tables otherwise errors about unknown algorithms will occur if an attempt is made to decrypt a private key
These functions are currently the only way to store encrypted private keys using DER format
Currently all the functions use BIOs or FILE pointers, there are no functions which work directly on memory: this can be readily worked around by converting the buffers to memory BIOs, see BIO_s_mem_APIName for details
This library contains a fast implementation of the DES encryption algorithm
DES_random_key_APIName generates a random key
The PRNG must be seeded prior to using this function (see rand_APIName )
If the PRNG could not generate a secure key, 0 is returned
DES_set_key_checked_APIName will check that the key passed is of odd parity and is not a weak or semi-weak key
If the parity is wrong, then -1 is returned
If the key is a weak key, then -2 is returned
If an error is returned, the key schedule is not generated
DES_set_odd_parity_APIName sets the parity of the passed DES_set_odd_parity_APIParam_1 to odd
DES_is_weak_key_APIName returns 1 if the passed key is a weak key, 0 if it is ok
The following routines mostly operate on an input and output stream of DES_string_to_key_APIParam_2 DES_set_odd_parity_APIParam_1 DES_set_key_APIParam_1 DES_set_key_unchecked_APIParam_1 DES_key_sched_APIParam_1 DES_quad_cksum_APIParam_2 DES_string_to_2keys_APIParam_2 DES_cbc_cksum_APIParam_2 DES_ecb2_encrypt_APIParam_1 DES_ecb3_encrypt_APIParam_1 DES_is_weak_key_APIParam_1 DES_random_key_APIParam_1 DES_ecb_encrypt_APIParam_1 DES_set_key_checked_APIParam_1s
DES_pcbc_encrypt_APIName encrypt/decrypts using the propagating cipher block chaining mode used by Kerberos v4
Kerberos v4 parameters are the same as DES_ncbc_encrypt_APIName
DES_cfb64_encrypt_APIName implements CFB mode of DES with 64bit feedback
Why is this useful you ask?
Because this routine will allow you to encrypt an arbitrary number of bytes, no 8 byte padding
Each call to this routine will encrypt the input bytes to output and then update ivec and num
num contains 'how far' we are though ivec
If this does not make much sense, read more about cfb mode of DES :-)
DES_ede3_cfb64_encrypt_APIName and DES_ede2_cfb64_encrypt_APIName is the same as DES_cfb64_encrypt_APIName except that Triple-DES is used
DES_ofb64_encrypt_APIName is the same as DES_cfb64_encrypt_APIName using Output Feed Back mode
DES_ede3_ofb64_encrypt_APIName and DES_ede2_ofb64_encrypt_APIName is the same as DES_ofb64_encrypt_APIName, using Triple-DES
The following functions are included in the DES library for compatibility with the MIT Kerberos library
DES_cbc_cksum_APIName produces an 8 byte checksum based on the input stream (via CBC encryption)
The last 4 bytes of the checksum are returned and the complete 8 bytes are placed in DES_cbc_cksum_APIParam_2
This function is used by Kerberos v4
Other applications should use EVP_DigestInit_APIName etc instead
The following are DES-based transformations:
DES_fcrypt_APIName is a fast version of the Unix crypt_APIName function
This version takes only a small amount of space relative to other fast crypt_APIName implementations
This is different to the normal crypt in that the third parameter is the buffer that the return value is written into
It needs to be at least 14 bytes long
This function is thread safe, unlike the normal crypt
Single-key DES is insecure due to Single-key DES short key size
ECB mode is not suitable for most applications; see des_modes_APIName
The evp_APIName library provides higher-level encryption functions
DES_3cbc_encrypt_APIName is flawed and must not be used in applications
DES_string_to_key_APIName is available for backward compatibility with the MIT library
New applications should use a cryptographic hash function
The same applies for DES_string_to_2key_APIName
These functions decode and encode a PKCS#10 certificate request
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page
EC_GROUP_copy copies the curve EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 into EC_GROUP_copy_APIParam_1
Both EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 and EC_GROUP_copy_APIParam_1 must use the same EC_METHOD
EC_GROUP_dup creates a new EC_GROUP object and copies the content from EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 to the newly created EC_GROUP object
EC_GROUP_method_of obtains the EC_METHOD of EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_curve_name_APIParam_1 EC_GROUP_get0_generator_APIParam_1 EC_GROUP_get_curve_name_APIParam_1 EC_GROUP_set_point_conversion_form_APIParam_1 EC_GROUP_set_asn1_flag_APIParam_1 EC_GROUP_set_generator_APIParam_1 EC_GROUP_get_degree_APIParam_1
EC_GROUP_set_generator sets curve paramaters that must be agreed by all participants using the curve
These paramaters include the EC_GROUP_set_generator_APIParam_2, the EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 and the EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4
The EC_GROUP_set_generator_APIParam_2 is a well defined point on the curve chosen for cryptographic operations
Integers used for point multiplications will be between 0 and n-1 where n is the EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3
The EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 multipied by the EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4 gives the number of points on the curve
EC_GROUP_get0_generator returns the generator for the identified EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_curve_name_APIParam_1 EC_GROUP_get0_generator_APIParam_1 EC_GROUP_get_curve_name_APIParam_1 EC_GROUP_set_point_conversion_form_APIParam_1 EC_GROUP_set_asn1_flag_APIParam_1 EC_GROUP_set_generator_APIParam_1 EC_GROUP_get_degree_APIParam_1
The functions EC_GROUP_get_order and EC_GROUP_get_cofactor populate the provided EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 and EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4 parameters with the respective order and cofactors for the EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_curve_name_APIParam_1 EC_GROUP_get0_generator_APIParam_1 EC_GROUP_get_curve_name_APIParam_1 EC_GROUP_set_point_conversion_form_APIParam_1 EC_GROUP_set_asn1_flag_APIParam_1 EC_GROUP_set_generator_APIParam_1 EC_GROUP_get_degree_APIParam_1
The functions EC_GROUP_set_curve_name and EC_GROUP_get_curve_name, set and get the NID for the curve respectively (see EC_GROUP_new_APIName )
If a curve does not have a NID associated with it, then EC_GROUP_get_curve_name will return 0
The asn1_flag value on a curve is used to determine whether there is a specific ASN1 OID to describe the curve or not
If the asn1_flag is 1 ,then this is a named curve with an associated ASN1 OID
If not ,then asn1_flag is 0
The functions EC_GROUP_get_asn1_flag and EC_GROUP_set_asn1_flag get and set the status of the asn1_flag for the curve
If set ,then the curve_name must also be set
The point_coversion_form for a curve controls how EC_POINT data is encoded as ASN1 as defined in X9.62 (ECDSA)
point_conversion_form_t is an enum defined as follows:
For POINT_CONVERSION_UNCOMPRESSED the point is encoded as an octet signifying the UNCOMPRESSED form has been used followed by the octets for x, followed by the octets for y
For any given x co-ordinate for a point on a curve it is possible to derive two possible y values
For POINT_CONVERSION_COMPRESSED the point is encoded as an octet signifying that the COMPRESSED form has been used AND which of the two possible solutions for y has been used, followed by the octets for x
For POINT_CONVERSION_HYBRID the point is encoded as an octet signifying the HYBRID form has been used AND which of the two possible solutions for y has been used, followed by the octets for x, followed by the octets for y
The functions EC_GROUP_set_point_conversion_form and EC_GROUP_get_point_conversion_form set and get the point_conversion_form for the curve respectively
ANSI X9.62 (ECDSA standard) defines a method of generating the curve parameter b from a random number
This provides advantages in that a parameter obtained in this way is highly unlikely to be susceptible to special purpose attacks, or have any trapdoors in it
If the seed is present for a curve, then the b parameter was generated in a verifiable fashion using that seed
The OpenSSL EC library does not use this seed value but does enable you to inspect it using EC_GROUP_get0_seed
This returns a pointer to a memory block containing the seed that was used
The length of the memory block can be obtained using EC_GROUP_get_seed_len
A number of the builtin curves within the library provide seed values that can be obtained
It is also possible to set a custom seed using EC_GROUP_set_seed and passing a pointer to a memory block, along with the length of the seed
Again, the EC library will not use this seed value, although it will be preserved in any ASN1 based communications
EC_GROUP_get_degree gets the degree of the field
For Fp fields this will be the number of bits in p. For F2^m fields this will be the value m
The function EC_GROUP_check_discriminant calculates the discriminant for the curve and verifies that it is valid
For a curve defined over Fp the discriminant is given by the formula 4*a^3 + 27*b^2 whilst for F2^m curves the discriminant is simply b
In either case for the curve to be valid the discriminant must be non zero
The function EC_GROUP_check performs a number of checks on a curve to verify that it is valid
Checks performed include verifying that the discriminant is non zero; that a generator has been defined; that the generator is on the curve and has the correct order
EC_GROUP_cmp compares EC_GROUP_cmp_APIParam_1 and EC_GROUP_cmp_APIParam_2 to determine whether they represent the same curve or not
The functions EC_GROUP_get_basis_type, EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis should only be called for curves defined over an F2^m field
Addition and multiplication operations within an F2^m field are performed using an irreducible polynomial function f(x)
This function is either a trinomial of the form:
f(x) = x^m + x^k + 1 with m > k >= 1
or a pentanomial of the form:
f(x) = x^m + x^k3 + x^k2 + x^k1 + 1 with m > k3 > k2 > k1 >= 1
The following functions return 1 on success or 0 on error: EC_GROUP_copy, EC_GROUP_set_generator, EC_GROUP_check, EC_GROUP_check_discriminant, EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis
EC_GROUP_dup returns a pointer to the duplicated curve, or NULL on error
EC_GROUP_method_of returns the EC_METHOD implementation in use for the given curve or NULL on error
EC_GROUP_get0_generator returns the generator for the given curve or NULL on error
EC_GROUP_get_order, EC_GROUP_get_cofactor, EC_GROUP_get_curve_name, EC_GROUP_get_asn1_flag, EC_GROUP_get_point_conversion_form and EC_GROUP_get_degree return the order, cofactor, curve name (NID), ASN1 flag, point_conversion_form and degree for the specified curve respectively
If there is no curve name associated with a curve ,then EC_GROUP_get_curve_name will return 0
EC_GROUP_get0_seed returns a pointer to the seed that was used to generate the parameter b, or NULL if the seed is not specified
EC_GROUP_get_seed_len returns the length of the seed or 0 if the seed is not specified
EC_GROUP_set_seed returns the length of the seed that has been set
If the supplied seed is NULL, or the supplied seed length is 0, the return value will be 1
On error 0 is returned
EC_GROUP_cmp returns 0 if the curves are equal, 1 if they are not equal, or -1 on error
EC_GROUP_get_basis_type returns the values NID_X9_62_tpBasis or NID_X9_62_ppBasis (as defined in <openssl/obj_mac.h>) for a trinomial or pentanomial respectively
Alternatively in the event of an error a 0 is returned
These functions are used to obtain temporary BN_CTX_get_APIParam_0 variables from a BN_CTX_end_APIParam_1 BN_CTX_get_APIParam_1 BN_CTX_start_APIParam_1 (which can been created by using BN_CTX_new_APIName ) in order to save the overhead of repeatedly creating and freeing BN_CTX_get_APIParam_0s in functions that are called from inside a loop
A function must call BN_CTX_start_APIName first
Then, BN_CTX_get_APIName may be called repeatedly to obtain temporary BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0s
All BN_CTX_get_APIName calls must be made before calling any other functions that use the BN_CTX_start_APIParam_1 BN_CTX_get_APIParam_1 BN_CTX_get_APIParam_1 as an argument
Finally, BN_CTX_end_APIName must be called before returning from the function
When BN_CTX_end_APIName is called, the BN_CTX_get_APIParam_0 pointers obtained from BN_CTX_get_APIName become invalid
BN_CTX_start_APIName and BN_CTX_end_APIName return no values
BN_CTX_get_APIName returns a pointer to the BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0, or NULL on error
Once BN_CTX_get_APIName has failed, the subsequent calls will return NULL as well, so it is sufficient to check the return value of the last BN_CTX_get_APIName call
In case of an error, an error code is set, which can be obtained by ERR_get_error_APIName
Initially, the default RAND_METHOD is the OpenSSL internal implementation, as returned by RAND_SSLeay_APIName
RAND_get_default_method_APIName returns a pointer to the current RAND_METHOD
However, the meaningfulness of this result is dependent on whether the ENGINE API is being used, so this function is no longer recommended
RAND_set_rand_method_APIName returns no value
RAND_get_rand_method_APIName and RAND_SSLeay_APIName return pointers to the respective methods
In some cases the standard techniques for looking up and validating certificates are not appropriate: for example an application may wish to lookup certificates in a database or perform customised verification
This can be achieved by setting and verifying the signers certificates manually using the signed data utility functions
Chain verification should arguably be performed using the signing time rather than the current time
However since the signing time is supplied by the signer it cannot be trusted without additional evidence (such as a trusted timestamp)
CMS_verify_APIName returns 1 for a successful verification and zero if an error occurred
CMS_get0_signers_APIName returns all signers or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
The lack of single pass processing means that the signed content must all be held in memory if it is not detached
BIO_f_md_APIName returns the message digest BIO method
This is a filter BIO that digests any data passed through it, it is a BIO wrapper for the digest routines EVP_DigestInit_APIName, EVP_DigestUpdate_APIName and EVP_DigestFinal_APIName
Any data written or read through a digest BIO using BIO_read_APIName and BIO_write_APIName is digested
BIO_reset_APIName reinitialises a digest BIO
BIO_set_md_APIName sets the message digest of BIO BIO_set_md_APIParam_1 to BIO_set_md_APIParam_2: this must be called to initialize a digest BIO before any data is passed through it
It is a BIO_ctrl_APIName macro
BIO_get_md_APIName places the a pointer to the digest BIOs digest method in BIO_get_md_APIParam_2, it is a BIO_ctrl_APIName macro
BIO_get_md_ctx_APIName returns the digest BIOs context into BIO_get_md_ctx_APIParam_2
The context returned by BIO_get_md_ctx_APIName can be used in calls to EVP_DigestFinal_APIName and also the signature routines EVP_SignFinal_APIName and EVP_VerifyFinal_APIName
The context returned by BIO_get_md_ctx_APIName is an internal context structure
Changes made to this context will affect the digest BIO itself and the context pointer will become invalid when the digest BIO is freed
After the digest has been retrieved from a digest BIO it must be reinitialized by calling BIO_reset_APIName, or BIO_set_md_APIName before any more data is passed through it
If an application needs to call BIO_gets_APIName or BIO_puts_APIName through a chain containing digest BIOs ,then this can be done by prepending a buffering BIO
Before OpenSSL 1.0.0 the call to BIO_get_md_ctx_APIName would only work if the BIO had been initialized for example by calling BIO_set_md_APIName )
In OpenSSL 1.0.0 and later the context is always returned and the BIO is state is set to initialized
This allows applications to initialize the context externally if the standard calls such as BIO_set_md_APIName are not sufficiently flexible
BIO_f_md_APIName returns the digest BIO method
BIO_set_md_APIName, BIO_get_md_APIName and BIO_md_ctx_APIName return 1 for success and 0 for failure
The lack of support for BIO_puts_APIName and the non standard behaviour of BIO_gets_APIName could be regarded as anomalous
It could be argued that BIO_gets_APIName and BIO_puts_APIName should be passed to the next BIO in the chain and digest the data passed through and that digests should be retrieved using a separate BIO_ctrl_APIName call
This library implements type-checked dynamic hash tables
The hash table entries can be arbitrary structures
Usually The hash table entries consist of key and value fields
lh_<type>_insert_APIName inserts the structure pointed to by lh_retrieve_APIParam_2 into lh_retrieve_APIParam_1
If there already is an entry with the same key, the old value is replaced
Note that lh_<type>_insert_APIName stores pointers, the data are not copied
lh_<type>_delete_APIName deletes an entry from lh_retrieve_APIParam_1
lh_<type>_retrieve_APIName looks up an entry in lh_retrieve_APIParam_1
Normally, lh_retrieve_APIParam_2 is a structure with the key field(s) set; the function will return a pointer to a fully populated structure
When doing this, be careful if you delete entries from the hash table in your callbacks: the table may decrease in size, moving the item that you are currently on down lower in the hash table - this could cause some entries to be skipped during the iteration
The second best solution to this problem is to set hash->down_load=0 before you start (which will stop the hash table ever decreasing in size)
The best solution is probably to avoid deleting items from the hash table inside a "doall" callback!
lh_<type>_error_APIName can be used to determine if an error occurred in the last operation
lh_<type>_error_APIName is a macro
lh_<type>_new_APIName returns NULL on error, otherwise a pointer to the new lh_retrieve_APIParam_1 structure
When a hash table entry is replaced, lh_<type>_insert_APIName returns the value being replaced
NULL is returned on normal operation and on error
lh_<type>_delete_APIName returns the entry being deleted
NULL is returned if there is no such value in the hash table
lh_<type>_retrieve_APIName returns the hash table entry if lh_<type>_retrieve_APIName has been found, NULL otherwise
lh_<type>_error_APIName returns 1 if an error occurred in the last operation, 0 otherwise
lh_<type>_free_APIName, lh_<type>_doall_APIName and lh_<type>_doall_arg_APIName return no values
The various LHASH macros and callback types exist to make it possible to write type-checked code without resorting to function-prototype casting - an evil that makes application code much harder to audit/verify and also opens the window of opportunity for stack corruption and other hard-to-find bugs
It also, apparently, violates ANSI-C
The LHASH code regards table entries as constant data
As such, it internally represents lh_insert_APIName'd items with a "const void *" pointer type
This is why callbacks such as those used by lh_doall_APIName and lh_doall_arg_APIName declare their prototypes with "const", even for the parameters that pass back the table items' data pointers - for consistency, user-provided data is "const" at all times as far as the LHASH code is concerned
However, as callers are themselves providing these pointers, they can choose whether they too should be treating all such parameters as constant
As an example, a hash table may be maintained by code that, for reasons of encapsulation, has only "const" access to the data being indexed in the hash table (ie it is returned as "const" from elsewhere in their code) - in this case the LHASH prototypes are appropriate as-is
Conversely, if the caller is responsible for the life-time of the data in question, then they may well wish to make modifications to table item passed back in the lh_doall_APIName or lh_doall_arg_APIName callbacks (see the "STUFF_cleanup" example above)
If so, the caller can either cast the "const" away (if they're providing the raw callbacks themselves) or use the macros to declare/implement the wrapper functions without "const" types
Callers that only have "const" access to data they're indexing in a table, yet declare callbacks without constant types (or cast the "const" away themselves), are therefore creating their own risks/bugs without being encouraged to do so by the API
On a related note, those auditing code should pay special attention to any instances of DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types without any "const" qualifiers
lh_<type>_insert_APIName returns NULL both for success and error
SSL_CTX_set_tmp_rsa_APIName sets the temporary/ephemeral RSA key to be used to be SSL_CTX_set_tmp_rsa_APIParam_2
The key is inherited by all SSL objects newly created from SSL_CTX_set_tmp_rsa_APIParam_1 with <SSL_new_APIName|SSL_new_APIName>
Already created SSL objects are not affected
SSL_CTX_need_tmp_rsa_APIName returns 1, if a temporary/ephemeral RSA key is needed for RSA-based strength-limited 'exportable' ciphersuites because a RSA key with a keysize larger than 512 bits is installed
SSL_set_tmp_rsa_callback_APIName sets the callback only for SSL_set_tmp_rsa_APIParam_1 SSL_need_tmp_rsa_APIParam_1
SSL_set_tmp_rsa_APIName sets the key only for SSL_set_tmp_rsa_APIParam_1
SSL_need_tmp_rsa_APIName returns 1, if a temporary/ephemeral RSA key is needed, for RSA-based strength-limited 'exportable' ciphersuites because a RSA key with a keysize larger than 512 bits is installed
These functions apply to SSL/TLS servers only
When using a cipher with RSA authentication, an ephemeral RSA key exchange can take place
In this case the session data are negotiated using the ephemeral/temporary RSA key and the RSA key supplied and certified by the certificate chain is only used for signing
Under previous export restrictions, ciphers with RSA keys shorter (512 bits) than the usual key length of 1024 bits were created
To use these ciphers with RSA keys of usual length, an ephemeral key exchange must be performed, as the normal (certified) key cannot be directly used
Using ephemeral RSA key exchange yields forward secrecy, as the connection can only be decrypted, when the RSA key is known
By generating a temporary RSA key inside the server application that is lost when the application is left, it becomes impossible for an attacker to decrypt past sessions, even if he gets hold of the normal (certified) RSA key, as this key was used for signing only
The downside is that creating a RSA key is computationally expensive
Additionally, the use of ephemeral RSA key exchange is only allowed in the TLS standard, when the RSA key can be used for signing only, that is for export ciphers
Using ephemeral RSA key exchange for other purposes violates the standard and can break interoperability with clients
It is therefore strongly recommended to not use ephemeral RSA key exchange and use DHE (Ephemeral Diffie-Hellman) key exchange instead in order to achieve forward secrecy (see SSL_CTX_set_tmp_dh_callback_APIName )
An application may either directly specify the key or can supply the key via a callback function
The callback approach has the advantage, that the callback may generate the key only in case it is actually needed
As the generation of a RSA key is however costly, it will lead to a significant delay in the handshake procedure
Another advantage of the callback function is that it can supply keys of different size while the explicit setting of the key is only useful for key size of 512 bits to satisfy the export restricted ciphers and does give away key length if a longer key would be allowed
SSL_CTX_set_tmp_rsa_callback_APIName and SSL_set_tmp_rsa_callback_APIName do not return diagnostic output
SSL_CTX_set_tmp_rsa_APIName and SSL_set_tmp_rsa_APIName do return 1 on success and 0 on failure
Check the error queue to find out the reason of failure
SSL_CTX_need_tmp_rsa_APIName and SSL_need_tmp_rsa_APIName return 1 if a temporary RSA key is needed and 0 otherwise
CMS_verify_receipt_APIName returns 1 for a successful verification and zero if an error occurred
The error can be obtained from ERR_get_error_APIName
A human-readable hexadecimal output of the components of the RSA key, DSA parameters or key or DH parameters is printed to DHparams_print_APIParam_1 DSA_print_APIParam_1 RSA_print_APIParam_1 DSAparams_print_APIParam_1 or RSA_print_fp_APIParam_1 DSAparams_print_fp_APIParam_1 DHparams_print_fp_APIParam_1 DSA_print_fp_APIParam_1
The output lines are indented by RSA_print_fp_APIParam_3 DSA_print_APIParam_3 RSA_print_APIParam_3 DSA_print_fp_APIParam_3 spaces
These functions return 1 on success, 0 on error
If SSL_CTX_load_verify_locations_APIParam_2 is not NULL, it points to a file of CA certificates in PEM format
The file can contain several CA certificates identified by
Before, between, and after the certificates text is allowed which can be used eg for descriptions of the certificates
The SSL_CTX_load_verify_locations_APIParam_2 is processed on execution of the SSL_CTX_load_verify_locations_APIName function
If several CA certificates matching the name, key identifier, and serial number condition are available, only the first one will be examined
This may lead to unexpected results if the same CA certificate is available with different expiration dates
If a "certificate expired" verification error occurs, no other certificate will be searched
Make sure to not have expired certificates mixed with valid ones
The following return values can occur:
The operation succeeded
The EVP signature routines are a high level interface to digital signatures
EVP_SignInit_ex_APIName sets up signing context EVP_SignInit_ex_APIParam_1 to use digest EVP_SignInit_ex_APIParam_2 from ENGINE EVP_SignInit_ex_APIParam_3
EVP_SignInit_ex_APIParam_1 must be initialized with EVP_MD_CTX_init_APIName before calling this function
EVP_SignUpdate_APIName hashes EVP_SignUpdate_APIParam_3 bytes of data at EVP_SignUpdate_APIParam_2 into the signature context EVP_SignUpdate_APIParam_1
This function can be called several times on the same EVP_SignUpdate_APIParam_1 to include additional data
EVP_SignFinal_APIName signs the data in EVP_SignFinal_APIParam_1 using the private key EVP_SignFinal_APIParam_4 and places the signature in EVP_SignFinal_APIParam_2
EVP_SignFinal_APIParam_2 must be at least EVP_PKEY_size(pkey) bytes in size
EVP_SignFinal_APIParam_3 is an OUT paramter, and not used as an IN parameter
The number of bytes of data written (ie the length of the signature) will be written to the integer at EVP_SignFinal_APIParam_3, at most EVP_PKEY_size(pkey) bytes will be written
EVP_SignInit_APIName initializes a signing context EVP_SignInit_APIParam_1 to use the default implementation of digest EVP_SignInit_APIParam_2
EVP_PKEY_size_APIName returns the maximum size of a signature in bytes
The actual signature returned by EVP_SignFinal_APIName may be smaller
EVP_SignInit_ex_APIName, EVP_SignUpdate_APIName and EVP_SignFinal_APIName return 1 for success and 0 for failure
EVP_PKEY_size_APIName returns the maximum size of a signature in bytes
The error codes can be obtained by ERR_get_error_APIName
The EVP_SignInit_ex_APIParam_1 EVP_SignFinal_APIParam_1 EVP_PKEY_size_APIParam_1 EVP_SignInit_APIParam_1 EVP_SignUpdate_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces
This is because the code then becomes transparent to the algorithm used and much more flexible
Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type
A list of algorithms and associated public key algorithms appears in EVP_DigestInit_APIName
When signing with DSA private keys the random number generator must be seeded or the operation will fail
The random number generator does not need to be seeded for RSA signatures
The call to EVP_SignFinal_APIName internally finalizes a copy of the digest context
This means that calls to EVP_SignUpdate_APIName and EVP_SignFinal_APIName can be called later to digest and sign additional data
Since only a copy of the digest context is ever finalized, the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur
Older versions of this documentation wrongly stated that calls to EVP_SignUpdate_APIName could not be made after calling EVP_SignFinal_APIName
Since the private key is passed in the call to EVP_SignFinal_APIName, any error relating to the private key (for example an unsuitable key and digest combination) will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate_APIName
It is not possible to change the signing parameters using these function
The previous two bugs are fixed in the newer EVP_SignDigest*_APIName function
MD2, MD4, and MD5 are cryptographic hash functions with a 128 bit output
MD2_APIName, MD4_APIName, and MD5_APIName compute the MD2, MD4, and MD5 message digest of the MD2_APIParam_2 MD4_APIParam_2 MD5_APIParam_2 bytes at MD2_APIParam_1 MD4_APIParam_1 MD5_APIParam_1 and place it in MD2_Final_APIParam_1 MD4_Final_APIParam_1 MD5_Final_APIParam_1 (which must have space for MD2_DIGEST_LENGTH == MD4_DIGEST_LENGTH == MD5_DIGEST_LENGTH == 16 bytes of output)
If MD2_Final_APIParam_1 MD4_Final_APIParam_1 MD5_Final_APIParam_1 is NULL, the digest is placed in a static array
The following functions may be used if the message is not completely stored in memory:
MD2_Init_APIName initializes a MD2_Init_APIParam_1 structure
MD2_Final_APIName places the message digest in MD2_Final_APIParam_1, which must have space for MD2_DIGEST_LENGTH == 16 bytes of output, and erases the MD2_Final_APIParam_2
MD4_Init_APIName, MD4_Update_APIName, MD4_Final_APIName, MD5_Init_APIName, MD5_Update_APIName, and MD5_Final_APIName are analogous using an MD4_Init_APIParam_1 MD4_Update_APIParam_1 MD4_Final_APIParam_2 and MD5_Init_APIParam_1 MD5_Update_APIParam_1 MD5_Final_APIParam_2 structure
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly
MD2, MD4, and MD5 are recommended only for compatibility with existing applications
In new applications, SHA-1 or RIPEMD-160 should be preferred
MD2_APIName, MD4_APIName, and MD5_APIName return pointers to the hash value
MD2_Init_APIName, MD2_Update_APIName, MD2_Final_APIName, MD4_Init_APIName, MD4_Update_APIName, MD4_Final_APIName, MD5_Init_APIName, MD5_Update_APIName, and MD5_Final_APIName return 1 for success, 0 otherwise
SSL_CTX_get_client_cert_cb_APIName returns a pointer to the currently set callback function
During a handshake (or renegotiation) a server may request a certificate from the client
A client certificate must only be sent, when the server did send the request
When a certificate was set using the SSL_CTX_use_certificate_APIName family of functions, it will be sent to the server
The TLS standard requires that only a certificate is sent, if it matches the list of acceptable CAs sent by the server
This constraint is violated by the default behavior of the OpenSSL library
Using the callback function it is possible to implement a proper selection routine or to allow a user interaction to choose the certificate to be sent
If a callback function is defined and no certificate was yet defined for the SSL object, the callback function will be called
If the callback function returns a certificate, the OpenSSL library will try to load the private key and certificate data into the SSL object using the SSL_use_certificate_APIName and SSL_use_private_key_APIName functions
Thus it will permanently install the certificate and key for this SSL object
It will not be reset by calling SSL_clear_APIName
If the callback returns no certificate, the OpenSSL library will not send a certificate
The client_cert_cb_APIName cannot return a complete certificate chain, it can only return one client certificate
If the chain only has a length of 2, the root CA certificate may be omitted according to the TLS standard and thus a standard conforming answer can be sent to the server
For a longer chain, the client must send the complete chain (with the option to leave out the root CA certificate)
This can only be accomplished by either adding the intermediate CA certificates into the trusted certificate store for the SSL_CTX object (resulting in having to add CA certificates that otherwise maybe would not be trusted), or by adding the chain certificates using the SSL_CTX_add_extra_chain_cert_APIName function, which is only available for the SSL_CTX object as a whole and that therefore probably can only apply for one client certificate, making the concept of the callback function (to allow the choice from several certificates) questionable
Once the SSL object has been used in conjunction with the callback function, the certificate will be set for the SSL object and will not be cleared even when SSL_clear_APIName is being called
It is therefore mandatory to destroy the SSL object using SSL_free_APIName and create a new one to return to the previous state
The session id context becomes part of the session
The session id context is set by the SSL/TLS server
The SSL_CTX_set_session_id_context_APIName and SSL_set_session_id_context_APIName functions are therefore only useful on the server side
OpenSSL clients will check the session id context returned by the server when reusing a session
If the session id context is not set on an SSL/TLS server and client certificates are used, stored sessions will not be reused but a fatal error will be flagged and the handshake will fail
If a server returns a different session id context to an OpenSSL client when reusing a session, an error will be flagged and the handshake will fail
OpenSSL servers will always return the correct session id context, as an OpenSSL server checks the session id context itself before reusing a session as described above
SSL_CTX_set_session_id_context_APIName and SSL_set_session_id_context_APIName return the following values:
The operation succeeded
This function returns the RSA modulus size in bytes
This function can be used to determine how much memory must be allocated for an RSA encrypted value
The size in bytes
The X509 encode and decode routines encode and parse an i2d_X509_APIParam_1 i2d_X509_AUX_APIParam_1 d2i_X509_fp_APIParam_2 d2i_X509_bio_APIParam_2 d2i_X509_AUX_APIParam_1 i2d_re_X509_tbs_APIParam_1 d2i_X509_APIParam_1 i2d_X509_bio_APIParam_2 i2d_X509_fp_APIParam_2 structure, which represents an X509 certificate
If the call is successful, d2i_X509_AUX_APIParam_2 d2i_X509_APIParam_2 is incremented to the byte following the parsed data
i2d_X509_APIName encodes the structure pointed to by i2d_X509_APIParam_1 into DER format
If i2d_X509_APIParam_2 is not NULL is writes the DER encoded data to the buffer at i2d_X509_APIParam_2, and increments it to point after the data just written
If the return value is negative an error occurred, otherwise it returns the length of the encoded data
For OpenSSL 0.9.7 and later if i2d_X509_APIParam_2 i2d_X509_AUX_APIParam_2 i2d_re_X509_tbs_APIParam_2 is NULL memory will be allocated for a buffer and the encoded data written to it
In this case i2d_X509_APIParam_2 i2d_X509_AUX_APIParam_2 i2d_re_X509_tbs_APIParam_2 is not incremented and it points to the start of the data just written
i2d_X509_AUX_APIName is similar to i2d_X509_APIName, but the encoded output contains both the certificate and any auxiliary trust information
This is used by the PEM routines to write "TRUSTED CERTIFICATE" objects
Note, this is a non-standard OpenSSL-specific data format
d2i_X509_bio_APIName is similar to d2i_X509_APIName except d2i_X509_bio_APIName attempts to parse data from BIO d2i_X509_bio_APIParam_1
d2i_X509_fp_APIName is similar to d2i_X509_APIName except d2i_X509_fp_APIName attempts to parse data from FILE pointer d2i_X509_fp_APIParam_1
i2d_X509_bio_APIName is similar to i2d_X509_APIName except i2d_X509_bio_APIName writes the encoding of the structure i2d_X509_bio_APIParam_2 i2d_X509_APIParam_1 to BIO i2d_X509_bio_APIParam_1 and i2d_X509_bio_APIName returns 1 for success and 0 for failure
i2d_X509_fp_APIName is similar to i2d_X509_APIName except it writes the encoding of the structure i2d_X509_fp_APIParam_2 i2d_X509_APIParam_1 to BIO d2i_X509_bio_APIParam_1 i2d_X509_bio_APIParam_1 and it returns 1 for success and 0 for failure
i2d_re_X509_tbs_APIName is similar to i2d_X509_APIName except it encodes only the TBSCertificate portion of the certificate
The reason for the auto increment behaviour is to reflect a typical usage of ASN1 functions: after one structure is encoded or decoded another will processed after it
The use of temporary variable is mandatory
A common mistake is to attempt to use a buffer directly as follows:
The auto allocation feature (setting buf to NULL) only works on OpenSSL 0.9.7 and later
Attempts to use it on earlier versions will typically cause a segmentation violation
In some versions of OpenSSL the "reuse" behaviour of d2i_X509_APIName when d2i_X509_APIParam_1 is valid is broken and some parts of the reused structure may persist if some parts of the reused structure are not present in the new one
As a result the use of this "reuse" behaviour is strongly discouraged
i2d_X509_APIName will not return an error in many versions of OpenSSL, if mandatory fields are not initialized due to a programming error ,then the encoded structure may contain invalid data or omit the fields entirely and will not be parsed by d2i_X509_APIName
This may be fixed in future so code should not assume that i2d_X509_APIName will always succeed
The encoding of the TBSCertificate portion of a certificate is cached in the i2d_X509_APIParam_1 i2d_X509_AUX_APIParam_1 d2i_X509_fp_APIParam_2 d2i_X509_bio_APIParam_2 d2i_X509_AUX_APIParam_1 i2d_re_X509_tbs_APIParam_1 d2i_X509_APIParam_1 i2d_X509_bio_APIParam_2 i2d_X509_fp_APIParam_2 structure internally to improve encoding performance and to ensure certificate signatures are verified correctly in some certificates with broken (non-DER) encodings
Any function which encodes an X509 structure such as i2d_X509_APIName, i2d_X509_fp_APIName or i2d_X509_bio_APIName may return a stale encoding if the i2d_X509_APIParam_1 i2d_X509_fp_APIParam_2 i2d_X509_bio_APIParam_2 structure has been modified after deserialization or previous serialization
If, after modification, the i2d_re_X509_tbs_APIParam_1 object is re-signed with X509_sign_APIName, the encoding is automatically renewed
Otherwise, the encoding of the TBSCertificate portion of the i2d_re_X509_tbs_APIParam_1 can be manually renewed by calling i2d_re_X509_tbs_APIName
d2i_X509_APIName, d2i_X509_bio_APIName and d2i_X509_fp_APIName return a valid d2i_X509_APIParam_1 d2i_X509_bio_APIParam_2 d2i_X509_fp_APIParam_2 structure or NULL if an error occurs
The error code that can be obtained by ERR_get_error_APIName
If the "reuse" capability has been used with a valid X509 structure being passed in via d2i_X509_APIParam_1 then the object is not freed in the event of error but may be in a potentially invalid or inconsistent state
i2d_X509_APIName returns the number of bytes successfully encoded or a negative value if an error occurs
The error code can be obtained by ERR_get_error_APIName
i2d_X509_bio_APIName and i2d_X509_fp_APIName return 1 for success and 0 if an error occurs The error code can be obtained by ERR_get_error_APIName
SSL_get_error_APIName returns a result code (suitable for the C "switch" statement) for a preceding call to SSL_connect_APIName, SSL_accept_APIName, SSL_do_handshake_APIName, SSL_read_APIName, SSL_peek_APIName, or SSL_write_APIName on SSL_get_error_APIParam_1 SSL_get_error_APIParam_1
The value returned by that TLS/SSL I/O function must be passed to SSL_get_error_APIName in parameter SSL_get_error_APIParam_2 SSL_get_error_APIParam_2
In addition to SSL_get_error_APIParam_1 SSL_get_error_APIParam_1 SSL_get_error_APIParam_1 and SSL_get_error_APIParam_2 SSL_get_error_APIParam_2 SSL_get_error_APIParam_2, SSL_get_error_APIName inspects the current thread's OpenSSL error queue
Thus, SSL_get_error_APIName must be used in the same thread that performed the TLS/SSL I/O operation, and no other OpenSSL function calls should appear in between
The current thread's error queue must be empty before the TLS/SSL I/O operation is attempted, or SSL_get_error_APIName will not work reliably
The following return values can currently occur:
The operation did not complete; the same TLS/SSL I/O function should be called again later
The underlying BIO was not connected yet to the peer and the call would block in connect_APIName/accept_APIName
The SSL function should be called again when the connection is established
These messages can only appear with a BIO_s_connect_APIName or BIO_s_accept_APIName BIO, respectively
In order to find out, when the connection has been successfully established, on many platforms, select_APIName or poll_APIName for writing on the socket file descriptor can be used
The operation did not complete because an application callback set by SSL_CTX_set_client_cert_cb_APIName has asked to be called again
The TLS/SSL I/O function should be called again later
Details depend on the application
A non-recoverable, fatal error in the SSL library occurred, usually a protocol error
The OpenSSL error queue contains more information on the error
If this error occurs, then no further I/O operations should be performed on the connection and SSL_shutdown_APIName must not be called
These functions load the certificates and private keys into the SSL_CTX or SSL object, respectively
The SSL_CTX_* class of functions loads the certificates and keys into the SSL_CTX object SSL_CTX_check_private_key_APIParam_1 SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_ASN1_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1 SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_APIParam_1
The information is passed to SSL objects SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_file_APIParam_1 SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_ASN1_APIParam_1 SSL_use_certificate_file_APIParam_1 SSL_use_certificate_ASN1_APIParam_1 SSL_check_private_key_APIParam_1 SSL_use_PrivateKey_ASN1_APIParam_2 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1 created from SSL_CTX_check_private_key_APIParam_1 SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_ASN1_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1 SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_APIParam_1 with SSL_new_APIName by copying, so that changes applied to SSL_CTX_check_private_key_APIParam_1 SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_ASN1_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1 SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_APIParam_1 do not propagate to already existing SSL objects
The SSL_* class of functions only loads certificates and keys into a specific SSL object
The specific information is kept, when SSL_clear_APIName is called for this SSL object
SSL_CTX_use_certificate_APIName loads the certificate SSL_CTX_use_certificate_APIParam_2 SSL_use_certificate_APIParam_2 into SSL_CTX_use_certificate_APIParam_1, SSL_use_certificate_APIName loads SSL_CTX_use_certificate_APIParam_2 SSL_use_certificate_APIParam_2 into SSL_use_certificate_APIParam_1
The rest of the certificates needed to form the complete certificate chain can be specified using the SSL_CTX_add_extra_chain_cert_APIName function
SSL_CTX_use_certificate_ASN1_APIName loads the ASN1 encoded certificate from the memory location SSL_CTX_use_certificate_ASN1_APIParam_3 SSL_use_certificate_ASN1_APIParam_2 (with length SSL_CTX_use_certificate_ASN1_APIParam_2 SSL_use_certificate_ASN1_APIParam_3) into SSL_CTX_use_certificate_ASN1_APIParam_1, SSL_use_certificate_ASN1_APIName loads the ASN1 encoded certificate into SSL_use_certificate_ASN1_APIParam_1
SSL_CTX_use_certificate_file_APIName loads the first certificate stored in SSL_CTX_use_certificate_file_APIParam_2 SSL_use_certificate_file_APIParam_2 SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1
The formatting SSL_CTX_use_certificate_file_APIParam_3 SSL_use_certificate_file_APIParam_3 of the certificate must be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1
SSL_use_certificate_file_APIName loads the certificate from SSL_CTX_use_certificate_file_APIParam_2 SSL_use_certificate_file_APIParam_2 SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_use_certificate_file_APIParam_1
See the NOTES section on why SSL_CTX_use_certificate_chain_file_APIName should be preferred
SSL_CTX_use_certificate_chain_file_APIName loads a certificate chain from SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_CTX_use_certificate_chain_file_APIParam_1
The certificates must be in PEM format and must be sorted starting with the subject's certificate (actual client or server certificate), followed by intermediate CA certificates if applicable, and ending at the highest level (root) CA
There is no corresponding function working on a single SSL object
SSL_CTX_use_PrivateKey_APIName adds SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 as private key to SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1
SSL_CTX_use_RSAPrivateKey_APIName adds the private key SSL_CTX_use_RSAPrivateKey_APIParam_2 SSL_use_RSAPrivateKey_APIParam_2 of type RSA to SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1
SSL_use_PrivateKey_APIName adds SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 as private key to SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_APIParam_1; SSL_use_RSAPrivateKey_APIName adds SSL_CTX_use_RSAPrivateKey_APIParam_2 SSL_use_RSAPrivateKey_APIParam_2 as private key of type RSA to SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_APIParam_1
If a certificate has already been set and the private does not belong to the certificate an error is returned
To change a certificate, private key pair the new certificate needs to be set with SSL_use_certificate_APIName or SSL_CTX_use_certificate_APIName before setting the private key with SSL_CTX_use_PrivateKey_APIName or SSL_use_PrivateKey_APIName
SSL_CTX_use_PrivateKey_ASN1_APIName adds the private key of type SSL_CTX_use_PrivateKey_ASN1_APIParam_1 SSL_use_PrivateKey_ASN1_APIParam_1 stored at memory location SSL_CTX_use_PrivateKey_ASN1_APIParam_3 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_2 SSL_use_PrivateKey_ASN1_APIParam_3 SSL_use_RSAPrivateKey_ASN1_APIParam_2 (length SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_3 SSL_use_PrivateKey_ASN1_APIParam_4 SSL_use_RSAPrivateKey_ASN1_APIParam_3) to SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1
SSL_CTX_use_RSAPrivateKey_ASN1_APIName adds the private key of type RSA stored at memory location SSL_CTX_use_PrivateKey_ASN1_APIParam_3 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_2 SSL_use_PrivateKey_ASN1_APIParam_3 SSL_use_RSAPrivateKey_ASN1_APIParam_2 (length SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_3 SSL_use_PrivateKey_ASN1_APIParam_4 SSL_use_RSAPrivateKey_ASN1_APIParam_3) to SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1
SSL_use_PrivateKey_ASN1_APIName and SSL_use_RSAPrivateKey_ASN1_APIName add the private key to SSL_use_PrivateKey_ASN1_APIParam_2 SSL_use_RSAPrivateKey_ASN1_APIParam_1
SSL_CTX_use_PrivateKey_file_APIName adds the first private key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1
The formatting SSL_CTX_use_PrivateKey_file_APIParam_3 SSL_CTX_use_RSAPrivateKey_file_APIParam_3 SSL_use_PrivateKey_file_APIParam_3 SSL_use_RSAPrivateKey_file_APIParam_3 of the certificate must be specified from the known types SSL_FILETYPE_PEM, SSL_FILETYPE_ASN1
SSL_CTX_use_RSAPrivateKey_file_APIName adds the first private RSA key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1
SSL_use_PrivateKey_file_APIName adds the first private key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_use_PrivateKey_file_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1; SSL_use_RSAPrivateKey_file_APIName adds the first private RSA key found to SSL_use_PrivateKey_file_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1
SSL_CTX_check_private_key_APIName checks the consistency of a private key with the corresponding certificate loaded into SSL_CTX_check_private_key_APIParam_1
If more than one key/certificate pair (RSA/DSA) is installed, the last item installed will be checked
If eg the last item was a RSA certificate or key, the RSA key/certificate pair will be checked
SSL_check_private_key_APIName performs the same check for SSL_check_private_key_APIParam_1
If no key/certificate was explicitly added for this SSL_check_private_key_APIParam_1, the last item added into SSL_CTX_check_private_key_APIParam_1 will be checked
The internal certificate store of OpenSSL can hold several private key/certificate pairs at a time
The certificate used depends on the cipher selected, see also SSL_CTX_set_cipher_list_APIName
SSL_CTX_use_certificate_chain_file_APIName adds the first certificate found in the file to the certificate store
The other certificates are added to the store of chain certificates using SSL_CTX_add1_chain_cert_APIName
Note: versions of OpenSSL before 1.0.2 only had a single certificate chain store for all certificate types, OpenSSL 1.0.2 and later have a separate chain store for each type
SSL_CTX_use_certificate_chain_file_APIName should be used instead of the SSL_CTX_use_certificate_file_APIName function in order to allow the use of complete certificate chains even when no trusted CA storage is used or when the CA issuing the certificate shall not be added to the trusted CA storage
If additional certificates are needed to complete the chain during the TLS negotiation, CA certificates are additionally looked up in the locations of trusted CA certificates, see SSL_CTX_load_verify_locations_APIName
The private keys loaded from file can be encrypted
In order to successfully load encrypted keys, a function returning the passphrase must have been supplied, see SSL_CTX_set_default_passwd_cb_APIName
(Certificate files might be encrypted as well from the technical point of view, it however does not make sense as the data in the certificate is considered public anyway.)
All of the functions to set a new certificate will replace any existing certificate of the same type that has already been set
Similarly all of the functions to set a new private key will replace any private key that has already been set
Applications should call SSL_CTX_check_private_key_APIName or SSL_check_private_key_APIName as appropriate after loading a new certificate and private key to confirm that the certificate and key match
On success, the functions return 1
Otherwise check out the error stack to find out the reason
The Elliptic Curve library provides a number of different implementations through a single common interface
When constructing a curve using EC_GROUP_new (see EC_GROUP_new_APIName ) an implementation method must be provided
The functions described here all return a const pointer to an EC_METHOD_get_field_type_APIParam_1 structure that can be passed to EC_GROUP_NEW
It is important that the correct implementation type for the form of curve selected is used
For F2^m curves there is only one implementation choice, ie EC_GF2_simple_method
For Fp curves the lowest common denominator implementation is the EC_GFp_simple_method implementation
All other implementations are based on this one
EC_GFp_mont_method builds on EC_GFp_simple_method but adds the use of montgomery multiplication (see BN_mod_mul_montgomery_APIName )
EC_GFp_nist_method offers an implementation optimised for use with NIST recommended curves (NIST curves are available through EC_GROUP_new_by_curve_name as described in EC_GROUP_new_APIName )
The functions EC_GFp_nistp224_method, EC_GFp_nistp256_method and EC_GFp_nistp521_method offer 64 bit optimised implementations for the NIST P224, P256 and P521 curves respectively
Note, however, that these implementations are not available on all platforms
All EC_GFp* functions and EC_GF2m_simple_method always return a const pointer to an EC_METHOD structure
EC_METHOD_get_field_type returns an integer that identifies the type of field the EC_METHOD structure supports
This function returns the size of an ASN.1 encoded DSA signature in bytes
This function can be used to determine how much memory must be allocated for a DSA signature
The size in bytes
OPENSSL_no_config_APIName disables configuration
If called before OPENSSL_config_APIName no configuration takes place
There are several reasons why calling the OpenSSL configuration routines is advisable
For example new ENGINE functionality was added to OpenSSL 0.9.7
In OpenSSL 0.9.7 control functions can be supported by ENGINEs, this can be used (among other things) to load dynamic ENGINEs from shared libraries (DSOs)
However very few applications currently support the control interface and so very few can load and use dynamic ENGINEs
Equally in future more sophisticated ENGINEs will require certain control operations to customize them
If an application calls OPENSSL_config_APIName ,it doesn't need to know or care about ENGINE control operations because they can be performed by editing a configuration file
Applications should free up configuration at application closedown by calling CONF_modules_free_APIName
Neither OPENSSL_config_APIName nor OPENSSL_no_config_APIName return a value
If present the SMIMECapabilities attribute indicates support for the following algorithms: triple DES, 128 bit RC2, 64 bit RC2, DES and 40 bit RC2
If any of these algorithms is disabled, then it will not be included
Some advanced attributes such as counter signatures are not supported
PKCS7_sign_APIName returns either a valid PKCS7 structure or NULL if an error occurred
The error can be obtained from ERR_get_error_APIName
CMS_decrypt_APIName extracts and decrypts the content from a CMS EnvelopedData structure
CMS_decrypt_APIParam_2 is the private key of the recipient, CMS_decrypt_APIParam_3 is the recipient's certificate, CMS_decrypt_APIParam_5 is a BIO to write the content to and CMS_decrypt_APIParam_6 is an optional set of flags
The CMS_decrypt_APIParam_4 parameter is used in the rare case where the encrypted content is detached
The CMS_decrypt_APIParam_4 parameter will normally be set to NULL
OpenSSL_add_all_algorithms_APIName (or equivalent) should be called before using this function or errors about unknown algorithms will occur
Although the recipients certificate is not needed to decrypt the data, the recipients certificate is needed to locate the appropriate (of possible several) recipients in the CMS structure
It is possible to determine the correct recipient key by other means (for example looking them up in a database) and setting them in the CMS structure in advance using the CMS utility functions such as CMS_set1_pkey_APIName
In this case both CMS_decrypt_APIParam_3 and CMS_decrypt_APIParam_2 should be set to NULL
To process KEKRecipientInfo types CMS_set1_key_APIName or CMS_RecipientInfo_set0_key_APIName and CMS_ReceipientInfo_decrypt_APIName should be called before CMS_decrypt_APIName and CMS_decrypt_APIParam_3 and CMS_decrypt_APIParam_2 set to NULL
The following flags can be passed in the CMS_decrypt_APIParam_6 parameter
CMS_decrypt_APIName returns either 1 for success or 0 for failure
The error can be obtained from ERR_get_error_APIName
The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify_APIName also applies to CMS_decrypt_APIName
SSL_CTX_new_APIName creates a new SSL_CTX_new_APIParam_0 object as framework to establish TLS/SSL enabled connections
The SSL_CTX object uses SSL_CTX_new_APIParam_1 as connection method
The methods exist in a generic type (for client and server use), a server only type, and a client only type
SSL_CTX_new_APIParam_1 can be of the following types:
A TLS/SSL connection established with these methods will only understand the TLSv1.2 protocol
A client will send out TLSv1.2 client hello messages and will also indicate that it only understand TLSv1.2
A server will only understand TLSv1.2 client hello messages
A TLS/SSL connection established with these methods will only understand the TLSv1.1 protocol
A client will send out TLSv1.1 client hello messages and will also indicate that it only understand TLSv1.1
A server will only understand TLSv1.1 client hello messages
A TLS/SSL connection established with these methods will only understand the TLSv1 protocol
A client will send out TLSv1 client hello messages and will indicate that it only understands TLSv1
A server will only understand TLSv1 client hello messages
A TLS/SSL connection established with these methods will only understand the SSLv3 protocol
A client will send out SSLv3 client hello messages and will indicate that it only understands SSLv3
A server will only understand SSLv3 client hello messages
The SSLv3 protocol is deprecated and should not be used
A TLS/SSL connection established with these methods will only understand the SSLv2 protocol
A client will send out SSLv2 client hello messages and will also indicate that it only understand SSLv2
A server will only understand SSLv2 client hello messages
The SSLv2 protocol offers little to no security and should not be used
As of OpenSSL 1.0.2g, EXPORT ciphers and 56-bit DES are no longer available with SSLv2
These are the version-flexible DTLS methods
These are the version-specific methods for DTLSv1.2
These are the version-specific methods for DTLSv1
SSL_CTX_new_APIName initializes the list of ciphers, the session cache setting, the callbacks, the keys and certificates and the options to SSL_CTX_new_APIName default values
The following return values can occur:
The creation of a new SSL_CTX object failed
Check the error stack to find out the reason
The return value points to an allocated SSL_CTX object
OCSP_resp_count_APIName returns the number of OCSP_single_get0_status_APIParam_1 structures in OCSP_resp_count_APIParam_1
OCSP_resp_get0_APIName returns the OCSP_resp_get0_APIParam_0 structure in OCSP_resp_get0_APIParam_1 corresponding to index OCSP_resp_get0_APIParam_2
Where OCSP_resp_get0_APIParam_2 runs from 0 to OCSP_resp_count(bs) - 1
OCSP_resp_find_APIName searches OCSP_resp_find_APIParam_1 for OCSP_resp_find_APIParam_2 and returns the index of the first matching entry after OCSP_resp_find_APIParam_3 or starting from the beginning if OCSP_resp_find_APIParam_3 is -1
OCSP_resp_get0_signature_APIName returns the signature from OCSP_resp_get0_signature_APIParam_1
OCSP_resp_get0_certs_APIName returns any certificates included in OCSP_resp_get0_APIParam_1 OCSP_resp_get0_id_APIParam_1 OCSP_resp_get0_tbs_sigalg_APIParam_1 OCSP_resp_count_APIParam_1 OCSP_resp_get0_signature_APIParam_1 OCSP_resp_get0_signer_APIParam_1 OCSP_resp_find_status_APIParam_1 OCSP_resp_find_APIParam_1 OCSP_resp_get1_id_APIParam_1 OCSP_resp_get0_respdata_APIParam_1
OCSP_resp_find_status_APIName returns 1 if OCSP_resp_find_status_APIParam_2 is found in OCSP_resp_find_status_APIParam_1 and 0 otherwise
OCSP_resp_count_APIName returns the total number of OCSP_single_get0_status_APIParam_1 fields in OCSP_resp_count_APIParam_1
OCSP_resp_get0_APIName returns a pointer to an OCSP_resp_get0_APIParam_0 structure or NULL if OCSP_resp_get0_APIParam_2 is out of range
OCSP_resp_find_APIName returns the index of OCSP_resp_find_APIParam_2 in OCSP_resp_find_APIParam_1 (which may be 0) or -1 if OCSP_resp_find_APIParam_2 was not found
OCSP_single_get0_status_APIName returns the status of OCSP_single_get0_status_APIParam_1 or -1 if an error occurred
OCSP_resp_get0_signer_APIName returns 1 if the signing certificate was located, or 0 on error
OCSP_basic_verify_APIName returns 1 on success, 0 on error, or -1 on fatal error such as malloc failure
Applications will typically call OCSP_resp_find_status_APIName using the certificate ID of interest and then check its validity using OCSP_check_validity_APIName
They can then take appropriate action based on the status of the certificate
