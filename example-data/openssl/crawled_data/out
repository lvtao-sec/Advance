The following return values of SSL_connect_APIName can occur, 0, 1, <0||||null
SSL_get_certificate_APIName and SSL_get_privatekey_APIName return internal pointers that must not be freed by the application program||||null
RSA_private_decrypt_APIParam_3 must point to RSA_size_APIName RSA_private_decrypt_APIParam_4 bytes of memory||||null
EVP_PKEY_CTX_new_APIName, EVP_PKEY_CTX_new_id_APIName, EVP_PKEY_CTX_dup_APIName returns either the newly allocated EVP_PKEY_CTX structure or NULL if an error occurred||||null
RAND_pseudo_bytes_APIName was deprecated in OpenSSL 1.1.0||||null
X509_get_notBefore_APIName and X509_get_notAfter_APIName were deprecated in OpenSSL 1.1.0||||null
SSL_CTX_free_APIName does not provide diagnostic information||||null
DSA_do_sign_APIName returns the signature, NULL on error||||null
DSA_do_verify_APIName returns 1 for a valid signature, 0 for an incorrect signature and -1 on error||||null
This implies , that all corresponding sessions from an external session cache are removed as well||||null
The error codes can be obtained by ERR_get_error_APIName||||null
It prints the ` load ' and the ` actual load '||||null
DSA_sign_setup_APIName may be used to precompute part of the signing operation for each signature in case signature generation is time-critical||||null
lh_node_usage_stats_APIName prints out a short summary of the state of the hash table||||null
These functions do not return values||||null
The lh_stats_bio_APIParam_1 lh_stats_APIParam_1 lh_node_stats_bio_APIParam_1 lh_node_stats_APIParam_1 lh_node_usage_stats_APIParam_1 lh_node_usage_stats_bio_APIParam_1 structure records statistics about most aspects of accessing the hash table||||null
lh_node_stats_APIName prints the number of entries for each ` bucket ' in the hash table||||null
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures||||null
The load is the average number of data items per ` bucket ' in the hash table||||null
i2d_CMS_bio_stream_APIName outputs a CMS_ContentInfo structure in BER format||||null
On failure an error code can be obtained from ERR_get_error_APIName||||null
It is otherwise identical to the function SMIME_write_CMS_APIName||||null
The ` actual load ' is the average number of items per ` bucket ' , but only for buckets which contain entries||||null
lh_stats_bio_APIName , lh_node_stats_bio_APIName and lh_node_usage_stats_bio_APIName are the same as the above , except that the output goes to a lh_stats_bio_APIParam_2 lh_node_stats_bio_APIParam_2 lh_node_usage_stats_bio_APIParam_2||||null
i2d_CMS_bio_stream_APIName returns 1 for success or 0 for failure||||null
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure||||null
This function is effectively a version of the i2d_CMS_bio_APIName supporting streaming||||null
It also calls the free_APINameing procedures for indirectly affected items||||if applicable
The prefix `` i2d '' is arguably wrong||||null
the SSL_CTX object pointed to by SSL_CTX_free_APIParam_1 and frees up the allocated memory||||if the the reference count has reached 0
SSL_CTX_free_APIName decrements the reference count of SSL_CTX_free_APIParam_1 , and removes||||null
This library implements the Blowfish cipher , which was invented and described by Counterpane||||null
Blowfish is a block cipher that operates on 64 bit blocks of data||||null
the session cache , the list of ciphers , the list of Client CAs , the certificates and keys||||null
Blowfish can be used in the same modes as DES||||null
This is mostly a legacy of Eric Young writing this library for the reasons of implementing what looked like a nice algorithm rather than for a particular software product||||null
Blowfish is currently one of the faster block ciphers||||null
lh_stats_APIName prints out statistics on the size of the hash table , how many entries are in it , and the number and result of calls to the routines in this library||||null
BF_set_key_APIName sets up the BF_set_key_APIParam_1 BF_set_key_APIParam_1 using the BF_set_key_APIParam_2 bytes long key at BF_set_key_APIParam_3||||null
Blowfish consists of a key setup phase and the actual encryption or decryption phase||||null
It uses a variable size key , but typically , 128 bit keys are considered good for strong encryption||||null
It is quite a bit faster than DES , and much faster than IDEA or RC2||||null
BF_encrypt_APIName and BF_decrypt_APIName are the lowest level functions for Blowfish encryption||||null
BF_ofb64_encrypt_APIName is the OFB mode for Blowfish with 64 bit feedback||||null
The alternative is to use BF_ecb_encrypt_APIName||||null
It uses the same parameters as BF_cfb64_encrypt_APIName , which must be initialized the same way||||null
None of the functions presented here return any value||||null
They encrypt/decrypt the first 64 bits of the vector pointed by BF_encrypt_APIParam_1 BF_decrypt_APIParam_1 , using the key BF_encrypt_APIParam_2 BF_decrypt_APIParam_2||||null
For the moment of this writing following bits are significant||||null
Naturally it 's meaningful on x86 and x86_64 platforms only||||null
Applications should use the higher level functions EVP_EncryptInit_APIName etc instead of calling the blowfish functions directly||||null
Less intuitive is clearing bit # 28||||null
BN_mod_inverse_APIName returns the BN_mod_inverse_APIParam_1 containing the inverse, and NULL on error||||null
Following bits are significant||||null
Alternatively you can reconfigure the toolkit with no-sse2 option and recompile||||null
The variable is normally set up automatically upon toolkit initialization , but can be manipulated afterwards to modify crypto library behaviour||||null
The error codes can be obtained by ERR_get_error_APIName||||null
Value returned by OPENSSL_ia32cap_loc_APIName is address of a variable containing IA-32 processor capabilities bit vector as it appears in EDX||||null
The vector is further extended with EBX value returned by CPUID with EAX=7 and ECX=0 as input||||null
RIPEMD-160 is a cryptographic hash function with a 160 bit output||||null
These functions should not be used||||unless you implement ` modes ' of Blowfish
RIPEMD160_Init_APIName initializes a RIPEMD160_Init_APIParam_1 structure||||null
ECX register pair after executing CPUID instruction with EAX = 1 input value||||null
RIPEMD160_APIName computes the RIPEMD-160 message digest of the RIPEMD160_APIParam_2 bytes at RIPEMD160_APIParam_1 and places it in RIPEMD160_Final_APIParam_1||||null
RIPEMD160_APIName returns a pointer to the hash value||||null
This in turn affects the decision on , most notably in AES assembler module||||null
RIPEMD160_Init_APIName, RIPEMD160_Update_APIName and RIPEMD160_Final_APIName return 1 for success, 0 otherwise||||null
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly||||null
The truth is that it is not copied from CPUID output verbatim , but is adjusted to reflect||||null
X509_NAME_add_entry_APIName adds a copy of X509_NAME_add_entry_APIParam_2 structure X509_NAME_add_entry_APIParam_2 to X509_NAME_add_entry_APIParam_1||||null
you should be aware that they take each 32-bit chunk in host-byte order , which is little-endian on little-endian platforms and big-endian on big-endian ones||||If you still want to use these functions
RIPEMD160_Final_APIName places the message digest in RIPEMD160_Final_APIParam_1 , which must have space for RIPEMD160_DIGEST_LENGTH == 20 bytes of output , and erases the RIPEMD160_Final_APIParam_2||||null
the digest is placed in a static array||||If RIPEMD160_Final_APIParam_1 is NULL
will need to find an item in the hash table||||while the ` load ' is the average number that will be done to record a miss
So the ` actual load ' is the average number of searches that||||null
The new entry is added to a position determined by X509_NAME_add_entry_APIParam_3 and X509_NAME_add_entry_APIParam_4||||null
X509_NAME_delete_entry_APIName deletes an entry from X509_NAME_delete_entry_APIParam_1 at position X509_NAME_delete_entry_APIParam_2||||null
The field value to be added is in X509_NAME_add_entry_by_txt_APIParam_4 X509_NAME_add_entry_by_OBJ_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_4 of length X509_NAME_add_entry_by_txt_APIParam_5 X509_NAME_add_entry_by_OBJ_APIParam_5 X509_NAME_add_entry_by_NID_APIParam_5||||null
X509_NAME_add_entry_APIParam_2 must be freed up after the call||||null
The deleted entry is returned and must be freed up||||null
The following functions may be used||||if the message is not completely stored in memory
You might have to do the latter , but under control of OS that does not enable XMM registers||||if target OpenSSL application is executed on SSE2 capable CPU
In X509_NAME_add_entry_by_txt_APIName the X509_NAME_add_entry_by_txt_APIParam_2 string represents the field name using OBJ_txt2obj||||null
X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 determines how the new type is added||||null
X509_NAME_add_entry_by_txt_APIName , X509_NAME_add_entry_by_OBJ_APIName and X509_NAME_add_entry_by_NID_APIName add a field whose name is defined by a string X509_NAME_add_entry_by_txt_APIParam_2 , an object X509_NAME_add_entry_by_OBJ_APIParam_2 or a NID X509_NAME_add_entry_by_NID_APIParam_2 respectively||||null
This adds a new entry to the end of X509_NAME_add_entry_by_txt_APIParam_1 X509_NAME_add_entry_APIParam_1 X509_NAME_add_entry_by_NID_APIParam_1 X509_NAME_delete_entry_APIParam_1 X509_NAME_add_entry_by_OBJ_APIParam_1 as a single valued RelativeDistinguishedName||||null
X509_NAME_delete_entry_APIName returns either the deleted X509_NAME_delete_entry_APIParam_0 structure of NULL if an error occurred||||null
clearing bit # 26 at run-time disables high-performance SSE2 code present in the crypto library||||while clearing bit # 24 disables SSE2 code operating on 128-bit XMM register bank
The X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 and X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 parameters determine where a new entry should be added||||null
RAND_egd is a wrapper for RAND_egd_bytes||||null
X509_NAME_add_entry_by_txt_APIName, X509_NAME_add_entry_by_OBJ_APIName, X509_NAME_add_entry_by_NID_APIName and X509_NAME_add_entry_APIName return 1 for success of 0 if an error occurred||||null
RAND_egd_APIName queries the entropy gathering daemon EGD on socket RAND_egd_APIParam_1||||null
a new RDN is created||||If it is zero
For almost all applications X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 can be set to -1 and X509_NAME_add_entry_by_txt_APIParam_7 X509_NAME_add_entry_APIParam_4 X509_NAME_add_entry_by_NID_APIParam_7 X509_NAME_add_entry_by_OBJ_APIParam_7 to 0||||null
This will be a multivalued RDN||||null
RAND_egd_APIName queries 255 bytes and uses RAND_add_APIName to seed the OpenSSL built-in PRNG||||null
RAND_egd_bytes_APIName queries the entropy gathering daemon EGD on socket RAND_egd_bytes_APIParam_1 RAND_egd_APIParam_1||||null
X509_NAME_add_entry_by_txt_APIParam_6 X509_NAME_add_entry_APIParam_3 X509_NAME_add_entry_by_NID_APIParam_6 X509_NAME_delete_entry_APIParam_2 X509_NAME_add_entry_by_OBJ_APIParam_6 actually determines the index where the new entry is inserted||||null
RAND_egd_bytes_APIName queries RAND_egd_bytes_APIParam_2 bytes and uses RAND_add_APIName to seed the OpenSSL built-in PRNG||||null
Even though you can manipulate the value programmatically , you most likely will find the value more appropriate to set up an environment variable with the same name prior starting target application , eg on Intel P4 processor ` env OPENSSL_ia32cap = 0x16980010 apps/openssl ' , or better yet ` env OPENSSL_ia32cap = ~ 0x1000000 apps/openssl ' to achieve same effect without modifying the application source code||||null
This function is more flexible than RAND_egd_APIName||||null
RAND_query_egd_bytes_APIName performs the actual query of the EGD daemon on socket RAND_query_egd_bytes_APIParam_1||||null
This can be advantageous||||null
Alternatively , the EGD-interface compatible daemon PRNGD can be used||||null
It is available from http||||null
The PRNG state is not considered||||null
RAND_query_egd_bytes_APIName returns the number of bytes read from the daemon on success, and -1 if the connection failed||||null
PRNGD does employ an internal PRNG itself and can never run out of entropy||||null
SSL_set_connect_state_APIName sets SSL_set_connect_state_APIParam_1 to work in client mode||||null
SSL_set_accept_state_APIName sets SSL_set_accept_state_APIParam_1 to work in server mode||||null
Several chunks can be queried||||during one connection
the EGD entropy gathering daemon provides a socket interface through which entropy can be gathered in chunks up to 255 bytes||||null
RAND_query_egd_bytes_APIParam_3 bytes are queried and written into RAND_query_egd_bytes_APIParam_2||||If RAND_query_egd_bytes_APIParam_2 is given
SSL_set_connect_state_APIName and SSL_set_accept_state_APIName do not return diagnostic information||||null
On systems without / dev / * random devices providing entropy from the kernel , the EGD entropy gathering daemon can be used to collect entropy||||null
one secret key must be generated||||When only
only one secret key is not necessary to request the full amount 255 bytes from the EGD socket||||null
SSL_CTX_add_client_custom_ext_APIName and SSL_CTX_add_server_custom_ext_APIName return 1 for success and 0 for failure||||null
SSL_extension_supported_APIName returns 1 if the extension SSL_extension_supported_APIParam_1 is handled internally by OpenSSL and 0 otherwise||||null
RAND_query_egd_bytes_APIParam_3 bytes are queried and used to seed the OpenSSL built-in PRNG using RAND_add_APIName||||If RAND_query_egd_bytes_APIParam_2 is NULL
RAND_egd_APIName and RAND_egd_bytes_APIName return the number of bytes read from the daemon on success, and -1 if the connection failed or the daemon did not return enough data to fully seed the PRNG||||null
SSL_SESSION_get_time_APIName returns the time at which the session SSL_SESSION_get_time_APIParam_1 was established||||null
SSL_SESSION_get_timeout_APIName returns the timeout value set for session SSL_SESSION_get_timeout_APIParam_1 in seconds||||null
the extension type must not be handled by OpenSSL internally or an error occurs||||null
SSL_extension_supported_APIName returns 1 if the extension SSL_extension_supported_APIParam_1 is handled internally by OpenSSL and 0 otherwise||||null
Even though it may be clear from the method chosen , whether client or server mode was requested , the handshake routines must be explicitly set||||null
SSL_SESSION_set_time_APIName replaces the creation time of the session SSL_SESSION_set_time_APIParam_1 with the chosen value SSL_SESSION_set_time_APIParam_2||||null
SSL_SESSION_set_timeout_APIName sets the timeout value for session SSL_SESSION_set_timeout_APIParam_1 in seconds to SSL_SESSION_set_timeout_APIParam_2||||null
SSL_SESSION_get_time_APIName and SSL_SESSION_get_timeout_APIName return the currently valid values||||null
Sessions are expired by examining the creation time and the timeout value||||null
SSL_SESSION_set_time_APIName and SSL_SESSION_set_timeout_APIName return 1 on success||||null
BN_num_bytes_APIName returns the size of a BN_num_bytes_APIParam_1 in bytes||||null
BIO_s_mem_APIName return the memory BIO method function||||null
BN_num_bytes_APIName is a macro||||null
Using these functions it is possible to extend or shorten the lifetime of the session||||null
The SSL_get_time_APIName , SSL_set_time_APIName , SSL_get_timeout_APIName , and SSL_set_timeout_APIName functions are synonyms for the SSL_SESSION _ * _ APIName counterparts||||null
BN_num_bits_APIName returns the number of significant bits in a BN_num_bits_APIParam_1, following the same principle as BN_num_bits_word_APIName||||null
The time is given in seconds since the Epoch and compatible to the time delivered by the time_APIName call||||null
If any of the function is passed the NULL pointer for the session SSL_set_time_APIParam_1 SSL_SESSION_set_timeout_APIParam_1 SSL_SESSION_get_time_APIParam_1 SSL_SESSION_set_time_APIParam_1 SSL_set_timeout_APIParam_1 SSL_SESSION_get_timeout_APIParam_1 SSL_get_time_APIParam_1 SSL_get_timeout_APIParam_1, 0 is returned||||null
OpenSSL automatically queries EGD , if the socket is located at / var/run/egd-pool , / dev/egd-pool or / etc/egd-pool||||when entropy is requested via RAND_bytes_APIName or the status is checked via RAND_status_APIName for the first time
A memory BIO is a source/sink BIO which uses memory for its I/O||||null
Memory BIOs support BIO_gets_APIName and BIO_puts_APIName||||null
Any data written to a memory BIO can be recalled by reading from it||||null
BIO_ctrl_pending_APIName returns the number of bytes currently stored||||null
Calling BIO_reset_APIName on a read write memory BIO clears any data in it||||null
If the BIO_set_mem_eof_return_APIParam_2 is zero an empty memory BIO will return EOF  will be false||||null
Data written to a memory BIO is stored in a BUF_MEM structure which is extended as appropriate to accommodate the stored data||||null
It is implemented as a macro||||null
It is a macro||||null
To avoid ambiguity with a normal positive return value BIO_set_mem_eof_return_APIParam_2 should be set to a negative value, typically -1||||null
Both are set at creation time of the session to the actual time and the default timeout value at creation , respectively , as set by SSL_CTX_set_timeout_APIName||||null
If BIO_set_mem_eof_return_APIParam_2 is non zero it will return BIO_set_mem_eof_return_APIParam_2 when it is empty and it will set the read retry flag  is true)||||null
BIO_eof_APIName is true||||if no data is in the BIO
On a read only BIO it restores the BIO to its original state and the read only data can be read again||||null
It is a macro||||null
The use of a read only memory BIO avoids this problem||||null
BIO_set_mem_eof_return_APIName sets the behaviour of memory BIO BIO_set_mem_eof_return_APIParam_1||||when it is empty
There should be an option to set the maximum size of a memory BIO||||null
it was either assigned a dedicated client method , a dedicated server method , or a generic method , that can be used for both client and server connections||||When the SSL_CTX object was created with SSL_CTX_new_APIName
There should be a way to `` rewind '' a read write BIO without destroying BIO contents||||null
If a callback function has not been set, the NULL pointer is returned||||null
BIO_set_mem_buf_APIName sets the internal BUF_MEM structure to BIO_set_mem_buf_APIParam_2 and sets the close flag to BIO_set_mem_buf_APIParam_3 , that is BIO_set_mem_buf_APIParam_3 should be either BIO_CLOSE or BIO_NOCLOSE||||null
The copying operation should not occur after every small read of a large BIO to improve efficiency||||null
SSL_set_bio_APIName can not fail||||null
SSL_CTX_sess_get_new_cb_APIName , SSL_CTX_sess_get_remove_cb_APIName , and SSL_CTX_sess_get_get_cb_APIName allow to retrieve the function pointers of the provided callback functions||||null
The SSL engine inherits the behaviour of SSL_set_bio_APIParam_2 and SSL_set_bio_APIParam_3 , respectively||||null
will always succeed||||if memory is available
Writes to memory BIOs||||null
that is their size can grow indefinitely||||null
synchronization with the internal session cache is realized via callback functions||||null
SSL_get_fd_APIName returns the file descriptor which is linked to SSL_get_fd_APIParam_1 SSL_get_rfd_APIParam_1 SSL_get_wfd_APIParam_1 SSL_get_fd_APIParam_1||||null
The following return values can occur||||null
SSL_get_rfd_APIName and SSL_get_wfd_APIName return the file descriptors for the read or the write channel, which can be different||||null
SSL_set_bio_APIName connects the BIOs SSL_set_bio_APIParam_2 and SSL_set_bio_APIParam_3 for the read and write operations of the TLS/SSL side of SSL_set_bio_APIParam_1||||null
is automatically called||||whenever a new session was negotiated
SSL_CTX_sess_set_new_cb_APIName sets the callback function , which||||null
The operation failed||||null
Inside these callback functions , session can be saved to disk or put into a database using the d2i_SSL_SESSION_APIName interface||||null
If the read and the write channel are different, SSL_get_fd_APIName will return the file descriptor of the read channel||||null
The file descriptor linked to SSL_get_fd_APIParam_1 SSL_get_rfd_APIParam_1 SSL_get_wfd_APIParam_1||||null
A X. 509 CRL is a tool to help determine if a certificate is still valid||||null
In OpenSSL , the type X509_REQ is used to express such a certificate request||||null
the SSL_set_bio_APIParam_1 will also have non-blocking behaviour||||If a BIO is non-blocking
BIO_free_APIName will be called||||If there was already a BIO connected to SSL_set_bio_APIParam_1
A failure can occur||||if an attempt is made to add the same SSL_CTX_add_client_custom_ext_APIParam_2 SSL_CTX_add_server_custom_ext_APIParam_2 more than once , if an attempt is made to use an extension type handled internally by OpenSSL or if an internal error occurs
d2i_RSAPublicKey_APIName and i2d_RSAPublicKey_APIName decode and encode a PKCS # 1 RSAPublicKey structure||||null
SSL_CTX_sess_set_get_cb_APIName sets the callback function which is called||||whenever a SSL/TLS client proposed to resume a session but the session could not be found in the internal session cache
The exact definition of those can be found in the X. 509 document from ITU-T , or in RFC3280 from PKIX||||null
A X. 509 certificate is a structured grouping of information about an individual , a device , or anything one can imagine||||null
A related structure is a certificate request , defined in PKCS # 10 from RSA Security , Inc , also reflected in RFC2896||||null
d2i_RSA_PUBKEY_APIName and i2d_RSA_PUBKEY_APIName decode and encode an RSA public key using a SubjectPublicKeyInfo structure||||null
In OpenSSL , the type X509 is used to express such a certificate , and the type X509_CRL is used to express a CRL||||null
d2i_RSAPrivateKey_APIName , i2d_RSAPrivateKey_APIName decode and encode a PKCS # 1 RSAPrivateKey structure||||null
Finally , there 's the supertype X509_INFO , which can contain a CRL , a certificate and a corresponding private key||||null
To handle some complex parts of a certificate , there are the types X509_NAME , X509_ATTRIBUTE , X509_EXTENSION and a few more||||null
is automatically called||||whenever a session is removed by the SSL engine
SSL_CTX_sess_set_remove_cb_APIName sets the callback function , which||||null
the operation can be very slow||||if a BIO contains a lot of data and it is read in small chunks
Every read from a read write memory BIO will remove the data just read with an internal copy operation||||null
d2i_Netscape_RSA_APIName , i2d_Netscape_RSA_APIName decode and encode an RSA private key in NET format||||null
The data encoded by the private key functions is unencrypted and offers no private key security||||null
The usage of all of these functions is similar to the d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
The NET format functions are present to provide compatibility with certain very old software||||null
RSA_private_decrypt_APIParam_5 RSA_public_encrypt_APIParam_5 denotes one of the following modes||||null
PKCS # 1 v1 .5 padding||||null
This currently is the most widely used mode||||null
RSA_public_encrypt_APIName encrypts the RSA_public_encrypt_APIParam_1 bytes at RSA_public_encrypt_APIParam_2 using the public key RSA_public_encrypt_APIParam_4 and stores the ciphertext in RSA_public_encrypt_APIParam_3||||null
This mode is recommended for all new applications||||null
The i2d_RSAPrivateKey_APIParam_1 i2d_RSA_PUBKEY_APIParam_1 d2i_RSAPublicKey_APIParam_1 d2i_RSAPrivateKey_APIParam_1 d2i_RSA_PUBKEY_APIParam_1 i2d_RSAPublicKey_APIParam_1 structure passed to the private key encoding functions should have all the PKCS # 1 private key components present||||null
The random number generator must be seeded prior to calling RSA_public_encrypt_APIName||||null
RSA_private_decrypt_APIParam_5 is the padding mode that was used to encrypt the data||||null
RSA_private_decrypt_APIName returns the size of the recovered plaintext||||null
PKCS # 1 v1 .5 padding with an SSL-specific modification that denotes that the server is SSL3 capable||||null
EME-OAEP as defined in PKCS # 1 v2 .0 with SHA-1 , MGF1 and an empty encoding parameter||||null
On error, -1 is returned||||null
This format has some severe security weaknesses and should be avoided||||if possible
the error codes can be obtained by ERR_get_error_APIName||||null
RSA_private_decrypt_APIName decrypts the RSA_private_decrypt_APIParam_1 bytes at RSA_private_decrypt_APIParam_2 using the private key RSA_private_decrypt_APIParam_4 and stores the plaintext in RSA_private_decrypt_APIParam_3||||null
The function SSL_CONF_CTX_free_APIName frees up the context SSL_CONF_CTX_free_APIParam_1||||null
SSL_CONF_CTX_free_APIName does not return a value||||null
SSL_CONF_CTX_new_APIName returns either the newly allocated SSL_CONF_CTX_new_APIParam_0 structure or NULL if an error occurs||||null
This is an inherent weakness in the PKCS # 1 v1 .5 padding design||||null
ERR_remove_thread_state and ERR_remove_state_APIName return no value||||null
The function SSL_CONF_CTX_new_APIName allocates and initialises an SSL_CONF_CTX_new_APIParam_0 structure for use with the SSL_CONF functions||||null
The pointer to the SSL_CTX object is returned||||null
SSL_get_SSL_CTX_APIName returns a pointer to the SSL_CTX object, from which SSL_get_SSL_CTX_APIParam_1 was created with SSL_new_APIName||||null
The following return values can occur||||null
Decryption failures in the RSA_PKCS1_PADDING mode leak information which can potentially be used to mount a Bleichenbacher padding oracle attack||||null
SSL_set_fd_APIParam_2 will typically be the socket file descriptor of a network connection||||null
SSL_set_fd_APIName sets the file descriptor SSL_set_fd_APIParam_2 as the input/output facility for the TLS/SSL side of SSL_set_fd_APIParam_1||||null
The operation failed||||null
Check the error stack to find out why||||null
The operation succeeded||||null
BN_rand_APIName generates a cryptographically strong pseudo-random number of BN_rand_APIParam_2 in length and stores it in BN_rand_APIParam_1||||null
The value of BN_rand_APIParam_2 must be zero or greater||||null
If BN_rand_APIParam_2 is less than zero, or too small to accomodate the requirements specified by the BN_rand_APIParam_3 and BN_rand_APIParam_4 parameters, an error is returned||||null
The functions return 1 on success, 0 on error||||null
SSL_set_rfd_APIName and SSL_set_wfd_APIName perform the respective action , but only for the read channel or the write channel , which can be set independently||||null
they must be freed||||when threads are terminated in order to avoid memory leaks
||||null
BN_pseudo_rand_APIName does the same , but pseudo-random numbers generated by this function are not necessarily unpredictable||||null
The error codes can be obtained by ERR_get_error_APIName||||null
BIO_free_APIName will be called||||If there was already a BIO connected to SSL_set_fd_APIParam_1 SSL_set_rfd_APIParam_1 SSL_set_wfd_APIParam_1
The PRNG must be seeded prior to calling BN_rand_APIName or BN_rand_range_APIName||||null
the number will be odd||||If BN_rand_APIParam_4 is true
These functions generate the ASN1 encoding of a string in an ASN1_generate_v3_APIParam_0 ASN1_generate_nconf_APIParam_0 structure||||null
The DSA_sign_APIParam_1 DSA_verify_APIParam_1 parameter is ignored||||null
the most significant bit of the random number can be zero||||If BN_rand_APIParam_3 is -1
ASN1_generate_nconf_APIName and ASN1_generate_v3_APIName return the encoded data as an ASN1_generate_nconf_APIParam_0 ASN1_generate_v3_APIParam_0 structure or NULL if an error occurred||||null
BN_pseudo_rand_range_APIName does the same , but is based on BN_pseudo_rand_APIName , and hence numbers generated by it are not necessarily unpredictable||||null
The error codes that can be obtained by ERR_get_error_APIName||||null
DSA_sign_APIName and DSA_sign_setup_APIName return 1 on success, 0 on error||||null
The PRNG must be seeded before DSA_sign_APIName is called||||null
The error codes can be obtained by ERR_get_error_APIName||||null
ASN1_generate_v3_APIParam_1 ASN1_generate_nconf_APIParam_1 contains the string to encode ASN1_generate_nconf_APIParam_2 or ASN1_generate_v3_APIParam_2 contains the optional configuration information where additional strings will be read from||||null
BN_rand_range_APIName generates a cryptographically strong pseudo-random number BN_rand_range_APIParam_1 BN_pseudo_rand_range_APIParam_1 BN_pseudo_rand_APIParam_1 in the range 0 < = BN_rand_range_APIParam_1 BN_pseudo_rand_range_APIParam_1 BN_pseudo_rand_APIParam_1 < BN_rand_range_APIParam_2 BN_pseudo_rand_range_APIParam_2||||null
pseudo-random numbers generated by this function can be used for non-cryptographic purposes and for certain purposes in cryptographic protocols , but usually not for key generation etc||||null
EVP_PKEY_CTX_dup_APIName duplicates the context EVP_PKEY_CTX_dup_APIParam_1||||null
DSA_verify_APIName returns 1 for a valid signature, 0 for an incorrect signature and -1 on error||||null
EVP_PKEY_CTX_free_APIName frees up the context EVP_PKEY_CTX_free_APIParam_1||||null
EVP_PKEY_CTX_free_APIName does not return a value||||null
ASN1_generate_v3_APIParam_2 or ASN1_generate_nconf_APIParam_2 can be set to NULL||||if no additional configuration will be used
EVP_PKEY_CTX_new_APIName, EVP_PKEY_CTX_new_id_APIName, EVP_PKEY_CTX_dup_APIName returns either the newly allocated EVP_PKEY_CTX_dup_APIParam_1 structure of NULL if an error occurred||||null
The function SSL_CONF_CTX_set1_prefix_APIName sets the command prefix of SSL_CONF_CTX_set1_prefix_APIParam_1 to SSL_CONF_CTX_set1_prefix_APIParam_2||||null
The EVP_PKEY_CTX_new_APIName function allocates public key algorithm context using the algorithm specified in EVP_PKEY_CTX_new_APIParam_1 and ENGINE EVP_PKEY_CTX_new_APIParam_2||||null
ASN1_generate_nconf_APIParam_2 will typically come from a config file wherease ASN1_generate_v3_APIParam_2 is obtained from an ASN1_generate_v3_APIParam_2 structure which will typically be used by X509 v3 certificate extension functions||||null
The EVP_PKEY_CTX_new_id_APIName function allocates public key algorithm context using the algorithm specified by EVP_PKEY_CTX_new_id_APIParam_1 and ENGINE EVP_PKEY_CTX_new_id_APIParam_2||||null
SSL_CONF_CTX_set1_prefix_APIName returns 1 for success and 0 for failure||||null
Command prefixes alter the commands recognised by subsequent SSL_CTX_cmd_APIName calls||||null
BN_BLINDING_free_APIName frees the BN_BLINDING_free_APIParam_1 structure||||null
BN_BLINDING_thread_id_APIName provides access to the BN_BLINDING_thread_id_APIParam_0 object within the BN_BLINDING_thread_id_APIParam_1 structure||||null
BN_BLINDING_new_APIName returns the newly allocated BN_BLINDING_new_APIParam_0 structure or NULL in case of an error||||null
BN_BLINDING_get_flags_APIName returns the currently set BN_BLINDING_get_flags_APIParam_1 flags||||null
BN_BLINDING_new_APIName allocates a new BN_BLINDING_new_APIParam_0 structure and copies the BN_BLINDING_new_APIParam_1 and BN_BLINDING_new_APIParam_2 values into the newly created BN_BLINDING_new_APIParam_0 object||||null
BN_BLINDING_thread_id_APIName returns a pointer to the thread id object within a BN_BLINDING_thread_id_APIParam_1 object||||null
BN_BLINDING_convert_APIName and BN_BLINDING_invert_APIName are wrapper functions for BN_BLINDING_convert_ex_APIName and BN_BLINDING_invert_ex_APIName with BN_BLINDING_convert_ex_APIParam_2 BN_BLINDING_invert_ex_APIParam_2 set to NULL||||null
BN_BLINDING_create_param_APIName returns the newly created BN_BLINDING_create_param_APIParam_1 parameters or NULL on error||||null
EVP_MD_CTX_init_APIName initializes digest context EVP_MD_CTX_init_APIParam_1||||null
BN_BLINDING_update_APIName, BN_BLINDING_convert_APIName, BN_BLINDING_invert_APIName, BN_BLINDING_convert_ex_APIName and BN_BLINDING_invert_ex_APIName return 1 on success and 0 if an error occurred||||null
EVP_MD_CTX_create_APIName allocates, initializes and returns a digest context||||null
The EVP digest routines are a high level interface to message digests||||null
locking||||if needed for multi-threaded use
This is to help users provide proper||||null
EVP_DigestInit_ex_APIParam_1 must be initialized before calling this function||||null
The EVP_PKEY_CTX_new_id_APIName function is normally used||||when no EVP_PKEY_CTX_new_id_APIParam_0 structure is associated with the operations , during parameter generation of key genration for some algorithms
The `` thread id '' object of a newly allocated BN_BLINDING_thread_id_APIParam_1 structure is initialised to the thread id in which BN_BLINDING_new_APIName was called||||null
EVP_DigestInit_ex_APIName sets up digest context EVP_DigestInit_ex_APIParam_1 to use a digest EVP_DigestInit_ex_APIParam_2 from ENGINE EVP_DigestInit_ex_APIParam_3||||null
EVP_DigestInit_ex_APIParam_2 will typically be supplied by a functionsuch as EVP_sha1_APIName||||null
EVP_DigestUpdate_APIName hashes EVP_DigestUpdate_APIParam_3 bytes of data at EVP_DigestUpdate_APIParam_2 into the digest context EVP_DigestUpdate_APIParam_1||||null
This function can be called several times on the same EVP_DigestUpdate_APIParam_1 to hash additional data||||null
EVP_MD_CTX_copy_ex_APIName can be used to copy the message digest state from EVP_MD_CTX_copy_ex_APIParam_2 to EVP_MD_CTX_copy_ex_APIParam_1||||null
EVP_MD_CTX_cleanup_APIName cleans up digest context EVP_MD_CTX_cleanup_APIParam_1 , EVP_MD_CTX_cleanup_APIName should be called after a digest context is no longer needed||||null
for files , `` SSL '' is set||||if the prefix
command names such as `` SSLProtocol '' , `` SSLOptions '' etc are recognised instead of `` Protocol '' and `` Options ''||||null
it is set to 1||||If BN_rand_APIParam_3 is 0
and if BN_rand_APIParam_3 is 1 , the two most significant bits of the number will be set to 1 , so that the product of two such random numbers will always have 2 * 2*BN_rand_APIParam_2 length||||null
the BN_BLINDING_new_APIParam_1 and BN_BLINDING_new_APIParam_2 or , after specific number of uses and , by re-creating the blinding parameters||||if the necessary parameters are set
BN_BLINDING_update_APIName updates the BN_BLINDING_update_APIParam_1 parameters by squaring||||null
Similarly the prefix is ''||||for command lines if
-- ssl - '' '' -- ssl-no_tls1_2 '' is recognised instead of '' - no_tls1_2 ''||||null
EVP_MD_CTX_copy_ex_APIParam_1 must be initialized before calling this function||||null
EVP_MD_CTX_md_APIName returns the EVP_MD_CTX_md_APIParam_1 structure corresponding to the passed EVP_MD_CTX_md_APIParam_1||||null
EVP_DigestFinal_APIName is similar to EVP_DigestFinal_ex_APIName except the digest context EVP_DigestFinal_APIParam_1 EVP_DigestFinal_ex_APIParam_1 is automatically cleaned up||||null
EVP_dss_APIName and EVP_dss1_APIName return EVP_dss_APIParam_0 EVP_dss1_APIParam_0 structures for SHA and SHA1 digest algorithms but using DSS  for the signature algorithm||||null
EVP_MD_CTX_copy_ex_APIName returns 1 if successful or 0 for failure||||null
EVP_MD_CTX_copy_APIName is similar to EVP_MD_CTX_copy_ex_APIName except the destination EVP_MD_CTX_copy_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 does not have to be initialized||||null
EVP_MD_CTX_destroy_APIName cleans up digest context EVP_MD_CTX_destroy_APIParam_1 and frees up the space allocated to EVP_MD_CTX_destroy_APIName , EVP_MD_CTX_destroy_APIName should be called only on a context created using EVP_MD_CTX_create_APIName||||null
EVP_DigestInit_ex_APIName, EVP_DigestUpdate_APIName and EVP_DigestFinal_ex_APIName return 1 for success and 0 for failure||||null
EVP_md_null_APIName is a `` null '' message digest that does nothing||||null
ie the hash it returns is of zero length||||null
there is no need to use these pseudo-digests in OpenSSL 1.0.0 and later , they are however retained for compatibility||||null
EVP_MD_size_APIName, EVP_MD_block_size_APIName, EVP_MD_CTX_size_APIName and EVP_MD_CTX_block_size_APIName return the digest or block size in bytes||||null
EVP_get_digestbyname_APIName, EVP_get_digestbynid_APIName and EVP_get_digestbyobj_APIName return an EVP_get_digestbyname_APIParam_0 structure when passed a digest name, a digest NID or an ASN1_OBJECT structure respectively||||null
EVP_MD_type_APIName, EVP_MD_pkey_type_APIName and EVP_MD_type_APIName return the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none exists||||null
The digest table must be initialized using , , OpenSSL_add_all_digests_APIName for these functions to work||||null
EVP_MD_block_size_APIName and EVP_MD_CTX_block_size_APIName return the block size of the message digest when passed an EVP_MD_block_size_APIParam_1 or an EVP_MD_CTX_destroy_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_block_size_APIName0 EVP_MD_CTX_block_size_APIName1 EVP_MD_CTX_block_size_APIName2 EVP_MD_CTX_block_size_APIName3 structure||||null
EVP_MD_size_APIName and EVP_MD_CTX_size_APIName return the size of the message digest when passed an EVP_MD_size_APIParam_1 or an EVP_MD_CTX_destroy_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_size_APIName0 EVP_MD_CTX_size_APIName1 EVP_MD_CTX_size_APIName2 EVP_MD_CTX_size_APIName3 structure, ie the size of the hash||||null
EVP_get_digestbyname_APIName, EVP_get_digestbynid_APIName and EVP_get_digestbyobj_APIName return either an EVP_get_digestbyname_APIParam_0 structure or NULL if an error occurs||||null
EVP_DigestInit_APIName behaves in the same way as EVP_DigestInit_ex_APIName except the passed context EVP_DigestInit_APIParam_1 EVP_DigestInit_ex_APIParam_1 does not have to be initialized , and it always uses the default digest implementation||||null
This is useful||||if large amounts of data are to be hashed which only differ in the last few bytes
New applications should use the SHA2 digest algorithms such as SHA256||||null
EVP_md_null_APIName, EVP_md2_APIName, EVP_md5_APIName, EVP_sha_APIName, EVP_sha1_APIName, EVP_dss_APIName, EVP_dss1_APIName, EVP_mdc2_APIName and EVP_ripemd160_APIName return pointers to the corresponding EVP_MD structures||||null
The other digest algorithms are still in common use||||null
This is because the code becomes transparent to the digest used and much more flexible||||null
The functions EVP_DigestInit_APIName , EVP_DigestFinal_APIName and EVP_MD_CTX_copy_APIName are obsolete but are retained to maintain compatibility with existing code||||null
Stack allocation of EVP_MD_CTX structures is common||||null
For most applications the EVP_DigestInit_ex_APIParam_3 parameter to EVP_DigestInit_ex_APIName will be set to NULL to use the default digest implementation||||null
Applications wishing to avoid this should use EVP_MD_CTX_create_APIName instead||||null
SSL_alert_type_string_APIName returns a one letter string indicating the type of the alert specified by SSL_alert_type_string_APIParam_1||||null
SSL_alert_type_string_long_APIName returns a string indicating the type of the alert specified by SSL_alert_type_string_long_APIParam_1||||null
SSL_alert_desc_string_long_APIName returns a string describing the reason of the alert specified by SSL_alert_desc_string_long_APIParam_1||||null
SSL_alert_desc_string_APIName returns a two letter string as a short form describing the reason of the alert specified by SSL_alert_desc_string_APIParam_1||||null
The `` close notify '' alert is sent as a warning alert||||null
In OpenSSL 0.9.7 and later||||if digest contexts are not cleaned up after use memory leaks will occur
The alert is sent as a special message and does not influence the normal data stream||||null
This will cause binary compatibility issues||||if the size of EVP_MD_CTX structure changes
Other examples for non-fatal errors are certificate errors||||null
The following strings can occur for SSL_alert_type_string_APIName or SSL_alert_type_string_long_APIName||||null
A fatal alert always leads to a connection abort||||null
The following strings can occur for SSL_alert_desc_string_APIName or SSL_alert_desc_string_long_APIName||||null
Several alert messages must be sent as fatal alert messages as specified by the TLS RFC||||null
This indicates that no support is available for this alert type||||null
A warning alert is sent||||when a non-fatal error condition occurs
The connection shall be closed||||null
The EVP_MD_CTX_destroy_APIParam_1 EVP_MD_block_size_APIParam_1 EVP_MD_size_APIParam_1 EVP_DigestFinal_APIParam_1 EVP_DigestUpdate_APIParam_1 EVP_DigestFinal_ex_APIParam_1 EVP_MD_CTX_init_APIParam_1 EVP_MD_CTX_copy_ex_APIParam_1 EVP_DigestInit_APIParam_1 EVP_MD_CTX_md_APIParam_1 EVP_MD_block_size_APIParam_10 EVP_MD_block_size_APIParam_11 EVP_MD_block_size_APIParam_12 EVP_MD_block_size_APIParam_13 EVP_MD_block_size_APIParam_14 interface to message digests should almost always be used in preference to the low level interfaces||||null
The receiving side may cancel the connection on reception of a warning alert on it discretion||||null
Probably SSL_alert_type_string_APIParam_1 SSL_alert_desc_string_APIParam_1 SSL_alert_desc_string_long_APIParam_1 SSL_alert_type_string_long_APIParam_1 does not contain a correct alert message||||null
New applications should use EVP_DigestInit_ex_APIName , EVP_DigestFinal_ex_APIName and EVP_MD_CTX_copy_ex_APIName||||null
This is a warning alert||||null
An inappropriate message was received||||null
This message is always fatal||||null
This alert is returned if a record is received with an incorrect MAC||||null
it sends an alert||||When one side of an SSL/TLS communication wants to inform the peer about a special situation
The decompression function received improper input||||null
This alert is always fatal and should never be observed in communication between proper implementations||||null
This message is always fatal||||null
EVP_md2_APIName, EVP_md5_APIName, EVP_sha_APIName, EVP_sha1_APIName, EVP_sha224_APIName, EVP_sha256_APIName, EVP_sha384_APIName, EVP_sha512_APIName, EVP_mdc2_APIName and EVP_ripemd160_APIName return EVP_md5_APIName0 EVP_md5_APIName1 EVP_md5_APIName2 EVP_md5_APIName3 EVP_md5_APIName4 EVP_md5_APIName5 EVP_md5_APIName6 EVP_md5_APIName7 EVP_md5_APIName8 EVP_md5_APIName9 structures for the MD2, MD5, SHA, SHA1, SHA224, SHA256, SHA384, SHA512, MDC2 and RIPEMD160 digest algorithms respectively||||null
This is a fatal error||||null
A certificate was of an unsupported type||||null
A certificate was corrupt , contained signatures that did not verify correctly , etc||||null
A certificate was revoked by A certificate signer||||null
A client , that was asked to send a certificate , does not send a certificate||||null
A certificate has expired or is not currently valid||||null
This is always fatal||||null
Some other issue arose in processing the certificate , rendering it unacceptable||||null
This message is always fatal||||null
This message is always fatal||||null
A field in the handshake was out of range or inconsistent with other fields||||null
This message is always fatal||||null
Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available||||null
This message is always fatal||||null
This message is always fatal||||null
This message is always fatal||||null
A TLSCiphertext decrypted in an invalid way||||null
A message could not be decoded||||null
This message is always fatal||||null
The protocol version the client has attempted to negotiate is recognized , but not supported||||null
This message is always fatal||||null
This message is always fatal||||null
A negotiation not in compliance with export restrictions was detected||||null
the sender decided not to proceed with negotiation||||when access control was applied
A valid certificate was received , but||||null
This alert should be followed by a close_notify||||null
This handshake is being canceled for some reason unrelated to a protocol failure||||null
A handshake cryptographic operation failed , including being unable to correctly verify a signature , decrypt a key exchange , or validate a finished message||||null
attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method||||null
This message is generally a warning||||null
A TLSCiphertext record was received which had a length more than 2 ^ 14 +2048 bytes , or a record decrypted to a TLSCompressed record with more than 2 ^ 14 +1024 bytes||||null
A valid certificate chain or partial chain was received , but the certificate was not accepted , trusted CA||||null
This message is always a warning||||null
An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue||||null
These functions decode and encode an ASN1 OBJECT IDENTIFIER||||null
either it was n't an even multiple of the block length or its padding values||||when checked , were n't correct
This indicates that no description is available for this alert type||||null
Probably SSL_alert_type_string_APIParam_1 SSL_alert_desc_string_APIParam_1 SSL_alert_desc_string_long_APIParam_1 SSL_alert_type_string_long_APIParam_1 does not contain a correct alert message||||null
Either of these would normally lead to renegotiation||||null
The ENGINE_new_APIName function returns a structural reference to a new  ENGINE object||||null
Returned instead of handshake_failure||||when a negotiation has failed specifically
Sent by the server to indicate that the server does not recognize a PSK identity or an SRP identity||||null
One case where this would be appropriate would be where a server has spawned a process to satisfy a request||||null
Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking||||null
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
the process might receive security parameters at startup and it might be difficult to communicate changes to these parameters after that point||||null
the recipient should respond with this alert||||when that is not appropriate
at that point , the original requester can decide||||null
There are other ENGINE API functions that return structural references such as||||null
ENGINE_by_id_APIName , ENGINE_get_first_APIName , ENGINE_get_last_APIName , ENGINE_get_next_APIName , ENGINE_get_prev_APIName||||null
All structural references should be released by a corresponding to call to the ENGINE_free_APIName function||||null
If it returns a functional reference to an ENGINE, it will also cache another reference to speed up processing future queries||||null
At this point it is important to mention an important API function||||null
The first thing to consider is||||null
These objects act as containers for implementations of cryptographic algorithms , and support a reference-counted mechanism to allow them to be dynamically loaded in and out of the running application||||null
That 's all that 's required||||null
The following code illustrates how to approach this||||null
In the latter case , OpenSSL will from on behave the way it used to before the ENGINE API existed||||null
The following code illustrates how this can work||||null
itself will only actually be cleaned up and deallocated||||when the last structural reference is released
The ENGINE object||||null
one should obtain a new reference||||when making copies of an ENGINE pointer if the copies will be used independently
If no ENGINE should  be used, it will return NULL and the caller will operate with a NULL ENGINE handle - this usually equates to using the conventional software implementation||||null
As mentioned , functional references exist||||when the cryptographic functionality of an ENGINE is required to be available
When a default ENGINE is requested for a given abstraction/algorithm/mode, ), a "get_default" call will be made to the ENGINE subsystem to process the corresponding state table and return a functional reference to an initialised ENGINE whose implementation should be used||||null
ENGINE_set_default_RSA_APIName does the same job as ENGINE_register_RSA_APIName except that it also sets the state table 's cached response for the `` get_default '' query||||null
It should also be noted that many ENGINE API function calls that accept a structural reference will internally obtain another reference - typically this happens whenever the supplied ENGINE will be needed by OpenSSL after the function has returned||||null
So the first consideration is - this is controlled by calling the various `` load '' functions , eg||||null
Having called any of these functions , ENGINE objects would have been dynamically allocated and populated with these implementations and linked into OpenSSL 's internal linked list||||null
Due to the modular nature of the ENGINE API , pointers to ENGINEs need to be treated as handles - ie not only as pointers , but also as references to the underlying ENGINE object||||null
To clarify a particular function 's handling of references , one should always consult that function 's documentation `` man '' page , or failing that the openssl/engine.h header file includes some hints||||null
This section will explain the basic things an application programmer should support to make the most useful elements of the ENGINE functionality available to the user||||null
the structural reference passed to it||||if part of the function 's job is to do so
In a similar way , some functions will automatically release||||null
ENGINE they want used||||if any is to be used at all
Some applications will want to allow the user to specify exactly which||||null
A functional reference can be obtained in one of two ways||||null
In the case of abstractions like EVP_CIPHER , where implementations are indexed by ` nid ' , these flags and cached-responses are distinct for each ` nid ' value||||null
This mechanism is entirely based on the use of name-value pairs and assumes ASCII input -LRB- no unicode or UTF for now !||||null
This behaviour can also be changed||||null
if the ENGINE_TABLE_FLAG_NOINIT flag is set , no attempted initialisations will take place, instead the only way for the state table to return a non-NULL ENGINE to the "get_default" query will be if one is expressly set in the table||||null
openssl/engine.h defines an index , ENGINE_CMD_BASE , that all control commands implemented by ENGINEs should be numbered from||||null
from an existing structural reference to the required ENGINE , or by asking OpenSSL for the default operational ENGINE for a given cryptographic purpose||||null
These implementations are registered in the tables and indexed by an ` nid ' value , , and ENGINEs can support arbitrarily many of them||||null
For each supported abstraction , the ENGINE code maintains an internal table of state to control which implementations are available for a given abstraction and which should be used by default||||null
This function should initialise the ENGINE  and set it as the default for everything except RAND and return a boolean success or failure||||null
we assume the user is only supplying commands specific to the given ENGINE so we set this to FALSE||||null
Any command value lower than this symbol is considered a `` generic '' command is handled directly by the OpenSSL core routines||||null
In the case of other abstractions like RSA , DSA , etc , there is only one `` algorithm '' so all implementations implicitly register using the same ` nid ' index||||null
any ENGINE API functionality that knows it requires cleanup can register its cleanup details to be called||||during ENGINE_cleanup_APIName
This mechanism uses an internal callback registration table so that||||null
There is a mechanism supported by the ENGINE framework that allows each ENGINE implementation to define an arbitrary set of configuration `` commands '' and expose them to OpenSSL and any applications based on OpenSSL||||null
It is using these `` core '' control commands that one can discover the the control commands implemented by a given ENGINE , specifically the commands||||null
ENGINE_CTRL_GET_FLAGS returns a bitwise-OR'd mask of the following possible values||||null
It is possible to discover at run-time the names , numerical-ids , descriptions and input parameters of the control commands supported by an ENGINE using a structural reference||||null
Likewise , it will cache a NULL response||||if no ENGINE was available so that future queries wo n't repeat the same iteration unless the state table changes
The ENGINE API and internal architecture is currently being reviewed||||null
DH_generate_key_APIName returns 1 on success, 0 otherwise||||null
Note that the string-pairs used for control commands consist of a command `` name '' followed by the command `` parameter '' - the parameter could be NULL in some cases but the name can not||||null
The fact that ENGINEs are made visible to OpenSSL does not mean they are `` registered '' or called into use by OpenSSL automatically - that behaviour is something for the application to control||||null
The error codes can be obtained by ERR_get_error_APIName||||null
It is otherwise identical to the function SMIME_write_PKCS7_APIName||||null
PEM_write_bio_PKCS7_stream_APIName outputs a PKCS7 structure in PEM format||||null
Whilst these commands are automatically processed by the OpenSSL framework code , they use various properties exposed by each ENGINE to process these queries||||null
DH_compute_key_APIName returns the size of the shared secret on success, -1 on error||||null
Slated for possible release in 0.9.8 is support for transparent loading of `` dynamic '' ENGINEs||||null
RAND_add_APIName mixes the RAND_add_APIParam_2 bytes at RAND_add_APIParam_1 into the PRNG state||||null
By calling DH_compute_key_APIName , these are combined with the other party 's public value to compute the shared key||||null
it should be used by default for all RSA , DSA||||If it is available
and symmetric cipher operations , otherwise OpenSSL should use its builtin software as per usual||||null
Here we 'll assume an application has been configured by its user or admin to want to use the `` ACME '' ENGINE||||if it is available in the version of OpenSSL the application was compiled with
PEM_write_bio_PKCS7_stream_APIName returns 1 for success or 0 for failure||||null
This function is effectively a version of the PEM_write_bio_PKCS7_APIName supporting streaming||||null
It is also possible for the application to dynamically interrogate the loaded ENGINE implementations for the names , descriptions , and input flags of their available `` control commands '' , providing a more flexible configuration scheme||||null
Suitable input comes from user interaction and certain hardware events||||null
This approach allows ENGINE_cleanup_APIName to clean up after any ENGINE functionality at all that your program uses , yet does n't automatically create linker dependencies to all possible ENGINE functionality - only the cleanup callbacks required by the functionality you do use will be required by the linker||||null
DH_generate_key_APIName performs the first step of a Diffie-Hellman key exchange by generating private and public DH values||||null
The other functions do not return values||||null
RAND_add_APIName may be called with sensitive data such as user entered passwords||||null
The seed values can not be recovered from the PRNG output||||null
the function to add a new ENGINE to OpenSSL's internal list is ENGINE_add_APIName - if this function returns success, OpenSSL will have stored a new structural reference internally so the caller is still responsible for freeing their own reference with ENGINE_free_APIName when they are finished with it||||null
It adds the current contents of the screen to the PRNG||||null
All except ENGINE_CTRL_GET_FLAGS return the string length of a command name or description, or populate a supplied character buffer with a copy of the command name or description||||null
Note that some control commands are defined by OpenSSL itself and it will intercept and handle these control commands on behalf of the ENGINE , ie the ENGINE 's ctrl_APIName handler is not used for the control command||||null
The RAND_screen_APIName function is available for the convenience of Windows programmers||||null
that implement RSA_METHOD will be passed to ENGINE_init_APIName and||||if any of those succeed , that ENGINE will be set as the default for RSA use from on
Let illustrate by example||||null
the next time OpenSSL tries to set up an RSA key , any bundled ENGINEs||||null
Details about sources of randomness and how to estimate their entropy can be found in the literature , eg RFC 1750||||null
a function after initialisation||||null
RAND_status_APIName and RAND_event_APIName return 1 if the PRNG has been seeded with enough data, 0 otherwise||||null
The RAND_add_APIParam_3 argument is an estimate of how much randomness is contained in RAND_add_APIParam_1 , measured in bytes||||null
It should be noted that both methods can not be used on servers that run without user interaction||||null
For applications that can catch Windows events , seeding the PRNG by calling RAND_event_APIName is a significantly better source of randomness||||null
Others may prefer to load all support and have OpenSSL automatically use at run-time any ENGINE that is able to successfully initialise - ie to assume that this corresponds to acceleration hardware attached to the machine or some such thing||||null
Note that ENGINE_ctrl_cmd_string_APIName accepts a boolean argument that can relax the semantics of the function - if set non-zero ,it will only return failure if the ENGINE supported the given command name but failed while executing it, if the ENGINE doesn't support the command name ,it will simply return success without doing anything||||null
Each state table has a flag to note||||null
An ENGINE has 3 properties it exposes that can affect how this behaves||||null
the ENGINE_get_next_APIName and ENGINE_get_prev_APIName functions are used for iterating across the internal ENGINE list - they will return a new structural reference to the next  ENGINE in the list or NULL if at the end  of the list, but in either case the structural reference passed to the function is released on behalf of the caller||||null
applications determinie||||if an ENGINE supports certain specific commands it might want to use
These commands are supported in the discovery mechanisms simply to allow||||null
The CMS_uncompress_APIParam_2 parameter will normally be set to NULL||||null
The CMS_uncompress_APIParam_2 parameter is used in the rare case where the compressed content is detached||||null
it can supply a ctrl_APIName handler , it can specify ENGINE_FLAGS_MANUAL_CMD_CTRL in the ENGINE 's flags , and it can expose an array of control command descriptions||||null
This would allow ENGINE implementations to be provided independently of OpenSSL libraries and/or OpenSSL-based applications , and would also remove any requirement for applications to explicitly use the `` dynamic '' ENGINE to bind to shared-library implementations||||null
all other commands will fail , otherwise||||If the ENGINE 's array of control commands is empty
Thus , , this increases the uncertainty about the state and makes the PRNG output less predictable||||if the data at RAND_add_APIParam_1 are unpredictable to an adversary
ENGINE_CTRL_GET_FIRST_CMD_TYPE returns the identifier of the first command supported by the ENGINE, ENGINE_GET_NEXT_CMD_TYPE takes the identifier of a command supported by the ENGINE and returns the next command identifier or fails if there are no more, ENGINE_CMD_FROM_NAME takes a string name for a command and returns the corresponding identifier or fails if no such command name exists, and the remaining commands take a command identifier and return properties of the corresponding commands||||null
`` INTERNAL '' commands are not intended to be exposed to text-based configuration by applications , administrations , users , etc These can support arbitrary operations via ENGINE_ctrl_APIName , including passing to and/or from the control commands data of any arbitrary type||||null
any other flags are purely informational to the caller||||If the ENGINE_CMD_FLAG_INTERNAL flag is set
- this flag will prevent the command being usable for any higher-level ENGINE functions such as ENGINE_ctrl_cmd_string_APIName||||null
it will simply pass all these `` core '' control||||If an ENGINE specifies the ENGINE_FLAGS_MANUAL_CMD_CTRL flag
commands directly to the ENGINE 's ctrl_APIName handler , so it is up to the ENGINE to reply to these `` discovery '' commands itself||||null
However||||if the user is expected to know which ENGINE device he/she is using applications may not need to concern themselves with discovering the supported control commands and simply prefer to pass settings into ENGINEs exactly as they are provided by the user
There are probably numerous other ways in which applications may prefer to handle things , so we will simply illustrate the consequences as they apply to a couple of simple cases and leave developers to consider these and the source code to openssl 's builtin utilities as guides||||null
it should be used||||if there is an ENGINE that implements it and can be initialised
The second way to get a functional reference is by asking OpenSSL for a default implementation for a given task , eg by ENGINE_get_default_RSA_APIName , ENGINE_get_default_cipher_engine_APIName , etc These are discussed in the next section , , such as RSA , DSA , EVP_CIPHER_CTX , etc||||null
Here we 'll assume we want to load and register all ENGINE implementations bundled with OpenSSL , such that for any cryptographic algorithm required by OpenSSL -||||null
instantiating new ENGINEs , iterating across OpenSSL 's internal linked-list of loaded ENGINEs , reading information about an ENGINE , etc Essentially a structural reference is sufficient||||if you only need to query or manipulate the data of an ENGINE implementation rather than use an ENGINE implementation functionality
This basic type of reference is used for||||null
it is necessary to use the ENGINE_cleanup_APIName function to correspondingly cleanup before program exit , if the caller wishes to avoid memory leaks||||If no ENGINE API functions are called at all in an application , there are no inherent memory leaks to worry about from the ENGINE functionality , however if any ENGINEs are loaded
calls||||if an application does not call any ENGINE API
OpenSSL maintains an internal linked list of `` visible '' ENGINEs from which it has to operate - at start-up , this list is empty and in fact and it uses static linking against openssl , the resulting application binary will not contain any alternative ENGINE code at all||||null
it is ideal||||if applications want to provide a transparent way for users to provide arbitrary configuration `` directives '' directly to such ENGINEs
-RRB- , so||||null
The cryptographic functionality that can be provided by an ENGINE_set_default_DH_APIParam_1 ENGINE_set_ECDSA_APIParam_1 ENGINE_set_default_APIParam_1 ENGINE_set_default_string_APIParam_1 ENGINE_get_ciphers_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_1 ENGINE_unregister_ECDSA_APIParam_1 ENGINE_get_flags_APIParam_1 ENGINE_get_prev_APIParam_1 ENGINE_register_STORE_APIParam_1 ENGINE_remove_APIParam_1 ENGINE_get_finish_function_APIParam_1 ENGINE_set_ECDSA_APIParam_12 ENGINE_set_ECDSA_APIParam_13 ENGINE_up_ref_APIParam_1 ENGINE_set_ex_data_APIParam_1 ENGINE_register_RAND_APIParam_1 ENGINE_set_ECDSA_APIParam_17 ENGINE_set_ECDSA_APIParam_18 ENGINE_set_default_RAND_APIParam_1 ENGINE_set_default_APIParam_10 ENGINE_set_default_APIParam_11 ENGINE_set_default_APIParam_12 ENGINE_set_default_DSA_APIParam_1 ENGINE_set_default_APIParam_14 ENGINE_set_default_APIParam_15 ENGINE_ctrl_cmd_APIParam_1 ENGINE_set_default_APIParam_17 ENGINE_set_default_APIParam_18 ENGINE_set_default_APIParam_19 ENGINE_set_default_string_APIParam_10 ENGINE_set_default_string_APIParam_11 ENGINE_set_default_string_APIParam_12 ENGINE_register_ECDSA_APIParam_1 ENGINE_set_default_string_APIParam_14 ENGINE_set_default_string_APIParam_15 ENGINE_set_default_string_APIParam_16 ENGINE_load_private_key_APIParam_1 ENGINE_get_ctrl_function_APIParam_1 ENGINE_get_load_privkey_function_APIParam_1 ENGINE_set_name_APIParam_1 ENGINE_get_next_APIParam_1 ENGINE_get_ECDSA_APIParam_1 ENGINE_get_ciphers_APIParam_13 ENGINE_cmd_is_executable_APIParam_1 ENGINE_get_ciphers_APIParam_15 ENGINE_init_APIParam_1 ENGINE_unregister_ciphers_APIParam_1 ENGINE_unregister_DSA_APIParam_1 ENGINE_set_RSA_APIParam_1 ENGINE_get_cipher_APIParam_1 ENGINE_register_ECDH_APIParam_1 ENGINE_register_DH_APIParam_1 ENGINE_get_ECDH_APIParam_1 ENGINE_get_destroy_function_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_15 ENGINE_get_load_pubkey_function_APIParam_16 ENGINE_set_RAND_APIParam_1 ENGINE_unregister_STORE_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_19 ENGINE_unregister_ECDSA_APIParam_10 ENGINE_get_DH_APIParam_1 ENGINE_set_DSA_APIParam_1 ENGINE_unregister_ECDSA_APIParam_13 ENGINE_register_RSA_APIParam_1 ENGINE_unregister_ECDSA_APIParam_15 ENGINE_unregister_ECDSA_APIParam_16 ENGINE_unregister_digests_APIParam_1 ENGINE_unregister_ECDSA_APIParam_18 ENGINE_unregister_ECDSA_APIParam_19 ENGINE_get_flags_APIParam_10 ENGINE_set_default_ECDSA_APIParam_1 ENGINE_set_load_privkey_function_APIParam_1 ENGINE_get_flags_APIParam_13 ENGINE_get_flags_APIParam_14 ENGINE_get_flags_APIParam_15 ENGINE_get_flags_APIParam_16 ENGINE_get_flags_APIParam_17 ENGINE_get_RAND_APIParam_1 ENGINE_get_flags_APIParam_19 ENGINE_set_digests_APIParam_1 ENGINE_set_load_pubkey_function_APIParam_1 ENGINE_get_digest_APIParam_1 ENGINE_set_ctrl_function_APIParam_1 implementation includes the following abstractions||||null
These functions create , manipulate , and use cryptographic modules in the form of ENGINE_set_default_DH_APIParam_1 ENGINE_set_ECDSA_APIParam_1 ENGINE_set_default_APIParam_1 ENGINE_set_default_string_APIParam_1 ENGINE_get_ciphers_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_1 ENGINE_unregister_ECDSA_APIParam_1 ENGINE_get_flags_APIParam_1 ENGINE_get_prev_APIParam_1 ENGINE_register_STORE_APIParam_1 ENGINE_remove_APIParam_1 ENGINE_get_finish_function_APIParam_1 ENGINE_set_ECDSA_APIParam_12 ENGINE_set_ECDSA_APIParam_13 ENGINE_up_ref_APIParam_1 ENGINE_set_ex_data_APIParam_1 ENGINE_register_RAND_APIParam_1 ENGINE_set_ECDSA_APIParam_17 ENGINE_set_ECDSA_APIParam_18 ENGINE_set_default_RAND_APIParam_1 ENGINE_set_default_APIParam_10 ENGINE_set_default_APIParam_11 ENGINE_set_default_APIParam_12 ENGINE_set_default_DSA_APIParam_1 ENGINE_set_default_APIParam_14 ENGINE_set_default_APIParam_15 ENGINE_ctrl_cmd_APIParam_1 ENGINE_set_default_APIParam_17 ENGINE_set_default_APIParam_18 ENGINE_set_default_APIParam_19 ENGINE_set_default_string_APIParam_10 ENGINE_set_default_string_APIParam_11 ENGINE_set_default_string_APIParam_12 ENGINE_register_ECDSA_APIParam_1 ENGINE_set_default_string_APIParam_14 ENGINE_set_default_string_APIParam_15 ENGINE_set_default_string_APIParam_16 ENGINE_load_private_key_APIParam_1 ENGINE_get_ctrl_function_APIParam_1 ENGINE_get_load_privkey_function_APIParam_1 ENGINE_set_name_APIParam_1 ENGINE_get_next_APIParam_1 ENGINE_get_ECDSA_APIParam_1 ENGINE_get_ciphers_APIParam_13 ENGINE_cmd_is_executable_APIParam_1 ENGINE_get_ciphers_APIParam_15 ENGINE_init_APIParam_1 ENGINE_unregister_ciphers_APIParam_1 ENGINE_unregister_DSA_APIParam_1 ENGINE_set_RSA_APIParam_1 ENGINE_get_cipher_APIParam_1 ENGINE_register_ECDH_APIParam_1 ENGINE_register_DH_APIParam_1 ENGINE_get_ECDH_APIParam_1 ENGINE_get_destroy_function_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_15 ENGINE_get_load_pubkey_function_APIParam_16 ENGINE_set_RAND_APIParam_1 ENGINE_unregister_STORE_APIParam_1 ENGINE_get_load_pubkey_function_APIParam_19 ENGINE_unregister_ECDSA_APIParam_10 ENGINE_get_DH_APIParam_1 ENGINE_set_DSA_APIParam_1 ENGINE_unregister_ECDSA_APIParam_13 ENGINE_register_RSA_APIParam_1 ENGINE_unregister_ECDSA_APIParam_15 ENGINE_unregister_ECDSA_APIParam_16 ENGINE_unregister_digests_APIParam_1 ENGINE_unregister_ECDSA_APIParam_18 ENGINE_unregister_ECDSA_APIParam_19 ENGINE_get_flags_APIParam_10 ENGINE_set_default_ECDSA_APIParam_1 ENGINE_set_load_privkey_function_APIParam_1 ENGINE_get_flags_APIParam_13 ENGINE_get_flags_APIParam_14 ENGINE_get_flags_APIParam_15 ENGINE_get_flags_APIParam_16 ENGINE_get_flags_APIParam_17 ENGINE_get_RAND_APIParam_1 ENGINE_get_flags_APIParam_19 ENGINE_set_digests_APIParam_1 ENGINE_set_load_pubkey_function_APIParam_1 ENGINE_get_digest_APIParam_1 ENGINE_set_ctrl_function_APIParam_1 objects||||null
If zlib support is not compiled into OpenSSL ,then CMS_uncompress_APIName will always return an error||||null
The error can be obtained from ERR_get_error_APIName||||null
CMS_uncompress_APIName returns either 1 for success or 0 for failure||||null
The following flags can be passed in the CMS_uncompress_APIParam_4 parameter||||null
The only currently supported compression algorithm is zlib||||null
if the structure indicates the use of any other algorithm ,an error is returned||||null
EVP_DigestSignUpdate_APIName hashes EVP_DigestSignUpdate_APIParam_3 bytes of data at EVP_DigestSignUpdate_APIParam_2 into the signature context EVP_DigestSignUpdate_APIParam_1||||null
The EVP signature routines are a high level interface to digital signatures||||null
This function is currently implemented usig a macro||||null
This function can be called several times on the same EVP_DigestSignUpdate_APIParam_1 to include additional data||||null
The error codes can be obtained from ERR_get_error_APIName||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
EVP_DigestSignFinal_APIName signs the data in EVP_DigestSignFinal_APIParam_1 places the signature in EVP_DigestSignFinal_APIParam_2||||null
EVP_DigestSignInit_APIName EVP_DigestSignUpdate_APIName and EVP_DigestSignaFinal_APIName return 1 for success and 0 or a negative value for failure||||null
The EVP_DigestSignFinal_APIParam_1 EVP_DigestSignInit_APIParam_1 EVP_DigestSignUpdate_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces||||null
This is because the code becomes transparent to the algorithm used and much more flexible||||null
The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify_APIName also applies to CMS_decompress_APIName||||null
In previous versions of OpenSSL there was a link between message digest types and public key algorithms||||null
The call to EVP_DigestSignFinal_APIName internally finalizes a copy of the digest context||||null
This is no longer necessary and the use of clone digest is now discouraged||||null
As a result EVP_PKEY_size_APIName would have to return a value which indicates the maximum possible signature for any set of parameters||||null
See SSL_CIPHER_get_name_APIName for more details||||null
This meant that `` clone '' digests such as EVP_dss1_APIName needed to be used to sign using SHA1 and DSA||||null
SSL_get_current_cipher_APIName returns the cipher actually used or NULL, when no session has been established||||null
This means that calls to EVP_DigestSignUpdate_APIName and EVP_DigestSignFinal_APIName can be called later to digest and sign additional data||||null
For some key types and parameters the random number generator must be seeded or the operation will fail||||null
SSL_get_cipher_APIName and SSL_get_cipher_name_APIName are identical macros to obtain the name of the currently used cipher||||null
The timeout value SSL_CTX_set_timeout_APIParam_2 must be given in seconds||||null
SSL_CTX_get_timeout_APIName returns the currently set timeout value for SSL_CTX_get_timeout_APIParam_1||||null
SSL_get_current_cipher_APIName returns a pointer to an SSL_CIPHER object containing the description of the actually used cipher of a connection established with the SSL_get_current_cipher_APIParam_1 object||||null
the maximum size of the output buffer is written to the EVP_DigestSignFinal_APIParam_3 parameter||||If EVP_DigestSignFinal_APIParam_2 is NULL
SSL_get_cipher_bits_APIName is a macro to obtain the number of secret/algorithm bits used and SSL_get_cipher_version_APIName returns the protocol name||||null
SSL_CTX_set_timeout_APIName sets the timeout for newly created sessions for SSL_CTX_set_timeout_APIParam_1 to SSL_CTX_set_timeout_APIParam_2||||null
The use of EVP_PKEY_size_APIName with these functions is discouraged||||null
Changes of the timeout value do not affect already established sessions||||null
SSL_CTX_set_timeout_APIName returns the previously set timeout value||||null
the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur||||null
All currently supported protocols have the same default timeout value of 300 seconds||||null
SSL_CTX_get_timeout_APIName returns the currently set timeout value||||null
The expiration time of a single session can be modified using the SSL_SESSION_get_time_APIName family of functions||||null
Due to this realization , all sessions behave according to the timeout value valid at the time of the session negotiation||||null
is created , it is assigned a maximum lifetime||||Whenever a new session
The default value for session timeout is decided on a per protocol basis , see SSL_get_default_timeout_APIName||||null
locking_function is needed to perform locking on shared data structures||||null
the session is not reused||||If the actual time is later than creation time plus timeout
They can be useful for debugging||||null
This lifetime is specified by storing the creation time of the session and the timeout value valid at this time||||null
CRYPTO_THREADID_cmp_APIName compares two thread IDs||||null
CRYPTO_lock_APIParam_3 and CRYPTO_lock_APIParam_4 are the file number of the function setting the lock||||null
CRYPTO_THREADID_current_APIName records the currently-executing thread ID into the given CRYPTO_THREADID_current_APIParam_1 object||||null
CRYPTO_THREADID_hash_APIName returns a numeric value usable as a hash-table key||||null
CRYPTO_THREADID_cpy_APIName duplicates a thread ID value||||null
Once threadid_func_APIName is registered , or||||if the built-in default implementation is to be used
To enable this , the following is required||||null
Multi-threaded applications will crash at random||||if it is not set
Three additional callback function , dyn_create_function , dyn_lock_function and dyn_destroy_function||||null
dyn_create_function is needed to create a lock||||null
A structure defined with the data that each lock needs to handle||||null
Additionally , OpenSSL supports dynamic locks , and sometimes , some parts of OpenSSL need it for better performance||||null
CRYPTO_get_new_dynlockid_APIName is used to create locks||||null
struct CRYPTO_dynlock_value has to be defined to contain whatever structure is needed to handle locks||||null
Expired sessions are removed from the internal session cache , , either directly by the application or automatically||||whenever SSL_CTX_flush_sessions_APIName is called
CRYPTO_get_new_dynlockid_APIName will call dyn_create_function for the actual creation||||null
the EVP_DigestSignFinal_APIParam_3 parameter should contain the length of the EVP_DigestSignFinal_APIParam_2 buffer||||If EVP_DigestSignFinal_APIParam_2 is not NULL , before the call
if the call is successful , the signature is written to EVP_DigestSignFinal_APIParam_2 and the amount of data written to EVP_DigestSignFinal_APIParam_3||||null
CRYPTO_destroy_dynlockid_APIName is used to destroy locks||||null
CRYPTO_destroy_dynlockid_APIName will call dyn_destroy_function for the actual destruction||||null
n is the number of the lock as returned from CRYPTO_get_new_dynlockid_APIName||||null
CRYPTO_lock_APIName is used to lock and unlock the locks||||null
mode is a bitfield describing what should be done with the lock||||null
mode can be combined from 1,2,4,8||||null
CRYPTO_num_locks_APIName returns the required number of locks||||null
CRYPTO_get_new_dynlockid_APIName returns the index to the newly created lock||||null
The other functions return no values||||null
Multi-threaded applications might crash at random||||if it is not set
X509_NAME_get_index_by_NID_APIParam_3 X509_NAME_get_index_by_OBJ_APIParam_3 should initially be set to -1||||null
If there are no more entries, -1 is returned||||null
X509_NAME_get_index_by_NID_APIName and X509_NAME_get_index_by_OBJ_APIName retrieve the next index matching X509_NAME_get_index_by_NID_APIParam_2 or X509_NAME_get_index_by_OBJ_APIParam_2 after X509_NAME_get_index_by_NID_APIParam_3 X509_NAME_get_index_by_OBJ_APIParam_3||||null
If X509_NAME_get_index_by_NID_APIParam_2 is invalid  ,then -2 is returned||||null
Multi-threaded applications might crash at random||||if it is not set
dyn_destroy_function is needed to destroy the lock l||||null
X509_NAME_entry_count_APIName returns the total number of entries in X509_NAME_entry_count_APIParam_1||||null
The value returned is an internal pointer which must not be freed||||null
Also , dynamic locks are currently not used internally by OpenSSL , but may do so in the future||||null
X509_NAME_get_entry_APIName retrieves the X509_NAME_get_entry_APIParam_0 from X509_NAME_get_entry_APIParam_1 corresponding to index X509_NAME_get_entry_APIParam_2||||null
The length of the output string written is returned excluding the terminating null||||null
X509_NAME_get_index_by_NID_APIName can also return -2 if the supplied NID is invalid||||null
If X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3 is <NULL> the amount of space needed in X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3  is returned||||null
n. Multi-threaded applications might crash at random||||if it is not set
dyn_lock_function is needed to perform locking off dynamic lock numbered||||null
X509_NAME_get_index_by_NID_APIName and X509_NAME_get_index_by_OBJ_APIName return the index of the next matching entry or -1 if not found||||null
These values are pairwise exclusive , with undefined behaviour||||if misused
Applications which could pass invalid NIDs to X509_NAME_get_index_by_NID_APIName should check for the return value of -2||||null
You can find out||||if OpenSSL was configured with thread support
At most X509_NAME_get_text_by_NID_APIParam_4 X509_NAME_get_text_by_OBJ_APIParam_4 bytes will be written and the text written to X509_NAME_get_text_by_NID_APIParam_3 X509_NAME_get_text_by_OBJ_APIParam_3 will be null terminated||||null
X509_NAME_get_text_by_NID_APIName, X509_NAME_get_text_by_OBJ_APIName retrieve the "text" from the first entry in X509_NAME_get_text_by_NID_APIParam_1 X509_NAME_get_text_by_OBJ_APIParam_1 which matches X509_NAME_get_text_by_NID_APIParam_2 or X509_NAME_get_text_by_OBJ_APIParam_2, if no such entry exists, -1 is returned||||null
Alternatively the NID validity can be determined first by checking OBJ_nid2obj is not NULL||||null
X509_NAME_entry_count_APIName returns the total number of entries||||null
X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName are legacy functions which have various limitations which make X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName of minimal use in practice||||null
These functions implement Montgomery multiplication||||null
X509_NAME_get_text_by_NID_APIName and X509_NAME_get_text_by_OBJ_APIName can only find the first matching entry and will copy the contents of the field verbatim||||null
Acceptable values for X509_NAME_get_entry_APIParam_2 run from 0 to - 1 -RRB-||||null
For a more general solution X509_NAME_get_index_by_NID_APIName or X509_NAME_get_index_by_OBJ_APIName should be used followed by X509_NAME_get_entry_APIName on any matching indices and the various X509_NAME_get_entry_APIParam_0 utility functions on the result||||null
this can be highly confusing||||if the target is a muticharacter string type like a BMPString or a UTF8String
This is usually the exact numeric or pointer-based thread ID used internally , however this also handles the unusual case where pointers are larger than ` long ' variables and the platform 's thread IDs are pointer-based - , mixing is done to attempt to produce a unique numeric value even though it is not as wide as the platform 's true thread IDs||||null
X509_NAME_get_entry_APIName returns an X509_NAME_get_entry_APIParam_1 pointer to the requested entry or NULL if the index is invalid||||null
BN_MONT_CTX_init_APIName initializes an existing uninitialized BN_MONT_CTX_init_APIParam_1||||null
BN_MONT_CTX_new_APIName allocates and initializes a BN_MONT_CTX_init_APIParam_1 structure||||null
BN_MONT_CTX_copy_APIName copies the BN_MONT_CTX_copy_APIParam_1 BN_MONT_CTX_copy_APIParam_2 to BN_MONT_CTX_copy_APIParam_1||||null
BN_mod_mul_montgomery_APIName computes Mont||||null
= BN_mod_mul_montgomery_APIParam_2 * BN_mod_mul_montgomery_APIParam_3 * R ^ -1 and places the result in BN_mod_mul_montgomery_APIParam_1||||null
BN_from_montgomery_APIName performs the Montgomery reduction BN_from_montgomery_APIParam_1 = BN_from_montgomery_APIParam_2 * R ^ -1||||null
Newer applications should use a more modern algorithm such as PBKDF2 as defined in PKCS # 5v2 .1 and provided by PKCS5_PBKDF2_HMAC||||null
BN_MONT_CTX_set_APIName sets up the BN_MONT_CTX_set_APIParam_1 structure from the modulus BN_MONT_CTX_set_APIParam_2 by precomputing its inverse and a value R||||null
BN_to_montgomery_APIName is a macro||||null
BN_MONT_CTX_new_APIName returns the newly allocated BN_MONT_CTX_new_APIParam_0, and NULL on error||||null
BN_MONT_CTX_init_APIName and BN_MONT_CTX_free_APIName have no return values||||null
For all functions , BN_MONT_CTX_init_APIParam_1 BN_MONT_CTX_set_APIParam_3 is a previously allocated BN_MONT_CTX_set_APIParam_3 used for temporary variables||||null
For the other functions, 1 is returned for success, 0 on error||||null
The BN_MONT_CTX_init_APIParam_1 BN_MONT_CTX_set_APIParam_1 BN_MONT_CTX_copy_APIParam_1 BN_MONT_CTX_free_APIParam_1 BN_to_montgomery_APIParam_3 BN_from_montgomery_APIParam_3 structure is defined as follows||||null
The error codes can be obtained by ERR_get_error_APIName||||null
d2i_DSAPublicKey_APIName and i2d_DSAPublicKey_APIName decode and encode the DSA public key components structure||||null
d2i_DSAPrivateKey_APIName , i2d_DSAPrivateKey_APIName decode and encode the DSA private key components||||null
The inputs must be reduced modulo BN_MONT_CTX_set_APIParam_2 , otherwise the result will be outside the expected range||||null
d2i_DSA_PUBKEY_APIName and i2d_DSA_PUBKEY_APIName decode and encode an DSA public key using a SubjectPublicKeyInfo structure||||null
all these functions are implemented using macros||||null
These functions are used automatically||||when BN_mod_exp_APIName is called with suitable input , but These functions may be useful when several operations are to be performed using the same modulus
SSL_CTX_set_options_APIName adds the options set via bitmask in SSL_CTX_set_options_APIParam_2 to SSL_CTX_set_options_APIParam_1||||null
Options already set before are not cleared !||||null
BN_MONT_CTX_free_APIName frees the components of the BN_MONT_CTX_free_APIParam_1 , and||||if it was created by BN_MONT_CTX_new_APIName , also the structure itself
The usage of all of these functions is similar to the d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
SSL_CTX_get_options_APIName returns the options set for SSL_CTX_get_options_APIParam_1||||null
SSL_set_options_APIName adds the options set via bitmask in SSL_set_options_APIParam_2 to SSL_set_options_APIParam_1||||null
The data encoded by the private key functions is unencrypted and offers no private key security||||null
Options already set before are not cleared !||||null
SSL_get_options_APIName returns the options set for SSL_get_options_APIParam_1||||null
SSL_CTX_clear_options_APIName clears the options set via bitmask in SSL_CTX_clear_options_APIParam_2 to SSL_CTX_clear_options_APIParam_1||||null
SSL_clear_options_APIName clears the options set via bitmask in SSL_clear_options_APIParam_2 to SSL_clear_options_APIParam_1||||null
SSL_get_secure_renegotiation_support_APIName indicates whether the peer supports secure renegotiation||||null
SSL_CTX_set_options_APIName and SSL_set_options_APIName affect the protocol behaviour of the SSL library||||null
SSL_clear_APIName does not affect the settings||||null
Changes to SSL_CTX_set_options_APIParam_1 SSL_CTX_get_options_APIParam_1 SSL_CTX_clear_options_APIParam_1 do not affect already created SSL objects||||null
Using 16 bytes is ok but it should be ok to use 32||||null
The i2d_DSA_PUBKEY_APIParam_1 d2i_DSAparams_APIParam_1 d2i_DSAPrivateKey_APIParam_1 d2i_DSA_PUBKEY_APIParam_1 i2d_DSA_SIG_APIParam_1 d2i_DSAPublicKey_APIParam_1 d2i_DSA_SIG_APIParam_1 i2d_DSAPublicKey_APIParam_1 i2d_DSAparams_APIParam_1 i2d_DSAPrivateKey_APIParam_1 structure passed to the private key encoding functions should have all the private key components present||||null
The behaviour of the API can be changed by using the similar SSL_CTX_set_mode_APIName and SSL_set_mode_APIName functions||||null
This option has no effect for connections using other ciphers||||null
As of OpenSSL 0.9.8 q and 1.0.0 c , this option has no effect||||null
This is needed as a workaround for some implementations||||null
the option settings of the SSL object are used||||During a handshake
All of the above bug workarounds||||null
Disable version rollback attack detection||||null
Some clients violate this rule by adapting to the server 's answer||||null
Adds a padding extension to ensure the ClientHello size is never between 256 and 511 bytes in length||||null
the client must still use the same SSLv3 .1 = TLSv1 announcement||||null
This option is no longer implemented and is treated as no op||||null
Disables a countermeasure against a SSL 3.0 / TLS 1.0 protocol vulnerability affecting CBC ciphers , which can not be handled by some broken SSL implementations||||null
the current option setting is copied||||When a new SSL object is created from a context using SSL_new_APIName
Netscape-Commerce/1 .12 , , accepts a 32 byte challenge but appears to only use 16 bytes when generating the encryption keys||||when talking SSLv2
Works for 3.x and 4||||null
Do n't prefer ECDHE-ECDSA ciphers||||when the client appears to be Safari on OS X. OS X 10.8
Some clients step down to SSLv3 with respect to the server 's answer and violate the version rollback protection . -RRB-||||null
Do not use the SSLv3 protocol||||null
Do not use the TLSv1 protocol||||null
the client sends a SSLv2 hello and accepts up to SSLv3 .1 = TLSv1 , the server only understands up to SSLv3||||null
www.microsoft.com -||||when talking SSLv2 , if session-id reuse is performed , the session-id passed back in the server-finished message is different from the one decided upon
the SSLv3 protocol is recommended that applications should set this option||||null
Do not use the TLSv1 .1 protocol||||null
Do not use the TLSv1 .2 protocol||||null
This option is not needed for clients||||null
set , the SSL server will always follow the clients preferences||||When not
SSL_CTX_set_options_APIName and SSL_set_options_APIName return the new options bitmask after adding SSL_CTX_set_options_APIParam_2 SSL_set_options_APIParam_2||||null
SSL_CTX_get_options_APIName and SSL_get_options_APIName return the current bitmask||||null
SSL_CTX_clear_options_APIName and SSL_clear_options_APIName return the new options bitmask after clearing SSL_CTX_clear_options_APIParam_2 SSL_clear_options_APIParam_2||||null
SSL_get_secure_renegotiation_support_APIName returns 1 is the peer supports secure renegotiation and 0 if it does not||||null
Normally clients and servers will , where possible , transparently make use of RFC4507bis tickets for stateless session resumption||||null
It can contain public as well as private RSA keys||||null
BIO_s_socket_APIName returns the socket BIO method||||null
but as mentioned above||||when operating in SSLv2/v3 compatibility mode
According to the SSLv3 spec , one should use 32 bytes for the challenge , this breaks this server so 16 bytes is the way to go||||null
the client must send the same information about acceptable SSL/TLS protocol levels as during the first hello||||During the client key exchange
Because of the different protocol , for SSLv2 , the server will send its list of preferences to the client and the client chooses||||null
In public keys , the private exponent and the related secret values are NULL||||null
BIO_read_APIName and BIO_write_APIName read or write the underlying socket||||null
This is a wrapper round the platform 's socket routines||||null
BIO_puts_APIName is supported but BIO_gets_APIName is not||||null
Note that RSA keys may use non-standard RSA_set_method_APIParam_2 RSA_set_default_method_APIParam_1 implementations , either directly or by the use of RSA_new_method_APIParam_1 modules||||null
BIO_new_socket_APIName returns a socket BIO using BIO_new_socket_APIParam_1 and BIO_new_socket_APIParam_2||||null
BIO_get_fd_APIName places the socket in BIO_get_fd_APIParam_2 if it is not NULL, it also returns the socket||||null
The RSA_set_ex_data_APIParam_1 RSA_free_APIParam_1 RSA_blinding_on_APIParam_1 RSA_print_fp_APIParam_2 RSA_set_method_APIParam_1 RSA_get_method_APIParam_1 RSA_print_APIParam_2 RSA_check_key_APIParam_1 RSA_set_default_method_APIParam_1 RSA_get_ex_data_APIParam_1 RSA_free_APIParam_10 RSA_free_APIParam_11 RSA_free_APIParam_12 structure consists of several BIGNUM components||||null
In some cases , these BIGNUM values will not be used by the implementation or may be used for alternative data storage||||null
BIO_set_fd_APIName sets the socket of BIO BIO_set_fd_APIParam_1 to BIO_set_fd_APIParam_2 and the close flag to BIO_set_fd_APIParam_3||||null
BIO_set_fd_APIName and BIO_get_fd_APIName are macros||||null
BIO_s_socket_APIName returns the socket BIO method||||null
Socket BIOs also support any relevant functionality of file descriptor BIOs||||null
Any code mixing the two will not work on all platforms||||null
applications should generally avoid using RSA structure elements directly and instead use API functions to query or modify keys||||null
BIO_set_fd_APIName always returns 1||||null
BIO_get_fd_APIName returns the socket or -1 if the BIO has not been initialized||||null
the socket is shut down and closed when the BIO is freed||||If the close flag is set
The reason for having separate file descriptor and socket BIOs is that on some platforms sockets are not file descriptors and use distinct I/O routines , Windows is one such platform||||null
it will crash/hang||||If we accept a netscape connection , demand a client cert , have a non-self-signed CA which does not have its CA in netscape , and the browser has a cert
These functions implement RSA public key encryption and signatures as defined in PKCS # 1 v2 .0 -LSB- RFC 2437 -RSB-||||null
BIO_new_socket_APIName returns the newly allocated BIO or NULL is an error occurred||||null
SSL_get_ex_data_X509_STORE_CTX_idx_APIName returns the index number under which the pointer to the SSL object is stored into the X509_STORE_CTX object||||null
To retrieve this pointer the X509_STORE_CTX_get_ex_data_APIName function can be used with the correct index||||null
The index value to access the pointer||||null
This index is globally the same for all X509_STORE_CTX objects and can be retrieved using SSL_get_ex_data_X509_STORE_CTX_idx_APIName||||null
An error occurred , check the error stack for a detailed error message||||null
The value depends on other index values defined for X509_STORE_CTX objects before the SSL index is created||||null
These functions determine why a BIO is not able to read or write data||||null
These functions will typically be called after a failed BIO_read_APIName or BIO_write_APIName call||||null
BIO_get_retry_reason_APIName returns the reason for a special condition if passed the relevant BIO, as returned by BIO_get_retry_BIO_APIName||||null
A similar condition on a file BIO will mean that it has reached EOF||||null
Some BIO types may place additional information on the error queue||||null
The meaning of the reason code and the action that should be taken depends on the type of BIO that resulted in this condition||||null
the cause is an error condition||||If BIO_should_retry_APIName is false
BIO_get_retry_BIO_APIName determines the precise reason for the special condition, it returns the BIO that caused this condition and if BIO_get_retry_BIO_APIParam_2 is not NULL it contains the reason code||||null
For more details see the individual BIO type manual pages||||null
This is typically done with file BIOs||||null
An application will normally wait until the necessary condition is satisfied||||null
How this is done depends on the underlying I/O structure||||null
if a call to BIO_read_APIName on a socket BIO returns 0 and BIO_should_retry_APIName is false the cause will be that the connection closed||||null
BIO_should_retry_APIName is true||||if the call that produced this condition should be retried at a later time
If BIO_should_retry_APIName returns false ,then the precise "error condition" depends on the BIO type that caused it and the return code of the BIO operation||||null
BIO_should_write_APIName is true||||if the cause of the condition is that a BIO needs to read data
An application can retry the failed call immediately or avoid this situation by setting SSL_MODE_AUTO_RETRY on the underlying SSL structure||||null
It is possible for a BIO to block indefinitely if the underlying I/O structure cannot process or return any data||||null
This depends on the behaviour of the platforms I/O functions||||null
BIO_should_read_APIName is true||||if the cause of the condition is that a BIO needs to read data
PKCS12_create_APIName creates a PKCS # 12 structure||||null
The index value is set||||when SSL_get_ex_data_X509_STORE_CTX_idx_APIName is first called either by the application program directly or indirectly during other SSL setup functions or during the handshake
SMIME_read_PKCS7_APIName parses a message in S/MIME format||||null
SMIME_read_PKCS7_APIParam_1 is a BIO to read the message from||||null
This is often not desirable||||null
The parsed PKCS#7 structure is returned or NULL if an error occurred||||null
Otherwise the type of PKCS7_type_APIParam_0 can be determined using PKCS7_type_APIName||||null
one solution is to use non blocking I/O and use a timeout on the select_APIName call||||null
The OpenSSL ASN1 functions can not gracefully deal with non blocking I/O||||null
SSL BIOs are the only current exception to this rule||||null
The MIME parser used by SMIME_read_PKCS7_APIName is somewhat primitive||||null
that is they can not retry after a partial read or write||||null
SSL BIOs can request a retry||||null
BIO_should_io_special_APIName is true||||if some `` special '' condition , that is a reason other than reading or writing is the cause of the condition
SMIME_read_PKCS7_APIName returns a valid SMIME_read_PKCS7_APIParam_0 structure or NULL if an error occurred||||null
The error can be obtained from ERR_get_error_APIName||||null
almost all current BIO types will not request a retry||||If the underlying I/O structure is in a blocking mode
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures||||null
is stored into the X509_STORE_CTX object to identify the connection affected||||Whenever a X509_STORE_CTX object is created for the verification of the peers certificate during a handshake , a pointer to the SSL object
SSL_SESSION_get_ex_new_index_APIName is used to register a new index for application specific data||||null
SSL_SESSION_get_ex_data_APIName is used to retrieve the information for SSL_SESSION_get_ex_data_APIParam_2 from SSL_SESSION_get_ex_data_APIParam_1||||null
X509_VERIFY_PARAM_get_flags_APIName returns the flags in X509_VERIFY_PARAM_get_flags_APIParam_1||||null
The application data is only maintained for sessions held in memory||||null
SSL_SESSION_set_ex_data_APIName is used to store application data at SSL_SESSION_set_ex_data_APIParam_3 for SSL_SESSION_set_ex_data_APIParam_2 into the SSL_SESSION_set_ex_data_APIParam_1 object||||null
To support future functionality should be initialized to NULL||||null
only passing the relevant data to ASN1 functions||||when the entire structure can be read or written
This is usually worked around by||||null
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure||||null
X509_VERIFY_PARAM_clear_flags_APIName clears the flags X509_VERIFY_PARAM_set_flags_APIParam_2 in X509_VERIFY_PARAM_clear_flags_APIParam_1||||null
These defaults are||||null
X509_VERIFY_PARAM_set_purpose_APIName sets the verification purpose in X509_VERIFY_PARAM_set_purpose_APIParam_1 to X509_VERIFY_PARAM_set_purpose_APIParam_2||||null
Normally the current time is used||||null
X509_VERIFY_PARAM_set_trust_APIName sets the trust setting in X509_VERIFY_PARAM_set_trust_APIParam_1 to X509_VERIFY_PARAM_set_trust_APIParam_2||||null
X509_VERIFY_PARAM_set_time_APIName sets the verification time in X509_VERIFY_PARAM_set_time_APIParam_1 to X509_VERIFY_PARAM_set_time_APIParam_2||||null
X509_VERIFY_PARAM_set_depth_APIName sets the maximum verification depth to X509_VERIFY_PARAM_set_depth_APIParam_2||||null
a socket and BIO_should_read_APIName is true||||if the cause is ultimately
a call to select_APIName may be made to wait until data is available and retry the BIO operation||||null
Applications must not free the return value||||null
X509_VERIFY_PARAM_get0_peername_APIName returns the DNS hostname or subject CommonName from the peer certificate that matched one of the reference identifiers||||null
That is the maximum number of untrusted CA certificates that can appear in a chain||||null
This determines the acceptable purpose of the certificate chain , SSL client or SSL server||||null
or when a reference identifier specifies a parent domain||||When wildcard matching is not disabled
40 bit RC2 encryption for certificates , triple DES encryption for private keys , a key iteration count of PKCS12_DEFAULT_ITER and a MAC iteration count of 1||||null
The application data is not included||||when dumping the session with i2d_SSL_SESSION_APIName and can not be restored
X509_VERIFY_PARAM_set1_ip_asc_APIName sets the expected IP address to X509_VERIFY_PARAM_set1_ip_asc_APIParam_2||||null
The parser assumes that the PKCS7 structure is always base64 encoded and will not handle the case where the PKCS7 structure is in binary format or uses quoted printable format||||null
X509_VERIFY_PARAM_get_flags_APIName returns the current verification flags||||null
The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints||||null
The return string is allocated by the library and is no longer valid once the associated X509_VERIFY_PARAM_get0_peername_APIParam_1 argument is freed||||null
X509_VERIFY_PARAM_set_time_APIName and X509_VERIFY_PARAM_set_depth_APIName do not return values||||null
a streaming single pass option should be available||||null
X509_VERIFY_PARAM_get_depth_APIName returns the current verification depth||||null
The X509_VERIFY_PARAM_set1_ip_asc_APIParam_2 argument is a NUL-terminal ASCII string||||null
X509_VERIFY_PARAM_set_flags_APIName, X509_VERIFY_PARAM_clear_flags_APIName, X509_VERIFY_PARAM_set_purpose_APIName, X509_VERIFY_PARAM_set_trust_APIName, X509_VERIFY_PARAM_add0_policy_APIName X509_VERIFY_PARAM_set1_policies_APIName, X509_VERIFY_PARAM_set1_host_APIName, X509_VERIFY_PARAM_set_hostflags_APIName, X509_VERIFY_PARAM_set1_email_APIName, X509_VERIFY_PARAM_set1_ip_APIName and X509_VERIFY_PARAM_set1_ip_asc_APIName return 1 for success and 0 for failure||||null
rather than a hostname , the peer name may be a wildcard name or a sub-domain of the reference identifier respectively||||null
dotted decimal quad for IPv4 and colon-separated hexadecimal for IPv6||||null
The condensed ''||||null
These functions manipulate the X509_VERIFY_PARAM_set1_ip_asc_APIParam_1 X509_VERIFY_PARAM_set1_policies_APIParam_1 X509_VERIFY_PARAM_set_trust_APIParam_1 X509_VERIFY_PARAM_clear_flags_APIParam_1 X509_VERIFY_PARAM_add1_host_APIParam_1 X509_VERIFY_PARAM_set_hostflags_APIParam_1 X509_VERIFY_PARAM_set_purpose_APIParam_1 X509_VERIFY_PARAM_set_depth_APIParam_1 X509_VERIFY_PARAM_get_depth_APIParam_1 X509_VERIFY_PARAM_set1_host_APIParam_1 X509_VERIFY_PARAM_set1_policies_APIParam_10 X509_VERIFY_PARAM_set1_policies_APIParam_11 X509_VERIFY_PARAM_set1_policies_APIParam_12 X509_VERIFY_PARAM_set1_policies_APIParam_13 X509_VERIFY_PARAM_set1_policies_APIParam_14 X509_VERIFY_PARAM_set1_policies_APIParam_15 X509_VERIFY_PARAM_set1_policies_APIParam_16 structure associated with a certificate verification operation||||null
EVP_PKEY_verify_init_APIName and EVP_PKEY_verify_APIName return 1 if the verification was successful and 0 if it failed||||null
After the call to EVP_PKEY_verify_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
A negative value indicates an error other that signature verification failure||||null
'' notation is supported for IPv6 addresses||||null
All these functions use DER format and unencrypted keys||||null
d2i_AutoPrivateKey_APIName is similar to d2i_PrivateKey_APIName except d2i_AutoPrivateKey_APIName attempts to automatically detect the private key format||||null
Othewise the functions behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
The above functions should be used to manipulate verification parameters instead of legacy functions which work in specific structures such as X509_STORE_CTX_set_flags_APIName||||null
The error code can be obtained by calling ERR_get_error_APIName||||null
i2d_PrivateKey_APIName returns the number of bytes successfully encoded or a negative value if an error occurs||||null
Unlike other functions the return value 0 from EVP_PKEY_verify_APIName only indicates that the signature did not not verify successfully  it is not an indication of a more serious error||||null
OPENSSL_VERSION_NUMBER is a numeric release version identifier||||null
Applications wishing to encrypt or decrypt private keys should use other functions such as d2i_PKC8PrivateKey_APIName instead||||null
These functions are similar to the d2i_X509_APIName functions , and you should refer to that page for a detailed description||||null
The function EVP_PKEY_verify_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
Versions prior to 0.9.3 have identifiers < 0x0930||||null
Versions between 0.9.3 and 0.9.5 had a version identifier with this interpretation||||null
the retry conditions of several non blocking BIOs in a single select_APIName call it is possible to service several BIOs in a single thread , can occur||||during the initial handshake process
By combining||||null
The status nibble has one of the values 0 for development , 1 to e for betas 1 to 14 , and f for release||||null
The number was 0x0090581f||||null
For backward compatibility , SSLEAY_VERSION_NUMBER is also defined||||null
SSLeay_APIName returns this number||||null
`` OpenSSL 1.0.1 a 15 Oct 2015 ''||||null
SSLeay_version_APIName returns different strings depending on SSLeay_version_APIParam_1||||null
OPENSSL_VERSION_TEXT is the text variant of the version number and the release date||||null
The text variant of the version number and the release date||||null
`` OpenSSL 0.9.5 a 1 Apr 2000 ''||||null
The version number||||null
For an unknown SSLeay_version_APIParam_1, the text "not available" is returned||||null
Version 0.9.5 a had an interim interpretation that is like the current one , except the patch level got the highest bit set , to keep continuity||||null
The date of the build process in the form `` built on||||null
The return value can be compared to the macro to make sure that the correct version of the library has been loaded, especially when using DLLs on Windows systems||||null
The compiler flags set for the compilation process in the form `` compiler||||null
EC_POINT_invert calculates the inverse of the supplied point EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2||||null
The result is placed back in EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2||||null
The function EC_POINT_is_at_infinity tests||||null
Similarly EC_POINT_dbl doubles the point EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 and places the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2||||null
EC_POINT_is_on_curve tests whether the supplied point is on the curve or not||||null
EC_POINT_cmp compares the two supplied points and tests||||null
it is valid for EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2 to be one of EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 or EC_POINT_add_APIParam_4 EC_POINT_cmp_APIParam_3||||null
EC_POINT_add adds the two points EC_POINT_dbl_APIParam_3 EC_POINT_add_APIParam_3 EC_POINT_cmp_APIParam_2 EC_POINT_invert_APIParam_2 and EC_POINT_add_APIParam_4 EC_POINT_cmp_APIParam_3 and places the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2||||null
See EC_GROUP_copy_APIName for information about the generator||||null
EC_POINT_is_at_infinity returns 1 if the point is at infinity, or 0 otherwise||||null
''||||if available or `` built on
The functions EC_POINT_make_affine and EC_POINTs_make_affine force the internal representation of the EC_POINT into the affine co-ordinate system||||null
The value EC_POINTs_mul_APIParam_3 EC_POINT_mul_APIParam_3 may be NULL in which case the result is just EC_POINT_mul_APIParam_4 * EC_POINTs_mul_APIParam_6 EC_POINT_mul_APIParam_5||||null
date not available '' otherwise||||null
EC_GROUP_have_precompute_mult return 1 if a precomputation has been done, or 0 if not||||null
EC_POINT_cmp returns 1 if the points are not equal, 0 if the points are, or -1 on error||||null
available or `` compiler||||'' if
information not available '' otherwise||||null
In the case of EC_POINTs_make_affine the value EC_POINTs_mul_APIParam_4 EC_POINTs_make_affine_APIParam_2 provides the number of points in the array EC_POINTs_make_affine_APIParam_3 to be forced||||null
EC_POINT_is_on_curve returns 1 if the point is on the curve, 0 if not, or -1 on error||||null
EC_POINT_mul calculates the value generator * EC_POINTs_mul_APIParam_3 EC_POINT_mul_APIParam_3 + EC_POINT_mul_APIParam_4 * EC_POINTs_mul_APIParam_6 EC_POINT_mul_APIParam_5 and stores the result in EC_POINT_dbl_APIParam_2 EC_POINTs_mul_APIParam_2 EC_POINT_add_APIParam_2 EC_POINT_mul_APIParam_2||||null
The following functions return 1 on success or 0 on error||||null
SSL_CTX_set_quiet_shutdown_APIParam_2 may be 0 or 1||||null
SSL_CTX_set_quiet_shutdown_APIName sets the `` quiet shutdown '' flag for SSL_CTX_set_quiet_shutdown_APIParam_1 to be SSL_CTX_set_quiet_shutdown_APIParam_2||||null
SSL_CTX_get_quiet_shutdown_APIName returns the "quiet shutdown" setting of SSL_CTX_get_quiet_shutdown_APIParam_1||||null
The function EC_GROUP_precompute_mult stores multiples of the generator for faster point multiplication , whilst EC_GROUP_have_precompute_mult tests whether precomputation has already been done||||null
EC_POINT_add , EC_POINT_dbl , EC_POINT_invert , EC_POINT_make_affine , EC_POINTs_make_affine , EC_POINTs_make_affine , EC_POINT_mul , EC_POINTs_mul and EC_GROUP_precompute_mult||||null
SSL objects created from SSL_CTX_set_quiet_shutdown_APIParam_1 inherit the SSL_CTX_set_quiet_shutdown_APIParam_2 valid at the time SSL_new_APIName is called||||null
SSL_set_quiet_shutdown_APIName sets the `` quiet shutdown '' flag for SSL_set_quiet_shutdown_APIParam_1 SSL_set_quiet_shutdown_APIParam_1 to be SSL_set_quiet_shutdown_APIParam_2 SSL_set_quiet_shutdown_APIParam_2||||null
SSL_get_quiet_shutdown_APIName returns the "quiet shutdown" setting of SSL_get_quiet_shutdown_APIParam_1||||null
SSL_set_quiet_shutdown_APIParam_2 SSL_set_quiet_shutdown_APIParam_2 may be 0 or 1||||null
The setting stays valid until SSL_set_quiet_shutdown_APIParam_1 SSL_set_quiet_shutdown_APIParam_1 is removed with SSL_free_APIName or SSL_set_quiet_shutdown_APIName is called again||||null
This behaviour violates the TLS standard||||null
SSL_CTX_set_quiet_shutdown_APIName and SSL_set_quiet_shutdown_APIName do not return diagnostic information||||null
SSL_CTX_get_quiet_shutdown_APIName and SSL_get_quiet_shutdown return the current setting||||null
The default is normal shutdown behaviour as described by the TLS standard||||null
BN_swap_APIName exchanges the values of BN_swap_APIParam_1 and BN_swap_APIParam_2||||null
The session is thus considered to be shutdown , but no `` close notify '' alert is sent to the peer||||null
This list is globally maintained for all SSL operations within this application||||null
It is not changed||||when SSL_clear_APIName is called
It can not be set for specific SSL_CTX or SSL objects||||null
It is currently not recommended to integrate compression into applications||||null
SSL_COMP_add_compression_method_APIName adds the compression method SSL_COMP_add_compression_method_APIParam_2 with the identifier SSL_COMP_add_compression_method_APIParam_1 to the list of available compression methods||||null
The TLS standard allows the integration of compression methods into the communication||||null
Applications for non-public use may agree on certain compression methods||||null
SSL_COMP_free_compression_methods_APIName frees the internal table of compression methods that were built internally , and possibly augmented by adding SSL_COMP_add_compression_method_APIName||||null
the parties must send out `` close notify '' alert messages using SSL_shutdown_APIName for a clean shutdown||||Normally when a SSL connection is finished
Using different compression methods with the same identifier will lead to connection failure||||null
SSL_COMP_add_compression_method_APIName may return the following values||||null
Using it in the current state is not recommended||||null
There is no way to restrict the list of compression methods supported on a per connection basis||||null
The operation succeeded||||null
The operation failed||||null
The TLS RFC does however not specify compression methods or their corresponding identifiers , so there is currently no compatible way to integrate compression with unknown peers||||null
BN_value_one_APIName returns a BN_value_one_APIParam_0 constant of value 1||||null
Check the error queue to find out the reason||||null
BN_zero_APIName and BN_one_APIName are macros||||null
This constant is useful for use in comparisons and assignment||||null
Unlike the mechanisms to set a cipher list , there is no method available to restrict the list of compression method on a per connection basis||||null
BN_get_word_APIName returns BN_get_word_APIParam_1, if it can be represented as a BN_get_word_APIParam_0||||null
the OpenSSL library will have the COMP_zlib_APIName compression method available||||If enabled during compilation
BN_value_one_APIName returns the constant||||null
BN_zero_APIName , BN_one_APIName and BN_set_word_APIName set BN_zero_APIParam_1 BN_one_APIParam_1 BN_set_word_APIParam_1 BN_zero_APIParam_1 BN_one_APIParam_1 to the values 0 , 1 and BN_set_word_APIParam_2 respectively||||null
BN_set_word_APIParam_2 is a macro that will be an unsigned integral type optimied for the most efficient implementation on the local platform||||null
BN_zero_APIName, BN_one_APIName and BN_set_word_APIName return 1 on success, 0 otherwise||||null
BN_get_word_APIName returns the value BN_get_word_APIParam_1, or all-bits-set if BN_get_word_APIParam_1 cannot be represented as a BN_get_word_APIParam_0||||null
BN_set_word_APIParam_2 should probably be a typedef||||null
Once the identities of the compression methods for the TLS protocol have been standardized , the compression API will most likely be changed||||null
An OpenSSL client speaking a protocol that allows compression will unconditionally send the list of all compression methods enabled with SSL_COMP_add_compression_method_APIName to the server||||during the handshake
EVP_PKEY_free_APIName frees up the private key EVP_PKEY_free_APIParam_1||||null
The `` Configure '' target of the library build in the form `` platform||||null
The structure returned by EVP_PKEY_new_APIName is empty||||null
The `` OPENSSLDIR '' setting of the library build in the form `` OPENSSLDIR||||null
EVP_PKEY_new_APIName returns either the newly allocated EVP_PKEY_new_APIParam_0 structure of NULL if an error occurred||||null
The EVP_PKEY_new_APIName function allocates an empty EVP_PKEY_new_APIParam_0 structure which is used by OpenSSL to store private keys||||null
EVP_PKEY_free_APIName does not return a value||||null
The following return values can occur||||null
The EVP_PKEY_free_APIParam_1 structure is used by various OpenSSL functions which require a general private key without reference to any particular algorithm||||null
The behaviour of SSL_connect_APIName depends on the underlying BIO||||null
If a BN_get_word_APIParam_1 is equal to the value of all-bits-set, it will collide with the error condition returned by BN_get_word_APIName which uses that as an error value||||null
The TLS/SSL handshake was successfully completed , a TLS/SSL connection has been established||||null
The paramgen_init_APIName and paramgen_APIName methods deal with key parameter generation||||null
To add a private key to this empty structure the functions described in EVP_PKEY_set1_RSA_APIName should be used||||null
available or `` platform||||'' if
information not available '' otherwise||||null
There are two places where the EVP_PKEY_meth_add0_APIParam_1 objects are stored||||null
The paramgen_init_APIName and paramgen_APIName methods are called by EVP_PKEY_paramgen_init_APIName and EVP_PKEY_paramgen_APIName to handle the parameter generation process||||null
An OpenSSL server will match the identifiers listed by a client against its own compression methods and will unconditionally activate compression||||when a matching identifier is found
The keygen_init_APIName and keygen_APIName methods are called by EVP_PKEY_keygen_init_APIName and EVP_PKEY_keygen_APIName||||null
The keygen_init_APIName and keygen_APIName methods are used to generate the actual key for the specified algorithm||||null
Those methods are usually used to perform different jobs , such as generating a key , signing or verifying , encrypting or decrypting , etc||||null
'' ... '' ''||||if available or `` OPENSSLDIR
N/A '' otherwise||||null
one is a built-in static array representing the standard methods for different algorithms , and the other one is a stack of user-defined application-specific methods , which can be manipulated by using EVP_PKEY_meth_add0_APIName||||null
EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_10 EVP_PKEY_meth_get_cleanup_APIParam_11 EVP_PKEY_meth_get_cleanup_APIParam_12 EVP_PKEY_meth_get_cleanup_APIParam_13 EVP_PKEY_meth_get_cleanup_APIParam_14 EVP_PKEY_meth_get_cleanup_APIParam_15 EVP_PKEY_meth_get_cleanup_APIParam_16 EVP_PKEY_meth_get_cleanup_APIParam_17 EVP_PKEY_meth_get_cleanup_APIParam_18 EVP_PKEY_meth_get_cleanup_APIParam_19 EVP_PKEY_meth_get_keygen_APIParam_10 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_15 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_17 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 is a structure which holds a set of methods for a specific public key cryptographic algorithm||||null
The sign_init_APIName and sign_APIName methods are called by EVP_PKEY_sign_init_APIName and EVP_PKEY_sign_APIName||||null
The verify_init_APIName and verify_APIName methods are called by EVP_PKEY_verify_init_APIName and EVP_PKEY_verify_APIName||||null
The verify_init_APIName and verify_APIName methods are used to verify||||null
The verify_recover_init_APIName and verify_recover_APIName methods are called by EVP_PKEY_verify_recover_init_APIName and EVP_PKEY_verify_recover_APIName||||null
The verify_recover_init_APIName and verify_recover_APIName methods are used to verify a signature and recover the digest from the signature||||null
The sign_init_APIName and sign_APIName methods are used to generate the signature of a piece of data using a private key||||null
The encrypt_init_APIName and encrypt_APIName methods are used to encrypt a piece of data||||null
The encrypt_init_APIName and encrypt_APIName methods are called by EVP_PKEY_encrypt_init_APIName and EVP_PKEY_encrypt_APIName||||null
The decrypt_init_APIName and decrypt_APIName methods are used to decrypt a piece of data||||null
The derive_init_APIName and derive_APIName methods are called by EVP_PKEY_derive_init_APIName and EVP_PKEY_derive_APIName||||null
The decrypt_init_APIName and decrypt_APIName methods are called by EVP_PKEY_decrypt_init_APIName and EVP_PKEY_decrypt_APIName||||null
See EVP_PKEY_CTX_ctrl_APIName and related functions for detail||||null
The ctrl_APIName and ctrl_str_APIName methods are used to adjust algorithm-specific settings||||null
The following flags are supported||||null
The digestsign_APIName and digestverify_APIName methods could be called by EVP_DigetSign_APIName and EVP_DigestVerify_APIName||||null
The derive_init_APIName and derive_APIName methods are used to derive the shared secret from a public key algorithm||||null
EVP_PKEY_meth_free_APIName frees an existing EVP_PKEY_meth_free_APIParam_1 pointed by EVP_PKEY_meth_free_APIParam_1||||null
The digestsign_APIName and digestverify_APIName methods are used to generate or verify a signature in a one-shot mode||||null
EVP_PKEY_meth_new_APIName creates and returns a new EVP_PKEY_meth_new_APIParam_0 object, and associates the given EVP_PKEY_meth_new_APIParam_1 and EVP_PKEY_meth_new_APIParam_2||||null
EVP_PKEY_meth_copy_APIName copies an EVP_PKEY_meth_copy_APIParam_1 object from EVP_PKEY_meth_copy_APIParam_2 to EVP_PKEY_meth_copy_APIParam_1||||null
EVP_PKEY_meth_find_APIName finds an EVP_PKEY_meth_find_APIParam_0 object with the EVP_PKEY_meth_new_APIParam_1||||null
EVP_PKEY_meth_free_APIName and EVP_PKEY_meth_copy_APIName do not return values||||null
EVP_PKEY_meth_new_APIName returns a pointer to a new EVP_PKEY_meth_new_APIParam_0 object or returns NULL on error||||null
This function first searches through the user-defined method objects and the built-in objects||||null
EVP_PKEY_meth_find_APIName returns a pointer to the found EVP_PKEY_meth_find_APIParam_0 object or returns NULL if not found||||null
EVP_PKEY_meth_add0_APIName adds EVP_PKEY_meth_add0_APIParam_1 to the user defined stack of methods||||null
EVP_PKEY_meth_add0_APIName returns 1 if method is added successfully or 0 if an error occurred||||null
All EVP_PKEY_meth_set and EVP_PKEY_meth_get functions have no return values||||null
For the 'get' functions, function pointers are returned by arguments||||null
SSL_SESSION_free_APIName does not provide diagnostic information||||null
Depending on the settings , see SSL_CTX_set_session_cache_mode_APIName , the SSL_SESSION objects are internally referenced by the SSL_CTX and linked into its session cache||||null
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures||||null
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure||||null
SSL objects may be using the SSL_SESSION object||||null
SSL_get_ex_new_index_APIName is used to register a new index for application specific data||||null
The following return values can occur||||null
SSL_get_ex_data_APIName is used to retrieve the information for SSL_get_ex_data_APIParam_2 from SSL_get_ex_data_APIParam_1||||null
The reference count of the BIO is not incremented||||null
It must not be called on other SSL_SESSION objects , as this would cause incorrect reference counts and program failures||||null
No BIO was connected to the SSL object||||null
SSL_SESSION objects are allocated||||when a TLS/SSL handshake operation is successfully completed
as a session may be reused , several SSL objects may be using one SSL_SESSION object at the same time||||null
SSL_get_rbio_APIName and SSL_get_wbio_APIName return pointers to the BIOs for the read or the write channel, which can be different||||null
SSL_set_ex_data_APIName is used to store application data at SSL_set_ex_data_APIParam_3 for SSL_set_ex_data_APIParam_2 into the SSL_set_ex_data_APIParam_1 object||||null
The BIO linked to SSL_get_wbio_APIParam_1 SSL_get_rbio_APIParam_1||||null
It is crucial to keep the reference count correct and not delete a SSL_SESSION object that is still used , as this may lead to program failures due to dangling pointers||||null
EVP_PKEY_get0_engine_APIName returns a reference to the ENGINE handling EVP_PKEY_get0_engine_APIParam_1||||null
EVP_PKEY_set1_RSA_APIName , EVP_PKEY_set1_DSA_APIName , EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName set the key referenced by EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 to EVP_PKEY_set1_RSA_APIParam_2 EVP_PKEY_set1_DSA_APIParam_2 EVP_PKEY_set1_DSA_APIName0 EVP_PKEY_set1_DSA_APIName1||||null
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key in EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 or NULL if the key is not of the correct type||||null
EVP_PKEY_set_alias_type_APIName allows modifying a EVP_PKEY to use a different set of algorithms than the default||||null
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key or NULL if an error occurred||||null
This is currently used to support SM2 keys , which use an identical encoding to ECDSA||||null
EVP_PKEY_set1_engine_APIName returns 1 for success and 0 for failure||||null
EVP_PKEY_assign_RSA_APIName , EVP_PKEY_assign_DSA_APIName , EVP_PKEY_assign_DH_APIName , EVP_PKEY_assign_EC_KEY_APIName , EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName are implemented as macros||||null
Previous versions of this document suggested using EVP_PKEY_type to determine the type of a key||||null
The EVP_PKEY_meth_set functions set the corresponding fields of EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_10 EVP_PKEY_meth_get_cleanup_APIParam_11 EVP_PKEY_meth_get_cleanup_APIParam_12 EVP_PKEY_meth_get_cleanup_APIParam_13 EVP_PKEY_meth_get_cleanup_APIParam_14 EVP_PKEY_meth_get_cleanup_APIParam_15 EVP_PKEY_meth_get_cleanup_APIParam_16 EVP_PKEY_meth_get_cleanup_APIParam_17 EVP_PKEY_meth_get_cleanup_APIParam_18 EVP_PKEY_meth_get_cleanup_APIParam_19 EVP_PKEY_meth_get_keygen_APIParam_10 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_15 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_17 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 structure with the arguments passed||||null
the SSL_SESSION_free_APIParam_1 structure pointed to by SSL_SESSION_free_APIParam_1 and frees up the allocated memory||||if the reference count has reached 0
SSL_SESSION_free_APIName decrements the reference count of SSL_SESSION_free_APIParam_1 and removes||||null
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName return 1 for success or 0 for failure||||null
EVP_PKEY_set_alias_type_APIName returns 1 for success and 0 for error||||null
EVP_PKEY_set1_engine_APIName is typically used by an ENGINE returning an HSM key as part of its routine to load a private key||||null
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName, EVP_PKEY_assign_EC_KEY_APIName, EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName return 1 for success and 0 for failure||||null
Most applications wishing to know a key type will simply call EVP_PKEY_base_id_APIName and will not care about the actual type||||null
which will be identical in almost all cases||||null
The ASN1_OBJECT allocation routines , allocate and free an ASN1_OBJECT structure , which represents an ASN1 OBJECT IDENTIFIER||||null
ASN1_OBJECT_new_APIName allocates and initializes a ASN1_OBJECT structure||||null
ASN1_OBJECT_free_APIName frees up the ASN1_OBJECT_free_APIParam_1 structure ASN1_OBJECT_free_APIParam_1||||null
Otherwise it returns a pointer to the newly allocated structure||||null
The ASN1 object utility functions such as OBJ_nid2obj_APIName are used instead||||null
SSL_SESSION_free_APIName must only be called for SSL_SESSION objects , or||||when the SSL_SESSION object was generated outside a TLS handshake operation , eg by using d2i_SSL_SESSION_APIName
it is almost never used in applications||||null
ASN1_OBJECT_free_APIName returns no value||||null
The EVP_PKEY_meth_get functions get the corresponding fields of EVP_PKEY_meth_set_verify_recover_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_1 EVP_PKEY_meth_set_encrypt_APIParam_1 EVP_PKEY_meth_set_ctrl_APIParam_1 EVP_PKEY_meth_get_verifyctx_APIParam_1 EVP_PKEY_meth_set_sign_APIParam_1 EVP_PKEY_meth_set_copy_APIParam_1 EVP_PKEY_meth_set_verifyctx_APIParam_1 EVP_PKEY_meth_get_paramgen_APIParam_1 EVP_PKEY_meth_get_cleanup_APIParam_10 EVP_PKEY_meth_get_cleanup_APIParam_11 EVP_PKEY_meth_get_cleanup_APIParam_12 EVP_PKEY_meth_get_cleanup_APIParam_13 EVP_PKEY_meth_get_cleanup_APIParam_14 EVP_PKEY_meth_get_cleanup_APIParam_15 EVP_PKEY_meth_get_cleanup_APIParam_16 EVP_PKEY_meth_get_cleanup_APIParam_17 EVP_PKEY_meth_get_cleanup_APIParam_18 EVP_PKEY_meth_get_cleanup_APIParam_19 EVP_PKEY_meth_get_keygen_APIParam_10 EVP_PKEY_meth_get_verify_recover_APIParam_1 EVP_PKEY_meth_set_cleanup_APIParam_1 EVP_PKEY_meth_get_copy_APIParam_1 EVP_PKEY_meth_get_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_15 EVP_PKEY_meth_set_init_APIParam_1 EVP_PKEY_meth_get_keygen_APIParam_17 EVP_PKEY_meth_get_ctrl_APIParam_1 EVP_PKEY_meth_add0_APIParam_1 EVP_PKEY_meth_set_keygen_APIParam_1 structure to the arguments provided||||null
If the allocation fails, ASN1_OBJECT_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
Several OpenSSL structures can have application specific data attached to them||||null
These functions implement the Digital Signature Algorithm||||null
On failure an error code can be obtained from ERR_get_error_APIName||||null
Signature generation and verification are described in DSA_sign_APIName||||null
DSA_generate_key_APIName returns 1 on success, 0 otherwise||||null
The generation of shared DSA parameters is described in DSA_generate_parameters_APIName||||null
The PRNG must be seeded prior to calling DSA_generate_key_APIName||||null
DSA_generate_key_APIName describes how to generate a signature key||||null
This has several potential uses , it can be used to cache data associated with a structure or some additional data||||null
The error codes can be obtained by ERR_get_error_APIName||||null
this is no longer possible||||null
the equivalent is EVP_PKEY_base_id||||null
Since the application data can be anything at all it is passed and retrieved as a RSA_set_ex_data_APIParam_3 CRYPTO_EX_free_APIParam_1 CRYPTO_EX_new_APIParam_1 RSA_get_ex_new_index_APIParam_2 CRYPTO_EX_dup_APIParam_3 type||||null
Note that DSA keys may use non-standard DSA_set_default_method_APIParam_1 DSA_set_method_APIParam_2 implementations , either directly or by the use of DSA_new_method_APIParam_1 modules||||null
These functions perform arithmetic operations on BIGNUMs with unsigned integers||||null
BN_add_word_APIName, BN_sub_word_APIName and BN_mul_word_APIName return 1 for success, 0 on error||||null
These functions are much more efficient than the normal BIGNUM arithmetic operations||||null
For BN_div_word_APIName and BN_mod_word_APIName , BN_div_word_APIParam_2 BN_mod_word_APIParam_2 must not be 0||||null
The error codes can be obtained by ERR_get_error_APIName||||null
If the peer did not present a certificate, NULL is returned||||null
In some cases , these BIGNUM values will not be used by the implementation or may be used for alternative data storage||||null
SSL_get_peer_cert_chain_APIName returns a pointer to STACK_OF certificates forming the certificate chain of the peer||||null
The peer certificate chain is not necessarily available after reusing a session, in which case a NULL pointer is returned||||null
The reference count of the STACK_OF object is not incremented||||null
applications should generally avoid using DSA structure elements directly and instead use API functions to query or modify keys||||null
The following return values can occur||||null
eg incorrectly became 0||||when an SSL_SESSION object was completely freed as the reference count
These failures may also appear delayed , , but it is still referenced in the internal session cache and the cache list is processed during a SSL_CTX_flush_sessions_APIName operation||||null
The DSA_size_APIParam_1 d2i_DSAPrivateKey_APIParam_1 d2i_DSAPublicKey_APIParam_1 d2i_DSA_SIG_APIParam_1 i2d_DSAparams_APIParam_1 DSA_set_default_method_APIParam_1 DSA_set_method_APIParam_1 i2d_DSA_SIG_APIParam_1 DSA_get_ex_data_APIParam_1 DSA_sign_setup_APIParam_1 d2i_DSAPrivateKey_APIParam_10 d2i_DSAPrivateKey_APIParam_11 d2i_DSAPrivateKey_APIParam_12 d2i_DSAPrivateKey_APIParam_13 d2i_DSAPrivateKey_APIParam_14 d2i_DSAPrivateKey_APIParam_15 d2i_DSAPrivateKey_APIParam_16 d2i_DSAPrivateKey_APIParam_17 d2i_DSAPrivateKey_APIParam_18 d2i_DSAPrivateKey_APIParam_19 d2i_DSAPublicKey_APIParam_10 DSAparams_print_APIParam_2 i2d_DSAPrivateKey_APIParam_1 structure consists of several BIGNUM components||||null
the stack also||||If called on the client side
contains the peer 's certificate||||null
the pointer must not be used any longer||||If the corresponding session is freed
the peer 's certificate must be obtained separately using SSL_get_peer_certificate_APIName||||if called on the server side
EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_DSA_APIName0 EVP_PKEY_assign_DSA_APIName1 will be freed||||when the parent EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DH_APIName5 EVP_PKEY_assign_DH_APIParam_1 EVP_PKEY_assign_DH_APIName7 EVP_PKEY_assign_POLY1305_APIParam_1 EVP_PKEY_assign_SIPHASH_APIParam_1 is freed
EVP_PKEY_assign_RSA_APIName , EVP_PKEY_assign_DSA_APIName , EVP_PKEY_assign_DH_APIName , EVP_PKEY_assign_EC_KEY_APIName , EVP_PKEY_assign_POLY1305_APIName and EVP_PKEY_assign_SIPHASH_APIName also set the referenced key to EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_DSA_APIName0 EVP_PKEY_assign_DSA_APIName1 however these use the supplied EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 EVP_PKEY_assign_DSA_APIName0 EVP_PKEY_assign_DSA_APIName1 internally and so EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2||||null
In accordance with the OpenSSL naming convention the key obtained from or assigned to the EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get0_DSA_APIParam_1 EVP_PKEY_set1_engine_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get0_poly1305_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set_alias_type_APIParam_1 EVP_PKEY_get0_DH_APIParam_1 EVP_PKEY_get0_engine_APIParam_1 EVP_PKEY_assign_RSA_APIParam_12 EVP_PKEY_assign_RSA_APIParam_13 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_id_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_17 EVP_PKEY_assign_RSA_APIParam_18 EVP_PKEY_base_id_APIParam_1 EVP_PKEY_assign_DSA_APIParam_10 EVP_PKEY_assign_DSA_APIParam_11 EVP_PKEY_assign_DSA_APIParam_12 EVP_PKEY_get0_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_14 EVP_PKEY_assign_DSA_APIParam_15 using the EVP_PKEY_assign_SIPHASH_APIParam_2 EVP_PKEY_assign_DSA_APIParam_17 functions must be freed as well as EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get0_DSA_APIParam_1 EVP_PKEY_set1_engine_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get0_poly1305_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set_alias_type_APIParam_1 EVP_PKEY_get0_DH_APIParam_1 EVP_PKEY_get0_engine_APIParam_1 EVP_PKEY_assign_RSA_APIParam_12 EVP_PKEY_assign_RSA_APIParam_13 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_id_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_assign_RSA_APIParam_17 EVP_PKEY_assign_RSA_APIParam_18 EVP_PKEY_base_id_APIParam_1 EVP_PKEY_assign_DSA_APIParam_10 EVP_PKEY_assign_DSA_APIParam_11 EVP_PKEY_assign_DSA_APIParam_12 EVP_PKEY_get0_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_14 EVP_PKEY_assign_DSA_APIParam_15||||null
The return value points to the certificate chain presented by the peer||||null
An EC_POINT represents a point on a curve||||null
EC_POINT_free frees the memory associated with the EC_POINT||||null
EC_POINT_copy copies the point EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 into EC_POINT_copy_APIParam_1||||null
EC_POINT_clear_free destroys any sensitive data held within the EC_POINT and frees the EC_POINT memory||||null
Both EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 and EC_POINT_copy_APIParam_1 must use the same EC_METHOD||||null
EC_POINT_method_of obtains the EC_METHOD associated with EC_POINT_method_of_APIParam_1 EC_POINT_free_APIParam_1 EC_POINT_set_to_infinity_APIParam_2 EC_POINT_clear_free_APIParam_1||||null
A point is set to be at infinity by calling EC_POINT_set_to_infinity||||null
A valid point on a curve is the special point at infinity||||null
Jacobian projective co-ordinates are expressed as three values x , y and z||||null
A mapping exists between Jacobian projective co-ordinates and affine co-ordinates||||null
EC_POINT_dup creates a new EC_POINT object and copies the content from EC_POINT_copy_APIParam_2 EC_POINT_dup_APIParam_1 to the newly created EC_POINT object||||null
Working in this co-ordinate system provides more efficient point multiplication operations||||null
Conversion to Jacobian projective to affine co-ordinates is simple||||null
The co-ordinate is mapped to||||null
As well as the affine co-ordinates , a point can alternatively be described in terms of its Jacobian projective co-ordinates||||null
A Jacobian projective co-ordinate can be written as an affine co-ordinate as , y / -RRB-||||null
To set or get the projective co-ordinates use EC_POINT_set_Jprojective_coordinates_GFp and EC_POINT_get_Jprojective_coordinates_GFp respectively||||null
In addition EC_POINTs can be converted to and from various external representations||||null
Supported representations are octet strings , BIGNUMs and hexadecimal||||null
the certificate chain is no longer available||||when a session is reused
No certificate was presented by the peer or no connection was established or||||null
The return value provides the number of octets stored||||null
Octet strings are stored in a buffer along with an associated buffer length||||null
A new point is constructed by calling the function EC_POINT_new and providing the EC_POINT_get_affine_coordinates_GF2m_APIParam_1 EC_POINT_get_affine_coordinates_GFp_APIParam_1 EC_POINT_get_Jprojective_coordinates_GFp_APIParam_1 EC_POINT_set_compressed_coordinates_GFp_APIParam_1 EC_POINT_set_compressed_coordinates_GF2m_APIParam_1 EC_POINT_set_Jprojective_coordinates_GFp_APIParam_1 EC_POINT_set_to_infinity_APIParam_1 EC_POINT_set_affine_coordinates_GF2m_APIParam_1 EC_POINT_point2oct_APIParam_1 EC_POINT_set_affine_coordinates_GFp_APIParam_1 EC_POINT_get_affine_coordinates_GFp_APIParam_10 EC_POINT_get_affine_coordinates_GFp_APIParam_11 EC_POINT_get_affine_coordinates_GFp_APIParam_12 object that the point relates to||||null
The function EC_POINT_point2hex_APIName will allocate sufficient memory to store the hexadecimal string||||null
EC_POINT_new and EC_POINT_dup return the newly allocated EC_POINT or NULL on error||||null
EC_POINT_method_of returns the EC_METHOD associated with the supplied EC_POINT||||null
EC_POINT_point2oct returns the length of the required buffer, or 0 on error||||null
A point held in a BIGNUM is calculated by converting the point to an octet string and converting that octet string into a BIGNUM integer||||null
The function EC_POINT_point2oct must be supplied with a buffer long enough to store the octet string||||null
EC_POINT_point2bn returns the pointer to the BIGNUM supplied, or NULL on error||||null
Calling the function with a NULL buffer will not perform the conversion but will still return the required buffer length||||null
Points in hexadecimal format are stored in a NULL terminated character string where each character is one of the printable values 0-9 or A-F||||null
It is the caller 's responsibility to free this memory with a subsequent call to OPENSSL_free_APIName||||null
EC_POINT_bn2point returns the pointer to the EC_POINT supplied, or NULL on error||||null
EC_POINT_point2hex returns a pointer to the hex string, or NULL on error||||null
EC_POINT_hex2point returns the pointer to the EC_POINT supplied, or NULL on error||||null
The following return values can occur||||null
The creation of a new SSL structure failed||||null
SSL_new_APIName creates a new SSL_new_APIParam_1 structure which is needed to hold the data for a TLS/SSL connection||||null
The return value points to an allocated SSL structure||||null
The following functions return 1 on success or 0 on error||||null
Check the error stack to find out the reason||||null
Each line is indented by X509_NAME_print_ex_APIParam_3 spaces||||null
EC_POINT_copy , EC_POINT_set_to_infinity , EC_POINT_set_Jprojective_coordinates_GFp , EC_POINT_get_Jprojective_coordinates_GFp , EC_POINT_set_affine_coordinates_GFp , EC_POINT_get_affine_coordinates_GFp , EC_POINT_set_compressed_coordinates_GFp , EC_POINT_set_affine_coordinates_GF2m , EC_POINT_get_affine_coordinates_GF2m , EC_POINT_set_compressed_coordinates_GF2m and EC_POINT_oct2point||||null
X509_NAME_print_ex_APIName prints a human readable version of X509_NAME_print_ex_APIParam_2 to BIO X509_NAME_print_ex_APIParam_1||||null
The functions EC_POINT_point2oct , EC_POINT_oct2point , EC_POINT_point2bn , EC_POINT_bn2point , EC_POINT_point2hex and EC_POINT_hex2point convert from and to EC_POINTs for the formats||||null
octet string , BIGNUM and hexadecimal respectively||||null
The output format can be extensively customised by use of the X509_NAME_print_ex_APIParam_4 parameter||||null
The new structure inherits the settings of the underlying context SSL_new_APIParam_1||||null
X509_NAME_oneline_APIName prints an ASCII version of X509_NAME_oneline_APIParam_1 to X509_NAME_oneline_APIParam_2||||null
X509_NAME_print_ex_fp_APIName is identical to X509_NAME_print_ex_APIName except the output is written to FILE pointer X509_NAME_print_ex_fp_APIParam_1||||null
If X509_NAME_oneline_APIParam_2 is NULL, a buffer is dynamically allocated and returned, and X509_NAME_oneline_APIParam_3 is ignored||||null
connection method , options , verification settings , timeout settings||||null
X509_NAME_print_APIName prints out X509_NAME_print_APIParam_2 to X509_NAME_print_APIParam_1 indenting each line by X509_NAME_print_APIParam_3 characters||||null
Otherwise, at most X509_NAME_oneline_APIParam_3 bytes will be written, including the ending '\\0', and X509_NAME_oneline_APIParam_2 is returned||||null
Several options can be ored together||||null
Their use is strongly discouraged in new applications||||null
RSA_get_default_method_APIName returns a pointer to the current default RSA_METHOD||||null
The complete set of the flags supported by X509_NAME_print_ex_APIName is listed below||||null
Initially, the default RSA_METHOD is the OpenSSL internal implementation, as returned by RSA_PKCS1_SSLeay_APIName||||null
In addition a number options can be set for commonly used formats||||null
Additionally all the options supported by ASN1_STRING_print_ex_APIName can be used to control how each field value is displayed||||null
Multiple lines are used||||if the output exceeds 80 characters
RSA_set_method_APIName selects RSA_set_method_APIParam_2 to perform all operations using the key RSA_set_method_APIParam_1||||null
RSA_get_method_APIName returns a pointer to the RSA_METHOD being used by RSA_get_method_APIParam_1 RSA_set_method_APIParam_1||||null
RSA_set_default_method_APIName returns no value||||null
RSA_PKCS1_SSLeay_APIName, RSA_PKCS1_null_method_APIName, RSA_get_default_method_APIName and RSA_get_method_APIName return pointers to the respective RSA_METHODs||||null
RSA_set_method_APIName returns a pointer to the old RSA_METHOD implementation that was replaced||||null
RSA_new_method_APIName allocates and initializes an RSA_new_method_APIParam_1 structure so that RSA_new_method_APIParam_1 will be used for the RSA operations||||null
However , the meaningfulness of this result is dependent on||||null
Otherwise it returns a pointer to the newly allocated structure||||null
The functions X509_NAME_oneline_APIName and X509_NAME_print_APIName are legacy functions which produce a non standard output form , they do n't handle multi character fields and have various quirks and inconsistencies||||null
PKCS12_parse_APIName returns 1 for success and zero if an error occurred||||null
PKCS12_parse_APIName parses a PKCS12 structure||||null
the return type may be replaced with a RSA_get_default_method_APIParam_1 RSA_null_method_APIParam_1 RSA_PKCS1_SSLeay_APIParam_1 declaration in a future release||||null
RSA_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails||||null
the default method is used||||If RSA_new_method_APIParam_1 is NULL
The error can be obtained from ERR_get_error_APIName||||null
Only a single private key and corresponding certificate is returned by this function||||null
However , this return value should probably be ignored||||null
Attributes currently can not be stored in the private key PKCS12_parse_APIParam_3 structure||||null
More complex PKCS#12 files with multiple private keys will only return the first match||||null
The only currently supported compression algorithm is zlib using the NID NID_zlib_compression||||null
CMS_compress_APIName returns either a CMS_ContentInfo structure or NULL if an error occurred||||null
If zlib support is not compiled into OpenSSL ,then CMS_compress_APIName will return an error||||null
The error can be obtained from ERR_get_error_APIName||||null
The EVP_PKEY_derive_APIName derives a shared secret using EVP_PKEY_derive_APIParam_1||||null
The EVP_PKEY_derive_set_peer_APIName function sets the peer key||||null
this will normally be a public key||||null
BIO_next_APIName returns the next BIO in a chain||||null
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
BIO_method_type_APIName returns the type of a BIO||||null
EVP_PKEY_derive_init_APIName and EVP_PKEY_derive_APIName return 1 for success and 0 or a negative value for failure||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
the handle to that ENGINE will be released during the change||||if the previous method was supplied by an ENGINE
This will replace the RSA_METHOD used by the RSA key and||||null
This method may or may not be supplied by an ENGINE implementation, but if it is, the return value can only be guaranteed to be valid as long as the RSA key itself is valid and does not have its implementation changed by RSA_set_method_APIName||||null
After the call to EVP_PKEY_derive_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
BIO_find_type_APIName returns a matching BIO or NULL for no match||||null
It is possible to have RSA keys that only work with certain RSA_METHOD implementations , and attempting to change the RSA_METHOD for the key can have unexpected results||||null
BIO_next_APIName returns the next BIO in a chain||||null
It can be used to traverse all BIOs in a chain or used in conjunction with BIO_find_type_APIName to find all BIOs of a certain type||||null
the maximum size of the output buffer is written to the EVP_PKEY_derive_APIParam_3 parameter||||If EVP_PKEY_derive_APIParam_2 is NULL
The function EVP_PKEY_derive_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
the EVP_PKEY_derive_APIParam_3 parameter should contain the length of the EVP_PKEY_derive_APIParam_2 buffer||||If EVP_PKEY_derive_APIParam_2 is not NULL , before the call
if the call is successful , the shared secret is written to EVP_PKEY_derive_APIParam_2 and the amount of data written to EVP_PKEY_derive_APIParam_3||||null
BIO_method_type_APIName returns the type of the BIO BIO_find_type_APIParam_1 BIO_next_APIParam_1||||null
Previous versions had to use||||null
The following return values can occur||||null
The server looks up the session in its cache||||null
A new session was negotiated||||null
A session was reused||||null
BIO_next_APIName was added to OpenSSL 0.9.6 to provide a ` clean ' way to traverse a BIO chain or find multiple matches using BIO_find_type_APIName||||null
ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 must be at least 120 bytes long||||null
For ERR_error_string_n_APIName , ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 may not be NULL||||null
The string will have the following format||||null
Query , was negotiated||||during the handshake
BIO_find_type_APIName in OpenSSL 0.9.5 a and earlier could not be safely passed a NULL pointer for the BIO_find_type_APIParam_1 argument||||null
ERR_lib_error_string_APIName, ERR_func_error_string_APIName and ERR_reason_error_string_APIName return the library name, function name and reason string respectively||||null
a client can propose to reuse a session||||During the negotiation
SSL_CTX_get_max_cert_list_APIName returns the currently set maximum size for SSL_CTX_get_max_cert_list_APIParam_1||||null
The OpenSSL error strings should be loaded by calling ERR_load_crypto_strings_APIName or , for SSL applications , SSL_load_error_strings_APIName first||||null
ERR_print_errors_APIName can be used to print all error codes currently in the queue||||null
ERR_lib_error_string_APIName, ERR_func_error_string_APIName and ERR_reason_error_string_APIName return the strings, and NULL if none is registered for the error code||||null
writes at most ERR_error_string_n_APIParam_3 ERR_error_string_n_APIParam_3 characters and truncates the string||||if necessary
ERR_error_string_n_APIName is a variant of ERR_error_string_APIName that||||null
SSL_get_max_cert_list_APIName returns the currently set maximum size for SSL_set_max_cert_list_APIParam_1||||null
it will be reused||||If both client and server agree on the session
and a flag is being set that can be queried by the application||||null
ERR_error_string_APIName generates a human-readable string representing the error code ERR_error_string_APIParam_1 ERR_error_string_n_APIParam_1 ERR_error_string_APIParam_1 ERR_error_string_n_APIParam_1 , and places it at ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2||||null
the error string is placed in a static buffer||||If ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 ERR_error_string_APIParam_2 ERR_error_string_n_APIParam_2 is NULL
This setting stays valid until a new value is set||||null
The SSL objects inherit the setting valid for SSL_CTX_set_max_cert_list_APIParam_1 at the time SSL_new_APIName is being called||||null
The OpenSSL library handles incoming data by a dynamically allocated buffer||||null
the error string will contain the numeric code||||If there is no text string registered for the given error code
The TLS/SSL standard does not give any maximum size of the certificate chain||||null
The default value for the maximum certificate chain size is 100kB||||null
SSL_CTX_set_max_cert_list_APIName and SSL_set_max_cert_list_APIName return the previously set value||||null
the peer may send a certificate chain||||During the handshake process
This should be sufficient for usual certificate chains||||null
SSL_set_max_cert_list_APIName sets the maximum size allowed for the peer 's certificate chain for SSL_set_max_cert_list_APIParam_1 to be <size> bytes||||null
SSL_CTX_get_max_cert_list_APIName and SSL_get_max_cert_list_APIName return the currently set value||||null
SSL_CTX_set_max_cert_list_APIName sets the maximum size allowed for the peer 's certificate chain for all SSL objects created from SSL_CTX_set_max_cert_list_APIParam_1 to be <size> bytes||||null
Normally The RSA_padding_xxx_xxx_APIName functions should not be called from application programs||||null
The following encoding methods are implemented||||null
PKCS # 1 v2 .0 EMSA-PKCS1-v1_5||||null
The RSA_padding_xxx_xxx_APIName functions are called from the RSA encrypt , decrypt , sign and verify functions||||null
used for signatures||||null
PKCS # 1 v2 .0 EME-PKCS1-v1_5||||null
PKCS # 1 v2 .0 EME-OAEP||||null
PKCS # 1 EME-PKCS1-v1_5 with SSL-specific modification||||null
simply copy the data||||null
The RSA_padding_add_xxx_APIName functions return 1 on success, 0 on error||||null
Error codes can be obtained by calling ERR_get_error_APIName||||null
The random number generator must be seeded prior to calling RSA_padding_add_xxx_APIName||||null
The RSA_padding_check_xxx_APIName functions return the length of the recovered data, -1 on error||||null
The pseudo-random number generator must be seeded prior to calling DH_generate_parameters_APIName||||null
the handshake will fail with a SSL_R_EXCESSIVE_MESSAGE_SIZE error||||If the maximum certificate chain size allowed is exceeded
DH_generate_parameters_ex_APIName and DH_check_APIName return 1 if the check could be performed, 0 otherwise||||null
DH_generate_parameters_ex_APIParam_3 is a small number > 1 , typically 2 or 5||||null
DH_generate_parameters_ex_APIParam_2 is the length in bits of the safe prime to be generated||||null
DH_generate_parameters_APIName  returns a pointer to the DH structure, or NULL if the parameter generation fails||||null
The error codes can be obtained by ERR_get_error_APIName||||null
DH_generate_parameters_ex_APIName generates Diffie-Hellman parameters that can be shared among a group of users , and stores them in the provided DH_generate_parameters_ex_APIParam_1 structure||||null
DH_generate_parameters_ex_APIName and DH_generate_parameters_APIName may run for several hours before finding a suitable prime||||null
The parameters generated by DH_generate_parameters_ex_APIName and DH_generate_parameters_APIName are not to be used in signature schemes||||null
In order to prevent this buffer from growing without bounds due to data received from a faulty or malicious peer , a maximum size for the certificate chain is set||||null
The referred module is available as <openssl> / ms/applink||||null
These functions implement the Diffie-Hellman key agreement protocol||||null
OPENSSL_Applink is application-side interface which provides a glue between OpenSSL BIO layer and Win32 compiler run-time environment||||null
Even though it appears at application side , it 's essentially OpenSSL private interface||||null
The following return values can occur||||null
The behaviour of SSL_accept_APIName depends on the underlying BIO||||null
The generation of shared DH parameters is described in DH_generate_parameters_APIName||||null
OBJ_txt2nid_APIName returns NID corresponding to text string <s>||||null
DH_generate_key_APIName describes how to perform a key agreement||||null
The TLS/SSL handshake was successfully completed , a TLS/SSL connection has been established||||null
Under normal conditions it should never be necessary to set a value smaller than the default , as the buffer is handled dynamically and only uses the memory actually required by the data sent by the peer||||null
Note that DH keys may use non-standard DH_set_method_APIParam_2 DH_set_default_method_APIParam_1 implementations , either directly or by the use of DH_new_method_APIParam_1 modules||||null
In some cases , these BIGNUM values will not be used by the implementation or may be used for alternative data storage||||null
OBJ_txt2obj_APIName converts the text string OBJ_txt2obj_APIParam_1 into an ASN1_OBJECT structure||||null
The DH_check_APIParam_1 DH_set_method_APIParam_1 DH_get_ex_data_APIParam_1 i2d_DHparams_APIParam_1 DH_generate_key_APIParam_1 DH_set_ex_data_APIParam_1 DH_compute_key_APIParam_3 DH_free_APIParam_1 DHparams_print_APIParam_2 DH_set_default_method_APIParam_1 DH_set_method_APIParam_10 DH_set_method_APIParam_11 DH_set_method_APIParam_12 structure consists of several BIGNUM components||||null
OBJ_obj2txt_APIName converts the OBJ_obj2txt_APIParam_3 OBJ_obj2txt_APIParam_3 into a textual representation||||null
The total amount of space required is returned||||null
applications should generally avoid using DH structure elements directly and instead use API functions to query or modify keys||||null
application developers are not expected to implement it , but to compile provided module with compiler of their choice and link it into the target application||||null
If the two are identical 0 is returned||||null
OBJ_cmp_APIName compares OBJ_cmp_APIParam_1 to OBJ_cmp_APIParam_2||||null
OBJ_dup_APIName returns a copy of OBJ_dup_APIParam_1||||null
OBJ_txt2nid_APIParam_1 can be a long name , a short name or the numerical respresentation of an object||||null
OBJ_obj2nid_APIName, OBJ_ln2nid_APIName, OBJ_sn2nid_APIName return the corresponding NID for the object OBJ_obj2nid_APIParam_1, the long name <ln> or the short name <sn> respectively or NID_undef if an error occurred||||null
A new NID is returned for the created object||||null
OBJ_create_APIName adds a new object to the internal table||||null
For special applications it can be necessary to extend the maximum certificate chain size allowed to be sent by the peer , see eg the work on `` Internet X. 509 Public Key Infrastructure Proxy Certificate Profile '' and `` TLS Delegation Protocol '' at http||||null
the OID for commonName has the following definitions||||null
the numerical form will always be used||||If OBJ_obj2txt_APIParam_4 is 1
/ / www.ietf.org / and http||||null
New objects can be added by calling OBJ_create_APIName||||null
only the numerical form is acceptable||||If OBJ_txt2obj_APIParam_2 is 1
OBJ_create_APIParam_1 is the numerical form of the object , OBJ_create_APIParam_2 the short name and OBJ_create_APIParam_3 the long name||||null
long names and short names will be interpreted as well as numerical forms||||If OBJ_txt2obj_APIParam_2 is 0
Objects which are not in the table have the NID value NID_undef||||null
OBJ_cleanup_APIName cleans up OpenSSLs internal object table||||null
Table objects have certain advantages over other objects||||null
They are also static constant structures which are shared||||null
These functions can not return OBJ_cmp_APIParam_1 OBJ_obj2txt_APIParam_3 OBJ_create_APIParam_1 OBJ_ln2nid_APIParam_1 OBJ_sn2nid_APIParam_1||||null
their NIDs can be used in a C language switch statement||||null
a null terminated string to OBJ_obj2txt_APIParam_1 at most OBJ_obj2txt_APIParam_2 bytes are written , truncating the result||||if necessary
The representation is written as||||null
that is there is only a single constant structure for each table object||||null
The latter can not be constant||||null
Instead OBJ_obj2txt_APIParam_1 must point to a valid buffer and OBJ_obj2txt_APIParam_2 should be set to a positive value||||null
Objects do not need to be in the internal tables to be processed , the functions OBJ_txt2obj_APIName and OBJ_obj2txt_APIName can process the numerical form of an OID||||null
this should be called before an application exits||||if any new objects were added using OBJ_create_APIName
OBJ_nid2obj_APIName , OBJ_nid2ln_APIName and OBJ_nid2sn_APIName convert the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 to an ASN1_OBJECT structure , the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 long name and the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 short name respectively , or NULL||||if an error occurred
OBJ_nid2obj_APIName returns an OBJ_nid2obj_APIParam_0 structure or NULL is an error occurred||||null
OBJ_nid2ln_APIName and OBJ_nid2sn_APIName returns a valid string or NULL on error||||null
X509_STORE_set_verify_cb_APIName and X509_STORE_set_verify_cb_func_APIName do not return a value||||null
A buffer length of 80 should be more than enough to handle any OID encountered in practice||||null
OBJ_nid2obj_APIName returns a pointer to an internal table and does not allocate memory||||null
X509_STORE_set_verify_cb_func_APIName also sets the verification callback but X509_STORE_set_verify_cb_func_APIName is implemented as a macro||||null
ASN1_OBJECT_free_APIName will have no effect||||null
These functions are an implementation of MDC2 with DES||||null
The macro version of this function was the only one available before OpenSSL 1.0.0||||null
OBJ_obj2txt_APIName is awkward and messy to use||||null
MDC2 is a method to construct hash functions with 128 bit output from block ciphers||||null
MDC2_Init_APIName initializes a MDC2_Init_APIParam_1 structure||||null
MDC2_APIName returns a pointer to the hash value||||null
MDC2_APIName computes the MDC2 message digest of the MDC2_APIParam_2 bytes at MDC2_APIParam_1 and places it in MDC2_Final_APIParam_1||||null
MDC2_Init_APIName, MDC2_Update_APIName and MDC2_Final_APIName return 1 for success, 0 otherwise||||null
DSA_SIG_new_APIName allocates and initializes a DSA_SIG_new_APIParam_0 structure||||null
DSA_SIG_free_APIName frees the DSA_SIG_free_APIParam_1 structure and its components||||null
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly||||null
OBJ_obj2txt_APIName does n't follow the convention of other OpenSSL functions where the buffer can be set to NULL to determine the amount of data that should be written||||null
The values are erased before the memory is returned to the system||||null
DSA_SIG_free_APIName returns no value||||null
Otherwise it returns a pointer to the newly allocated structure||||null
If the allocation fails, DSA_SIG_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
the digest is placed in a static array||||If MDC2_Final_APIParam_1 is NULL
SSL_CTX_add_session_APIName adds the session SSL_CTX_add_session_APIParam_2 to the context SSL_CTX_add_session_APIParam_1||||null
MDC2_Final_APIName places the message digest in MDC2_Final_APIParam_1 , which must have space for MDC2_DIGEST_LENGTH == 16 bytes of output , and erases the MDC2_Final_APIParam_2||||null
SSL_SESSION_free_APIName is called once for SSL_CTX_remove_session_APIParam_2||||null
The following functions may be used||||if the message is not completely stored in memory
The reference count for session SSL_CTX_add_session_APIParam_2 is incremented by 1||||null
SSL_CTX_remove_session_APIName removes the session SSL_CTX_remove_session_APIParam_2 from the context SSL_CTX_remove_session_APIParam_1||||null
The following values are returned by all functions||||null
SSL_add_session_APIName and SSL_remove_session_APIName are synonyms for their SSL_CTX _ * _ APIName counterparts||||null
If the session is actually identical , SSL_CTX_add_session_APIName is a no-op, and the return value is 0||||null
it is assumed that both sessions are identical||||null
ERR_peek_error_APIName returns the earliest error code from the thread's error queue without modifying it||||null
ERR_get_error_APIName returns the earliest error code from the thread's error queue and removes the entry||||null
This function can be called repeatedly until there are no more error codes to return||||null
ERR_peek_last_error_APIName returns the latest error code from the thread's error queue without modifying it||||null
EVP_SealUpdate_APIName and EVP_SealFinal_APIName return 1 for success and 0 for failure||||null
The EVP envelope routines are a high level interface to envelope encryption||||null
can be resumed||||if desired
So the application can use SSL_CTX_add_session_APIName directly to have full control over the sessions that||||null
Data can be encrypted using this key||||null
the old session is removed by calling SSL_SESSION_free_APIName||||If a session with the same session id already exists
See ERR_GET_LIB_APIName for obtaining information about location and reason of the error , and ERR_error_string_APIName for human-readable error messages||||null
the random number generator must be seeded before calling EVP_SealInit_APIName||||null
The BIO_new_APIName function returns a new BIO using method BIO_new_APIParam_1||||null
The public key must be RSA||||null
They generate a random key and IV `` envelope '' it by using public key encryption||||null
BIO_new_APIName returns a newly created BIO or NULL if the call fails||||null
BIO_set_APIName sets the method of an already existing BIO||||null
EVP_SealUpdate_APIName and EVP_SealFinal_APIName have exactly the same properties as the EVP_EncryptUpdate_APIName and EVP_EncryptFinal_APIName routines , as documented on the EVP_EncryptInit_APIName manual page||||null
The error code , or||||0 if there is no error in the queue
For more details see the individual BIO_METHOD descriptions||||null
BIO_free_all_APIName and BIO_vfree_APIName do not return values||||null
The old session is removed and replaced by the new session||||If the same session is stored in a different SSL_SESSION object
BIO_set_APIName, BIO_free_APIName return 1 for success and 0 for failure||||null
BIO_free_APIName frees up a single BIO, BIO_vfree_APIName also frees up a single BIO but it does not return a value||||null
Some BIOs can be used immediately after calling BIO_new_APIName||||null
So symmetric encryption is used for bulk encryption and the small random symmetric key used is transferred using public key encryption||||null
Others need some additional initialization , and frequently a utility function exists to create and initialize such BIOs||||null
Calling BIO_free_all_APIName a single BIO has the same effect as calling BIO_free_APIName on it other than the discarded return value||||null
Normally the BIO_new_APIParam_1 BIO_set_APIParam_2 argument is supplied by a function which returns a pointer to a BIO_METHOD||||null
Calling BIO_free_APIName may also have some effect on the underlying I/O structure , it may close the file being referred to under certain circumstances||||null
All the functions work through a context of the type UI||||null
Envelope encryption is the usual method of using public key encryption on large amounts of data , this is but symmetric encryption is fast||||null
Also , user-defined random data can be passed down to the underlying method through calls to UI_add_user_data||||null
There is a naming convention for such functions||||null
UI stands for User Interface , and is general purpose set of routines to prompt the user for text-based information||||null
The default UI method does n't care about these data , but other methods might||||null
it does not halt||||if an error occurs freeing up an individual BIO in the chain
BIO_free_all_APIName frees up an entire BIO chain||||null
The functions are as follows||||null
A UI can contain more than one prompt , which are performed in the given sequence||||null
a source/sink BIO is normally called BIO_s _ * _ APIName and a filter BIO BIO_f _ * _ APIName||||null
Finally , use UI_process_APIName to actually perform the prompting and UI_get0_result_APIName to find the result to the prompt||||null
UI_new_APIName creates a new UI using the default UI method||||null
Each prompt gets an index number which is returned by the UI_add and UI_dup functions, and has to be used to get the corresponding result with UI_get0_result_APIName||||null
UI_new_method_APIName creates a new UI using the given UI method||||null
it will only free one BIO resulting in a memory leak||||If BIO_free_APIName is called on a BIO chain
UI_OpenSSL_APIName returns the built-in UI method (note||||null
See further on -RRB-||||null
Through user-written methods , prompting can be done in any way imaginable , be it plain text prompting , through dialog boxes or from a cell phone||||null
not the default one , since the default can be changed||||null
The first thing to do is to create a UI with UI_new_APIName or UI_new_method_APIName , add information to it with the UI_add or UI_dup functions||||null
The difference between the two is only conceptual||||null
A set of characters that can be used to cancel the prompt is given as well||||null
Other methods may make a difference between them , however||||null
With the builtin method , there 's no technical difference between them||||null
The given information is used to prompt for information , a password , and to verify a password||||null
This context contains all the information needed to prompt correctly as well as a reference to a UI_METHOD , which is an ordered vector of functions that carry out the actual prompting||||null
The flags currently supported are UI_INPUT_FLAG_ECHO , which is relevant for UI_add_input_string_APIName and will have the users response be echoed||||null
The builtin UI method does n't care about this info||||null
The prompt itself is divided in two , one part being the descriptive text and one describing the possible answers||||null
UI_free_APIName removes a UI from memory , along with all other pieces of memory that 's connected to it , like duplicated input strings , results and others||||null
UI_add_verify_string_APIName takes and extra argument that should be a pointer to the result buffer of the input string that it 's supposed to verify , or verification will fail||||null
UI_add_info_string_APIName and UI_add_error_string_APIName add strings that are shown at the same time as the prompt for extra information or to show an error string||||null
UI_add_user_data_APIName adds a piece of memory for the method to use at any time||||null
UI_get0_user_data_APIName retrieves the data that has last been given to the UI with UI_add_user_data_APIName||||null
This method is the most machine/OS dependent part of OpenSSL and normally generates the most problems||||when porting
the internal cache will not be populated automatically by new sessions negotiated by the SSL/TLS implementation , even though the internal cache will be searched automatically for session-resume requests||||If a server SSL_CTX is configured with the SSL_SESS_CACHE_NO_INTERNAL_STORE flag
UI_add_input_boolean_APIName adds a prompt to the UI that 's supposed to be answered in a boolean way , with a single character for yes and a different character for no||||null
UI_dup_input_string_APIName , UI_dup_verify_string_APIName , UI_dup_input_boolean_APIName , UI_dup_info_string_APIName and UI_dup_error_string_APIName are basically the same as their UI_add counterparts , except that they make their own copies of all strings||||null
UI_add_input_string_APIName and UI_add_verify_string_APIName add a prompt to the UI , as well as flags and a result buffer and the desired minimum and maximum sizes of the result , not counting the final NUL character||||null
UI_get0_result_APIName returns a pointer to the result buffer associated with the information indexed by UI_get0_result_APIParam_2||||null
UI_ctrl_APIName adds extra control for the application author||||null
UI_process_APIName goes through the information given so far, does all the printing and prompting and returns||||null
UI_get_default_method_APIName returns a pointer to the current default UI method||||null
UI_get_method_APIName returns the UI method associated with a given UI||||null
UI_set_default_method_APIName changes the default UI method to the one given||||null
UI_set_method_APIName changes the UI method associated with a given UI||||null
SSL_CTX_set_ssl_version_APIName sets a new default TLS/SSL SSL_CTX_set_ssl_version_APIParam_2 for SSL objects newly created from this SSL_CTX_set_ssl_version_APIParam_1||||null
SSL_set_ssl_method_APIName sets a new TLS/SSL SSL_set_ssl_method_APIParam_2 for a particular SSL_get_ssl_method_APIParam_1 object||||null
SSL_get_ssl_method_APIName returns a function pointer to the TLS/SSL method set in SSL_get_ssl_method_APIParam_1||||null
The following return values can occur for SSL_CTX_set_ssl_version_APIName and SSL_set_ssl_method_APIName||||null
The available SSL_set_ssl_method_APIParam_2 SSL_CTX_set_ssl_version_APIParam_2 choices are described in SSL_CTX_new_APIName||||null
Note that several calls to this function does n't add data , it replaces the previous blob with the one given as argument||||null
The operation succeeded||||null
The new choice failed , check the error stack to find out the reason||||null
For now , it understands two commands||||null
UI_CTRL_PRINT_ERRORS, which makes UI_process_APIName print the OpenSSL error stack as part of processing the UI, and UI_CTRL_IS_REDOABLE, which returns a flag saying if the used UI can be used again or not||||null
BN_ucmp_APIName compares their absolute values||||null
BN_cmp_APIName compares the numbers BN_cmp_APIParam_1 BN_ucmp_APIParam_1 and BN_cmp_APIParam_2 BN_ucmp_APIParam_2||||null
BN_is_zero_APIName , BN_is_one_APIName , BN_is_word_APIName and BN_is_odd_APIName are macros||||null
RSA_private_encrypt_APIName returns the size of the signature )||||null
RSA_public_decrypt_APIName returns the size of the recovered message digest||||null
reset||||when SSL_clear_APIName is called
It may be||||null
These functions handle RSA signatures at a low level||||null
SSL objects already created with SSL_new_APIName are not affected , except||||when SSL_clear_APIName is being called
BN_is_zero_APIName, BN_is_one_APIName BN_is_word_APIName and BN_is_odd_APIName return 1 if the condition is true, 0 otherwise||||null
BN_ucmp_APIName is the same using the absolute values of BN_cmp_APIParam_1 BN_ucmp_APIParam_1 and BN_cmp_APIParam_2 BN_ucmp_APIParam_2||||null
On error, -1 is returned||||null
SSL_check_chain_APIName returns a bitmap of flags indicating the validity of the chain||||null
the error codes can be obtained by ERR_get_error_APIName||||null
It could use the chain of the first set which returns suitable flags||||null
It will typically be called in the certificate callback||||null
SSL_CONF_cmd_value_type_APIName returns the type of value that SSL_CONF_cmd_value_type_APIParam_2 refers to||||null
BN_cmp_APIName returns -1 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 < BN_cmp_APIParam_2 BN_ucmp_APIParam_2, 0 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 == BN_cmp_APIParam_2 BN_ucmp_APIParam_2 and 1 if BN_cmp_APIParam_1 BN_ucmp_APIParam_1 > BN_cmp_APIParam_2 BN_ucmp_APIParam_2||||null
BN_is_odd_APIName tests||||if a is odd
SSL_check_chain_APIName must be called in servers after a client hello message or in clients after a certificate request message||||null
The function SSL_CONF_finish_APIName must be called after all configuration operations have been completed||||null
The order of operations is significant||||null
An application wishing to support multiple certificate chains may call this function on each chain in turn||||null
Applications may wish to specify a different `` legacy '' chain for earlier versions of TLS or DTLS||||null
The function SSL_CONF_finish_APIName is used to finalise any operations or to process defaults||||null
starting with the one it considers the most secure||||null
This can be used to set either defaults or values which can not be overridden||||null
it will disable SSLv3 support by default but the user can override it||||null
A return value of -2 means SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is not recognised||||null
an application might call SSL_CTX_cmd_APIName and if it returns -2  continue with processing of application specific commands||||null
Applications can also use SSL_CTX_cmd_APIName to process command lines||||null
BN_is_zero_APIName , BN_is_one_APIName and BN_is_word_APIName test||||if BN_is_zero_APIParam_1 BN_is_one_APIParam_1 BN_is_word_APIParam_1 BN_is_odd_APIParam_1 equals 0 , 1 , or BN_is_word_APIParam_2 respectively
If -3 is returned ,a required argument is missing and an error is indicated||||null
If -2 is returned ,then SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is not recognised and application specific arguments can be checked instead||||null
If 0 is returned ,some other error occurred and this can be reported back to the user||||null
if the return value is positive it is used to skip that number of arguments as they have been processed by SSL_CTX_cmd_APIName||||null
SSL_CONF_finish_APIName returns 1 for success and 0 for failure||||null
||||if an application calls
A return value of -3 means SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is recognised and the command requires a value but SSL_CONF_cmd_APIParam_3 is NULL||||null
If the peer did not present a certificate, NULL is returned||||null
By checking the return code of SSL_CTX_cmd_APIName it is possible to query if a given SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 is recognised, this is useful is SSL_CTX_cmd_APIName values are mixed with additional application specific operations||||null
SSL_get_peer_certificate_APIName returns a pointer to the X509 certificate the peer presented||||null
the method of the SSL object is reset to the method currently set in the corresponding SSL_CTX object||||When SSL_clear_APIName is called and no session is connected to an SSL object
The following return values can occur||||null
Since the supported signature algorithms extension is only used in TLS 1.2 and DTLS 1.2 the results for earlier versions of TLS and DTLS may not be very useful||||null
The X509 object must be explicitly freed using X509_free_APIName||||null
No certificate was presented by the peer or no connection was established||||null
The return value points to the certificate presented by the peer||||null
CONF_modules_unload_APIName finishes and unloads configuration modules||||null
That a certificate is returned does not indicate information about the verification state, use SSL_get_verify_result_APIName to check the verification state||||null
no certificates are sent||||If an anonymous cipher is used
CONF_modules_free_APIName closes down and frees up all memory allocated by all configuration modules||||null
None of the functions return a value||||null
A client will only send a certificate||||when explicitly requested to do so by the server
BN_CTX_new_APIName allocates and initializes a BN_CTX_new_APIParam_0 structure||||null
BN_CTX_init_APIName initializes an existing uninitialized BN_CTX_new_APIParam_0||||null
Use BN_CTX_new_APIName instead||||null
Normally applications will only call CONF_modules_free_APIName at application to tidy up any configuration performed||||null
BN_CTX_new_APIName returns a pointer to the BN_CTX_new_APIParam_0||||null
This should not be used for new programs||||null
Due to the protocol definition , a TLS/SSL server will always send a certificate||||if present
checking||||if it matches a supported signature algorithm , supported curves
The validity of a chain is determined by and in the case of client authentication certificate types and issuer names||||null
One way to do this is to set the prefix to an appropriate value using SSL_CONF_CTX_set1_prefix_APIName , pass the current argument to SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 and the following argument to SSL_CONF_cmd_APIParam_3||||null
BN_CTX_init_APIName and BN_CTX_free_APIName have no return values||||null
If the allocation fails, the allocation returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
SMIME_write_PKCS7_APIParam_1 is the BIO to write the data to||||null
SMIME_write_PKCS7_APIParam_2 is the appropriate SMIME_write_PKCS7_APIParam_2 structure||||null
SMIME_write_PKCS7_APIParam_4 is an optional set of flags||||null
only modules loaded from DSOs will be unloads||||If CONF_modules_unload_APIParam_1 is set to 0
SMIME_write_PKCS7_APIName returns 1 for success or 0 for failure||||null
The following flags can be passed in the SMIME_write_PKCS7_APIParam_4 parameter||||null
SMIME_write_PKCS7_APIName adds the appropriate MIME headers to a PKCS # 7 structure to produce an S/MIME message||||null
A return code of 0 indicates that both SSL_CONF_cmd_value_type_APIParam_2 SSL_CONF_cmd_APIParam_2 and SSL_CONF_cmd_APIParam_3 are valid but an error occurred attempting to perform the operation||||null
SSL_rstate_string_APIName returns a 2 letter string indicating the current read state of the SSL object SSL_rstate_string_APIParam_1||||null
SSL_rstate_string_long_APIName returns a string indicating the current read state of the SSL object SSL_rstate_string_long_APIParam_1||||null
BN_CTX_end_APIName must be called before the BN_CTX_new_APIParam_0 may be freed by BN_CTX_free_APIName||||If BN_CTX_start_APIName has been used on the BN_CTX_new_APIParam_0
SMIME_write_PKCS7_APIName always base64 encodes PKCS # 7 structures , there should be an option to disable this||||null
When working in a blocking environment, SSL_rstate_string[_long]_APIName should always return "RD"/"read done"||||null
SSL_rstate_string_APIName and SSL_rstate_string_long_APIName can return the following values||||null
This function should only seldom be needed in applications||||null
due to an error in the syntax of SSL_CONF_cmd_APIParam_3 the error queue may provide additional information||||null
The header of the record is being evaluated||||null
BN_CTX_free_APIName frees the components of the BN_CTX_new_APIParam_0 , and||||if it was created by BN_CTX_new_APIName , also the structure itself
it will not be destroyed||||when the session containing the peer certificate is freed
The reference count of the X509 object is incremented by one , so that||||null
the content must be supplied in the SMIME_write_PKCS7_APIParam_3 argument||||If streaming is enabled
the content is output in BER format using indefinite length constructuted encoding except in the case of signed data with detached content where the content is absent and DER format is used||||If streaming is performed
The body of the record is being evaluated||||null
The record has been completely processed||||null
The read state is unknown||||null
This should never happen||||null
Several OpenSSL structures can have application specific data attached to Several OpenSSL structures||||null
SSL_CIPHER_get_name_APIName returns a pointer to the name of SSL_CIPHER_get_name_APIParam_1||||null
SSL_CTX_get_ex_new_index_APIName is used to register a new index for application specific data||||null
If the argument is the NULL pointer, a pointer to the constant value "NONE" is returned||||null
SSL_CTX_get_ex_data_APIName is used to retrieve the information for SSL_CTX_get_ex_data_APIParam_2 from SSL_CTX_get_ex_data_APIParam_1||||null
If SSL_CIPHER_get_bits_APIParam_1 is NULL, 0 is returned||||null
These functions are used internally by OpenSSL to manipulate application specific data attached to a specific structure||||null
SSL_CIPHER_get_bits_APIName returns the number of secret bits used for SSL_CIPHER_get_bits_APIParam_1||||null
SSL_CTX_set_ex_data_APIName is used to store application data at SSL_CTX_set_ex_data_APIParam_3 for SSL_CTX_set_ex_data_APIParam_2 into the SSL_CTX_set_ex_data_APIParam_1 object||||null
An export cipher like eg EXP-RC4-MD5 has only 40 secret bits||||null
The number of bits processed can be different from the secret bits||||null
The search space is hence only 40 bits||||null
Textual representation of the cipher name||||null
The algorithm does use the full 128 bits , of which however 88bits are fixed||||null
The string returned by SSL_CIPHER_description_APIName in case of success consists of cleartext information separated by one or more blanks in the following sequence||||null
The standard terminology for ephemeral Diffie-Hellman schemes is DHE or ECDHE||||null
SSL_get_shutdown_APIName returns the shutdown mode of SSL_get_shutdown_APIParam_1||||null
SSL_set_shutdown_APIName sets the shutdown state of SSL_set_shutdown_APIParam_1 to SSL_set_shutdown_APIParam_2||||null
OpenSSL versions after 1.0.2 will report the standard terms via SSL_CIPHER_get_name and SSL_CIPHER_description||||null
No shutdown setting , yet||||null
The shutdown state of an ssl connection is a bitmask of||||null
SSL_CIPHER_get_bits_APIParam_2 contains the number of bits processed by the chosen algorithm||||If SSL_CIPHER_get_bits_APIParam_2 is not NULL
SSL_SENT_SHUTDOWN and SSL_RECEIVED_SHUTDOWN can be set at the same time||||null
It is recommended to use the standard terminology||||during configuration for clarity of configuration
The actual condition for a correctly closed session is SSL_SENT_SHUTDOWN||||null
SSL_set_shutdown_APIName does not return diagnostic information||||null
SSL_get_shutdown_APIName returns the current setting||||null
This version of OpenSSL idiosyncratically reports these schemes as EDH and EECDH , even though This version of OpenSSL also accepts the standard terminology||||null
RSA_check_key_APIName returns 1 if RSA_check_key_APIParam_1 is a valid RSA key, and 0 otherwise||||null
The shutdown state of the connection is used to determine the state of the ssl session||||null
-1 is returned if an error occurs while checking the key||||null
A `` close notify '' shutdown alert was sent to the peer , the connection is being considered closed and the session is closed and correct||||null
A shutdown alert was received form the peer , either a normal `` close notify '' or a fatal error||||null
SSL_set_shutdown_APIName can be used to set this state without sending a close alert to the peer||||null
The array consist of all NIDs of curves in preference order||||null
A method of verifying the RSA key using opaque RSA API functions might need to be considered||||null
Right now RSA_check_key_APIName simply uses the RSA structure elements directly , bypassing the RSA_METHOD table altogether||||null
This function does not work on RSA public keys that have only the modulus and public exponent elements populated||||null
SSL_CTX_set1_curves_APIName sets the supported curves for SSL_CTX_set1_curves_APIParam_1 to SSL_CTX_set1_curves_APIParam_3 curves in the array SSL_CTX_set1_curves_APIParam_2||||null
SSL_CTX_set1_curves_list_APIName sets the supported curves for SSL_CTX_set1_curves_list_APIParam_1 to string SSL_CTX_set1_curves_list_APIParam_2||||null
It returns the total number of supported curves||||null
For a TLS client the curves are used directly in the supported curves extension||||null
SSL_get1_curves_APIName returns the set of supported curves sent by a client in the supported curves extension||||null
For a TLS server the curves are used to determine the set of shared curves||||null
the reason code can be obtained using ERR_get_error_APIName||||If the key is invalid or an error occurred
it is considered bad and removed according to RFC2246||||If the session is still open , when SSL_clear_APIName or SSL_free_APIName is called
It can return zero if the client did not send a supported curves extension||||null
The SSL_get1_curves_APIParam_2 parameter can be NULL to simply return the number of curves for memory allocation purposes||||null
SSL_set1_curves_APIName and SSL_set1_curves_list_APIName are similar except SSL_set1_curves_APIName and SSL_set1_curves_list_APIName set supported curves for the SSL structure SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1||||null
SSL_get_shared_curve_APIName returns shared curve SSL_get_shared_curve_APIParam_2 for a server-side SSL SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1||||null
If the value SSL_get_shared_curve_APIParam_2 is out of range, NID_undef is returned||||null
SSL_RECEIVED_SHUTDOWN will be set , for setting SSL_SENT_SHUTDOWN the application must however still call SSL_shutdown_APIName or SSL_set_shutdown_APIName itself||||If a `` close notify '' was received
The string is a colon separated list of curve NIDs or names , `` P-521||||null
If SSL_get_shared_curve_APIParam_2 is -1 ,then the total number of shared curves is returned, which may be zero||||null
The SSL_get1_curves_APIParam_2 array is in the form of a set of curve NIDs in preference order||||null
All these functions are implemented as macros||||null
This function performs integrity checks on all the RSA key material , so the RSA key structure must contain all the private key data too||||null
The best fix will probably be to introduce a "check_key_APIName '' handler to the RSA_METHOD function table so that alternative implementations can also provide alternative implementations own verifiers||||null
Newer applications should just call||||null
SSL_get1_curves_APIName returns the number of curves, which may be zero||||null
SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName set automatic curve selection for server SSL_CTX_set_ecdh_auto_APIParam_1 or SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1 to SSL_CTX_set_ecdh_auto_APIParam_2 SSL_set_ecdh_auto_APIParam_2||||null
SSL_CTX_set1_curves_APIName, SSL_CTX_set1_curves_list_APIName, SSL_set1_curves_APIName, SSL_set1_curves_list_APIName, SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName return 1 for success and 0 for failure||||null
they will automatically support ECDH using the most appropriate shared curve||||null
The functions SSL_CTX_set_ecdh_auto_APIName and SSL_set_ecdh_auto_APIName can be used to make a server always choose the most appropriate curve for a client||||null
When called on a client SSL_set1_curves_APIParam_1 SSL_set1_curves_list_APIParam_1 SSL_get1_curves_APIParam_1, SSL_get_shared_curve_APIName has no meaning and returns -1||||null
Other than for diagnostic purposes , most applications will only be interested in the first shared curve so SSL_get_shared_curve_APIParam_2 is normally set to zero||||null
CMS_get1_certs_APIName returns all certificates in CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1||||null
CMS_get1_crls_APIName returns any CRLs in CMS_add0_crl_APIParam_1 CMS_add1_crl_APIParam_1||||null
CMS_add0_cert_APIName and CMS_add1_cert_APIName add certificate CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 to CMS_add0_cert_APIParam_1 CMS_add1_cert_APIParam_1||||null
must be of type signed data or enveloped data||||null
Previous versions of OpenSSL could effectively only use a single ECDH curve set using a function such as SSL_CTX_set_ecdh_tmp_APIName||||null
CMS_add0_cert_APIName, CMS_add1_cert_APIName and CMS_add0_crl_APIName and CMS_add1_crl_APIName return 1 for success and 0 for failure||||null
CMS_add0_crl_APIName and CMS_add1_crl_APIName add CRL CMS_add0_crl_APIParam_2 CMS_add1_crl_APIParam_2 to CMS_add0_crl_APIParam_1 CMS_add1_crl_APIParam_1||||null
The CMS_ContentInfo structure CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1 must be of type signed data or enveloped data or an error will be returned||||null
SSL_get_shared_curve_APIName returns the NID of shared curve SSL_get_shared_curve_APIParam_2 or NID_undef if there is no shared curve SSL_get_shared_curve_APIParam_2||||null
The function CMS_get0_RecipientInfos_APIName returns all the CMS_RecipientInfo structures associated with a CMS EnvelopedData structure||||null
CMS_RecipientInfo_type_APIName returns the type of CMS_RecipientInfo structure CMS_RecipientInfo_type_APIParam_1||||null
The same certificate or CRL must not be added to the same cms structure more than once||||null
It will currently return CMS_RECIPINFO_TRANS, CMS_RECIPINFO_AGREE, CMS_RECIPINFO_KEK, CMS_RECIPINFO_PASS, or CMS_RECIPINFO_OTHER||||null
CMS_get1_certs_APIName and CMS_get1_crls_APIName return the STACK of certificates or CRLs or NULL if there are none or an error occurs||||null
It returns zero if the comparison is successful and non zero if not||||null
CMS_RecipientInfo_set0_pkey_APIName associates the private key CMS_RecipientInfo_set0_pkey_APIParam_2 with the CMS_RecipientInfo structure CMS_RecipientInfo_set0_pkey_APIParam_1 , which must be of type CMS_RECIPINFO_TRANS||||null
the highest preference curve is automatically used for ECDH temporary keys used during key exchange||||If SSL_CTX_set_ecdh_auto_APIParam_2 SSL_set_ecdh_auto_APIParam_2 is 1
CMS_RecipientInfo_decrypt_APIName attempts to decrypt CMS_RecipientInfo structure CMS_RecipientInfo_decrypt_APIParam_2 in structure CMS_RecipientInfo_decrypt_APIParam_1||||null
CMS_RecipientInfo_ktri_cert_cmp_APIName compares the certificate CMS_RecipientInfo_ktri_cert_cmp_APIParam_2 against the CMS_RecipientInfo structure CMS_RecipientInfo_ktri_cert_cmp_APIParam_1 , which must be of type CMS_RECIPINFO_TRANS||||null
A key must have been associated with the structure first||||null
CMS_RecipientInfo_encrypt_APIName attempts to encrypt CMS_RecipientInfo structure CMS_RecipientInfo_encrypt_APIParam_2 CMS_RecipientInfo_decrypt_APIParam_2 in structure CMS_RecipientInfo_encrypt_APIParam_1 CMS_RecipientInfo_decrypt_APIParam_1||||null
the total number of shared curves is -1||||if SSL_get_shared_curve_APIParam_2
or||||null
A key must have been associated with the structure first and the content encryption key must be available||||null
Depending on the type the CMS_RecipientInfo structure can be ignored or its key identifier data retrieved using an appropriate function||||null
by a previous call to CMS_RecipientInfo_decrypt_APIName||||null
CMS_RecipientInfo_set0_key_APIName associates the symmetric key CMS_RecipientInfo_set0_key_APIParam_2 of length CMS_RecipientInfo_set0_key_APIParam_3 with the CMS_RecipientInfo structure CMS_RecipientInfo_set0_key_APIParam_1 , which must be of type CMS_RECIPINFO_KEK||||null
As the CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 implies CMS_add0_cert_APIName adds CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 internally to CMS_add0_cert_APIParam_1 CMS_add1_cert_APIParam_1 and it must not be freed up after the call as opposed to CMS_add1_cert_APIName where CMS_add0_cert_APIParam_2 CMS_add1_cert_APIParam_2 must be freed up||||null
The only error which will occur in practice is||||if the CMS_add1_crl_APIParam_1 CMS_add0_crl_APIParam_1 CMS_add1_cert_APIParam_1 CMS_add0_cert_APIParam_1 type is invalid
In typical usage and application will retrieve all CMS_RecipientInfo structures using CMS_get0_RecipientInfos_APIName and check the type of each using CMS_RecpientInfo_type_APIName||||null
it should consider using the SSL_CONF interface instead of manually parsing options||||If an application wishes to make use of several of these functions for configuration purposes either on a command line or in a file
CMS_get0_RecipientInfos_APIName returns all CMS_RecipientInfo structures, or NULL if an error occurs||||null
CMS_RecipientInfo_encrypt_APIName return 1 for success or 0 if an error occurs||||null
The CMS_RecipientInfo_encrypt_APIName can be used to add a new recipient to an existing enveloped data structure||||null
CMS_RecipientInfo_ktri_get0_signer_id_APIName, CMS_RecipientInfo_set0_pkey_APIName, CMS_RecipientInfo_kekri_get0_id_APIName, CMS_RecipientInfo_set0_key_APIName and CMS_RecipientInfo_decrypt_APIName return 1 for success or 0 if an error occurs||||null
CMS_RecipientInfo_ktri_cert_cmp_APIName and CMS_RecipientInfo_kekri_cmp_APIName return 0 for a successful comparison and non zero otherwise||||null
Any error can be obtained from ERR_get_error_APIName||||null
The mark is removed||||null
ERR_set_mark_APIName returns 0 if the error stack is empty, otherwise 1||||null
ERR_pop_to_mark_APIName will pop the top of the error stack until a mark is found||||null
ERR_pop_to_mark_APIName returns 0 if there was no mark in the error stack, which implies that the stack became empty, otherwise 1||||null
They can be used by the OpenSSL configuration code||||null
ASN1_add_oid_module_APIName adds just the ASN1 OBJECT module||||null
The function OPENSSL_load_builtin_modules_APIName adds all the standard OpenSSL configuration modules to the internal list||||null
ENGINE_add_conf_module_APIName adds just the ENGINE configuration module||||null
The main purpose of these functions is to enable an application to lookup recipient keys using any appropriate technique||||when the simpler method of CMS_decrypt_APIName is not appropriate
None of the functions return a value||||null
the whole stack is removed||||If there is no mark
ERR_set_mark_APIName sets a mark on the current topmost error record||||if there is one
For all current standard OpenSSL public key algorithms SHA1 is returned||||null
It returns 0 or a negative value for failure||||null
||||if the corresponding secret or private key can be obtained by any appropriate means it can associated with the structure and CMS_RecpientInfo_decrypt_APIName called
The EVP_PKEY_get_default_digest_nid_APIName function returns 1 if the message digest is advisory  and 2 if it is mandatory||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
The EVP_PKEY_get_default_digest_nid_APIName function sets EVP_PKEY_get_default_digest_nid_APIParam_2 to the default message digest NID for the public key signature operations associated with key EVP_PKEY_get_default_digest_nid_APIParam_1||||null
SSL_flush_sessions_APIName is a synonym for SSL_CTX_flush_sessions_APIName||||null
Applications should call OPENSSL_load_builtin_modules_APIName to load all configuration modules instead of adding modules selectively||||null
OPENSSL_load_builtin_modules_APIName is called automatically||||If the simple configuration function OPENSSL_config_APIName is called
Typically an application will first decrypt an appropriate CMS_RecipientInfo structure to make the content encrypt key available , it will add a new recipient using a function such as CMS_add1_recipient_cert_APIName and finally encrypt the content encryption key using CMS_RecipientInfo_encrypt_APIName||||null
SSL_CTX_flush_sessions_APIName causes a run through the session cache of SSL_CTX_flush_sessions_APIParam_1 to remove sessions expired at time SSL_CTX_flush_sessions_APIParam_2||||null
SSL_CTX_flush_sessions_APIName will only check sessions stored in the internal cache||||null
Applications must check for <= 0 return value on error||||null
A complete description of the process is contained in the verify_APIName manual page||||null
As sessions will not be reused ones they are expired , they should be removed from the cache to save resources||||null
may be missing from the application when new modules are added||||if an
otherwise functionality||||null
The X509_verify_cert_APIName function attempts to discover and validate a certificate chain based on parameters in X509_verify_cert_APIParam_1||||null
A negative return value can also happen due to internal resource problems or if a retry operation is requested during internal lookups||||null
SSL_CTX_set_cert_verify_callback_APIName does not provide diagnostic information||||null
This can either be done automatically||||whenever 255 new sessions were established or manually by calling SSL_CTX_flush_sessions_APIName
If a complete chain can be built and validated this function returns 1, otherwise it return zero, in exceptional circumstances it can also return a negative code||||null
the internal session cache will collect all sessions established up to the specified maximum number||||If enabled
The client can only send exactly one session ticket||||null
This indicates an error||||null
The parameter SSL_CTX_flush_sessions_APIParam_2 SSL_flush_sessions_APIParam_2 specifies the time which should be used for the expiration test , in most cases the actual time given by time_APIName will be used||||null
a TLS client must send the a session ticket extension to the server||||null
the remove_session_cb is however called to synchronize with the external cache||||When a session is found and removed
Session resumption shortcuts the TLS so that the client certificate negiotation do n't occur||||null
returns 0 to indicate the callback function was set||||null
Applications can use longer keys to maintain a consistent level of security||||null
SSL_CTX_get_cert_store_APIName returns a pointer to the current certificate verification storage||||null
It makes up for this by storing client certificate an all other negotiated state information encrypted within the ticket||||null
additional error information can be obtained by examining X509_verify_cert_APIParam_1 using , X509_STORE_CTX_get_error_APIName||||If the function fails
SSL_CTX_set_cert_store_APIName sets/replaces the certificate verification storage of SSL_CTX_set_cert_store_APIParam_1 to/with SSL_CTX_set_cert_store_APIParam_2||||null
As a result applications may wish to use multiple keys and avoid using long term keys stored in files||||null
The server , through the callback function , either agrees to reuse the session ticket information or it starts a full TLS handshake to create a new session ticket||||null
A negative return value from X509_verify_cert_APIName can occur if it is invoked incorrectly, such as with no certificate set in X509_verify_cert_APIParam_1, or when it is called twice in succession without reinitialising X509_verify_cert_APIParam_1 for the second call||||null
Applications rarely call this function directly but this function is used by OpenSSL internally for certificate validation , in both the S/MIME and SSL/TLS code||||null
These CA certificates are made available via lookup methods , handled inside the X509_STORE||||null
Typically the trusted certificate store is handled indirectly via using SSL_CTX_load_verify_locations_APIName||||null
SSL_CTX_set_cert_store_APIName does not return diagnostic output||||null
Currently no detailed documentation on how to use the X509_STORE object is available||||null
SSL_CTX_get_cert_store_APIName returns the current setting||||null
In order to verify the certificates presented by the peer , trusted CA certificates must be accessed||||null
The function CMS_get0_SignerInfos_APIName returns all the CMS_SignerInfo structures associated with a CMS signedData structure||||null
So will eg the verify_callback_APIName be overridden with the verify_callback_APIName set via the SSL_CTX_set_verify_APIName family of functions||||null
Using the SSL_CTX_set_cert_store_APIName and SSL_CTX_get_cert_store_APIName functions it is possible to manipulate the X509_STORE object beyond the SSL_CTX_load_verify_locations_APIName call||||null
it will be X509_STORE_free_APINameed||||If another X509_STORE object is currently set in SSL_CTX_set_cert_store_APIParam_1
It returns zero if the comparison is successful and non zero if not||||null
CMS_SignerInfo_get0_signature_APIName retrieves the signature associated with CMS_SignerInfo_get0_signature_APIParam_1 in a pointer to an ASN1_OCTET_STRING structure||||null
This pointer returned corresponds to the internal signature value if CMS_SignerInfo_get0_signature_APIParam_1 so it may be read or modified||||null
CMS_SignerInfo_set1_signer_cert_APIName sets the signers certificate of CMS_SignerInfo_set1_signer_cert_APIParam_1 to CMS_SignerInfo_set1_signer_cert_APIParam_2||||null
all this state information available exactly||||as if a full negiotation had occured
In a resumed session the applications will have||||null
CMS_SignerInfo_cert_cmp_APIName compares the certificate CMS_SignerInfo_cert_cmp_APIParam_2 against the signer identifier CMS_SignerInfo_cert_cmp_APIParam_1||||null
From the X509_STORE the X509_STORE_CTX used||||when verifying certificates is created
Not all members of the X509_STORE are used||||when the verification takes place
CMS_SignerInfo_get0_signer_id_APIName returns 1 for success and 0 for failure||||null
Once all signer certificates have been set CMS_verify_APIName can be used||||null
CMS_get0_SignerInfos_APIName returns all CMS_SignerInfo structures, or NULL there are no signers or an error occurs||||null
CMS_SignerInfo_set1_signer_cert_APIName does not return a value||||null
The OpenSSL library uses your callback function to help implement a common TLS ticket construction state according to RFC5077 Section 4 such that per session state is unnecessary and a small set of cryptographic variables needs to be maintained by the callback function implementation||||null
It will obtain the signer certificate by some unspecified means and set it using CMS_SignerInfo_set1_signer_cert_APIName||||null
In typical usage and application will retrieve all CMS_SignerInfo structures using CMS_get0_SignerInfo_APIName and retrieve the identifier information using CMS||||null
CMS_SignerInfo_cert_cmp_APIName returns 0 for a successful comparison and non zero otherwise||||null
This indicates that it was not possible to set/retrieve a session ticket and the SSL/TLS session will continue by by negiotationing a set of cryptographic parameters or using the alternate SSL/TLS resumption mechanism , session ids||||null
Any error can be obtained from ERR_get_error_APIName||||null
This document must be updated||||when documentation about the X509_STORE object and its handling becomes available
X509_check_email_APIName checks if the certificate matches the specified email X509_check_email_APIParam_2||||null
The certificate matching functions are used to check||||null
The length is either 4 or 16||||null
The validity of the certificate and its trust level has to be checked by other means||||null
X509_check_ip_APIName checks if the certificate matches a specified IPv4 or IPv6 address||||null
The X509_check_ip_APIParam_2 array is in binary format , in network byte order||||null
By default , wildcards are supported and wildcards match only in the left-most label||||null
but wildcards may match part of that label with an explicit prefix or suffix||||null
The X509_check_ip_asc_APIParam_3 argument is usually 0||||null
Only the mailbox syntax of RFC 822 is supported , comments are not allowed , and no attempt is made to normalize quoted characters||||null
The X509_check_ip_asc_APIParam_3 argument can be the bitwise OR of the flags||||null
the overall security is only 128 bits because breaking the ticket key||||if a ciphersuite uses 256 bit ciphers but only a 128 bit ticket key
will enable an attacker to obtain the session keys||||null
X509_check_ip_asc_APIName is similar , except that the NUL-terminated string X509_check_ip_asc_APIParam_2 is first converted to the internal representation||||null
The main purpose of these functions is to enable an application to lookup signers certificates using any appropriate technique||||when the simpler method of CMS_verify_APIName is not appropriate
by default , the host X509_check_host_APIParam_2 `` www.example.com '' would match a certificate with a SAN or CN value of '' *.example.com '' , `` w*.example.com '' or '' *w.example.com ''||||null
they can obtain the master secret for any ticket using that key and decrypt any traffic using that session||||If an attacker can obtain the key used to encrypt a session ticket
X509_check_host_APIName checks if the certificate Subject Alternative Name or Subject CommonName matches the specified host name , which must be encoded in the preferred name syntax described in section 3.5 of RFC 1034||||null
All functions can also return -2 if the input is malformed||||null
X509_check_host_APIName returns -2 if the provided X509_check_host_APIParam_2 contains embedded NULs||||null
Only explicitly marked addresses in the certificates are considered||||null
Applications are encouraged to use X509_VERIFY_PARAM_set1_host_APIName rather than explicitly calling X509_check_host_APIName||||null
These functions all return 1 for success and 0 or a negative value for failure||||null
passing a public key to EVP_PKEY_print_private_APIName will only print the public components||||null
IP addresses stored in DNS names and Common Names are ignored||||null
X509_check_host_APIName return 1 for a successful match, 0 for a failed match and -1 for an internal error||||null
SSL_get_servername_APIName returns a servername extension value of the specified type if provided in the Client Hello or NULL||||null
SSL_CTX_set_tlsext_servername_arg_APIName sets a context-specific argument to be passed into the callback for this SSL_CTX_set_tlsext_servername_arg_APIParam_1||||null
typically a memory allocation failure or an ASN .1 decoding error||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
SSL_CTX_set_tlsext_servername_callback_APIName and SSL_CTX_set_tlsext_servername_arg_APIName both always return 1 indicating success||||null
The servername callback is executed first , followed by the ALPN callback||||null
The user-defined argument optionally defined by SSL_CTX_set_msg_callback_arg_APIName or SSL_set_msg_callback_arg_APIName||||null
The SSL_set_msg_callback_arg_APIParam_1 SSL_CTX_set_msg_callback_arg_APIParam_1 object that received or sent the message||||null
This function returns the Diffie-Hellman size in bytes||||null
Protocol messages are passed to the callback function after decryption and fragment collection where applicable||||null
The size in bytes||||null
The ALPN and SNI callbacks are both executed Hello processing||||during Client
DSA_dup_DH_APIName returns the new DSA_dup_DH_APIParam_0 structure, and NULL on error||||null
DSA_dup_DH_APIName duplicates DSA parameters/keys as DH parameters/keys||||null
the callback function will never see messages that are considered too large to be processed||||null
only those contained in the key will be printed||||If the key does not include all the components indicated by the function
The error codes can be obtained by ERR_get_error_APIName||||null
BIO_f_cipher_APIName returns the cipher BIO method||||null
This flag is 0 and 1 when a protocol message has been sent||||when a protocol message has been received
This function can be used to determine how much memory must be allocated for the shared secret computed by DH_compute_key_APIName||||null
Cipher BIOs do not support BIO_gets_APIName or BIO_puts_APIName||||null
It is a BIO wrapper for the cipher routines EVP_CipherInit_APIName , EVP_CipherUpdate_APIName and EVP_CipherFinal_APIName||||null
BIO_get_cipher_status_APIName is a BIO_ctrl_APIName macro which can be called to determine||||null
This is a filter BIO that encrypts any data written through it , and decrypts any data read from it||||null
BIO_get_cipher_ctx_APIName is a BIO_ctrl_APIName macro which retrieves the internal BIO cipher context||||null
A successful decrypt followed by EOF will also return zero for the final read||||null
the callback function may not be called||||If processing a received protocol message results in an error
BIO_f_cipher_APIName returns the cipher BIO method||||null
q is lost||||during that conversion
but the resulting DH parameters contain the resulting DH parameters length||||null
BIO_set_cipher_APIName does not return a value||||null
When decrypting an error on the final block is signalled by a zero return value from the read operation||||null
The retrieved context can be used in conjunction with the standard cipher routines to set it up||||null
BIO_get_cipher_status_APIName should be called to determine if the decrypt was successful||||null
BIO_get_cipher_status_APIName returns 1 for a successful decrypt and 0 for failure||||null
BIO_get_cipher_ctx_APIName currently always returns 1||||null
Be careful to avoid small subgroup attacks||||when using this
SSL_want_APIName returns state information for the SSL object SSL_want_APIParam_1||||null
Its return values are similar to that of SSL_get_error_APIName||||null
the internal checks will be suppressed as appropriate||||when DANE support is added to OpenSSL
Host name checks are out of scope with the DANE-EE_APIName certificate usage , and||||null
The other SSL_want_*_APIName calls are shortcuts for the possible states returned by SSL_want_*_APIName||||null
SSL_want_APIName examines the internal state information of the SSL object||||null
This is useful||||when BIO_set_cipher_APIName is not flexible enough for the applications needs
The following return values can currently occur for SSL_want_APIName||||null
Error conditions are not handled and must be treated using SSL_get_error_APIName||||null
The result returned by SSL_want_APIName should always be consistent with the result of SSL_get_error_APIName||||null
The information must only be used for normal operation under non-blocking I/O||||null
BIO_flush_APIName on an encryption BIO that is being written through is used to signal that no more data is to be encrypted||||null
A call to SSL_get_error_APIName should return SSL_ERROR_WANT_X509_LOOKUP||||null
There is no data to be written or to be read||||null
this is used to flush and possibly pad the final block through the BIO||||null
SSL_want_nothing_APIName, SSL_want_read_APIName, SSL_want_write_APIName, SSL_want_x509_lookup_APIName return 1, when the corresponding condition is true or 0 otherwise||||null
The operation did not complete||||null
BN_is_bit_set_APIName returns 1 if the bit is set, 0 otherwise||||null
All other functions return 1 for success, 0 on error||||null
The error codes can be obtained by ERR_get_error_APIName||||null
See EC_GROUP_copy_APIName for a description of point_conversion_form||||null
Unlike SSL_get_error_APIName , which also evaluates the error queue , the results are obtained by examining an internal state flag only||||null
As always , , it can be achieved by preceding the cipher BIO with a buffering BIO||||if BIO_gets_APIName or BIO_puts_APIName support is needed
There are two encoding flags currently defined - EC_PKEY_NO_PARAMETERS and EC_PKEY_NO_PUBKEY||||null
Private keys encoded without parameters can not be loaded using d2i_ECPrivateKey||||null
The ECPrivateKey encode and decode routines encode and parse an EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1 EC_KEY_set_enc_flags_APIParam_1 structure into a binary format and back again||||null
d2i_ECPrivateKey_APIName returns a valid d2i_ECPrivateKey_APIParam_1 structure or NULL if an error occurs||||null
The format of the external representation of the public key written by i2d_ECPrivateKey is described by the point_conversion_form||||null
BN_is_bit_set_APIName tests||||if bit BN_is_bit_set_APIParam_2 in BN_is_bit_set_APIParam_1 is set
For the shift functions , BN_rshift1_APIParam_1 BN_lshift1_APIParam_1 BN_rshift_APIParam_1 BN_lshift_APIParam_1 and BN_rshift1_APIParam_2 BN_clear_bit_APIParam_1 BN_mask_bits_APIParam_1 BN_lshift1_APIParam_2 BN_is_bit_set_APIParam_1 BN_rshift_APIParam_2 BN_lshift1_APIParam_10 BN_lshift1_APIParam_11 may be the same variable||||null
These functions are similar to the d2i_X509_APIName functions , and you should refer to that page for a detailed description||||null
The error code that can be obtained by ERR_get_error_APIName||||null
The error code can be obtained by ERR_get_error_APIName||||null
The functions EC_KEY_get_enc_flags and EC_KEY_set_enc_flags get and set the value of the encoding flags for the EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1||||null
EC_KEY_get_enc_flags returns the value of the current encoding flags for the EC_KEY||||null
i2d_ECPrivateKey_APIName returns the number of bytes successfully encoded or a negative value if an error occurs||||null
The CMS_add1_ReceiptRequest_APIName function adds a signed receipt request CMS_add1_ReceiptRequest_APIParam_2 to SignerInfo structure CMS_add1_ReceiptRequest_APIParam_1||||null
CMS_ReceiptRequest_create0_APIName returns a signed receipt request structure or NULL if an error occurred||||null
These flags define the behaviour of how the EC_KEY_get_enc_flags_APIParam_1 d2i_ECPrivateKey_APIParam_1 i2d_ECPrivateKey_APIParam_1 is converted into ASN1 in a call to i2d_ECPrivateKey||||null
For more details of the meaning of the fields see RFC2634||||null
the public key is not encoded along with the private key||||If EC_PKEY_NO_PUBKEY is set
CMS_add1_ReceiptRequest_APIName returns 1 for success or 0 if an error occurred||||null
RSA_verify_ASN1_OCTET_STRING_APIParam_1 RSA_sign_ASN1_OCTET_STRING_APIParam_1 is ignored||||null
CMS_get1_ReceiptRequest_APIName returns 1 is a signed receipt request is found and decoded||||null
the public parameters for the curve are not encoded along with the private key||||If EC_PKEY_NO_PARAMETERS is set
RSA_sign_ASN1_OCTET_STRING_APIName returns 1 on success, 0 otherwise||||null
It returns 0 if a signed receipt request is not present and -1 if it is present but malformed||||null
The random number generator must be seeded prior to calling RSA_sign_ASN1_OCTET_STRING_APIName||||null
RSA_verify_ASN1_OCTET_STRING_APIName returns 1 on successful verification, 0 otherwise||||null
The error codes can be obtained by ERR_get_error_APIName||||null
These functions serve no recognizable purpose||||null
These functions decode and encode an X509 CRL||||null
BIO_s_null_APIName returns the null sink BIO method||||null
Data written to the null sink is discarded, reads return EOF||||null
The contents of a signed receipt should only be considered meaningful||||if the corresponding CMS_ContentInfo structure can be successfully verified using CMS_verify_APIName
int CMS_get1_ReceiptRequest_APIName looks for a signed receipt request in CMS_get1_ReceiptRequest_APIParam_1||||if any is found it is decoded and written to CMS_get1_ReceiptRequest_APIParam_2
Othewise the functions behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
A null sink BIO behaves in a similar manner to the Unix / dev/null device||||null
BIO_s_null_APIName returns the null sink BIO method||||null
HMAC_APIParam_1 can be EVP_sha1_APIName , EVP_ripemd160_APIName etc||||null
A null bio can be placed on the end of a chain to discard any data passed through it||||null
HMAC_CTX_init_APIName initialises a HMAC_CTX_init_APIParam_1 before first use||||null
It must be called||||null
HMAC_CTX_cleanup_APIName erases the key and other data from the HMAC_CTX_cleanup_APIParam_1 and releases any associated resources||||null
HMAC is a MAC , ie a keyed hash function used for message authentication , which is based on a hash function||||null
It is deprecated and only included for backward compatibility with OpenSSL 0.9.6 b||||null
HMAC_CTX_init_APIName and HMAC_CTX_cleanup_APIName do not return values||||null
this can be achieved by adding a null sink BIO to the end of the chain||||null
HMAC_cleanup_APIName is an alias for HMAC_CTX_cleanup_APIName included for back compatibility with 0.9.6 b , it is deprecated||||null
HMAC_APIName returns a pointer to the message authentication code or NULL if an error occurred||||null
HMAC_Init_ex_APIName, HMAC_Update_APIName and HMAC_Final_APIName return 1 for success or 0 if an error occurred||||null
HMAC_APIName computes the message authentication code of the HMAC_APIParam_1 bytes at HMAC_APIParam_2 using the hash function HMAC_APIParam_1 and the key HMAC_APIParam_2 which is HMAC_Init_APIParam_3 HMAC_Init_ex_APIParam_3 bytes long||||null
HMAC_Init_APIName initializes a HMAC_Init_APIParam_1 structure to use the hash function HMAC_APIParam_1 and the key HMAC_Init_APIParam_2 which is HMAC_Init_APIParam_3 bytes long||||null
It must be called||||when an HMAC_CTX_cleanup_APIParam_1 is no longer required
the functions||||null
Some of the newer functions follow a naming convention using the numbers 0 and 1||||null
PKCS7_decrypt_APIName extracts and decrypts the content from a PKCS # 7 envelopedData structure||||null
The following functions may be used||||if the message is not completely stored in memory
OpenSSL_add_all_algorithms_APIName should be called before using this function or errors about unknown algorithms will occur||||null
PKCS7_decrypt_APIName returns either 1 for success or 0 for failure||||null
HMAC_Final_APIName places the message authentication code in HMAC_Final_APIParam_2 , which must have space for the hash function output||||null
The following flags can be passed in the PKCS7_decrypt_APIParam_5 parameter||||null
The error can be obtained from ERR_get_error_APIName||||null
PKCS7_decrypt_APIName must be passed the correct recipient key and certificate||||null
if HMAC_Init_ex_APIName is called with HMAC_Init_ex_APIParam_2 NULL and HMAC_APIParam_1 is not the same as the previous digest used by HMAC_Init_ex_APIParam_1 , an error is returned  is not supported||||null
At first the library must be initialized||||null
see SSL_library_init_APIName||||null
the TLS/SSL handshake is performed using SSL_accept_APIName or SSL_connect_APIName respectively||||null
A null sink is useful||||if , , an application wishes to digest some data by writing through a digest bio but not send the digested data anywhere
SSL_shutdown_APIName can be used to shut down the TLS/SSL connection||||null
X509_new_APIName allocates and initializes a X509 structure||||null
SSL_read_APIName and SSL_write_APIName are used to read and write data on the TLS/SSL connection||||null
Otherwise it returns a pointer to the newly allocated structure||||null
X509_free_APIName frees up the X509_free_APIParam_1 structure X509_free_APIParam_1||||null
X509_free_APIName returns no value||||null
If the allocation fails, X509_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
the recipients certificate is needed to locate the appropriate recipients in the PKCS # 7 structure||||null
The X509 ASN1 allocation routines , allocate and free an X509 structure , which represents an X509 certificate||||null
SSL_CTX_sessions_APIName returns a pointer to the lhash databases containing the internal session cache for SSL_CTX_sessions_APIParam_1||||null
It would be better||||if it could look up the correct key and certificate from a database
BIO_f_base64_APIName returns the base64 BIO method||||null
It is possible to directly access this database eg for searching||||null
Base64 BIOs do not support BIO_gets_APIName or BIO_puts_APIName||||null
BIO_f_base64_APIName returns the base64 BIO method||||null
The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign_APIName also applies to PKCS7_verify_APIName||||null
The sessions in the internal session cache are kept in an lhash_APIName type database||||null
SSL_CTX_sess_number_APIName returns the current number of sessions in the internal session cache||||null
SSL_CTX_sess_connect_APIName returns the number of started SSL/TLS handshakes in client mode||||null
This is a filter BIO that base64 encodes any data written through it and decodes any data read through it||||null
SSL_CTX_sess_connect_good_APIName returns the number of successfully established SSL/TLS sessions in client mode||||null
SSL_CTX_sess_accept_APIName returns the number of started SSL/TLS handshakes in server mode||||null
Because of the format of base64 encoding , the end of the encoded block can not always be reliably determined||||null
SSL_CTX_sess_connect_renegotiate_APIName returns the number of start renegotiations in client mode||||null
PKCS7_decrypt_APIParam_2 is the private key of the recipient , PKCS7_decrypt_APIParam_3 is the recipients certificate , PKCS7_decrypt_APIParam_4 is a BIO to write the content to and PKCS7_decrypt_APIParam_5 is an optional set of flags||||null
SSL_CTX_sess_accept_renegotiate_APIName returns the number of start renegotiations in server mode||||null
There should be some way of specifying a test that the BIO can perform to reliably determine EOF||||null
SSL_CTX_sess_accept_good_APIName returns the number of successfully established SSL/TLS sessions in server mode||||null
The ambiguity of EOF in base64 encoded data can cause additional data following the base64 encoded block to be misinterpreted||||null
SSL_CTX_sess_hits_APIName returns the number of successfully reused sessions||||null
SSL_CTX_sess_cb_hits_APIName returns the number of successfully retrieved sessions from the external session cache in server mode||||null
The functions return the values indicated in the DESCRIPTION section||||null
In client mode a session set with SSL_set_session_APIName successfully reused is counted as a hit||||null
These sessions are not included in the SSL_CTX_sess_hits_APIName count||||null
BIO_flush_APIName on a base64 BIO that is being written through is used to signal that no more data is to be encoded||||null
SSL_CTX_sess_misses_APIName returns the number of sessions proposed by clients that were not found in the internal session cache in server mode||||null
These functions decode and encode an CMS ContentInfo structure||||null
this is used to flush the final block through the BIO||||null
SSL_CTX_sess_cache_full_APIName returns the number of sessions that were removed||||null
The flag BIO_FLAGS_BASE64_NO_NL can be set with BIO_set_flags_APIName to encode the data all on one line or expect the data to be all on one line||||null
The error code returned by ERR_get_error_APIName consists of a library number, function code and reason code||||null
In server mode a session successfully retrieved from internal or external cache is counted as a hit||||null
ERR_GET_LIB_APIName , ERR_GET_FUNC_APIName and ERR_GET_REASON_APIName can be used to extract these||||null
ERR_GET_LIB_APIName , ERR_GET_FUNC_APIName and ERR_GET_REASON_APIName are macros||||null
SSL_CTX_sess_timeouts_APIName returns the number of sessions proposed by clients and either found in the internal or external session cache in server mode, but that were invalid due to timeout||||null
Otherwise they behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
The library number , function code and reason code respectively||||null
The EVP signature routines are a high level interface to digital signatures||||null
Note that different libraries may use the same value to signal different functions and reasons||||null
EVP_DigestVerifyUpdate_APIName hashes EVP_DigestVerifyUpdate_APIParam_3 bytes of data at EVP_DigestVerifyUpdate_APIParam_2 into the verification context EVP_DigestVerifyUpdate_APIParam_1||||null
This function is currently implemented using a macro||||null
EVP_DigestVerifyInit_APIName and EVP_DigestVerifyUpdate_APIName return 1 for success and 0 or a negative value for failure||||null
EVP_DigestVerifyFinal_APIName returns 1 for success||||null
Each sub-library of OpenSSL has a unique library number||||null
This function can be called several times on the same EVP_DigestVerifyUpdate_APIParam_1 to include additional data||||null
any other value indicates failure||||null
function and reason codes are unique within each sub-library||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
The error codes can be obtained from ERR_get_error_APIName||||null
EVP_DigestVerifyFinal_APIName verifies the data in EVP_DigestVerifyFinal_APIParam_1 against the signature in EVP_DigestVerifyFinal_APIParam_2 of length EVP_DigestVerifyFinal_APIParam_3||||null
The library number and function code describe where the error occurred , the reason code is the information about what went wrong||||null
A return value of zero indicates that the signature did not verify successfully , while other values indicate a more serious error||||null
This is because the code becomes transparent to the algorithm used and much more flexible||||null
This is no longer necessary and the use of clone digest is now discouraged||||null
The call to EVP_DigestVerifyFinal_APIName internally finalizes a copy of the digest context||||null
In parallel , the sessions form a linked list which is maintained separately from the lhash_APIName operations , so that the database must not be modified directly but by using the SSL_CTX_add_session_APIName family of functions||||null
For some key types and parameters the random number generator must be seeded or the operation will fail||||null
X509_STORE_CTX_set_verify_cb_APIName does not return a value||||null
In previous versions of OpenSSL there was a link between message digest types and public key algorithms||||null
The EVP_DigestVerifyUpdate_APIParam_1 EVP_DigestVerifyFinal_APIParam_1 EVP_DigestVerifyInit_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces||||null
This means that EVP_VerifyUpdate_APIName and EVP_VerifyFinal_APIName can be called later to digest and verify additional data||||null
The verification callback can be set and inherited from the parent structure performing the operation||||null
This meant that `` clone '' digests such as EVP_dss1_APIName needed to be used to sign using SHA1 and DSA||||null
Any of the following flags can be passed in the PKCS7_sign_add_signer_APIParam_5 parameter||||null
The verification callback can be used to customise the operation of certificate verification , either by overriding error conditions or logging errors for debugging purposes||||null
the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur||||null
Several certificates can be added one after another||||null
SSL_CTX_add_extra_chain_cert_APIName adds the certificate SSL_CTX_add_extra_chain_cert_APIParam_2 to the extra chain certificates associated with SSL_CTX_add_extra_chain_cert_APIParam_1||||null
PKCS7_sign_add_signers_APIName returns an internal pointer to the PKCS7_SIGNER_INFO structure just added or NULL if an error occurs||||null
These functions are implemented as macros||||null
SSL_CTX_add_extra_chain_cert_APIName and SSL_CTX_clear_extra_chain_certs_APIName return 1 on success and 0 for failure||||null
SSL_CTX_clear_extra_chain_certs_APIName clears all extra chain certificates associated with SSL_CTX_clear_extra_chain_certs_APIParam_1||||null
the default digest for the public key algorithm will be used||||If the PKCS7_sign_add_signer_APIParam_4 parameter is NULL
PKCS7_sign_add_signer_APIName adds a signer with certificate PKCS7_sign_add_signer_APIParam_2 and private key PKCS7_sign_add_signer_APIParam_3 using message digest PKCS7_sign_add_signer_APIParam_4 to a PKCS7 signed data structure PKCS7_sign_add_signer_APIParam_1||||null
SSL_get_ciphers_APIName returns the stack of available SSL_CIPHERs for SSL_get_cipher_list_APIParam_1, sorted by preference||||null
PKCS7_sign_add_signers_APIName returns an internal pointer to the PKCS7_SIGNER_INFO structure just added, this can be used to set additional attributes before it is finalized||||null
Check out the error stack to find out the reason for failure||||null
||||if multiple signers or non default digest algorithms are needed
If SSL_get_cipher_list_APIParam_1 is NULL or no ciphers are available, NULL is returned||||null
The main purpose of this function is to provide finer control over a PKCS # 7 signed data structure where the simpler PKCS7_sign_APIName function defaults are not appropriate||||null
SSL_get_cipher_list_APIName returns a pointer to the name of the SSL_CIPHER listed for SSL_get_cipher_list_APIParam_1 with SSL_get_cipher_list_APIParam_2||||null
A pointer to SSL_get_shared_ciphers_APIParam_2 is returned on success or NULL on error||||null
In some cases the X509_STORE_CTX_set_verify_cb_APIParam_1 structure is created and destroyed internally and the only way to set a custom verification callback is by inheriting it from the associated X509_STORE_CTX_set_verify_cb_APIParam_1||||null
If SSL_get_cipher_list_APIParam_1 is NULL, no ciphers are available, or there are less ciphers than SSL_get_cipher_list_APIParam_2 available, NULL is returned||||null
This function will return available shared ciphersuites||||null
If the supplied buffer is not large enough to contain the complete list of names a truncated list of names will be returned||||null
triple DES , 128 bit RC2 , 64 bit RC2 , DES and 40 bit RC2||||null
SMIME_read_CMS_APIName parses a message in S/MIME format||||null
Call SSL_get_cipher_list_APIName with SSL_get_cipher_list_APIParam_2 starting from 0 to obtain the sorted list of available ciphers, until NULL is returned||||null
SSL_get_shared_ciphers_APIParam_2 is the buffer that should be populated with the list of names and SSL_get_shared_ciphers_APIParam_3 is the size of that buffer||||null
SMIME_read_CMS_APIParam_1 is a BIO to read the message from||||null
The parsed CMS_ContentInfo structure is returned or NULL if an error occurred||||null
The details of the ciphers obtained by SSL_get_ciphers_APIName can be obtained using the SSL_CIPHER_get_name_APIName family of functions||||null
This is a server side function only and must only be called after the completion of the initial handshake||||null
SSL_get_shared_ciphers_APIName creates a colon separated and NUL terminated list of SSL_CIPHER names that are available in both the client and the server||||null
Otherwise the type of CMS_get0_type_APIParam_0 can be determined using CMS_get0_type_APIName||||null
The MIME parser used by SMIME_read_CMS_APIName is somewhat primitive||||null
SMIME_read_CMS_APIName returns a valid SMIME_read_CMS_APIParam_0 structure or NULL if an error occurred||||null
The error can be obtained from ERR_get_error_APIName||||null
These functions handle application specific data in DH structures||||null
These functions usage is identical to that of RSA_get_ex_new_index_APIName , RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName||||null
Note that just because a ciphersuite is available and shared by both the client and the server it does not mean that it is enabled||||null
Sometimes however it is useful to obtain the data originally signed using a signing operation||||null
Only certain public key algorithms can recover a signature in this way||||null
the library will try to complete the chain from the available CA certificates in the trusted CA storage , see SSL_CTX_load_verify_locations_APIName||||If no chain is specified
Normally an application is only interested in||||null
BN_copy_APIName copies BN_copy_APIParam_2 BN_dup_APIParam_1 to BN_copy_APIParam_1||||null
To support future functionality should be initialized to NULL||||null
The parser assumes that the CMS_ContentInfo structure is always base64 encoded and will not handle the case where the CMS_ContentInfo structure is in binary format or uses quoted printable format||||null
BN_dup_APIName creates a new BN_copy_APIParam_1 BN_dup_APIParam_1 containing the value BN_copy_APIParam_2 BN_dup_APIParam_1||||null
BN_copy_APIName returns BN_copy_APIParam_1 on success, NULL on error||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
EVP_PKEY_verify_recover_init_APIName and EVP_PKEY_verify_recover_APIName return 1 for success and 0 or a negative value for failure||||null
BN_dup_APIName returns the new BN_copy_APIParam_1 BN_dup_APIParam_1, and NULL on error||||null
The error codes can be obtained by ERR_get_error_APIName||||null
SSL_library_init_APIName registers the available SSL/TLS ciphers and digests||||null
The use of a memory BIO to hold the signed content limits the size of message which can be processed due to memory restraints||||null
OpenSSL_add_ssl_algorithms_APIName and SSLeay_add_ssl_algorithms_APIName are synonyms for SSL_library_init_APIName||||null
After the call to EVP_PKEY_verify_recover_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
a streaming single pass option should be available||||null
SSL_library_init_APIName must be called before any other action takes place||||null
SSL_library_init_APIName is not reentrant||||null
SSL_library_init_APIName always returns "1", so it is safe to discard the return value||||null
The length of the resulting ASN1 representation is returned||||null
If i2d_SSL_SESSION_APIParam_2 is the NULL pointer, only the length is calculated and returned||||null
SSL_library_init_APIName adds ciphers and digests used directly and indirectly by SSL/TLS||||null
d2i_SSL_SESSION_APIName returns a pointer to the newly allocated SSL_SESSION object||||null
i2d_SSL_SESSION_APIName returns the size of the ASN1 representation in bytes||||null
The function EVP_PKEY_verify_recover_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
In case of failure the NULL-pointer is returned and the error message can be retrieved from the error stack||||null
The SSL_SESSION object must be transformed into a binary ASN1 representation||||null
When the session is not valid, 0 is returned and no operation is performed||||null
i2d_SSL_SESSION_APIName transforms the SSL_SESSION object i2d_SSL_SESSION_APIParam_1 into the ASN1 representation and stores it into the memory location pointed to by i2d_SSL_SESSION_APIParam_2||||null
d2i_SSL_SESSION_APIName transforms the external ASN1 representation of an SSL/TLS session , stored as binary data at location d2i_SSL_SESSION_APIParam_2 with length d2i_SSL_SESSION_APIParam_3 , into an SSL_SESSION object||||null
ERR_load_strings_APIName registers error strings for library number ERR_load_strings_APIParam_1||||null
ERR_load_strings_APIParam_2 is an array of error string data||||null
The SSL_SESSION object is built from several malloc_APINameed parts , The SSL_SESSION object can not be moved , copied or stored directly||||null
ERR_load_strings_APIName returns no value||||null
The last entry in the array is -LCB- 0,0 -RCB-||||null
ERR_PACK_APIName return the error code||||null
One SSL_SESSION object , regardless of its reference count , must only be used with one SSL_CTX object||||null
ERR_get_next_error_library_APIName returns a new library number||||null
ERR_get_next_error_library_APIName can be used to assign library numbers to user libraries at runtime||||null
SSL_CTX_set0_verify_cert_store_APIName and SSL_CTX_set1_verify_cert_store_APIName set the certificate store used for certificate verification to SSL_CTX_set0_verify_cert_store_APIParam_2 SSL_CTX_set1_verify_cert_store_APIParam_2||||null
The chain store is used to build the certificate chain||||null
RSA is vulnerable to timing attacks||||null
All these functions return 1 for success and 0 for failure||||null
SSL_CTX_set0_chain_cert_store_APIName and SSL_CTX_set1_chain_cert_store_APIName set the certificate store used for certificate chain building to SSL_CTX_set0_chain_cert_store_APIParam_2 SSL_CTX_set1_chain_cert_store_APIParam_2||||null
RSA_blinding_on_APIName turns blinding on for key RSA_blinding_on_APIParam_1 RSA_blinding_on_APIParam_1 and generates a random blinding factor||||null
RSA_blinding_on_APIParam_2 RSA_blinding_on_APIParam_2 is NULL or a pre-allocated and initialized RSA_blinding_on_APIParam_2 RSA_blinding_on_APIParam_2||||null
The verification store is used to verify the certificate chain sent by the peer||||null
RSA_blinding_off_APIName returns no value||||null
SSL_SESSION objects keep internal link information about the session cache list||||when being inserted into one SSL_CTX object 's session cache
The random number generator must be seeded prior to calling RSA_blinding_on_APIName||||null
The stores pointers associated with an SSL_CTX structure are copied to any SSL structures||||when SSL_new_APIName is called
As a result SSL structures will not be affected||||if the parent SSL_CTX store pointer is set to a new value
RSA_blinding_off_APIName turns blinding off and frees the memory used for the blinding factor||||null
In a setup where attackers can measure the time of RSA decryption or signature operations , blinding must be used to protect the RSA operation from that attack||||null
that is an SSL/TLS client will use the verification store to verify the server 's certificate chain and a SSL/TLS server will use it to verify any client certificate chain||||null
the store associated with the parent SSL_CTX is used instead to retain compatibility with previous versions of OpenSSL||||If the chain or the verification store is not set
the session must be explicitly removed using SSL_SESSION_free_APIName||||unless the SSL_SESSION object is completely taken over , when being called inside the get_session_cb_APIName
The reference count is 1 , so that||||null
RSA_blinding_on_APIName returns 1 on success, and 0 if an error occurred||||null
SSL_set_session_APIName is only useful for TLS/SSL clients||||null
The following return values can occur||||null
Whether the session was reused can be queried with the SSL_session_reused_APIName call||||null
The operation succeeded||||null
The operation failed||||null
check the error stack to find out the reason||||null
The string is returned in des_read_pw_APIParam_1 des_read_pw_APIParam_1, which must have spac for at least des_read_pw_APIParam_3 des_read_pw_APIParam_3 bytes||||null
The DES library contained a few routines to prompt for passwords||||null
All other functions described here use des_read_pw_APIName to do the work||||null
One SSL_SESSION object , regardless of its reference count , must only be used with one SSL_CTX object||||null
These are n't necessarely dependent on DES , and have become part of the UI compatibility library||||null
A return code of -1 indicates a system error, 1 failure due to use interaction, and 0 is success||||null
SSL_CTX_set_default_read_ahead is a synonym for SSL_CTX_set_read_ahead , and SSL_CTX_get_default_read_ahead is a synonym for SSL_CTX_get_read_ahead||||null
the reference count of SSL_set_session_APIParam_2 SSL_set_session_APIParam_2 is incremented by 1||||When the session is set
to be used||||when the TLS/SSL connection is to be established
SSL_set_session_APIName sets SSL_set_session_APIParam_2 SSL_set_session_APIParam_2||||null
the reference count is decremented again during SSL_connect_APIName||||If the session is not reused
SSL_CTX_get_read_ahead_APIName and SSL_get_read_ahead_APIName indicate||||null
The second password is stored in des_read_pw_APIParam_2 des_read_pw_APIParam_2 , which must also be at least des_read_pw_APIParam_3 des_read_pw_APIParam_3 bytes||||null
If des_read_pw_APIParam_5 des_read_pw_APIParam_5 is set, the user is asked for the password twice and unless the two copies match, an error is returned||||null
des_read_pw_APIName writes the string specified by des_read_pw_APIParam_4 des_read_pw_APIParam_4 to standard output turns echo off and reads an input string from the terminal||||null
The return values for SSL_CTX_get_read_head_APIName and SSL_get_read_ahead_APIName are undefined for DTLS||||null
des_read_pw_string_APIName is available in the MIT Kerberos library as well , and is also available under the name EVP_read_pw_string_APIName||||null
SSL_get_read_ahead and SSL_CTX_get_read_ahead return 0 if reading ahead is off, and non zero otherwise||||null
SSL_SESSION_free_APIName will be called for that session||||If there is already a session set inside SSL_set_session_APIParam_1
SSL_CTX_set_mode_APIName adds the mode set via bitmask in SSL_CTX_set_mode_APIParam_2 to SSL_CTX_set_mode_APIParam_1||||null
Options already set before are not cleared||||null
SSL_SESSION objects keep internal link information about the session cache list||||when being inserted into one SSL_CTX object 's session cache
SSL_CTX_get_mode_APIName returns the mode set for SSL_CTX_get_mode_APIParam_1||||null
Options already set before are not cleared||||null
SSL_get_mode_APIName returns the mode set for SSL_get_mode_APIParam_1||||null
SSL_set_mode_APIName adds the mode set via bitmask in SSL_set_mode_APIParam_2 to SSL_set_mode_APIParam_1||||null
The following mode changes are available||||null
Allow SSL_write to return r with 0 < r < n||||null
These functions have no impact||||when used with DTLS
Make it possible to retry SSL_write_APIName with changed buffer location||||null
provides a buffer for you||||if des_read_pw_string_APIParam_4 des_read_pw_APIParam_5 is set
des_read_pw_string_APIName is a variant of des_read_pw_APIName that||||null
The flag SSL_MODE_AUTO_RETRY will cause read/write operations to only return after the handshake and successful completion||||null
This is not the default to avoid the misconception that non-blocking SSL_write_APIName behaves like non-blocking write_APIName||||null
des_read_password_APIName calls des_read_pw_APIName and converts the password to a DES key by calling DES_string_to_key_APIName||||null
In a non-blocking environment applications must be prepared to handle incomplete read/write operations||||null
In a blocking environment, applications are not always prepared to deal with read/write operations returning without success report||||null
If a renegotiation take place during normal operation, a SSL_read_APIName or SSL_write_APIName would return with -1 and indicate the need to retry with SSL_ERROR_WANT_READ||||null
Send TLS_FALLBACK_SCSV in the ClientHello||||null
Using this flag can save around 34k per idle SSL connection||||null
Once SSL_write_APIName returns with r, r bytes have been successfully written and the next call to SSL_write_APIName must only send the n-r bytes left, imitating the behaviour of write_APIName||||null
SSL_CTX_set_mode_APIName and SSL_set_mode_APIName return the new mode bitmask after adding SSL_CTX_set_mode_APIParam_2 SSL_set_mode_APIParam_2||||null
set , SSL_write_APIName will only report success once the complete chunk was written||||When not
des_read_2password_APIName operates in the same way as des_read_password_APIName except that it generates two keys by using the DES_string_to_2key_APIName function||||null
This flag has no effect on SSL v2 connections , or on DTLS connections||||null
SSL_CTX_get_mode_APIName and SSL_get_mode_APIName return the current bitmask||||null
To be set only by applications that reconnect with a downgraded protocol version||||null
Never bother the application with retries||||if the transport is blocking
see draft-ietf-tls-downgrade-scsv-00 for details||||null
Only use this in explicit fallback retries , following the guidance in draft-ietf-tls-downgrade-scsv-00||||null
Hence , these two functions are no longer the recommended way to control defaults||||null
These functions implement a cryptographically secure pseudo-random number generator||||null
This is described in RAND_add_APIName||||null
Since the introduction of the ENGINE API , the recommended way of controlling default implementations is by using the ENGINE API functions||||null
SSL_CTX_get_verify_mode_APIName returns the verification mode currently set in SSL_CTX_get_verify_mode_APIParam_1||||null
RAND_bytes_APIName describes how to obtain random data from the PRNG||||null
SSL_get_verify_mode_APIName returns the verification mode currently set in SSL_get_verify_mode_APIParam_1||||null
DO NOT ENABLE THIS||||if your application attempts a normal handshake
The mechanisms described below relate solely to the software PRNG implementation built in to OpenSSL and used by default||||null
SSL_CTX_get_verify_depth_APIName returns the verification depth limit currently set in SSL_CTX_get_verify_depth_APIParam_1||||null
SSL_get_verify_depth_APIName returns the verification depth limit currently set in SSL_get_verify_depth_APIParam_1||||null
A cryptographic PRNG must be seeded with unpredictable data such as mouse movements or keys pressed at random by the user||||null
If no limit has been explicitly set, -1 is returned and the default value will be used||||null
SSL_CTX_get_verify_callback_APIName returns a function pointer to the verification callback currently set in SSL_CTX_get_verify_mode_APIParam_1 SSL_CTX_get_verify_depth_APIParam_1||||null
The default RAND_set_rand_method_APIParam_1, as set by RAND_set_rand_method_APIName and returned by RAND_get_rand_method_APIName, is only used if no ENGINE has been set as the default "rand" implementation||||null
SSL_get_verify_callback_APIName returns a function pointer to the verification callback currently set in SSL_get_verify_depth_APIParam_1 SSL_get_verify_mode_APIParam_1||||null
If no callback was explicitly set, the NULL pointer is returned and the default callback will be used||||null
ERR_clear_error_APIName empties the current thread 's error queue||||null
ERR_clear_error_APIName has no return value||||null
If no limit has been explicitly set, -1 is returned and the default value will be used||||null
If no callback was explicitly set, the NULL pointer is returned and the default callback will be used||||null
DH_new_APIName allocates and initializes a DH_new_APIParam_0 structure||||null
The values are erased before the memory is returned to the system||||null
DH_free_APIName frees the DH_free_APIParam_1 structure and its components||||null
Otherwise it returns a pointer to the newly allocated structure||||null
DH_free_APIName returns no value||||null
If the allocation fails, DH_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
applications can use it||||when they need randomness
It is used by other library functions to generate random keys , and||||null
The EVP library provides a high-level interface to cryptographic functions||||null
The EVP_PKEY functions support the full range of asymmetric algorithm operations||||null
However , new applications should not typically use this||||null
having to go through the seeding process||||whenever the application is started
Its state can be saved in a seed file to avoid||||null
Algorithms are loaded with OpenSSL_add_all_algorithms_APIName||||null
The EVP_BytesToKey_APIName function provides some limited support for password based encryption||||null
Careful selection of the parameters will provide a PKCS # 5 PBKDF1 compatible implementation||||null
For more information , consult the engine_APIName man page||||null
their use is discouraged||||null
If ASN1_TIME_set_APIParam_1 is NULL , a new ASN1_TIME structure is allocated and returned||||null
All the symmetric algorithms , digests and asymmetric algorithms can be replaced by ENGINE modules providing alternative implementations||||null
The function ASN1_TIME_set_APIName sets the ASN1_TIME structure ASN1_TIME_set_APIParam_1 to the time represented by the time_t value ASN1_TIME_set_APIParam_2||||null
memory is either appended to a list of unused RAM chunks on the SSL_CTX , or simply freed||||if the list of unused chunks would become longer than SSL_CTX - > freelist_max_len , which defaults to 32
Released||||null
ASN1_TIME_check_APIName checks the syntax of ASN1_TIME structure ASN1_TIME_check_APIParam_1||||null
ASN1_TIME_print_APIName prints out the time ASN1_TIME_print_APIParam_2 to BIO ASN1_TIME_print_APIParam_1 in human readable format||||null
They can not be used with an ENGINE and ENGINE versions of new algorithms can not be accessed using the low level functions||||null
ASN1_TIME_set_string_APIName sets ASN1_TIME structure ASN1_TIME_set_string_APIParam_1 to the time represented by string ASN1_TIME_set_string_APIParam_2 which must be in appropriate ASN .1 time format||||null
Also makes code harder to adapt to new algorithms and some options are not cleanly supported at the low level and some operations are more efficient using the high level interface||||null
the various EVP functions will automatically use those implementations automatically in preference to built in software implementations||||If ENGINE implementations of ciphers or digests are registered as defaults
If the time structure has invalid format, it prints out "Bad time value" and returns an error||||null
ASN1_TIME_print_APIName currently does not print out the time zone||||null
ASN1_TIME_check_APIName returns 1 if the structure is syntactically correct and 0 otherwise||||null
The ASN1_TIME structure is represented as an ASN1_STRING internally and can be freed up using ASN1_STRING_free_APIName||||null
But all certificates complying with RFC5280 et al use GMT anyway||||null
it either prints out `` GMT '' or nothing||||null
ASN1_TIME_set_string_APIName returns 1 if the time value is successfully set and 0 otherwise||||null
ASN1_TIME_set_APIName and ASN1_TIME_adj_APIName return a pointer to an ASN1_TIME structure or NULL if an error occurred||||null
ASN1_TIME_diff_APIName returns 1 for sucess and 0 for failure||||null
The ASN1_TIME structure can represent years from 0000 to 9999 but no attempt is made to correct ancient calendar changes||||null
ASN1_TIME_print_APIName returns 1 if the time is successfully printed out and 0 if an error occurred||||null
RAND_load_file_APIName returns the number of bytes read||||null
RAND_file_name_APIName returns a pointer to RAND_file_name_APIParam_1 on success, and NULL on error||||null
BIO_s_bio_APIName returns the method for a BIO pair||||null
RAND_load_file_APIName reads a number of bytes from file RAND_load_file_APIParam_1 and adds them to the PRNG||||null
RAND_write_file_APIName returns the number of bytes written, and -1 if the bytes written were generated without appropriate seed||||null
BIO_reset_APIName clears any data in the write buffer||||null
Both halves must usually by handled by the same application thread||||null
BIO_destroy_pair_APIName destroys the association between two connected BIOs||||null
RAND_write_file_APIName writes a number of random bytes to file RAND_write_file_APIParam_1 RAND_load_file_APIParam_1 which can be used to initialize the PRNG by calling RAND_load_file_APIName in a later session||||null
It can fail||||if the pass ASN1_TIME structure has invalid syntax
BIO_make_bio_pair_APIName joins two separate BIOs into a connected pair||||null
BIO_shutdown_wr_APIName is used to close down a BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1||||null
Freeing up any half of the pair will automatically destroy the association||||null
BIO_get_write_buf_size_APIName returns the size of the write buffer||||null
After this call no further writes on BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 are allowed||||null
The standard calls BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName can be used to determine the amount of pending data in the read or write buffer||||null
This is currently 17K , sufficient for a maximum size TLS record||||null
Reads on the other half of the pair will return any pending data or EOF when all pending data has been read||||null
data from the buffer or request a retry||||if no data is available
Calls to BIO_read_APIName will read||||null
BIO_set_write_buf_size_APIName sets the write buffer size of BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 to BIO_new_bio_pair_APIParam_2||||null
data in the buffer or request a retry||||if the buffer is full
Calls to BIO_write_APIName will place||||null
starting with OpenSSL 0.9.5 , , the complete file is read||||if RAND_load_file_APIParam_2 is -1
BIO_get_write_guarantee_APIName and BIO_ctrl_get_write_guarantee_APIName return the maximum length of data that can be currently written to the BIO||||null
BIO_ctrl_get_write_guarantee_APIName is a function whereas BIO_get_write_guarantee_APIName is a macro||||null
BIO_ctrl_reset_read_request_APIName can also be used to reset the value returned by BIO_get_read_request_APIName to zero||||null
Both halves of a BIO pair should be freed||||null
A BIO pair is a pair of source/sink BIOs where data written to either half of the pair is buffered and can be read from the other half||||null
a default value is used||||If the size is not initialized
it is possible to make this one half of a BIO pair and have all the data processed by the chain under application control||||null
BIO_new_bio_pair_APIName does not check||||null
Writes larger than this value will return a value from BIO_write_APIName less than the amount requested or if the buffer is full request a retry||||null
BIO_write_APIName will succeed and place data in the write buffer||||null
BIO_read_APIName will initially fail and BIO_should_read_APIName will be true||||null
Check the error stack for more information||||null
This must be done before any normal processing due to a request and BIO_should_read_APIName being true||||null
All the remaining `` functions '' are implemented as macros||||null
BIO_new_bio_pair_APIName combines the calls to BIO_new_APIName , BIO_make_bio_pair_APIName and BIO_set_write_buf_size_APIName to create a connected pair of BIOs BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1 , BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 with write buffer sizes BIO_new_bio_pair_APIParam_2 BIO_new_bio_pair_APIParam_2 and BIO_new_APIName0 BIO_new_APIName0||||null
The EVP_PKEY_CTX_set_signature_md_APIName macro sets the message digest type used in a signature||||null
As the data is buffered, SSL_operation_APIName may return with a ERROR_SSL_WANT_READ condition, but there is still data in the write buffer||||null
Otherwise a deadlock may occur as the peer might be waiting for the data before being able to continue||||null
The EVP_PKEY_CTX_set_signature_md_APIName macro can be used with any public key algorithm supporting signature operations||||null
That is||||even if one half is implicit freed due to a BIO_free_all_APIName or SSL_free_APIName call the other half needs to be freed
Applications will not normally call EVP_PKEY_CTX_ctrl_APIName directly but will instead call one of the algorithm specific macros below||||null
The macro EVP_PKEY_CTX_set_rsa_padding_APIName sets the RSA padding mode for EVP_PKEY_CTX_set_rsa_padding_APIParam_1||||null
An application must not rely on the error value of SSL_operation_APIName but must assure that the write buffer is always flushed first||||null
More return values need to be added here]||||null
BIO_new_bio_pair_APIName returns 1 on success, with the new BIOs available in BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3, or 0 on failure, with NULL pointers stored into the locations for BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3||||null
BIO_eof_APIName is true||||if no data is in the peer BIO and the peer BIO has been shutdown
The EVP_PKEY_CTX_set_dh_paramgen_generator_APIName macro sets DH generator to EVP_PKEY_CTX_set_dh_paramgen_generator_APIParam_2 for DH parameter generation||||null
this can be used||||when the application wishes to use a non standard transport for TLS/SSL
One typical use of BIO pairs is to place TLS/SSL I/O under application control , or the normal socket routines are inappropriate||||null
The EVP_PKEY_CTX_set_ec_paramgen_curve_nid_APIName sets the EC curve for EC parameter generation to EVP_PKEY_CTX_set_ec_paramgen_curve_nid_APIParam_2||||null
EVP_PKEY_CTX_ctrl_APIName and its macros return a positive value for success and 0 or a negative value for failure||||null
Two RSA padding modes behave differently||||if EVP_PKEY_CTX_set_signature_md_APIName is used
The EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIParam_2 pointer is used internally by this function so it should not be modified or free after the call||||null
For EC parameter generation this macro must be called or an error occurs||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
Any of the following flags can be passed in the CMS_add1_signer_APIParam_5 parameter||||null
The EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIName macro sets the public exponent value for RSA key generation to EVP_PKEY_CTX_set_rsa_keygen_pubexp_APIParam_2 currently it should be an odd integer||||null
calling BIO_pending_APIName on the other half of the pair and , , reading it and sending it to the underlying transport||||if any data is pending
This can be done by||||null
CMS_add1_signer_APIName returns an internal pointer to the CMS_SignerInfo structure just added or NULL if an error occurs||||null
it will never succeed !||||If the application waits for data to be available on the underlying transport before flushing the write buffer
CMS_add1_signer_APIName returns an internal pointer to the CMS_SignerInfo structure just added, this can be used to set additional attributes before it is finalized||||null
CMS_add1_signer_APIName adds a signer with certificate CMS_add1_signer_APIParam_2 and private key CMS_add1_signer_APIParam_3 using message digest CMS_add1_signer_APIParam_4 to CMS_ContentInfo SignedData structure CMS_add1_signer_APIParam_1||||null
RAND_cleanup_APIName erases the memory used by the PRNG||||null
EVP_PKEY_encrypt_init_APIName and EVP_PKEY_encrypt_APIName return 1 for success and 0 or a negative value for failure||||null
RAND_cleanup_APIName returns no value||||null
To see why this is important consider a case where a request is sent using BIO_write_APIName and a response read with BIO_read_APIName , this can occur||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
After the call to EVP_PKEY_encrypt_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
These functions handle application specific data in X509_STORE_CTX structures||||null
The EVP cipher routines are a high level interface to certain symmetric ciphers||||null
If padding is disabled, EVP_EncryptFinal_ex_APIName will not encrypt any more data and it will return an error if any data remains in a partial block||||null
These functions usage is identical to that of RSA_get_ex_new_index_APIName , RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName||||null
In the case of X9 .31 padding for RSA the algorithm identifier byte is added or checked and removed||||if this control is called
the default digest for the public key algorithm will be used||||If the CMS_add1_signer_APIParam_4 parameter is NULL
It will be of the format MMM DD HH||||null
EVP_EncryptFinal_APIName , EVP_DecryptFinal_APIName and EVP_CipherFinal_APIName are identical to EVP_EncryptFinal_ex_APIName , EVP_DecryptFinal_ex_APIName and EVP_CipherFinal_ex_APIName||||null
EVP_CIPHER_CTX_cleanup_APIName clears all information from a cipher context and free up any allocated memory associate with EVP_CIPHER_CTX_cleanup_APIName||||null
EVP_CIPHER_CTX_init_APIName initializes cipher contex EVP_EncryptUpdate_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_CIPHER_type_APIParam_1 EVP_EncryptUpdate_APIParam_10 EVP_EncryptUpdate_APIParam_11 EVP_EncryptUpdate_APIParam_12 EVP_EncryptUpdate_APIParam_13 EVP_EncryptUpdate_APIParam_14 EVP_EncryptUpdate_APIParam_15 EVP_EncryptUpdate_APIParam_16 EVP_EncryptUpdate_APIParam_17||||null
The EVP_PKEY_CTX_set_rsa_padding_APIParam_2 parameter can take the value RSA_PKCS1_PADDING for PKCS # 1 padding , RSA_SSLV23_PADDING for SSLv23 padding , RSA_NO_PADDING for no padding , RSA_PKCS1_OAEP_PADDING for OAEP padding , RSA_X931_PADDING for X9 .31 padding and RSA_PKCS1_PSS_PADDING||||null
The function EVP_PKEY_encrypt_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
EVP_CIPHER_CTX_cleanup_APIName should be called after all operations using a cipher are complete so sensitive information does not remain in memory||||null
the plaintext buffer is an actual digest value and is encapsulated in a DigestInfo structure according to PKCS # 1 when signing and this structure is expected when verifying||||If this macro is called for PKCS # 1 padding
the GOST algorithms will not be included||||if the GOST ENGINE is not loaded
that is||||if the total data length is not a multiple of the block size
SS YYYY -LSB- GMT -RSB- , `` Feb 3 00||||null
52 2015 GMT '' it does not include a newline||||null
256 bit AES , Gost R3411-94 , Gost 28147-89 , 192 bit AES , 128 bit AES , triple DES , 128 bit RC2 , 64 bit RC2 , DES and 40 bit RC2||||null
EVP_get_cipherbyname_APIName, EVP_get_cipherbynid_APIName and EVP_get_cipherbyobj_APIName return an EVP_CIPHER structure when passed a cipher name, a NID or an ASN1_OBJECT structure||||null
EVP_CIPHER_CTX_set_key_length_APIName sets the key length of the cipher ctx||||null
EVP_CIPHER_mode_APIName and EVP_CIPHER_CTX_mode_APIName return the block cipher mode||||null
The actual NID value is an internal value which may not have a corresponding OBJECT IDENTIFIER||||null
If the cipher is a stream cipher ,then EVP_CIPH_STREAM_CIPHER is returned||||null
EVP_CIPH_ECB_MODE , EVP_CIPH_CBC_MODE , EVP_CIPH_CFB_MODE or EVP_CIPH_OFB_MODE||||null
EVP_EncryptInit_ex_APIName, EVP_EncryptUpdate_APIName and EVP_EncryptFinal_ex_APIName return 1 for success and 0 for failure||||null
EVP_DecryptFinal_ex_APIName returns 0 if the decrypt failed or 1 for success||||null
EVP_DecryptInit_ex_APIName and EVP_DecryptUpdate_APIName return 1 for success and 0 for failure||||null
EVP_CIPHER_CTX_ctrl_APIName allows various cipher specific parameters to be determined and set||||null
EVP_CipherInit_ex_APIName and EVP_CipherUpdate_APIName return 1 for success and 0 for failure||||null
EVP_CIPHER_CTX_cleanup_APIName returns 1 for success and 0 for failure||||null
EVP_CipherFinal_ex_APIName returns 0 for a decryption failure or 1 for success||||null
EVP_CIPHER_nid_APIName and EVP_CIPHER_CTX_nid_APIName return a NID||||null
EVP_CIPHER_block_size_APIName and EVP_CIPHER_CTX_block_size_APIName return the block size||||null
In previous releases they also cleaned up the EVP_EncryptFinal_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_CipherFinal_ex_APIParam_1 , but this is no longer done and EVP_CIPHER_CTX_clean_APIName must be called to free any context resources||||null
EVP_get_cipherbyname_APIName, EVP_get_cipherbynid_APIName and EVP_get_cipherbyobj_APIName return an EVP_get_cipherbyname_APIParam_0 structure or NULL on error||||null
EVP_CIPHER_key_length_APIName and EVP_CIPHER_CTX_key_length_APIName return the key length||||null
EVP_CIPHER_CTX_set_padding_APIName always returns 1||||null
EVP_CIPHER_iv_length_APIName and EVP_CIPHER_CTX_iv_length_APIName return the IV length or zero if the cipher does not use an IV||||null
EVP_CIPHER_param_to_asn1_APIName and EVP_CIPHER_asn1_to_param_APIName return 1 for success or zero for failure||||null
EVP_CIPHER_type_APIName and EVP_CIPHER_CTX_type_APIName return the NID of the cipher's OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER||||null
EVP_CIPHER_CTX_cipher_APIName returns an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_EncryptUpdate_APIParam_10 EVP_EncryptUpdate_APIParam_11 EVP_EncryptUpdate_APIParam_12 EVP_EncryptUpdate_APIParam_13 EVP_EncryptUpdate_APIParam_14 EVP_EncryptUpdate_APIParam_15 EVP_EncryptUpdate_APIParam_16 EVP_EncryptUpdate_APIParam_17 EVP_EncryptUpdate_APIParam_18 EVP_EncryptUpdate_APIParam_19 EVP_CIPHER_asn1_to_param_APIParam_10 EVP_EncryptInit_APIParam_1 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 structure||||null
EVP_CIPHER_CTX_cipher_APIName returns the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_EncryptUpdate_APIParam_12 EVP_EncryptUpdate_APIParam_13 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_EncryptUpdate_APIParam_17 EVP_EncryptUpdate_APIParam_18 EVP_DecryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_10 EVP_CIPHER_asn1_to_param_APIParam_11 EVP_CIPHER_asn1_to_param_APIParam_12 EVP_EncryptInit_ex_APIParam_1 structure when passed an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_ctrl_APIParam_1 EVP_EncryptUpdate_APIParam_13 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CipherFinal_APIParam_1 EVP_EncryptUpdate_APIParam_17 EVP_EncryptUpdate_APIParam_18 EVP_DecryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_10 EVP_CIPHER_asn1_to_param_APIParam_11 EVP_CIPHER_asn1_to_param_APIParam_12 EVP_EncryptInit_ex_APIParam_1 structure||||null
This is because the code becomes transparent to the cipher used and much more flexible||||null
This is a limitation of the current RC5 code rather than the EVP interface||||null
The functions EVP_EncryptInit_APIName , EVP_EncryptFinal_APIName , EVP_DecryptInit_APIName , EVP_CipherInit_APIName and EVP_CipherFinal_APIName are obsolete but are retained for compatibility with existing code||||null
The BIO_push_APIName function appends the BIO BIO_push_APIParam_2 to BIO_push_APIParam_1, it returns BIO_push_APIParam_1||||null
For RC5 the number of rounds can currently only be set to 8 , 12 or 16||||null
EVP_MAX_KEY_LENGTH and EVP_MAX_IV_LENGTH only refer to the internal ciphers with default key lengths||||null
attempting to set the key length to any value other than the fixed value is an error||||If the cipher is a fixed length cipher
The names of these functions are perhaps a little misleading||||null
it is not a strong test that the input data or key is correct||||null
EVP_EncryptInit_APIName , EVP_DecryptInit_APIName and EVP_CipherInit_APIName behave in a similar way to EVP_EncryptInit_ex_APIName , EVP_DecryptInit_ex and EVP_CipherInit_ex_APIName except the EVP_EncryptInit_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_CipherInit_APIParam_1 EVP_EncryptInit_ex_APIParam_1 EVP_CipherInit_ex_APIParam_1 parameter does not need to be initialized and they always use the default cipher implementation||||null
This is because it has become standard practice to define a generic key as a fixed unsigned char array containing EVP_MAX_KEY_LENGTH bytes||||null
BIO_push_APIName returns the end of the chain, BIO_push_APIParam_1||||null
New code should use EVP_EncryptInit_ex_APIName , EVP_EncryptFinal_ex_APIName , EVP_DecryptInit_ex_APIName , EVP_DecryptFinal_ex_APIName , EVP_CipherInit_ex_APIName and EVP_CipherFinal_ex_APIName||||null
SSL_pending_APIName returns the number of bytes which are available inside SSL_pending_APIParam_1 for immediate read||||null
The ASN1 code is incomplete The ASN1 code has only been tested for certain common S/MIME ciphers in CBC mode||||null
BIO_pop_APIName returns the next BIO in the chain, or NULL if there is no next BIO||||null
BIO_pop_APIName removes the BIO BIO_pop_APIParam_1 from a chain and returns the next BIO in the chain, or NULL if there is no next BIO||||null
the results are unpredictable||||If custom ciphers exceed these values
The number of bytes pending is returned||||null
Data are received in blocks from the peer||||null
||||if the block size is 8 and 11 bytes are to be encrypted 5 padding bytes of value 5 will be added
EVP_CIPHER_nid_APIName and EVP_CIPHER_CTX_nid_APIName return the NID of a cipher when passed an EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_nid_APIName2 EVP_CIPHER_CTX_nid_APIName3 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CIPHER_CTX_nid_APIName7 EVP_CIPHER_CTX_nid_APIName8 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_EncryptUpdate_APIParam_10 EVP_EncryptUpdate_APIParam_11 EVP_EncryptUpdate_APIParam_12 EVP_CipherUpdate_APIParam_1 EVP_EncryptUpdate_APIParam_14 or EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_CTX_nid_APIName2 EVP_CIPHER_param_to_asn1_APIParam_1 EVP_EncryptFinal_ex_APIParam_1 EVP_CIPHER_CTX_init_APIParam_1 EVP_CIPHER_CTX_nid_APIName7 EVP_CIPHER_CTX_nid_APIName8 EVP_CIPHER_CTX_cleanup_APIParam_1 EVP_EncryptUpdate_APIParam_10 EVP_EncryptUpdate_APIParam_11 EVP_EncryptUpdate_APIParam_12 EVP_CipherUpdate_APIParam_1 EVP_EncryptUpdate_APIParam_14 structure||||null
data can be buffered inside SSL_pending_APIParam_1 and are ready for immediate retrieval with SSL_read_APIName||||null
the decryption operation will always succeed if the total amount of data decrypted is a multiple of the block size||||If padding is disabled
This library performs arithmetic operations on integers of arbitrary size||||null
Additionally , the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_10 EVP_CIPHER_asn1_to_param_APIParam_11 EVP_CIPHER_asn1_to_param_APIParam_12 EVP_CIPHER_asn1_to_param_APIParam_13 EVP_CIPHER_asn1_to_param_APIParam_14 EVP_CIPHER_asn1_to_param_APIParam_15 EVP_CIPHER_asn1_to_param_APIParam_16 EVP_CIPHER_asn1_to_param_APIParam_17 EVP_CIPHER_asn1_to_param_APIParam_18 EVP_CIPHER_asn1_to_param_APIParam_19 EVP_CipherInit_ex_APIParam_10 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 interface will ensure the use of platform specific cryptographic acceleration such as AES-NI||||null
It uses dynamic memory allocation for storing its data structures||||null
The process of calling BIO_push_APIName and BIO_pop_APIName on a BIO may have additional consequences any effects will be noted in the descriptions of individual BIOs||||null
A random block has better than 1 in 256 chance of being of the correct format and problems with the input data earlier on will not produce a final decrypt error||||null
It was written for use in public key cryptography , such as RSA and Diffie-Hellman||||null
SSL_CTX_set_client_CA_list_APIName and SSL_set_client_CA_list_APIName do not return diagnostic information||||null
The basic object in this library is a BN_init_APIParam_1||||null
Where possible the EVP_EncryptUpdate_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_1 EVP_CipherInit_ex_APIParam_1 EVP_DecryptFinal_APIParam_1 EVP_CIPHER_CTX_set_padding_APIParam_1 EVP_CIPHER_CTX_set_key_length_APIParam_1 EVP_DecryptFinal_ex_APIParam_1 EVP_DecryptInit_APIParam_1 EVP_DecryptInit_ex_APIParam_1 EVP_CipherInit_APIParam_1 EVP_CIPHER_asn1_to_param_APIParam_10 EVP_CIPHER_asn1_to_param_APIParam_11 EVP_CIPHER_asn1_to_param_APIParam_12 EVP_CIPHER_asn1_to_param_APIParam_13 EVP_CIPHER_asn1_to_param_APIParam_14 EVP_CIPHER_asn1_to_param_APIParam_15 EVP_CIPHER_asn1_to_param_APIParam_16 EVP_CIPHER_asn1_to_param_APIParam_17 EVP_CIPHER_asn1_to_param_APIParam_18 EVP_CIPHER_asn1_to_param_APIParam_19 EVP_CipherInit_ex_APIParam_10 EVP_CipherUpdate_APIParam_1 EVP_EncryptInit_ex_APIParam_1 interface to symmetric ciphers should be used in preference to the low level interfaces||||null
It is used to hold a single large integer||||null
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName have the following return values||||null
Up to OpenSSL 0.9.6 , SSL_pending_APIName does not check if the record type of pending data is application data||||null
The removed BIO becomes a single BIO with no association with the original chain , it can thus be freed or attached to a different chain||||null
This type should be considered opaque and fields should not be modified or accessed directly||||null
The PEM functions read or write structures in PEM format||||null
In this sense PEM format is simply base64 encoded data surrounded by header lines||||null
They will also process a trusted X509 certificate but any trust settings are discarded||||null
The conversion of BN_add_APIParam_1 BN_cmp_APIParam_1 BN_zero_APIParam_1 BN_rand_APIParam_1 BN_generate_prime_APIParam_1 BN_set_bit_APIParam_1 BN_bn2bin_APIParam_1s to external formats is described in BN_bn2bin_APIName||||null
That means that there is no limit on the size of the numbers manipulated by these functions, but return values must always be checked in case a memory allocation error has occurred||||null
The algorithm to use is specified in the PEM_write_bio_PKCS8PrivateKey_nid_APIParam_3 PEM_write_PKCS8PrivateKey_nid_APIParam_3 parameter and should be the NID of the corresponding OBJECT IDENTIFIER||||null
Comparison is described in BN_cmp_APIName||||null
BIO_push_APIName joins two BIO chains whereas BIO_pop_APIName deletes a single BIO from a chain , the deleted BIO does not need to be at the end of a chain||||null
The creation of BN_add_APIParam_1 BN_cmp_APIParam_1 BN_zero_APIParam_1 BN_rand_APIParam_1 BN_generate_prime_APIParam_1 BN_set_bit_APIParam_1 BN_bn2bin_APIParam_1 objects is described in BN_new_APIName||||null
BN_add_APIName describes most of the arithmetic operations||||null
The PEM_write_X509_CRL_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_read_X509_CRL_APIParam_2 PEM_read_bio_X509_CRL_APIParam_2 functions process an X509 CRL using an X509_CRL structure||||null
The PEM_read_PKCS7_APIParam_2 PEM_read_bio_PKCS7_APIParam_2 PEM_write_PKCS7_APIParam_2 PEM_write_bio_PKCS7_APIParam_2 functions process a PKCS # 7 ContentInfo using a PKCS7 structure||||null
The PEM_write_bio_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_write_NETSCAPE_CERT_SEQUENCE_APIParam_2 functions process a Netscape Certificate Sequence using a NETSCAPE_CERT_SEQUENCE structure||||null
Padding is always added||||so if the data is already a multiple of the block size EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CipherInit_ex_APIParam_20 EVP_CipherInit_ex_APIParam_21 EVP_CipherInit_ex_APIParam_22 EVP_CipherInit_ex_APIParam_23 EVP_CipherInit_ex_APIParam_24 EVP_CipherInit_ex_APIParam_25 EVP_CipherInit_ex_APIParam_26 EVP_CipherInit_ex_APIParam_27 EVP_CipherInit_ex_APIParam_28 EVP_CipherInit_ex_APIParam_29 will equal the block size
the following||||null
BN_zero_APIName describes certain assignments , BN_rand_APIName the generation of random numbers , BN_generate_prime_APIName deals with prime numbers and BN_set_bit_APIName with bit operations||||null
is guaranteed to work||||null
A frequent cause of problems is attempting to use the PEM routines like this||||null
The function EVP_PKEY_copy_parameters_APIName copies the parameters from key EVP_PKEY_copy_parameters_APIParam_2 to key EVP_PKEY_copy_parameters_APIParam_1||||null
The PEM read routines in some versions of OpenSSL will not correctly reuse an existing structure||||null
The function EVP_PKEY_cmp_parameters_APIName compares the parameters of keys EVP_PKEY_cmp_parameters_APIParam_1 and EVP_PKEY_cmp_parameters_APIParam_2||||null
An error is returned if the parameters are missing in EVP_PKEY_copy_parameters_APIParam_2 or present in both EVP_PKEY_copy_parameters_APIParam_2 and EVP_PKEY_copy_parameters_APIParam_1 and mismatch||||null
These functions EVP_PKEY_copy_parameters_APIName returns 1 for success and 0 for failure||||null
PEM_write_bio_PKCS8PrivateKey_nid_APIName and PEM_write_PKCS8PrivateKey_nid_APIName also write out a private key as a PKCS # 8 EncryptedPrivateKeyInfo however it uses PKCS # 5 v1 .5 or PKCS # 12 encryption algorithms instead||||null
The function EVP_PKEY_cmp_APIName compares the public key components and paramters of keys EVP_PKEY_cmp_APIParam_1 and EVP_PKEY_cmp_APIParam_2||||null
One of these functions should be called before generating textual error messages||||null
The function EVP_PKEY_missing_parameters_APIName returns 1 if the public key parameters of EVP_PKEY_missing_parameters_APIParam_1 are missing and 0 if they are present or the algorithm doesn't use parameters||||null
ERR_free_strings_APIName frees all previously loaded error strings||||null
The function EVP_PKEY_missing_parameters_APIName returns 1 if the public key parameters of EVP_PKEY_missing_parameters_APIParam_1 are missing and 0 if they are present or the algorithm doesn't use parameters||||null
The function EVP_PKEY_cmp_parameters_APIName and EVP_PKEY_cmp_APIName return 1 if the keys match, 0 if they don't match, -1 if the key types are different and -2 if the operation is not supported||||null
The PEM_write_X509_REQ_NEW_APIParam_2 PEM_read_bio_X509_AUX_APIParam_2 PEM_read_X509_REQ_APIParam_2 PEM_read_bio_X509_REQ_APIParam_2 PEM_write_bio_X509_AUX_APIParam_2 PEM_write_bio_X509_REQ_NEW_APIParam_2 PEM_write_X509_CRL_APIParam_2 PEM_write_bio_X509_REQ_APIParam_2 PEM_write_X509_APIParam_2 PEM_write_bio_X509_CRL_APIParam_2 PEM_read_bio_X509_AUX_APIParam_20 PEM_read_bio_X509_AUX_APIParam_21 PEM_read_bio_X509_AUX_APIParam_22 PEM_read_bio_X509_AUX_APIParam_23 PEM_read_bio_X509_AUX_APIParam_24 PEM_read_bio_X509_AUX_APIParam_25 PEM_read_bio_X509_AUX_APIParam_26 PEM_read_bio_X509_AUX_APIParam_27 functions process an X509 certificate using an X509 structure||||null
Since OpenSSL private keys contain public key components too the function EVP_PKEY_cmp_APIName can also be used to determine if a private key matches a public key||||null
ERR_load_crypto_strings_APIName, SSL_load_error_strings_APIName and ERR_free_strings_APIName return no values||||null
this is a bug||||null
A DH_set_method_APIParam_2 DH_set_default_method_APIParam_1 specifies the functions that OpenSSL uses for Diffie-Hellman operations||||null
By modifying the method , alternative implementations such as hardware accelerators may be used||||null
However , this is not required||||when memory usage is an issue
The main purpose of the functions EVP_PKEY_missing_parameters_APIName and EVP_PKEY_copy_parameters_APIName is to handle public keys in certificates where the parameters are sometimes omitted from a public key||||if they are inherited from the CA that signed it
PKCS padding works by adding EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CipherInit_ex_APIParam_20 EVP_CipherInit_ex_APIParam_21 EVP_CipherInit_ex_APIParam_22 EVP_CipherInit_ex_APIParam_23 EVP_CipherInit_ex_APIParam_24 EVP_CipherInit_ex_APIParam_25 EVP_CipherInit_ex_APIParam_26 EVP_CipherInit_ex_APIParam_27 EVP_CipherInit_ex_APIParam_28 EVP_CipherInit_ex_APIParam_29 padding bytes of value EVP_EncryptUpdate_APIParam_2 EVP_CipherInit_ex_APIParam_2 EVP_DecryptFinal_APIParam_2 EVP_CIPHER_CTX_set_padding_APIParam_2 EVP_CIPHER_CTX_set_key_length_APIParam_2 EVP_DecryptFinal_ex_APIParam_2 EVP_DecryptInit_APIParam_2 EVP_DecryptInit_ex_APIParam_2 EVP_get_cipherbyname_APIParam_1 EVP_CipherInit_APIParam_2 EVP_CipherInit_ex_APIParam_20 EVP_CipherInit_ex_APIParam_21 EVP_CipherInit_ex_APIParam_22 EVP_CipherInit_ex_APIParam_23 EVP_CipherInit_ex_APIParam_24 EVP_CipherInit_ex_APIParam_25 EVP_CipherInit_ex_APIParam_26 EVP_CipherInit_ex_APIParam_27 EVP_CipherInit_ex_APIParam_28 EVP_CipherInit_ex_APIParam_29 to make the total length of the encrypted data a multiple of the block size||||null
where PEM_read_PrivateKey_APIParam_2 PEM_read_DHparams_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_2 PEM_read_bio_RSAPrivateKey_APIParam_2 PEM_read_bio_X509_AUX_APIParam_2 PEM_read_X509_REQ_APIParam_2 PEM_read_bio_X509_REQ_APIParam_2 PEM_read_RSAPrivateKey_APIParam_2 PEM_read_bio_PrivateKey_APIParam_2 PEM_read_PKCS7_APIParam_2 PEM_read_bio_PUBKEY_APIParam_2 PEM_write_bio_NETSCAPE_CERT_SEQUENCE_APIParam_2 PEM_read_DHparams_APIParam_22 PEM_read_DHparams_APIParam_23 PEM_write_PKCS8PrivateKey_APIParam_2 PEM_write_bio_X509_AUX_APIParam_2 PEM_write_bio_DSA_PUBKEY_APIParam_2 PEM_read_DHparams_APIParam_27 PEM_read_DHparams_APIParam_28 PEM_write_PUBKEY_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_20 PEM_write_X509_REQ_NEW_APIParam_21 PEM_write_X509_REQ_NEW_APIParam_22 PEM_write_RSAPublicKey_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_24 PEM_write_X509_REQ_NEW_APIParam_25 PEM_write_bio_X509_CRL_APIParam_2 PEM_write_X509_REQ_NEW_APIParam_27 PEM_write_X509_REQ_NEW_APIParam_28 PEM_write_X509_REQ_NEW_APIParam_29 PEM_read_bio_RSAPrivateKey_APIParam_20 PEM_read_bio_RSAPrivateKey_APIParam_21 PEM_read_bio_RSAPrivateKey_APIParam_22 PEM_write_bio_RSA_PUBKEY_APIParam_2 PEM_read_bio_RSAPrivateKey_APIParam_24 PEM_read_bio_RSAPrivateKey_APIParam_25 PEM_read_bio_RSAPrivateKey_APIParam_26 PEM_write_X509_REQ_APIParam_2 PEM_read_bio_DHparams_APIParam_2 PEM_write_bio_PKCS8PrivateKey_nid_APIParam_2 PEM_read_bio_X509_APIParam_2 PEM_write_bio_PrivateKey_APIParam_2 PEM_read_DSA_PUBKEY_APIParam_2 PEM_read_bio_X509_AUX_APIParam_23 PEM_read_X509_AUX_APIParam_2 PEM_read_bio_X509_AUX_APIParam_25 PEM_write_bio_DHparams_APIParam_2 PEM_write_PKCS7_APIParam_2 PEM_write_PKCS8PrivateKey_nid_APIParam_2 PEM_write_bio_DSAPrivateKey_APIParam_2 PEM_write_bio_PUBKEY_APIParam_2 PEM_write_DSAPrivateKey_APIParam_2 PEM_read_DSAparams_APIParam_2 PEM_read_bio_RSAPublicKey_APIParam_2 PEM_write_RSA_PUBKEY_APIParam_2 PEM_read_X509_REQ_APIParam_25 PEM_read_X509_REQ_APIParam_26 PEM_read_bio_X509_CRL_APIParam_2 PEM_write_bio_X509_APIParam_2 PEM_read_X509_REQ_APIParam_29 PEM_read_bio_X509_REQ_APIParam_20 PEM_write_PrivateKey_APIParam_2 PEM_read_bio_RSA_PUBKEY_APIParam_2 PEM_read_bio_X509_REQ_APIParam_23 already contains a valid certificate , may not work , whereas||||null
DH_get_default_method_APIName returns a pointer to the current default DH_METHOD||||null
Initially, the default DH_METHOD is the OpenSSL internal implementation, as returned by DH_OpenSSL_APIName||||null
DH_set_default_method_APIName returns no value||||null
DH_set_method_APIName selects DH_set_method_APIParam_2 to perform all operations using the key DH_set_method_APIParam_1||||null
DH_OpenSSL_APIName and DH_get_default_method_APIName return pointers to the respective DH_OpenSSL_APIParam_0 DH_get_default_method_APIParam_0s||||null
Otherwise it returns a pointer to the newly allocated structure||||null
However , the meaningfulness of this result is dependent on||||null
DH_set_method_APIName returns non-zero if the provided DH_set_method_APIParam_2 was successfully set as the method for DH_set_method_APIParam_1||||null
DH_new_method_APIName allocates and initializes a DH structure so that DH_new_method_APIParam_1 will be used for the DH operations||||null
See the NOTES section for important information about how these DH API functions are affected by the use of DH_new_method_APIParam_1 API calls||||null
DH_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails||||null
The returned pointer must not be freed by the calling application||||null
As of version 0.9.7 , DH_METHOD implementations are grouped together with other algorithmic APIs in DH_new_method_APIParam_1 modules||||null
SSL_CTX_get0_param_APIName and SSL_get0_param_APIName return a pointer to an SSL_CTX_get0_param_APIParam_0 SSL_get0_param_APIParam_0 structure||||null
SSL_CTX_set1_param_APIName and SSL_set1_param_APIName set the verification parameters to SSL_CTX_set1_param_APIParam_2 SSL_set1_param_APIParam_2 for SSL_CTX_set1_param_APIParam_1 or SSL_set1_param_APIParam_1||||null
SSL_CTX_set1_param_APIName and SSL_set1_param_APIName return 1 for success and 0 for failure||||null
i2d_PKCS7_bio_stream_APIName outputs a PKCS7 structure in BER format||||null
SSL_CTX_get0_param_APIName and SSL_get0_param_APIName retrieve an internal pointer to the verification parameters for SSL_CTX_get0_param_APIParam_1 or SSL_get0_param_APIParam_1 respectively||||null
It is possible to have DH keys that only work with certain DH_METHOD implementations , and attempting to change the DH_METHOD for the key can have unexpected results||||null
i2d_PKCS7_bio_stream_APIName returns 1 for success or 0 for failure||||null
the ENGINE API is the recommended way to control default implementations for use in DH and other cryptographic algorithms||||null
It is otherwise identical to the function SMIME_write_PKCS7_APIName||||null
This function is effectively a version of the d2i_PKCS7_bio_APIName supporting streaming||||null
The prefix `` i2d '' is arguably wrong||||null
Unlike many standard comparison functions, X509_cmp_time returns 0 on error||||null
It returns 0 on error||||null
X509_cmp_time_APIName compares the ASN1_TIME in X509_cmp_time_APIParam_1 with the time in <cmp_time>||||null
X509_cmp_time_APIName returns -1 if X509_cmp_time_APIParam_1 is earlier than, or equal to, X509_cmp_time_APIParam_2, and 1 otherwise||||null
A new EC_KEY can be constructed by calling EC_KEY_new||||null
that will override any DH defaults set using the DH API||||If a default ENGINE is specified for DH functionality using an ENGINE API function
An EC_KEY represents a public key and an associated private key||||null
X509_cmp_time_APIParam_1 must satisfy the ASN1_TIME format mandated by RFC 5280 , ie , X509_cmp_time_APIParam_1 format must be either YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ||||null
A curve can be associated with the EC_KEY by calling EC_KEY_set_group||||null
Refer to EC_GROUP_new_APIName for a description of curve names||||null
The reference count for the newly created EC_KEY is initially set to 1||||null
This function simply wraps calls to EC_KEY_new and EC_GROUP_new_by_curve_name||||null
EC_KEY_up_ref increments the reference count associated with the EC_KEY object||||null
the current time is used||||If X509_cmp_time_APIParam_2 is NULL
The private key is a random integer||||null
the handle to that ENGINE will be released during the change||||if the previous method was supplied by an ENGINE
This will replace the DH_METHOD used by the DH key and||||null
Alternatively a new EC_KEY can be constructed by calling EC_KEY_new_by_curve_name and supplying the nid of the associated curve||||null
EC_KEY_set_asn1_flag_APIParam_1 EC_KEY_set_conv_form_APIParam_1 must have an EC_GROUP object associated with it before calling this function||||null
EC_KEY_generate_key generates a new public and private key for the supplied EC_KEY_set_asn1_flag_APIParam_1 EC_KEY_set_conv_form_APIParam_1 object||||null
Typically parameters are retrieved from an SSL_CTX_get0_param_APIParam_1 or SSL_CTX_get0_param_APIParam_1 SSL_get0_param_APIParam_1 structure using SSL_CTX_get0_param_APIName or SSL_get0_param_APIName and an application modifies SSL_CTX_get0_param_APIName or SSL_get0_param_APIName to suit an application needs||||null
the default ENGINE for DH operations is used||||If DH_new_method_APIParam_1 is NULL
and if no default ENGINE is set , the DH_METHOD controlled by DH_set_default_method_APIName is used||||null
to add a hostname check||||null
EC_KEY_check_key performs various sanity checks on the EC_KEY object to confirm that it is valid||||null
For a description of point_conversion_forms please refer to EC_POINT_new_APIName||||null
It will also performs certain sanity checks on the key to confirm that it is valid||||null
The public key is an EC_POINT on the curve calculated by multiplying the generator for the curve by the private key||||null
This data is treated as a `` black box '' by the ec library||||null
Any flags that are already set are left set||||null
EC_KEY_set_flags sets the flags in the EC_KEY_set_flags_APIParam_2 EC_KEY_clear_flags_APIParam_2 parameter on the EC_KEY object||||null
EC_KEY_get_flags returns the current flags that are set for this EC_KEY||||null
The currently defined standard flags are EC_FLAG_NON_FIPS_ALLOW and EC_FLAG_FIPS_CHECKED||||null
EC_KEY_clear_flags clears the flags indicated by the EC_KEY_set_flags_APIParam_2 EC_KEY_clear_flags_APIParam_2 parameter||||null
EC_KEY_insert_key_method_data and EC_KEY_get_key_method_data enable the caller to associate arbitrary additional data specific to the elliptic curve scheme being used with the EC_KEY object||||null
EC_KEY_set_asn1_flag sets the asn1_flag on the underlying EC_GROUP object||||null
All other flags are left in their existing state||||null
Refer to EC_GROUP_copy_APIName for further information on the asn1_flag||||null
See also EC_POINT_add_APIName||||null
In addition there is the flag EC_FLAG_COFACTOR_ECDH which is specific to ECDH and is defined in ecdh.h||||null
EC_KEY_new, EC_KEY_new_by_curve_name and EC_KEY_dup return a pointer to the newly created EC_KEY object, or NULL on error||||null
EC_KEY_precompute_mult stores multiples of the underlying EC_GROUP generator for faster point multiplication||||null
EC_KEY_get_flags returns the flags associated with the EC_KEY object as an integer||||null
EC_KEY_copy returns a pointer to the destination key, or NULL on error||||null
EC_KEY_get0_group returns the EC_GROUP associated with the EC_KEY||||null
The functions EC_KEY_get_conv_form and EC_KEY_set_conv_form get and set the point_conversion_form for the EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_precompute_mult_APIParam_10 EC_KEY_precompute_mult_APIParam_11 EC_KEY_precompute_mult_APIParam_12 EC_KEY_precompute_mult_APIParam_13 EC_KEY_precompute_mult_APIParam_14 EC_KEY_precompute_mult_APIParam_15 EC_KEY_precompute_mult_APIParam_16 EC_KEY_precompute_mult_APIParam_17||||null
EC_KEY_get0_private_key returns the private key associated with the EC_KEY||||null
EC_KEY_get_conv_form return the point_conversion_form for the EC_KEY||||null
EC_KEY_up_ref, EC_KEY_set_group, EC_KEY_set_private_key, EC_KEY_set_public_key, EC_KEY_precompute_mult, EC_KEY_generate_key, EC_KEY_check_key and EC_KEY_set_public_key_affine_coordinates return 1 on success or 0 on error||||null
RC4 is a stream cipher with variable key length||||null
The data to be stored by EC_KEY_insert_key_method_data is provided in the EC_KEY_insert_key_method_data_APIParam_2 parameter , which must have associated functions for duplicating , freeing and `` clear_freeing '' the data item||||null
RC4_set_key_APIName and RC4_APIName do not return values||||null
EC_KEY_free decrements the reference count for the EC_KEY object , and||||if it has dropped to zero
Calling frees the memory associated with it||||null
RC4 consists of a key setup phase and the actual encryption or decryption phase||||null
RC4_set_key_APIName sets up the RC4_set_key_APIParam_1 RC4_set_key_APIParam_1 using the RC4_set_key_APIParam_2 bytes long key at RC4_set_key_APIParam_3||||null
decryption uses the same function calls as encryption||||null
Certain conditions have to be observed to securely use stream ciphers||||null
It is not permissible to perform multiple encryptions using the same key stream||||null
Applications should use the higher level functions EVP_EncryptInit_APIName etc instead of calling the RC4 functions directly||||null
If no peer certificate was presented, the returned result code is X509_V_OK||||null
SSL_get_verify_result_APIName is only useful in connection with SSL_get_peer_certificate_APIName||||null
SSL_get_verify_result_APIName returns the result of the verification of the X509 certificate presented by the peer, if any||||null
The following return values can currently occur||||null
Typically , 128 bit keys are used for strong encryption , but shorter insecure key sizes have been widely used due to export restrictions||||null
SSL_get_verify_result_APIName can only return one error code while the verification of a certificate can fail because of many reasons at the same time||||null
Documented in verify_APIName||||null
The verification succeeded or no peer certificate was presented||||null
This is because no verification error occurred , it does however not indicate success||||null
These can be used by passing EVP_rc2_40_cbc_APIName and EVP_rc2_64_cbc_APIName respectively||||null
EVP_des_ede3_cbc_APIName is the algorithm of choice for S/MIME use||||null
occurred||||during the processing
Only the last verification error that is available from SSL_get_verify_result_APIName||||null
PKCS7_encrypt_APIName returns either a PKCS7 structure or NULL if an error occurred||||null
Some old `` export grade '' clients may only support weak encryption using 40 or 64 bit RC2||||null
BIO_s_file_APIName returns the BIO file method||||null
The error can be obtained from ERR_get_error_APIName||||null
The verification result is part of the established session and is restored||||when a session is reused
Only RSA keys are supported in PKCS # 7 and envelopedData so the recipient certificates supplied to this function must all contain RSA public keys||||null
The functions EC_KEY_get0_group , EC_KEY_set_group , EC_KEY_get0_private_key , EC_KEY_set_private_key , EC_KEY_get0_public_key , and EC_KEY_set_public_key get and set the EC_GROUP object , the private key and the EC_POINT public key for the EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_precompute_mult_APIParam_10 EC_KEY_precompute_mult_APIParam_11 EC_KEY_precompute_mult_APIParam_12 EC_KEY_precompute_mult_APIParam_13 EC_KEY_precompute_mult_APIParam_14 EC_KEY_precompute_mult_APIParam_15 EC_KEY_precompute_mult_APIParam_16 EC_KEY_precompute_mult_APIParam_17 respectively||||null
the functions for duplicating , freeing and `` clear_freeing '' the data item must be provided again||||If a subsequent EC_KEY_get_key_method_data call is issued
and they must be the same as they were when the data item was inserted||||null
EC_KEY_set_public_key_affine_coordinates sets the public key for EC_KEY_set_flags_APIParam_1 EC_KEY_precompute_mult_APIParam_1 EC_KEY_set_group_APIParam_1 EC_KEY_generate_key_APIParam_1 EC_KEY_get0_private_key_APIParam_1 EC_KEY_set_public_key_APIParam_1 EC_KEY_set_private_key_APIParam_1 EC_KEY_get_conv_form_APIParam_1 EC_KEY_get_key_method_data_APIParam_1 EC_KEY_up_ref_APIParam_1 EC_KEY_precompute_mult_APIParam_10 EC_KEY_precompute_mult_APIParam_11 EC_KEY_precompute_mult_APIParam_12 EC_KEY_precompute_mult_APIParam_13 EC_KEY_precompute_mult_APIParam_14 EC_KEY_precompute_mult_APIParam_15 EC_KEY_precompute_mult_APIParam_16 EC_KEY_precompute_mult_APIParam_17 based on its affine co-ordinates , ie it constructs an EC_POINT object based on the supplied EC_KEY_precompute_mult_APIParam_18 and EC_KEY_precompute_mult_APIParam_19 values and sets the public key to be this EC_POINT||||null
BIO_gets_APIName and BIO_puts_APIName are supported on file BIOs||||null
Calls to BIO_read_APIName and BIO_write_APIName read and write data to the underlying stream||||null
BIO_eof_APIName calls feof_APIName||||null
Many browsers implement a `` sign and encrypt '' option which is simply an S/MIME envelopedData containing an S/MIME signed message||||null
This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to PKCS7_encrypt_APIName||||null
As BIO_s_file_APIName name implies BIO_s_file_APIName is a wrapper round the stdio FILE structure and BIO_s_file_APIName is a source/sink BIO||||null
BIO_flush_APIName on a file BIO calls the fflush_APIName function on the wrapped stream||||null
Flags can be||||null
BIO_CLOSE , BIO_NOCLOSE BIO_FP_TEXT||||null
BIO_reset_APIName attempts to change the file pointer to the start of file using fseek||||null
BIO_new_fp_APIName creates a file BIO wrapping BIO_new_fp_APIParam_1||||null
BIO_tell_APIName returns the value of the position pointer||||null
BIO_set_fp_APIName set the fp of a file BIO to BIO_set_fp_APIParam_2||||null
BIO_get_fp_APIName retrieves the fp of a file BIO , it is a macro||||null
BIO_s_file_APIName returns the file BIO method||||null
On Windows BIO_new_files reserves for the filename argument to be UTF-8 encoded||||null
BIO_new_file_APIName and BIO_new_fp_APIName return a file BIO or NULL if an error occurred||||null
BIO_set_fp_APIParam_3 BIO_new_fp_APIParam_2 has the same meaning as in BIO_new_fp_APIName , BIO_set_fp_APIParam_3 BIO_new_fp_APIParam_2 is a macro||||null
BIO_set_fp_APIName and BIO_get_fp_APIName return 1 for success or 0 for failure||||null
BIO_tell_APIName returns the current file position||||null
any quirks in stdio behaviour will be mirrored by the corresponding BIO||||null
BIO_reset_APIName and BIO_seek_APIName are implemented using fseek_APIName on the underlying stream||||null
Setting the BIO_CLOSE flag calls fclose_APIName on the stream||||when the BIO is freed
BIO_read_filename_APIName, BIO_write_filename_APIName, BIO_append_filename_APIName and BIO_rw_filename_APIName return 1 for success or 0 for failure||||null
PEM_write_bio_CMS_stream_APIName outputs a CMS_ContentInfo structure in PEM format||||null
BIO_seek_APIName returns the same value as the underlying fseek_APIName function||||null
It is otherwise identical to the function SMIME_write_CMS_APIName||||null
PEM_write_bio_CMS_stream_APIName returns 1 for success or 0 for failure||||null
0 for success or -1 for failure||||null
This function is effectively a version of the PEM_write_bio_CMS_APIName supporting streaming||||null
SHA1_Init_APIName initializes a SHA1_Init_APIParam_1 structure||||null
BIO_read_filename_APIName , BIO_write_filename_APIName , BIO_append_filename_APIName and BIO_rw_filename_APIName set the file BIO BIO_read_filename_APIParam_1 BIO_write_filename_APIParam_1 BIO_append_filename_APIParam_1 BIO_rw_filename_APIParam_1 to use file BIO_read_filename_APIParam_2 BIO_write_filename_APIParam_2 BIO_write_filename_APIName0 BIO_write_filename_APIName1 for reading , writing , append or read write respectively||||null
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly||||null
encode file names in UTF-8||||if you have to make it work in multi - lingual environment
SHA-1 is a cryptographic hash function with a 160 bit output||||null
SHA384 and SHA512 use SHA512_Init_APIParam_1 SHA512_Final_APIParam_2 SHA384_Update_APIParam_1 SHA512_Update_APIParam_1 SHA384_Init_APIParam_1 SHA384_Final_APIParam_2||||null
Reset SSL_clear_APIParam_1 to allow another connection||||null
SHA1_APIName, SHA224_APIName, SHA256_APIName, SHA384_APIName and SHA512_APIName return a pointer to the hash value||||null
All settings are kept||||null
Note that SHA224 and SHA256 use a SHA256_Final_APIParam_2 SHA256_Update_APIParam_1 SHA224_Final_APIParam_2 SHA224_Init_APIParam_1 SHA224_Update_APIParam_1 SHA256_Init_APIParam_1 object instead of SHA1_Final_APIParam_2 SHA1_Init_APIParam_1 SHA1_Update_APIParam_1||||null
SHA1_Init_APIName, SHA1_Update_APIName and SHA1_Final_APIName and equivalent SHA224, SHA256, SHA384 and SHA512 functions return 1 for success, 0 otherwise||||null
The SHA224 , SHA256 , SHA384 and SHA512 families of functions operate in the same way as for the SHA1 functions||||null
The buffer SHA512_Final_APIParam_1 SHA256_Final_APIParam_1 SHA1_Final_APIParam_1 SHA224_Final_APIParam_1 SHA384_Final_APIParam_1 must have space for the output from the SHA variant being used||||null
This will might lead to connection failures for a description of the method 's properties||||null
SHA1_Final_APIName places the message digest in SHA1_Final_APIParam_1 , which must have space for SHA_DIGEST_LENGTH == 20 bytes of output , and erases the SHA1_Final_APIParam_2||||null
The reset operation however keeps several settings of the last sessions||||null
The following return values can occur||||null
SSL_clear_APIName resets the SSL object to allow for another connection||||null
Use the sequence SSL_get_session_APIName||||null
SSL_free_APIName instead to avoid such failures||||null
The following functions may be used||||if the message is not completely stored in memory
The SSL_clear_APIName operation could not be performed||||null
The SSL_clear_APIName operation was successful||||null
Check the error stack to find out the reason||||null
The return value for fseek_APIName is 0 for success or -1 if an error occurred this differs from other types of BIO which will typically return 1 for success and a non positive value if an error occurred||||null
SSL_new_APIName , SSL_free_APIName , SSL_shutdown_APIName , SSL_set_shutdown_APIName , SSL_CTX_set_options_APIName , ssl_APIName , SSL_CTX_set_client_cert_cb_APIName||||null
The buffer library handles simple character arrays||||null
BUF_MEM_new_APIName allocates a new buffer of zero size||||null
BUF_MEM_free_APIName frees up an already existing buffer||||null
Buffers are used for various purposes in the library , most notably memory BIOs||||null
The data is zeroed before freeing up in case the buffer contains sensitive data||||null
BUF_MEM_grow_APIName changes the size of an already existing buffer to BUF_MEM_grow_APIParam_2||||null
the session object will be kept and all settings corresponding||||If a session was closed cleanly
BUF_MEM_new_APIName returns the buffer or NULL on error||||null
eg the special method used will be kept for the next handshake||||during the session
This explicitly means , that||||null
it should be used only||||when backward compatibility is required
The predecessor of SHA-1 , SHA , is also implemented , but||||null
BUF_MEM_free_APIName has no return value||||null
Memory allocated from these functions should be freed up using the OPENSSL_free_APIName function||||null
BUF_MEM_grow_APIName returns zero on error or the new size||||null
BUF_strdup_APIName , BUF_strndup_APIName , BUF_memdup_APIName , BUF_strlcpy_APIName , BUF_strlcat_APIName and BUF_strnlen are equivalents of the standard C library functions||||null
SSL_get_version_APIName returns the name of the protocol used for the connection SSL_get_version_APIParam_1||||null
Prior to that the results returned from this function may be unreliable||||null
It should only be called after the initial handshake has been completed||||null
The following strings can be returned||||null
BUF_strndup makes the explicit guarantee that BUF_strndup will never read past the first BUF_strndup_APIParam_2 BUF_memdup_APIParam_2 bytes of BUF_strndup_APIParam_1 BUF_strnlen_APIParam_1 BUF_strdup_APIParam_1 BUF_MEM_grow_APIParam_1||||null
The connection uses the SSLv2 protocol||||null
Any data already in the buffer is preserved||||if it increases in size
The connection uses the SSLv3 protocol||||null
The dup_APIName functions use OPENSSL_malloc_APIName underneath and so should be used in preference to the standard library for memory leak checking or replacing the malloc_APIName function||||null
The connection uses the TLSv1 .1 protocol||||null
The connection uses the TLSv1 .0 protocol||||null
The connection uses the TLSv1 .2 protocol||||null
This indicates an unknown protocol version||||null
RSA_generate_key is deprecated||||null
sense for a new connection with the exact same peer that shares these settings , and may fail||||if that peer changes its settings between connections
It only makes||||null
See BN_generate_prime_APIName for further details||||null
If key generation fails, RSA_generate_key_APIName returns NULL||||null
ASN1_STRING_new_APIName returns an allocated ASN1_STRING_new_APIParam_0 structure||||null
The error codes can be obtained by ERR_get_error_APIName||||null
as for the SHA1_APIName function above , the SHA224_APIName , SHA256_APIName , SHA384_APIName and SHA512_APIName functions are not thread safe||||if SHA512_Final_APIParam_1 SHA256_Final_APIParam_1 SHA1_Final_APIParam_1 SHA224_Final_APIParam_1 SHA384_Final_APIParam_1 is NULL
Also note that||||null
ASN1_STRING_new_APIName type is undefined||||null
RSA_generate_key_APIName goes into an infinite loop for illegal input values||||null
RSA_generate_key works in the same way as RSA_generate_key_ex except it uses `` old style '' call backs||||null
ASN1_STRING_type_new_APIName returns an allocated ASN1_STRING_type_new_APIParam_0 structure of type ASN1_STRING_type_new_APIParam_1||||null
ASN1_STRING_free_APIName frees up ASN1_STRING_free_APIParam_1||||null
Other string types call the ASN1_STRING_free_APIParam_1 functions||||null
ASN1_STRING_free_APIName does not return a value||||null
ASN1_OCTET_STRING_new_APIName calls ASN1_STRING_type||||null
ASN1_STRING_new_APIName and ASN1_STRING_type_new_APIName return a valid ASN1_STRING structure or NULL if an error occurred||||null
CMS_add1_recipient_cert_APIName adds recipient CMS_add1_recipient_cert_APIParam_2 to CMS_ContentInfo enveloped data structure CMS_add1_recipient_cert_APIParam_1 as a KeyTransRecipientInfo structure||||null
a random prime number is called as described in BN_generate_prime_APIName||||While a random prime number is generated
So , a SSL client object will use a TLSv1 client method for the next handshake and a SSL server object will use a TLSv1 server method , * _ methods were chosen on startup||||if the session was a TLSv1 session
SSL_CTX_set_tmp_dh_APIName sets DH parameters to be used to be SSL_CTX_set_tmp_dh_APIParam_2||||null
The key is inherited by all SSL_set_tmp_dh_APIParam_1 objects created from SSL_CTX_set_tmp_dh_APIParam_1||||null
SSL_set_tmp_dh_callback_APIName sets the callback only for SSL_set_tmp_dh_APIParam_1||||null
New attributes can also be added using CMS_encrypt_APIParam_0 and the CMS attribute utility functions||||null
SSL_set_tmp_dh_APIName sets the parameters only for SSL_set_tmp_dh_APIParam_1||||null
These functions apply to SSL/TLS servers only||||null
CMS_add1_recipient_cert_APIName and CMS_add0_recipient_key_APIName return an internal pointer to the CMS_RecipientInfo structure just added or NULL if an error occurs||||null
Ciphers with DSA keys always use ephemeral DH keys as well||||null
||||if one or more KEKRecipientInfo structures need to be added
Anonymous ciphers also use ephemeral DH keys||||null
The main purpose of this function is to provide finer control over a CMS enveloped data structure where the simpler CMS_encrypt_APIName function defaults are not appropriate||||null
This application guarantees that `` strong '' primes are used||||null
SSL_CTX_set_tmp_dh_callback_APIName and SSL_set_tmp_dh_callback_APIName do not return diagnostic output||||null
SSL_CTX_set_tmp_dh_APIName and SSL_set_tmp_dh_APIName do return 1 on success and 0 on failure||||null
The risk in reusing DH parameters is that an attacker may specialize on a very often used DH group||||null
the server must use a DH group and generate a DH key||||null
PKCS7_get0_signers_APIName returns all signers or NULL if an error occurred||||null
PKCS7_verify_APIName returns one for a successful verification and zero if an error occurs||||null
Check the error queue to find out the reason of failure||||null
An application may either directly specify the DH parameters or can supply the DH parameters via a callback function||||null
In these cases , the session data are negotiated using the ephemeral/temporary DH key and the key supplied and certified by the certificate chain is only used for signing||||null
The server will always generate a new DH key||||during the negotiation
BIO_f_buffer_APIName returns the buffering BIO method||||null
Chain verification should arguably be performed using the signing time rather than the current time||||null
The error can be obtained from ERR_get_error_APIName||||null
As generating DH parameters is extremely time consuming , an application should not generate the parameters on the fly but supply the parameters||||null
CMS_add0_recipient_key_APIName adds symmetric key CMS_add0_recipient_key_APIParam_3 of length CMS_add0_recipient_key_APIParam_4 using wrapping algorithm CMS_add0_recipient_key_APIParam_2 , identifier CMS_add0_recipient_key_APIParam_5 of length CMS_add0_recipient_key_APIParam_6 and optional values CMS_add0_recipient_key_APIParam_7 , CMS_add0_recipient_key_APIParam_8 and CMS_add0_recipient_key_APIParam_9 to CMS_ContentInfo enveloped data structure CMS_add0_recipient_key_APIParam_1 as a KEKRecipientInfo structure||||null
Both BIO_gets_APIName and BIO_puts_APIName are supported||||null
the actual key is newly generated||||during the negotiation
DH parameters can be reused , as||||null
BIO_get_buffer_num_lines_APIName returns the number of lines currently buffered||||null
Using ephemeral DH key exchange yields forward secrecy , as the connection can only be decrypted||||when the DH key is known
Calling BIO_reset_APIName on a buffering BIO clears any buffered data||||null
However since the signing time is supplied by the signer it can not be trusted without additional evidence||||null
Data written to a buffering BIO is buffered and periodically written to the next BIO in the chain||||null
BIO_f_buffer_APIName returns the buffering BIO method||||null
Applications should generate their own DH parameters||||during the installation process using the openssl dhparam_APIName application
Buffering BIOs implement BIO_gets_APIName by using BIO_read_APIName operations on the next BIO in the chain||||null
BIO_get_buffer_num_lines_APIName returns the number of lines buffered||||null
Data read from a buffering BIO comes from an internal buffer which is filled from the next BIO in the chain||||null
BIO_set_read_buffer_size_APIName, BIO_set_write_buffer_size_APIName and BIO_set_buffer_size_APIName return 1 if the buffer was successfully resized or 0 for failure||||null
The lack of single pass processing and need to hold all data in memory as mentioned in PKCS7_sign_APIName also applies to PKCS7_verify_APIName||||null
BIO_set_buffer_read_data_APIName returns 1 if the data was set correctly or 0 if there was an error||||null
Both are NULL-terminated||||null
If non-NULL, SSL_get_psk_identity_hint_APIName returns the PSK identity hint and SSL_get_psk_identity_APIName returns the PSK identity||||null
SSL_get_psk_identity_hint_APIName may return NULL if no PSK identity hint was used during the connection setup||||null
DSA_get_default_method_APIName returns a pointer to the current default DSA_METHOD||||null
Initially, the default DSA_METHOD is the OpenSSL internal implementation, as returned by DSA_OpenSSL_APIName||||null
A DSA_set_method_APIParam_2 DSA_set_default_method_APIParam_1 specifies the functions that OpenSSL uses for DSA operations||||null
Note that the return value is valid only during the lifetime of the SSL object SSL_get_psk_identity_APIParam_1 SSL_get_psk_identity_hint_APIParam_1||||null
By modifying the method , alternative implementations such as hardware accelerators may be used||||null
DSA_OpenSSL_APIName and DSA_get_default_method_APIName return pointers to the respective DSA_OpenSSL_APIParam_0 DSA_get_default_method_APIParam_0s||||null
BIO_flush_APIName may need to be retried||||if the ultimate source/sink BIO is non blocking
DSA_set_default_method_APIName returns no value||||null
Data is only written to the next BIO in the chain or||||when the write buffer fills
It is important to call BIO_flush_APIName||||whenever any pending data should be written such as when removing a buffering BIO using BIO_pop_APIName
Otherwise it returns a pointer to the newly allocated structure||||null
it is possible to provide BIO_gets_APIName functionality||||if the following BIOs do not support it
By prepending a buffering BIO to a chain||||null
DSA_set_method_APIName returns non-zero if the provided DSA_set_method_APIParam_2 was successfully set as the method for DSA_set_method_APIParam_1||||null
Similarly , SSL_get_psk_identity_APIName is used to retrieve the PSK identity used||||during the connection setup
DSA_new_method_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName if the allocation fails||||null
DSA_new_method_APIName allocates and initializes a DSA structure so that DSA_new_method_APIParam_1 will be used for the DSA operations||||null
See the NOTES section for important information about how these DSA API functions are affected by the use of DSA_new_method_APIParam_1 API calls||||null
As of version 0.9.7 , DSA_METHOD implementations are grouped together with other algorithmic APIs in DSA_new_method_APIParam_1 modules||||null
The following SSLeay_version_APIParam_1 values are supported||||null
The following return values can occur||||null
SSL_get_psk_identity_hint_APIName is used to retrieve the PSK identity hint used||||during the connection setup related to SSL object SSL_get_psk_identity_hint_APIParam_1 SSL_get_psk_identity_APIParam_1
SSLeay_version_APIName returns a pointer to a constant string describing the version of the OpenSSL library or giving information about the library build||||null
However , the meaningfulness of this result is dependent on||||null
The version of the OpenSSL library including the release date||||null
An invalid value for SSLeay_version_APIParam_1 was given||||null
SSL_CTX_sess_get_cache_size_APIName returns the currently valid session cache size||||null
The compiler flags set for the compilation process in the form `` compiler||||null
The date of the build process in the form `` built on||||null
SSL_CTX_sess_set_cache_size_APIName sets the size of the internal session cache of context SSL_CTX_sess_set_cache_size_APIParam_1 to SSL_CTX_sess_set_cache_size_APIParam_2||||null
This size can be modified using the SSL_CTX_sess_set_cache_size_APIName call||||null
the ENGINE API is the recommended way to control default implementations for use in DSA and other cryptographic algorithms||||null
This value is a hint and not an absolute||||null
see the notes below||||null
A special case is the size 0 , which is used for unlimited size||||null
SSL_CTX_sess_set_cache_size_APIName returns the previously valid size||||null
Cache space may also be reclaimed by calling SSL_CTX_flush_sessions_APIName to remove expired sessions||||null
SSL_CTX_sess_get_cache_size_APIName returns the currently valid size||||null
The internal session cache size is SSL_SESSION_CACHE_MAX_SIZE_DEFAULT , currently 1024 * 20 , so that up to 20000 sessions can be held||||null
This removal is not synchronized with the expiration of sessions||||null
Otherwise or on errors callback should return 0||||null
Return values from the client callback are interpreted as follows||||null
that will override any DSA defaults set using the DSA API||||If a default ENGINE is specified for DSA functionality using an ENGINE API function
available or `` compiler||||'' if
information not available '' otherwise||||null
the connection setup fails||||null
is lost||||when the application is left
By generating a temporary DH key inside the server application that , it becomes impossible for an attacker to decrypt past sessions||||null
SSL_read_APIName tries to read SSL_read_APIParam_3 bytes from the specified SSL_read_APIParam_1 into the buffer SSL_read_APIParam_2||||null
the default engine for DSA operations is used||||If DSA_new_method_APIParam_1 is NULL
and if no default ENGINE is set , the DSA_METHOD controlled by DSA_set_default_method_APIName is used||||null
''||||if available or `` built on
date not available '' otherwise||||null
The `` OPENSSLDIR '' setting of the library build in the form `` OPENSSLDIR||||null
The `` Configure '' target of the library build in the form `` platform||||null
unused sessions are dropped from the end of the cache||||If adding the session makes the cache exceed its size
SSL_read_APIName works based on the SSL/TLS records||||null
The behaviour of SSL_read_APIName depends on the underlying BIO||||null
is called||||when the client is sending the ClientKeyExchange message to the server
A client application must provide a callback function which||||null
the PSK identity and the pre-shared key to use||||during the connection setup phase
The purpose of the callback function is to select||||null
it will be performed transparently during the SSL_read_APIName operation||||If the peer requests a re-negotiation
'' ... '' ''||||if available or `` OPENSSLDIR
available or `` platform||||'' if
N/A '' otherwise||||null
information not available '' otherwise||||null
old session will be removed at the next time a session shall be added||||If the size of the session cache is reduced and more sessions are already in the session cache
The data are received in records||||null
For the transparent negotiation to succeed , the SSL_read_APIParam_1 must have been initialized to client or server mode||||null
a record has been completely received||||Only when
it can be processed||||null
This is being done by calling SSL_set_connect_state_APIName or SSL_set_accept_state_APIName before the first call to an SSL_read_APIName or SSL_write_APIName function||||null
At most the contents of the record will be returned||||null
The following return values can occur||||null
Only when the record has been received and processed completely, SSL_read_APIName will return reporting success||||null
SSL_pending_APIName can be used to find out||||null
The read operation was successful||||null
The return value is the number of bytes actually read from the TLS/SSL connection||||null
If SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 SSL_read_APIParam_3 is higher than the number of bytes buffered, SSL_read_APIName will return with the bytes buffered||||null
SSL_read_APIName will trigger the processing of the next record||||If no more bytes are in the buffer
SSL_read_APIName can be called without blocking or actually receiving new data from the underlying socket||||null
It can not be checked||||null
The response returned by the server can be obtained via a call to SSL_get_tlsext_status_ocsp_resp_APIName||||null
Old documentation indicated a difference between 0 and -1 , and that -1 was retryable||||null
SSLv2 does not support a shutdown alert protocol , so it can only be detected||||null
If the server has not provided any response data SSL_get_tlsext_status_ocsp_resp_APIParam_2 SSL_get_tlsext_status_ocsp_resp_APIParam_2 will be NULL and the return value from SSL_get_tlsext_status_ocsp_resp_APIName will be -1||||null
The callback when used on the server side should return with either SSL_TLSEXT_ERR_OK , SSL_TLSEXT_ERR_NOACK  or SSL_TLSEXT_ERR_ALERT_FATAL||||null
SSL_CTX_set_tlsext_status_cb_APIName, SSL_CTX_set_tlsext_status_arg_APIName, SSL_set_tlsext_status_type_APIName and SSL_set_tlsext_status_ocsp_resp_APIName return 0 on error or 1 on success||||null
Typically a callback would obtain an OCSP_RESPONSE object from this data via a call to the d2i_OCSP_RESPONSE_APIName function||||null
The value SSL_get_tlsext_status_ocsp_resp_APIParam_2 SSL_get_tlsext_status_ocsp_resp_APIParam_2 will be updated to point to the OCSP response data and the return value will be the length of that data||||null
CONF_modules_load_APIName is idential to CONF_modules_load_file_APIName except CONF_modules_load_APIName reads configuration information from CONF_modules_load_APIParam_1||||null
SSL_get_tlsext_status_ocsp_resp_APIName returns the length of the OCSP response data or -1 if there is no OCSP response data||||null
data that was not retrieved at the last call of SSL_read_APIName can still be buffered inside the SSL layer and will be retrieved on the next call to SSL_read_APIName||||null
These functions return 1 for success and a zero or negative value for failure||||null
You should instead call SSL_get_error_APIName to find out||||if it 's retryable
If module errors are not ignored ,the return code will reflect the return value of the failing module||||null
In other cases an application might consider a configuration file error as fatal and exit immediately||||null
in some cases an error may simply print out a warning message and the application continue||||null
The callback when used on the client side should return a negative value on error||||null
A pointer to the response data should be provided in the SSL_set_tlsext_status_ocsp_resp_APIParam_2 argument , and the length of that data should be in the SSL_set_tlsext_status_ocsp_resp_APIParam_3 argument||||null
The data may be left unmodified or translated||||null
There are two type of BIO , a source/sink BIO and a filter BIO||||null
A BIO is an I/O abstraction , it hides many of the underlying I/O details from an application||||null
Applications should call these functions after loading builtin modules using OPENSSL_load_builtin_modules_APIName , any ENGINEs using ENGINE_load_builtin_engines_APIName , any algorithms OPENSSL_add_all_algorithms_APIName and SSL_library_init_APIName||||null
BIOs can be joined together to form a chain||||null
Errors may also be handled differently by different applications||||during configuration
A server application must also call the SSL_CTX_set_tlsext_status_cb_APIName function||||if A server application wants to be able to provide clients with OCSP Certificate Status responses
A chain normally consist of one source/sink BIO and one or more filter BIOs||||null
SSL_CONF_CTX_set_ssl_ctx_APIName sets the context associated with SSL_CONF_CTX_set_ssl_ctx_APIParam_1 to the SSL_CONF_CTX_set_ssl_ctx_APIParam_2 structure SSL_CONF_CTX_set_ssl_ctx_APIParam_2||||null
Any previous SSL_CONF_CTX_set_ssl_ctx_APIParam_1 or SSL_CONF_CTX_set_ssl_ctx_APIParam_2 associated with SSL_CONF_CTX_set_ssl_ctx_APIParam_1 is cleared||||null
Typically the server callback would obtain the server certificate that is being sent back to the client via a call to SSL_get_certificate_APIName||||null
A filter BIO takes data from one BIO and passes it through to another , or the application||||null
Subsequent calls to SSL_CONF_cmd_APIName will be sent to SSL_CONF_CTX_set_ssl_ctx_APIParam_2||||null
obtain the OCSP response to be sent back||||null
Data read from or written to the first BIO traverses the chain to the end||||null
and set that response data by calling SSL_set_tlsext_status_ocsp_resp_APIName||||null
SSL_CONF_CTX_set_ssl_APIName sets the context associated with SSL_CONF_CTX_set_ssl_APIParam_1 to the SSL_CONF_CTX_set_ssl_APIParam_1 structure SSL_CONF_CTX_set_ssl_APIParam_2||||null
As its name implies a source/sink BIO is a source and/or sink of data , examples include a socket BIO and a file BIO||||null
SSL_CONF_CTX_set_ssl_ctx_APIName and SSL_CTX_set_ssl_APIName do not return a value||||null
0 or a positive value if it is acceptable||||if the response is not acceptable
EVP_PKEY_decrypt_init_APIName and EVP_PKEY_decrypt_APIName return 1 for success and 0 or a negative value for failure||||null
Any previous SSL_CONF_CTX_set_ssl_APIParam_1 or SSL_CONF_CTX_set_ssl_ctx_APIParam_2 associated with SSL_CONF_CTX_set_ssl_APIParam_1 is cleared||||null
Subsequent calls to SSL_CONF_cmd_APIName will be sent to SSL_CONF_CTX_set_ssl_APIParam_2||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
X509_STORE_CTX_set_error_APIName sets the error code of X509_STORE_CTX_set_error_APIParam_1 to X509_STORE_CTX_set_error_APIParam_2||||null
X509_STORE_CTX_get_error_depth_APIName returns a non-negative error depth||||null
As the size of an SSL/TLS record may exceed the maximum packet size of the underlying transport , it may be necessary to read several packets from the transport layer before the record is complete and SSL_read_APIName can succeed||||null
X509_verify_cert_error_string_APIName returns a human readable error string for verification error X509_verify_cert_error_string_APIParam_1||||null
X509_STORE_CTX_get_current_cert_APIName returns the certificate in X509_STORE_CTX_get_current_cert_APIParam_1 which caused the error or NULL if no certificate is relevant||||null
Applications can use the CONF_modules_load_APIName function||||if Applications wish to load a configuration file Applications and have finer control over how errors are treated
After the call to EVP_PKEY_decrypt_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
it can transparently handle SSL connections , unencrypted network connections and file I/O||||If an application uses a BIO for its I/O
X509_verify_cert_error_string_APIName returns a human readable error string for verification error X509_verify_cert_error_string_APIParam_1||||null
X509_STORE_CTX_get_current_cert_APIName returns the cerificate which caused the error or NULL if no certificate is relevant to the error||||null
it might be used in a verification callback to set an error based on additional checks||||null
In versions of OpenSSL before 1.0 the current certificate returned by X509_STORE_CTX_get_current_cert_APIName was never NULL||||null
Applications should check the return value before printing out any debugging information relating to the current certificate||||null
These functions are typically called after X509_verify_cert_APIName has indicated an error or in a verification callback to determine the nature of an error||||null
If an unrecognised error code is passed to X509_verify_cert_error_string_APIName, the numerical value of the unknown code is returned in a static buffer||||null
The function EVP_PKEY_decrypt_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
These functions are only useful for TLS/SSL servers||||null
SSL_CTX_set_client_CA_list_APIName and SSL_set_client_CA_list_APIName do not return diagnostic information||||null
The context need not be set or The context can be set to NULL in which case only syntax checking of commands is performed , where possible||||null
The effect of a filter BIO may change according to the I/O operation it is performing||||null
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName have the following return values||||null
SSL_CTX_add_client_CA_APIName and SSL_add_client_CA_APIName can be used to add additional items the list of client CAs||||null
The operation succeeded||||null
Check the error stack to find out the reason||||null
The function SSL_CONF_CTX_set_flags_APIName sets SSL_CONF_CTX_set_flags_APIParam_2 in the context SSL_CONF_CTX_set_flags_APIParam_1||||null
The function SSL_CONF_CTX_clear_flags_APIName clears SSL_CONF_CTX_clear_flags_APIParam_2 in the context SSL_CONF_CTX_clear_flags_APIParam_1||||null
The flags set affect how subsequent calls to SSL_CONF_cmd_APIName or SSL_CONF_argv_APIName behave||||null
Currently the following SSL_CONF_CTX_clear_flags_APIParam_2 SSL_CONF_CTX_set_flags_APIParam_2 values are recognised||||null
This is not thread safe but will never happen||||unless an invalid code is passed
At least one of these flags must be set||||null
recognise options intended for command line or configuration file use||||null
recognise options intended for use in SSL/TLS clients or servers||||null
One or both of these flags must be set||||null
recognise certificate and private key options||||null
SSL_CONF_CTX_set_flags_APIName and SSL_CONF_CTX_clear_flags_APIName returns the new flags value after setting or clearing flags||||null
an encryption BIO will encrypt data and decrypt data if it is being read from||||if it is being written to
If this option isn't set such errors are only reflected in the return values of SSL_CONF_set_cmd_APIName or SSL_CONF_set_argv_APIName||||null
indicate errors relating to unrecognised options or missing arguments in the error queue||||null
X509_check_private_key_APIName and X509_REQ_check_private_key_APIName return 1 if the keys match each other, and 0 if not||||null
the SSL_load_client_CA_file_APIName function can be used to help importing the necessary data||||If the list of acceptable CAs is compiled in a file
X509_check_private_key_APIName function checks the consistency of private key X509_check_private_key_APIParam_2 with the public key in X509_check_private_key_APIParam_1||||null
a new client CA list for SSL_CTX_add_client_CA_APIParam_1 or SSL_add_client_CA_APIParam_1 is opened||||If no list was specified before using SSL_CTX_set_client_CA_list_APIName or SSL_set_client_CA_list_APIName
X509_REQ_check_private_key_APIName is equivalent to X509_check_private_key_APIName except that X509_REQ_check_private_key_APIParam_1 X509_check_private_key_APIParam_1 represents a certificate request of structure X509_REQ_check_private_key_APIParam_1||||null
The error strings will have the following format||||null
the CA name extracted from SSL_CTX_add_client_CA_APIParam_2 to the list of CAs sent to the client||||when requesting a client certificate for SSL_CTX_add_client_CA_APIParam_1
SSL_CTX_add_client_CA_APIName adds||||null
ERR_print_errors_fp_APIName is the same , except that the output goes to a ERR_print_errors_fp_APIParam_1||||null
A failure||||while manipulating the STACK_OF object occurred or the X509_NAME could not be extracted from SSL_add_client_CA_APIParam_2 SSL_CTX_add_client_CA_APIParam_2
the reason code can be obtained using ERR_get_error_APIName||||If the key is invalid or an error occurred
the CA name extracted from SSL_add_client_CA_APIParam_2 to the list of CAs sent to the client||||when requesting a client certificate for the chosen SSL_add_client_CA_APIParam_1 , overriding the setting valid for SSL_add_client_CA_APIParam_1 's SSL_CTX object
SSL_add_client_CA_APIName adds||||null
ERR_print_errors_APIName and ERR_print_errors_fp_APIName return no values||||null
If successful a pointer to the d2i_ECPKParameters_APIParam_1 structure is returned||||null
If an error occurred ,then NULL is returned||||null
d2i_ECPKParameters_APIName attempts to decode d2i_ECPKParameters_APIParam_3 bytes at d2i_ECPKParameters_APIParam_2||||null
ERR_print_errors_APIName is a convenience function that prints the error strings for all errors that OpenSSL has recorded to ERR_print_errors_APIParam_1 , thus emptying the error queue||||null
i2d_ECPKParameters_APIName encodes the structure pointed to by i2d_ECPKParameters_APIParam_1 into DER format||||null
If the return value is negative an error occurred, otherwise it returns the length of the encoded data||||null
d2i_ECPKParameters_bio_APIName is similar to d2i_ECPKParameters_APIName except d2i_ECPKParameters_bio_APIName attempts to parse data from BIO ECPKParameters_print_APIParam_1||||null
i2d_ECPKParameters_APIParam_2 is not incremented and it points to the start of the data just written||||null
The ECPKParameters encode and decode routines encode and parse the public parameters for an ECPKParameters_print_APIParam_2 i2d_ECPKParameters_APIParam_1 d2i_ECPKParameters_APIParam_1 ECPKParameters_print_fp_APIParam_2 structure , which represents a curve||||null
The output lines are indented by ECPKParameters_print_APIParam_3 ECPKParameters_print_fp_APIParam_3 spaces||||null
d2i_ECPKParameters_fp_APIName is similar to d2i_ECPKParameters_APIName except d2i_ECPKParameters_fp_APIName attempts to parse data from FILE pointer ECPKParameters_print_fp_APIParam_1||||null
d2i_ECPKParameters_APIName, d2i_ECPKParameters_bio_APIName and d2i_ECPKParameters_fp_APIName return a valid d2i_ECPKParameters_APIParam_1 structure or NULL if an error occurs||||null
CMS_final_APIName finalises the structure CMS_final_APIParam_1||||null
the error string will contain the numeric code||||If there is no text string registered for the given error code
i2d_ECPKParameters_fp_APIName is similar to i2d_ECPKParameters_APIName except it writes the encoding of the structure i2d_ECPKParameters_APIParam_1 to BIO ECPKParameters_print_APIParam_1 and it returns 1 for success and 0 for failure||||null
i2d_ECPKParameters_bio_APIName is similar to i2d_ECPKParameters_APIName except it writes the encoding of the structure i2d_ECPKParameters_APIParam_1 to BIO ECPKParameters_print_APIParam_1 and it returns 1 for success and 0 for failure||||null
d2i_ECPKParameters_APIParam_2 is incremented to the byte following the parsed data||||If the call is successful
These functions are very similar to the X509 functions described in d2i_X509_APIName , where further notes and examples are available||||null
i2d_ECPKParameters_APIName returns the number of bytes successfully encoded or a negative value if an error occurs||||null
The ECPKParameters_print and ECPKParameters_print_fp functions print a human-readable output of the public parameters of the EC_GROUP to ECPKParameters_print_APIParam_1 or ECPKParameters_print_fp_APIParam_1||||null
i2d_ECPKParameters_bio_APIName, i2d_ECPKParameters_fp_APIName, ECPKParameters_print and ECPKParameters_print_fp return 1 for success and 0 if an error occurs||||null
The parameter CMS_final_APIParam_2 contains the content to be processed||||null
memory will be allocated for a buffer and the encoded data written to it||||If i2d_ECPKParameters_APIParam_2 is NULL
CMS_final_APIName returns 1 for success or 0 for failure||||null
It 's purpose is to perform any operations necessary on CMS_final_APIParam_1 and set the appropriate fields||||null
The EVP envelope routines are a high level interface to envelope decryption||||null
the DER encoded data to the buffer at i2d_ECPKParameters_APIParam_2||||If i2d_ECPKParameters_APIParam_2 is not NULL is writes
and increments it to point after the data just written||||null
EVP_OpenInit_APIName returns 0 on error or a non zero integer  if successful||||null
The EVP envelope routines decrypt a public key encrypted symmetric key and decrypt data using a public key encrypted symmetric key||||null
The CMS_final_APIParam_3 parameter contains a BIO to write content to after processing||||null
d2i_ECPKParameters_APIParam_0 is written to d2i_ECPKParameters_APIParam_1 If d2i_ECPKParameters_APIParam_1 is not NULL||||If d2i_ECPKParameters_APIParam_1 is not NULL
it is assumed that d2i_ECPKParameters_APIParam_1 contains a valid d2i_ECPKParameters_APIParam_1 structure and an attempt is made to reuse it||||null
EVP_OpenUpdate_APIName returns 1 for success or 0 for failure||||null
this is only used with detached data and will usually be set to NULL||||null
EVP_OpenFinal_APIName returns 0 if the decrypt failed or 1 for success||||null
X509_STORE_CTX_new_APIName returns a newly initialised X509_STORE_CTX_new_APIParam_0 structure||||null
X509_STORE_CTX_free_APIName completely frees up X509_STORE_CTX_free_APIParam_1||||null
X509_STORE_CTX_cleanup_APIName internally cleans up an X509_STORE_CTX_cleanup_APIParam_1 X509_STORE_CTX_init_APIParam_1 structure||||null
EVP_OpenUpdate_APIName and EVP_OpenFinal_APIName have exactly the same properties as the EVP_DecryptUpdate_APIName and EVP_DecryptFinal_APIName routines , as documented on the EVP_EncryptInit_APIName manual page||||null
The context can be reused with an new call to X509_STORE_CTX_init_APIName||||null
After this call X509_STORE_CTX_free_APIParam_1 is no longer valid||||null
These functions initialise an X509_STORE_CTX_init_APIParam_1 X509_STORE_CTX_set_default_APIParam_1 X509_STORE_CTX_set0_param_APIParam_1 X509_STORE_CTX_free_APIParam_1 X509_STORE_CTX_set_cert_APIParam_1 X509_STORE_CTX_get0_param_APIParam_1 X509_STORE_CTX_cleanup_APIParam_1 structure for subsequent use by X509_verify_cert_APIName||||null
X509_STORE_CTX_set0_param_APIName sets the intenal verification parameter pointer to X509_STORE_CTX_set0_param_APIParam_2||||null
X509_STORE_CTX_set_cert_APIName sets the certificate to be vertified in X509_STORE_CTX_set_cert_APIParam_1 to X509_STORE_CTX_set_cert_APIParam_2||||null
After this call X509_STORE_CTX_set0_param_APIParam_2 should not be used||||null
X509_STORE_CTX_new_APIName returns an newly allocates context or NULL is an error occurred||||null
X509_STORE_CTX_set_default_APIName looks up and sets the default verification method to X509_STORE_CTX_set_default_APIParam_2||||null
X509_STORE_CTX_init_APIName returns 1 for success or 0 if an error occurred||||null
X509_STORE_CTX_set_default_APIName returns 1 for success or 0 if an error occurred||||null
This uses the function X509_VERIFY_PARAM_lookup_APIName to find an appropriate set of parameters from X509_STORE_CTX_set_default_APIParam_2||||null
X509_STORE_CTX_cleanup_APIName, X509_STORE_CTX_free_APIName, X509_STORE_CTX_trusted_stack_APIName, X509_STORE_CTX_set_cert_APIName, X509_STORE_CTX_set_chain_APIName, X509_STORE_CTX_set0_crls_APIName and X509_STORE_CTX_set0_param_APIName do not return values||||null
X509_STORE_CTX_get0_param_APIName returns a pointer to an X509_STORE_CTX_get0_param_APIParam_0 structure or NULL if an error occurred||||null
ECDSA_SIG_new_APIName allocates a new ECDSA_SIG_new_APIParam_0 structure and initialize it||||null
ECDSA_SIG_new_APIName returns NULL if the allocation fails||||null
ECDSA_SIG_free_APIName frees the ECDSA_SIG_free_APIParam_1 structure ECDSA_SIG_free_APIParam_1||||null
ECDSA_size_APIName returns the maximum length of a DER encoded ECDSA signature created with the private EC key ECDSA_size_APIParam_1||||null
ECDSA_size_APIName returns the maximum length signature or 0 on error||||null
ECDSA_sign_setup_APIName and ECDSA_sign_APIName return 1 if successful or 0 on error||||null
BIO_f_ssl_APIName returns the SSL BIO method||||null
The ECDSA_SIG_free_APIParam_1 d2i_ECDSA_SIG_APIParam_1 i2d_ECDSA_SIG_APIParam_1 structure consists of two BIGNUMs for the r and s value of a ECDSA signature||||null
ECDSA_verify_APIName and ECDSA_do_verify_APIName return 1 for a valid signature, 0 for an invalid signature and -1 on error||||null
The error codes can be obtained by ERR_get_error_APIName||||null
the key length will be set to the value of the recovered key length||||If the cipher passed in the EVP_OpenInit_APIParam_2 parameter is a variable length cipher
Calling BIO_reset_APIName on an SSL BIO closes down any current SSL connection by calling SSL_shutdown_APIName||||null
The SSL BIO is reset to the initial accept or connect state||||null
This is a filter BIO which is a wrapper round the OpenSSL SSL routines adding a BIO `` flavour '' to SSL I/O||||null
BIO_set_ssl_mode_APIName sets the SSL BIO mode to BIO_new_ssl_APIParam_2||||null
BIO_reset_APIName is sent to the next BIO in the chain||||null
I/O performed on an SSL BIO communicates using the SSL protocol with the SSLs read and write BIOs||||null
ECDSA_do_verify_APIName verifies that the signature ECDSA_do_verify_APIParam_1 is a valid ECDSA signature of the hash value ECDSA_do_verify_APIParam_1 of size ECDSA_do_verify_APIParam_2 using the public key ECDSA_size_APIParam_1 ECDSA_sign_setup_APIParam_1 ECDSA_set_method_APIParam_1||||null
this will typically disconnect the underlying transport||||null
BIO_set_ssl_renegotiate_bytes_APIName sets the renegotiate byte count to BIO_ctrl_APIParam_3||||null
BIO_ctrl_APIParam_3 must be at least 512 bytes||||null
BIO_get_num_renegotiates_APIName returns the total number of session renegotiations due to I/O or timeout||||null
BIO_get_ssl_APIName retrieves the SSL pointer of BIO BIO_ctrl_APIParam_1 , BIO_get_ssl_APIName can be manipulated using the standard SSL library functions||||null
BIO_ssl_copy_session_id_APIName copies an SSL session id between BIO chains BIO_ssl_copy_session_id_APIParam_2 and BIO_ssl_copy_session_id_APIParam_1||||null
an attempt is made to establish one on the first I/O call||||If an SSL connection is not established
BIO_new_buffer_ssl_connect_APIName creates a new BIO chain consisting of a buffering BIO , an SSL BIO and a connect BIO||||null
BIO_ssl_shutdown_APIName closes down an SSL connection on BIO chain BIO_ssl_shutdown_APIParam_1||||null
It returns 1 if the connection was established successfully||||null
BIO_new_ssl_connect_APIName creates a new BIO chain consisting of an SSL BIO followed by a connect BIO||||null
server mode is set||||If BIO_new_ssl_APIParam_2 is 0
the internal SSL structure is also freed using SSL_free_APIName||||If the close flag is set when an SSL BIO is freed
a BIO is automatically used as the SSL BIOs read and write BIOs||||If a BIO is appended to an SSL BIO using BIO_push_APIName
BIO_do_handshake_APIName attempts to complete an SSL handshake on the supplied BIO and establish the SSL connection||||null
It does this by locating the SSL BIOs in each chain and calling SSL_copy_session_id_APIName on the internal SSL pointer||||null
using SSL_CTX BIO_new_ssl_APIParam_1 and using client mode||||if BIO_new_ssl_APIParam_2 is non zero
BIO_new_ssl_APIName allocates an SSL BIO||||null
It does this by locating the SSL BIO in the chain and calling SSL_shutdown_APIName on its internal SSL pointer||||null
In OpenSSL 0.9.6 and later the SSL flag SSL_AUTO_RETRY can be set to disable this behaviour||||null
A zero or negative value is returned if the connection could not be established, the call BIO_should_retry_APIName should be used for non blocking connect BIOs to determine if the call should be retried||||null
the servers name and port can be set using BIO_set_host_APIName on the BIO returned by BIO_new_ssl_connect_APIName without having to locate the connect BIO first||||null
Applications do not have to call BIO_do_handshake_APIName but may wish to do so to separate the handshake process from other I/O processing||||null
BN_mod_APIName corresponds to BN_div_APIName with BN_div_APIParam_1 set to NULL||||null
BN_nnmod_APIName reduces BN_nnmod_APIParam_2 modulo BN_nnmod_APIParam_3 and places the non-negative remainder in BN_nnmod_APIParam_1||||null
BN_mod_add_APIName adds BN_mod_add_APIParam_2 to BN_mod_add_APIParam_3 modulo BN_mod_add_APIParam_4 and places the non-negative result in BN_mod_add_APIParam_1||||null
BN_mod_sub_APIName subtracts BN_mod_sub_APIParam_3 from BN_mod_sub_APIParam_2 modulo BN_mod_sub_APIParam_4 and places the non-negative result in BN_mod_sub_APIParam_1||||null
this call has no effect||||If an SSL connection has already been established
That is||||when this flag is set an SSL BIO using a blocking transport will never request a retry
SSL BIOs are exceptional in that||||if the underlying transport is non blocking SSL BIOs can still request a retry in exceptional circumstances
this will happen||||if a session renegotiation takes place during a BIO_read_APIName operation
Specifically , one case where this happens is when step up occurs||||null
BN_mod_sqr_APIName takes the square of BN_mod_sqr_APIParam_2 modulo BN_mod_sqr_APIParam_3 and places the result in BN_mod_sqr_APIParam_1||||null
BN_gcd_APIParam_1 may be the same BN_gcd_APIParam_1 as BN_gcd_APIParam_2 or BN_gcd_APIParam_3||||null
BN_gcd_APIName computes the greatest common divisor of BN_gcd_APIParam_2 and BN_gcd_APIParam_3 and places the result in BN_gcd_APIParam_1||||null
Applications which included workarounds for this bug should be modified to handle this fix or they may free up an already freed BIO||||null
The session id is an arbitrary sequence of bytes||||null
SSL_CTX_set_generate_session_id_APIName sets the callback function for generating new session ids for SSL/TLS sessions for SSL_CTX_set_generate_session_id_APIParam_1 to be SSL_CTX_set_generate_session_id_APIParam_2||||null
The session id is not security critical but must be unique for the server||||null
SSL_CTX_set_generate_session_id_APIName and SSL_set_generate_session_id_APIName always return 1||||null
SSL_set_generate_session_id_APIName sets the callback function for generating new session ids for SSL/TLS sessions for SSL_set_generate_session_id_APIParam_1 to be SSL_set_generate_session_id_APIParam_3||||null
For all functions , BN_nnmod_APIParam_4 BN_sqr_APIParam_3 BN_mod_APIParam_4 BN_exp_APIParam_4 BN_mul_APIParam_4 BN_mod_sqr_APIParam_4 BN_gcd_APIParam_4 is a previously allocated BN_nnmod_APIParam_4 BN_sqr_APIParam_3 BN_mod_APIParam_4 BN_exp_APIParam_4 BN_mul_APIParam_4 BN_mod_sqr_APIParam_4 BN_gcd_APIParam_4 used for temporary variables||||null
SSL_has_matching_session_id_APIName will only query the internal session cache , not the external one||||null
the handshake is not immediately added to the cache||||null
see BN_sqr_APIParam_34||||null
The length of the session id is 16 bytes for SSLv2 sessions and between 1 and 32 bytes for SSLv3/TLSv1||||null
SSL_has_matching_session_id_APIName returns 1 if another session with the same id is already in the cache||||null
The callback must return 0 if The callback cannot generate a session id for whatever reason and return 1 on success||||null
CMS_sign_APIName returns either a valid CMS_ContentInfo structure or NULL if an error occurred||||null
Some attributes such as counter signatures are not supported||||null
Without a callback being set , an OpenSSL server will generate a unique session id from pseudo random numbers of the maximum possible length||||null
In OpenSSL versions before 1.0.0 the BIO_pop_APIName call was handled incorrectly , the I/O BIO reference count was incorrectly incremented and dissociated with the SSL BIO||||null
The error can be obtained from ERR_get_error_APIName||||null
BN_new_APIName allocates and initializes a BN_init_APIParam_1 structure||||null
The return values of the SSL*_ctrl_APIName functions depend on the command supplied via the SSL_ctrl_APIParam_2 SSL_CTX_ctrl_APIParam_2 parameter||||null
BN_init_APIName initializes an existing uninitialized BN_init_APIParam_1||||null
Additionally , the session id is transmitted in the clear information||||when reusing the session so it must not contain sensitive
Using the callback function , the session id can be changed to contain additional information like eg a host id in order to improve load balancing or external caching techniques||||null
It erases the memory used by BN_clear_APIParam_1 and sets it to the value 0||||null
the server generates a session id||||When a new session is established between client and server
BN_clear_free_APIName additionally overwrites the data before the memory is returned to the system||||null
BN_new_APIName returns a pointer to the BN_new_APIParam_0 initialised to the value 0||||null
BN_init_APIName, BN_clear_APIName, BN_free_APIName and BN_clear_free_APIName have no return values||||null
the result BN_nnmod_APIParam_1 BN_mod_mul_APIParam_1 BN_mod_sub_APIParam_1 BN_add_APIParam_1 BN_sqr_APIParam_1 BN_sub_APIParam_1 BN_mod_add_APIParam_1 BN_mod_APIParam_1 BN_exp_APIParam_1 BN_mul_APIParam_1 BN_mod_mul_APIParam_10 BN_mod_mul_APIParam_11 BN_mod_mul_APIParam_12 BN_mod_mul_APIParam_13 must be different from the arguments||||Unless noted otherwise
If the allocation fails, the allocation returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
These functions are not normally called directly , various macros are used instead||||null
BIO_tell_APIName returns the current file position of a file related BIO||||null
Collisions can also occur||||when using an external session cache , applies
BIO_ctrl_APIName , BIO_callback_ctrl_APIName , BIO_ptr_ctrl_APIName and BIO_int_ctrl_APIName are BIO `` control '' operations taking arguments of various types||||null
nothing is done||||If BN_free_APIParam_1 BN_clear_free_APIParam_1 is NULL
a race condition can occur in that another thread generates the same session id||||If another thread is using the same internal session cache
BIO_eof_APIName returns 1 if the BIO has read EOF, the precise meaning of "EOF" varies according to the BIO type||||null
BIO_seek_APIName resets a file related BIO 's file position pointer to BIO_seek_APIParam_2 bytes from start of file||||null
BIO_set_close_APIName sets the BIO BIO_set_close_APIParam_1 close flag to BIO_set_close_APIParam_2||||null
BIO_set_close_APIParam_2 can take the value BIO_CLOSE or BIO_NOCLOSE||||null
BIO_get_close_APIName returns the BIOs close flag||||null
BN_clear_APIName is used to destroy sensitive data such as keys||||when they are no longer needed
Not all BIOs support these calls||||null
BN_free_APIName frees the components of the BN_free_APIParam_1 BN_clear_free_APIParam_1 , and||||if it was created by BN_new_APIName , also the structure itself
BIO_pending_APIName, BIO_ctrl_pending_APIName, BIO_wpending_APIName and BIO_ctrl_wpending_APIName return the number of pending characters in the BIOs read and write buffers||||null
BIO_reset_APIName normally returns 1 for success and 0 or -1 for failure||||null
File BIOs are an exception, they return 0 for success and -1 for failure||||null
BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName return a size_t type and are functions, BIO_pending_APIName and BIO_wpending_APIName are macros which call BIO_ctrl_APIName||||null
BIO_eof_APIName returns 1 if EOF has been reached 0 otherwise||||null
the GOST algorithms will not be included||||if the GOST ENGINE is not loaded
BIO_set_close_APIName always returns 1||||null
BIO_flush_APIName returns 1 for success and 0 or -1 for failure||||null
BIO_flush_APIName normally writes out any internally buffered data , in some cases BIO_flush_APIName is used to signal EOF and that no more data will be written||||null
BIO_get_close_APIName returns the close flag value||||null
BIO_pending_APIName, BIO_ctrl_pending_APIName, BIO_wpending_APIName and BIO_ctrl_wpending_APIName return the amount of pending data||||null
BIO_CLOSE or BIO_NOCLOSE||||null
The return values of BIO_pending_APIName and BIO_wpending_APIName may not reliably determine the amount of pending data in all cases||||null
The standard macros are described below , macros specific to a particular type of BIO are described in the specific BIOs manual page as well as any special features of the standard calls||||null
BIO_seek_APIName and BIO_tell_APIName both return the current file position on success and -1 for failure, except file BIOs which for BIO_seek_APIName always return 0 for success and -1 for failure||||null
The BIO_should_retry_APIName call should be used and appropriate action taken is the call fails||||null
Source/sink BIOs return an 0 if they do not recognize the BIO_ctrl_APIName operation||||null
For other types of BIO they may not be supported||||null
BIO_flush_APIName ,  may return 0 or -1 indicating that the call should be retried later in a similar manner to BIO_write_APIName||||null
Some of the return values are ambiguous and care should be taken||||null
SSL_do_handshake_APIName will wait for a SSL/TLS handshake to take place||||null
The following return values can occur||||null
BIO_reset_APIName typically resets a BIO to some initial state , in the case of file related BIOs it rewinds the file pointer to the start of the file||||null
the underlying I/O stream should be closed||||when the BIO is freed
Typically BIO_CLOSE is used in a source/sink BIO to indicate that||||null
The behaviour of SSL_do_handshake_APIName depends on the underlying BIO||||null
X509_get0_notBefore_APIName, X509_get0_notAfter_APIName and X509_CRL_get0_lastUpdate_APIName return a pointer to an X509_get0_notBefore_APIParam_0 X509_get0_notAfter_APIParam_0 X509_CRL_get0_lastUpdate_APIParam_0 structure||||null
The handshake routines may have to be explicitly set in advance using either SSL_set_connect_state_APIName or SSL_set_accept_state_APIName||||null
However this can cause unexpected results||||null
The TLS/SSL handshake was successfully completed , a TLS/SSL connection has been established||||null
X509_set1_notBefore_APIName, X509_set1_notAfter_APIName, X509_CRL_set1_lastUpdate_APIName and X509_CRL_set1_nextUpdate_APIName return 1 for success or 0 for failure||||null
DSA_new_APIName allocates and initializes a DSA_new_APIParam_0 structure||||null
256 bit AES , Gost R3411-94 , Gost 28147-89 , 192 bit AES , 128 bit AES , triple DES , 128 bit RC2 , 64 bit RC2 , DES and 40 bit RC2||||null
It is equivalent to calling DSA_new_method||||null
The values are erased before the memory is returned to the system||||null
the handshake will be started||||If the connection is in client mode
DSA_free_APIName returns no value||||null
DSA_free_APIName frees the DSA_free_APIParam_1 structure and its components||||null
Otherwise it returns a pointer to the newly allocated structure||||null
X509_getm_notBefore_APIName and X509_getm_notAfter_APIName are similar to X509_get0_notBefore_APIName and X509_get0_notAfter_APIName except X509_getm_notBefore_APIName and X509_getm_notAfter_APIName return non-constant mutable references to the associated date field of the certificate||||null
If the allocation fails, DSA_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
Filter BIOs pass the operation to the next BIO in the chain||||if they do not internally handle a particular BIO_ctrl_APIName operation usually
The format of the string is described in ciphers_APIName||||null
The list of ciphers is inherited by all SSL_set_cipher_list_APIParam_1 objects created from SSL_CTX_set_cipher_list_APIParam_1||||null
SSL_CTX_set_cipher_list_APIName sets the list of available ciphers for SSL_CTX_set_cipher_list_APIParam_1 using the control string SSL_CTX_set_cipher_list_APIParam_2||||null
SSL_set_cipher_list_APIName sets the list of ciphers only for SSL_set_cipher_list_APIParam_1||||null
a return value of 0 can be returned if an operation is not supported, if an error occurred, if EOF has not been reached and in the case of BIO_seek_APIName on a file BIO for a successful operation||||null
Thus no syntax checking takes place||||null
This often means there is no need to locate the required BIO for a particular operation , it can be called on a chain and it will be automatically passed to the relevant BIO||||null
On the server side , additional restrictions apply||||null
Items that are not recognized , or , are simply ignored||||null
The control string SSL_set_cipher_list_APIParam_2 SSL_CTX_set_cipher_list_APIParam_2 should be universally usable and not depend on details of the library configuration||||null
All ciphers have additional requirements||||null
in the case of a file BIO some data may be available in the FILE structures internal buffers but it is not possible to determine this in a portably way||||null
this may still succeed||||if the chain ends in a FILE or file descriptor BIO
no current filter BIOs implement BIO_seek_APIName , but||||null
On the client side , the inclusion into the list is also sufficient||||null
It should be noted , that inclusion of a cipher to be used into the list is a necessary condition||||null
Failure is only flagged||||if no ciphers could be collected at all
All other ciphers need a corresponding certificate and key||||null
ADH ciphers do n't need a certificate , but DH-parameters must have been set||||null
RSA ciphers using DHE need a certificate and key and additional DH-parameters||||null
SSL_CTX_set_cipher_list_APIName and SSL_set_cipher_list_APIName return 1 if any cipher could be selected and 0 on complete failure||||null
DSA ciphers always use DH key exchange and need DH-parameters||||null
EVP_PKEY_type_APIName returns the type of key corresponding to the value EVP_PKEY_type_APIParam_1||||null
A RSA cipher can only be chosen||||when a RSA certificate is available
The type of a key can be obtained with EVP_PKEY_type||||null
A DSA cipher can only be chosen||||when a DSA certificate is available
EVP_PKEY_set1_RSA_APIName, EVP_PKEY_set1_DSA_APIName, EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName return 1 for success or 0 for failure||||null
EVP_PKEY_assign_RSA_APIName , EVP_PKEY_assign_DSA_APIName , EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName are implemented as macros||||null
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key in EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 or NULL if the key is not of the correct type||||null
EVP_PKEY_get1_RSA_APIName, EVP_PKEY_get1_DSA_APIName, EVP_PKEY_get1_DH_APIName and EVP_PKEY_get1_EC_KEY_APIName return the referenced key or NULL if an error occurred||||null
EVP_PKEY_set1_RSA_APIName , EVP_PKEY_set1_DSA_APIName , EVP_PKEY_set1_DH_APIName and EVP_PKEY_set1_EC_KEY_APIName set the key referenced by EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_set1_DH_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 to EVP_PKEY_set1_RSA_APIParam_2 EVP_PKEY_set1_DSA_APIParam_2 EVP_PKEY_set1_DSA_APIName0 EVP_PKEY_set1_DSA_APIName1||||null
EVP_PKEY_assign_RSA_APIName, EVP_PKEY_assign_DSA_APIName, EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName return 1 for success and 0 for failure||||null
The return value will be EVP_PKEY_RSA, EVP_PKEY_DSA, EVP_PKEY_DH or EVP_PKEY_EC for the corresponding key types or NID_undef if the key type is unassigned||||null
BIO_s_bio_APIName returns the method for a BIO pair||||null
SSL_get_default_timeout_APIName returns the default timeout value assigned to SSL_SESSION objects negotiated for the protocol valid for SSL_get_default_timeout_APIParam_1||||null
SSL_get_default_timeout_APIName return this hardcoded value, which is 300 seconds for all currently supported protocols||||null
RSA export ciphers with a keylength of 512 bits for the RSA key require a temporary 512 bit RSA key , as typically the supplied key has a length of 1024 bit||||null
BIO_reset_APIName clears any data in the write buffer||||null
Both halves must usually by handled by the same application thread||||null
BIO_make_bio_pair_APIName joins two separate BIOs into a connected pair||||null
BIO_destroy_pair_APIName destroys the association between two connected BIOs||||null
Freeing up any half of the pair will automatically destroy the association||||null
BIO_shutdown_wr_APIName is used to close down a BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1||||null
After this call no further writes on BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 are allowed||||null
BIO_get_write_buf_size_APIName returns the size of the write buffer||||null
Reads on the other half of the pair will return any pending data or EOF when all pending data has been read||||null
the hardcoded default timeout for the protocol will be used||||If the timeout value was not explicitly set using SSL_CTX_set_timeout_APIName
The standard calls BIO_ctrl_pending_APIName and BIO_ctrl_wpending_APIName can be used to determine the amount of pending data in the read or write buffer||||null
BIO_set_write_buf_size_APIName sets the write buffer size of BIO BIO_ctrl_get_write_guarantee_APIParam_1 BIO_ctrl_reset_read_request_APIParam_1 BIO_ctrl_get_read_request_APIParam_1 to BIO_new_bio_pair_APIParam_2||||null
is negotiated , a new session is assigned a timeout value , after which a new session will not be accepted for session reuse||||Whenever a new session
This is currently 17K , sufficient for a maximum size TLS record||||null
BIO_get_write_guarantee_APIName and BIO_ctrl_get_write_guarantee_APIName return the maximum length of data that can be currently written to the BIO||||null
A BIO pair is a pair of source/sink BIOs where data written to either half of the pair is buffered and can be read from the other half||||null
BIO_ctrl_reset_read_request_APIName can also be used to reset the value returned by BIO_get_read_request_APIName to zero||||null
data in the buffer or request a retry||||if the buffer is full
Calls to BIO_write_APIName will place||||null
data from the buffer or request a retry||||if no data is available
Calls to BIO_read_APIName will read||||null
BIO_ctrl_get_write_guarantee_APIName is a function whereas BIO_get_write_guarantee_APIName is a macro||||null
Both halves of a BIO pair should be freed||||null
BIO_new_bio_pair_APIName does not check||||null
it is possible to make this one half of a BIO pair and have all the data processed by the chain under application control||||null
a default value is used||||If the size is not initialized
Writes larger than this value will return a value from BIO_write_APIName less than the amount requested or if the buffer is full request a retry||||null
BIO_write_APIName will succeed and place data in the write buffer||||null
This must be done before any normal processing due to a request and BIO_should_read_APIName being true||||null
BIO_read_APIName will initially fail and BIO_should_read_APIName will be true||||null
Check the error stack for more information||||null
BIO_new_bio_pair_APIName combines the calls to BIO_new_APIName , BIO_make_bio_pair_APIName and BIO_set_write_buf_size_APIName to create a connected pair of BIOs BIO_new_bio_pair_APIParam_1 BIO_new_bio_pair_APIParam_1 , BIO_new_bio_pair_APIParam_3 BIO_new_bio_pair_APIParam_3 with write buffer sizes BIO_new_bio_pair_APIParam_2 BIO_new_bio_pair_APIParam_2 and BIO_new_APIName0 BIO_new_APIName0||||null
will be freed||||when the parent EVP_PKEY_assign_DSA_APIName6 EVP_PKEY_assign_DSA_APIName7 EVP_PKEY_assign_DSA_APIName8 EVP_PKEY_assign_DSA_APIName9 is freed
EVP_PKEY_assign_RSA_APIName , EVP_PKEY_assign_DSA_APIName , EVP_PKEY_assign_DH_APIName and EVP_PKEY_assign_EC_KEY_APIName also set the referenced key to EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 however these use the supplied EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2 internally and so EVP_PKEY_assign_RSA_APIParam_2 EVP_PKEY_assign_DSA_APIParam_2 EVP_PKEY_assign_DH_APIParam_2 EVP_PKEY_assign_EC_KEY_APIParam_2||||null
These functions handle application specific data in DSA structures||||null
As the data is buffered, SSL_operation_APIName may return with a ERROR_SSL_WANT_READ condition, but there is still data in the write buffer||||null
These functions usage is identical to that of RSA_get_ex_new_index_APIName , RSA_set_ex_data_APIName and RSA_get_ex_data_APIName as described in RSA_get_ex_new_index_APIName||||null
More return values need to be added here]||||null
EVP_PKEY_sign_init_APIName and EVP_PKEY_sign_APIName return 1 for success and 0 or a negative value for failure||||null
EVP_PKEY_sign_APIName does not hash the data to be signed , and is normally used to sign digests||||null
Otherwise a deadlock may occur as the peer might be waiting for the data before being able to continue||||null
For signing arbitrary messages , see the EVP_DigestSignInit_APIName and EVP_SignInit_APIName signing interfaces instead||||null
X509_NAME_ENTRY_get_object_APIName retrieves the field name of X509_NAME_ENTRY_get_object_APIParam_1 in and X509_NAME_ENTRY_get_object_APIParam_0 structure||||null
That is||||even if one half is implicit freed due to a BIO_free_all_APIName or SSL_free_APIName call the other half needs to be freed
In accordance with the OpenSSL naming convention the key obtained from or assigned to the EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_10 EVP_PKEY_get1_EC_KEY_APIParam_11 using the 1 functions must be freed as well as EVP_PKEY_set1_DSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_1 EVP_PKEY_assign_RSA_APIParam_1 EVP_PKEY_assign_DSA_APIParam_1 EVP_PKEY_get1_DSA_APIParam_1 EVP_PKEY_get1_RSA_APIParam_1 EVP_PKEY_set1_EC_KEY_APIParam_1 EVP_PKEY_get1_DH_APIParam_1 EVP_PKEY_assign_EC_KEY_APIParam_1 EVP_PKEY_set1_RSA_APIParam_1 EVP_PKEY_get1_EC_KEY_APIParam_10 EVP_PKEY_get1_EC_KEY_APIParam_11||||null
X509_NAME_ENTRY_get_data_APIName retrieves the field value of X509_NAME_ENTRY_get_data_APIParam_1 in and X509_NAME_ENTRY_get_data_APIParam_0 structure||||null
An application must not rely on the error value of SSL_operation_APIName but must assure that the write buffer is always flushed first||||null
X509_NAME_ENTRY_set_object_APIName sets the field name of X509_NAME_ENTRY_set_object_APIParam_1 to X509_NAME_ENTRY_set_object_APIParam_2||||null
this can be used||||when the application wishes to use a non standard transport for TLS/SSL
One typical use of BIO pairs is to place TLS/SSL I/O under application control , or the normal socket routines are inappropriate||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
X509_NAME_ENTRY_create_by_txt_APIName, X509_NAME_ENTRY_create_by_NID_APIName and X509_NAME_ENTRY_create_by_OBJ_APIName create and return an X509_NAME_ENTRY_create_by_txt_APIParam_1 X509_NAME_ENTRY_create_by_NID_APIParam_1 X509_NAME_ENTRY_create_by_OBJ_APIParam_1 structure||||null
After the call to EVP_PKEY_sign_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
BIO_eof_APIName is true||||if no data is in the peer BIO and the peer BIO has been shutdown
X509_NAME_ENTRY_get_object_APIName and X509_NAME_ENTRY_get_data_APIName can be used to examine an X509_NAME_ENTRY_get_object_APIParam_1 X509_NAME_ENTRY_get_data_APIParam_1 function as returned by X509_NAME_get_entry_APIName||||null
SSL_write_APIName writes SSL_write_APIParam_3 bytes from the buffer SSL_write_APIParam_2 into the specified SSL_write_APIParam_1 connection||||null
X509_NAME_ENTRY_set_data_APIName sets the field value of X509_NAME_ENTRY_set_data_APIParam_1 to string type X509_NAME_ENTRY_set_data_APIParam_2 and value determined by X509_NAME_ENTRY_set_data_APIParam_3 and X509_NAME_ENTRY_set_data_APIParam_4||||null
The behaviour of SSL_write_APIName depends on the underlying BIO||||null
calling BIO_pending_APIName on the other half of the pair and , , reading it and sending it to the underlying transport||||if any data is pending
This can be done by||||null
BIO_new_bio_pair_APIName returns 1 on success, with the new BIOs available in BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3, or 0 on failure, with NULL pointers stored into the locations for BIO_new_bio_pair_APIParam_1 and BIO_new_bio_pair_APIParam_3||||null
To see why this is important consider a case where a request is sent using BIO_write_APIName and a response read with BIO_read_APIName , this can occur||||null
The function EVP_PKEY_sign_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
For the transparent negotiation to succeed , the SSL_write_APIParam_1 must have been initialized to client or server mode||||null
it will never succeed !||||If the application waits for data to be available on the underlying transport before flushing the write buffer
the SSL_write_APIName operation is considered completed||||null
When this flag is set, SSL_write_APIName will also return with success, when a partial write has been successfully completed||||null
The following return values can occur||||null
This default behaviour can be changed with the SSL_MODE_ENABLE_PARTIAL_WRITE option of SSL_CTX_set_mode_APIName||||null
SSL_write_APIName will only return with success, when the complete contents of SSL_write_APIParam_2 SSL_write_APIParam_2 SSL_write_APIParam_2 SSL_write_APIParam_2 of length SSL_write_APIParam_3 SSL_write_APIParam_3 SSL_write_APIParam_3 SSL_write_APIParam_3 has been written||||null
This is being done by calling SSL_set_connect_state_APIName or SSL_set_accept_state_APIName before the first call to an SSL_read_APIName or SSL_write_APIName function||||null
The write operation was successful, the return value is the number of bytes actually written to the TLS/SSL connection||||null
it will be performed transparently during the SSL_write_APIName operation||||If the peer requests a re-negotiation
The bytes are sent and a new SSL_write_APIName operation with a new buffer must be started||||null
A partial write is performed with the size of a message block , which is 16kB for SSLv3/TLSv1||||null
It can not be checked , why the closure happened||||null
OpenSSL keeps an internal table of digest algorithms and ciphers||||null
OpenSSL_add_all_digests_APIName adds all digest algorithms to the table||||null
X509_NAME_ENTRY_create_by_txt_APIName , X509_NAME_ENTRY_create_by_OBJ_APIName , X509_NAME_ENTRY_create_by_NID_APIName and X509_NAME_ENTRY_set_data_APIName are seldom used in practice are typically used to create and add new entries in a single operation||||null
You should instead call SSL_get_error_APIName to find out||||if it 's retryable
OpenSSL uses this table to lookup ciphers via functions such as EVP_get_cipher_byname_APIName||||null
OpenSSL_add_all_algorithms_APIName adds all algorithms to the table||||null
None of the functions return a value||||null
Old documentation indicated a difference between 0 and -1 , and that -1 was retryable||||null
SSLv2 does not support a shutdown alert protocol , so it can only be detected||||null
EVP_cleanup_APIName removes all ciphers and digests from the table||||null
OpenSSL_add_all_ciphers_APIName adds all encryption algorithms to the table including password based encryption algorithms||||null
A typical application will call OpenSSL_add_all_algorithms_APIName initially and EVP_cleanup_APIName before exiting||||null
The cipher and digest lookup functions are used in many parts of the library||||null
This is a common query in the OpenSSL mailing lists||||null
An application does not need to add algorithms to use them explicitly , by EVP_sha1_APIName||||null
This includes the PEM , PKCS # 12 , SSL and S/MIME libraries||||null
Calling OpenSSL_add_all_algorithms_APIName links in all algorithms||||null
BIO_s_fd_APIName returns the file descriptor BIO method||||null
as a result a statically linked executable can be quite large||||null
it is possible for them to fail||||null
BIO_read_APIName and BIO_write_APIName read or write the underlying descriptor||||null
BIO_puts_APIName is supported but BIO_gets_APIName is not||||null
BIO_tell_APIName returns the current file position by calling lseek||||null
It just needs to add them||||if it needs to lookup algorithms
BIO_new_fd_APIName returns a file descriptor BIO using BIO_new_fd_APIParam_1 and BIO_new_fd_APIParam_2||||null
This is a wrapper round the platforms file descriptor routines such as read_APIName and write_APIName||||null
BIO_reset_APIName attempts to change the file pointer to the start of file using lseek||||null
Use socket BIOs instead||||null
BIO_s_fd_APIName returns the file descriptor BIO method||||null
several functions will misbehave and complain several functions can not find algorithms||||If the table is not initialized
File descriptor BIOs should not be used for socket I/O||||null
BIO_reset_APIName returns zero for success and -1 if an error occurred||||null
BIO_seek_APIName and BIO_tell_APIName return the current file position or -1 if an error occurred||||null
This will only happen as a result of a memory allocation failure so this is not too much of a problem in practice||||null
BIO_set_fd_APIName always returns 1||||null
it is possible to just add the required ciphers and digests||||If this is important
BIO_new_fd_APIName returns the newly allocated BIO or NULL is an error occurred||||null
These values reflect the underlying lseek_APIName behaviour||||null
BIO_get_fd_APIName returns the file descriptor or -1 if the BIO has not been initialized||||null
The behaviour of BIO_read_APIName and BIO_write_APIName depends on the behavior of the platforms read_APIName and write_APIName calls on the descriptor||||null
BN_bn2bin_APIName converts the absolute value of BN_bn2bin_APIParam_1 into big-endian form and stores BN_bn2bin_APIParam_1 at BN_bn2bin_APIParam_2||||null
The string must be freed later using OPENSSL_free_APIName||||null
For negative numbers , the string is prefaced with a leading ' - '||||null
BN_bn2hex_APIName and BN_bn2dec_APIName return printable strings containing the hexadecimal and decimal encoding of BN_bn2hex_APIParam_1 BN_bn2dec_APIParam_1 respectively||||null
A `` negative zero '' is converted to zero||||null
BN_dec2bn_APIName is the same using the decimal system||||null
BN_bin2bn_APIName returns the BN_bn2bin_APIParam_1 BN_bin2bn_APIParam_3, NULL on error||||null
BN_bn2bin_APIName returns the length of the big-endian number placed at BN_bn2bin_APIParam_2||||null
BN_bin2bn_APIName converts the positive integer in big-endian form of length BN_bin2bn_APIParam_2 at BN_bin2bn_APIParam_1 into a BN_bin2bn_APIParam_3 and places it in BN_bin2bn_APIParam_3||||null
BN_bn2hex_APIName and BN_bn2dec_APIName return a null-terminated string, or NULL on error||||null
BN_bn2mpi_APIName returns the length of the representation||||null
BN_print_fp_APIName and BN_print_APIName return 1 on success, 0 on write errors||||null
BN_mpi2bn_APIName returns the BN_bn2mpi_APIParam_1 BN_mpi2bn_APIParam_3, and NULL on error||||null
BN_bn2mpi_APIName stores the representation of BN_bn2mpi_APIParam_1 at BN_bn2mpi_APIParam_2 , where BN_bn2mpi_APIParam_2 must be large enough to hold the result||||null
a new BN_bin2bn_APIParam_3 is created||||If BN_bin2bn_APIParam_3 is NULL
The error codes can be obtained by ERR_get_error_APIName||||null
BN_print_APIName and BN_print_fp_APIName write the hexadecimal encoding of BN_print_APIParam_2 BN_print_fp_APIParam_2 , with a leading ' - ' for negative numbers , to the BN_print_APIParam_1 or BN_print_fp_APIParam_1 BN_print_APIParam_1 BN_print_fp_APIParam_1||||null
The EVP encode routines provide a high level interface to base 64 encoding and decoding||||null
it only computes the number 's length in hexadecimal digits||||If BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 is NULL
Encoding of binary data is performed in blocks of 48 input bytes||||null
The final block will output 4 bytes for every 3 bytes of input||||null
For every 3 bytes of binary data provided 4 bytes of base 64 encoded data will be produced plus some occasional newlines||||null
BN_hex2bn_APIName and BN_dec2bn_APIName return the number of characters used in parsing, or 0 on error, in which case no new BN_bn2hex_APIParam_1 BN_bn2dec_APIParam_1 BN_hex2bn_APIParam_1 BN_dec2bn_APIParam_1 will be created||||null
Similarly a newline character will also be output||||null
For each 48 byte input block encoded 64 bytes of base 64 data is output plus an additional newline character||||null
EVP_EncodeInit_APIName initialises EVP_EncodeInit_APIParam_1 for the start of a new encoding operation||||null
EVP_EncodeFinal_APIName must be called at the end of an encoding operation||||null
The function will return -1||||null
EVP_DecodeFinal_APIName must be called at the end of a decoding operation||||null
EVP_EncodeFinal_APIName will process any partial block of data remaining in the EVP_EncodeFinal_APIParam_1 object||||null
Otherwise the function returns 1 on success||||null
The output data will be stored in EVP_EncodeFinal_APIParam_2 and the length of the data written will be stored in EVP_EncodeFinal_APIParam_3||||null
EVP_DecodeInit_APIName initialises EVP_DecodeInit_APIParam_1 for the start of a new decoding operation||||null
BN_mpi2bn_APIName converts the BN_mpi2bn_APIParam_2 bytes long representation at BN_mpi2bn_APIParam_1 to a BN_mpi2bn_APIParam_3 and stores it at BN_mpi2bn_APIParam_3 , or in a newly allocated BN_mpi2bn_APIParam_3||||if BN_mpi2bn_APIParam_3 is NULL
Any leading whitespace will be trimmed as will any trailing whitespace, newlines, carriage returns or EOF characters||||null
After such trimming the length of the data in EVP_DecodeBlock_APIParam_2 must be divisbile by 4||||null
For every 4 input bytes exactly 3 output bytes will be produced||||null
This function will return the length of the data decoded or -1 on error||||null
EVP_DecodeBlock_APIName will decode the block of EVP_DecodeBlock_APIParam_3 characters of base 64 data contained in EVP_DecodeBlock_APIParam_2 and store the result in EVP_DecodeBlock_APIParam_1||||null
EVP_EncodeBlock_APIName returns the number of bytes encoded excluding the NUL terminator||||null
EVP_DecodeUpdate_APIName returns -1 on error and 0 or 1 on success||||null
the number is negative||||If the string starts with ' - '
EVP_DecodeFinal_APIName returns -1 on error or 1 on success||||null
If 0 is returned no more non-padding base 64 characters are expected||||null
EVP_DecodeBlock_APIName returns the length of the data decoded or -1 on error||||null
Callback has been called to indicate state change inside a loop||||null
Callback has been called to indicate error exit of a handshake function||||null
It is the caller 's responsibility to ensure that EVP_EncodeFinal_APIParam_2 is sufficiently large to accommodate the output data which will never be more than 65 bytes plus an additional NUL terminator||||null
BN_bn2mpi_APIName and BN_mpi2bn_APIName convert BN_bn2mpi_APIParam_1 BN_mpi2bn_APIParam_3s from and to a format that consists of the number 's length in bytes represented as a 4-byte big-endian number , and the number itself in big-endian format , where the most significant bit signals a negative number||||null
Callback has been called||||null
Callback has been called due to an alert being sent or received||||null
Callback has been called||||null
Callback has been called||||during read operation
Callback has been called||||during write operation
The output will be padded with 0 bits to ensure that the output is always 3 bytes for every 4 input bytes||||if necessary
Base 64 encoding converts binary data into a printable form that uses the characters A-Z , a-z , 0-9 , '' + '' and '' / '' to represent the data||||null
SSL_get_info_callback_APIName returns the current setting||||null
SSL_set_info_callback_APIName does not provide diagnostic information||||null
OBJ_txt2nid_APIName returns NID corresponding to text string <s>||||null
The current state information can be obtained using the SSL_state_string_APIName family of functions||||null
OBJ_txt2obj_APIName converts the text string OBJ_txt2obj_APIParam_1 into an ASN1_OBJECT structure||||null
The total amount of space required is returned||||null
OBJ_obj2txt_APIName converts the OBJ_obj2txt_APIParam_3 OBJ_obj2txt_APIParam_3 into a textual representation||||null
OBJ_txt2nid_APIParam_1 can be a long name , a short name or the numerical representation of an object||||null
OBJ_obj2nid_APIName, OBJ_ln2nid_APIName, OBJ_sn2nid_APIName return the corresponding NID for the object OBJ_obj2nid_APIParam_1, the long name <ln> or the short name <sn> respectively or NID_undef if an error occurred||||null
OBJ_cmp_APIName compares OBJ_cmp_APIParam_1 to OBJ_cmp_APIParam_2||||null
If the two are identical 0 is returned||||null
OBJ_dup_APIName returns a copy of OBJ_dup_APIParam_1||||null
i2t_ASN1_OBJECT_APIName is the same as OBJ_obj2txt_APIName with the OBJ_obj2txt_APIParam_4 set to zero||||null
OBJ_length_APIName returns the size of the content octets of OBJ_length_APIParam_1||||null
only the numerical form is acceptable||||If OBJ_txt2obj_APIParam_2 is 1
A new NID is returned for the created object in case of success and NID_undef in case of failure||||null
OBJ_create_APIName adds a new object to the internal table||||null
OBJ_cleanup_APIName releases any resources allocated by creating new objects||||null
long names and short names will be interpreted as well as numerical forms||||If OBJ_txt2obj_APIParam_2 is 0
New objects can be added by calling OBJ_create_APIName||||null
the OID for commonName has the following definitions||||null
OBJ_nid2ln_APIName and OBJ_nid2sn_APIName returns a valid string or NULL on error||||null
OBJ_nid2obj_APIName returns an OBJ_nid2obj_APIParam_0 structure or NULL is an error occurred||||null
OBJ_create_APIParam_1 is the numerical form of the object , OBJ_create_APIParam_2 the short name and OBJ_create_APIParam_3 the long name||||null
The latter can not be constant||||null
Objects which are not in the table have the NID value NID_undef||||null
the numerical form will always be used||||If OBJ_obj2txt_APIParam_4 is 1
a null terminated string to OBJ_obj2txt_APIParam_1 at most OBJ_obj2txt_APIParam_2 bytes are written , truncating the result||||if necessary
The representation is written as||||null
Table objects have certain advantages over other objects||||null
their NIDs can be used in a C language switch statement||||null
RSA_sign_APIName returns 1 on success, 0 otherwise||||null
RSA_verify_APIName returns 1 on successful verification, 0 otherwise||||null
They are also static constant structures which are shared||||null
that is there is only a single constant structure for each table object||||null
The error codes can be obtained by ERR_get_error_APIName||||null
Instead OBJ_obj2txt_APIParam_1 must point to a valid buffer and OBJ_obj2txt_APIParam_2 should be set to a positive value||||null
SSL_get_session_APIName returns a pointer to the SSL_get_session_APIParam_0 actually used in SSL_get_session_APIParam_1||||null
SSL_get0_session_APIName is the same as SSL_get_session_APIName||||null
A buffer length of 80 should be more than enough to handle any OID encountered in practice||||null
These functions can not return OBJ_cmp_APIParam_1 OBJ_obj2txt_APIParam_3 i2t_ASN1_OBJECT_APIParam_3 OBJ_create_APIParam_1 OBJ_ln2nid_APIParam_1 OBJ_sn2nid_APIParam_1 OBJ_length_APIParam_1||||null
Certain signatures with an improper algorithm identifier are accepted for compatibility with SSLeay 0.4.5||||null
SSL_get0_session_APIName returns a pointer to the actual session||||null
Objects do not need to be in the internal tables to be processed , the functions OBJ_txt2obj_APIName and OBJ_obj2txt_APIName can process the numerical form of an OID||||null
The reference count of the SSL_get_session_APIParam_0 is not incremented , so that the pointer can become invalid by other operations||||null
OBJ_obj2txt_APIName is awkward and messy to use||||null
The following return values can occur||||null
The ssl session contains all information required to re-establish the connection without a new handshake||||null
SSL_get1_session_APIName is the same as SSL_get_session_APIName , but the reference count of the SSL_get1_session_APIParam_0 SSL_get_session_APIParam_0 is incremented by one||||null
There is no session available in SSL_get0_session_APIParam_1 SSL_get_session_APIParam_1 SSL_get1_session_APIParam_1||||null
The return value points to the data of an SSL session||||null
SSL_SESSION_free_APIName must be explicitly called once to decrement the reference count again||||null
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
OBJ_obj2txt_APIName does n't follow the convention of other OpenSSL functions where the buffer can be set to NULL to determine the amount of data that should be written||||null
Within the library there are two forms of elliptic curve that are of interest||||null
The first form is those defined over the prime field Fp||||null
One SSL_SESSION object , regardless of its reference count , must only be used with one SSL_CTX object||||null
the session may be removed completely||||If SSL_clear_APIName or SSL_free_APIName is called
and the pointer obtained will become invalid||||null
As the reference counter is not incremented , the pointer is only valid||||while the connection is in use
The elements of Fp are the integers 0 to p-1 , where p is a prime number||||null
This gives us a revised elliptic curve equation as follows||||null
OBJ_nid2obj_APIName , OBJ_nid2ln_APIName and OBJ_nid2sn_APIName convert the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 to an ASN1_OBJECT structure , the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 long name and the NID OBJ_nid2obj_APIParam_1 OBJ_nid2ln_APIParam_1 OBJ_nid2sn_APIParam_1 short name respectively , or NULL||||if an error occurred
y ^ 2 mod p = x ^ 3 + ax + b mod p||||null
For this form the elliptic curve equation is modified to||||null
EC_group_get_curve_GFp obtains the previously set curve parameters||||null
y ^ 2 + xy = x ^ 3 + ax ^ 2 + b||||null
EC_group_get_curve_GF2m obtains the previously set curve parameters||||null
it can be removed at any time due to timeout during SSL_CTX_flush_sessions_APIName||||Even if the session is valid
A new curve can be constructed by calling EC_GROUP_new , using the implementation provided by EC_GROUP_new_APIParam_1||||null
An appropriate default implementation method will be used||||null
EC_GROUP_set_curve_GF2m sets the equivalent curve parameters for a curve over F2 ^ m||||null
call the function EC_get_builtin_curves||||null
The functions EC_GROUP_new_curve_GFp and EC_GROUP_new_curve_GF2m are shortcuts for calling EC_GROUP_new and the appropriate EC_group_set_curve function||||null
there will either be three or five bits set dependant on||||null
The parameter EC_get_builtin_curves_APIParam_1 should be an array of EC_builtin_curve structures of size EC_get_builtin_curves_APIParam_2||||null
It is necessary to call either EC_GROUP_set_curve_GFp or EC_GROUP_set_curve_GF2m as appropriate to create a curve defined over Fp or over F2 ^ m respectively||||null
The return value is the total number of curves available||||null
SSL_SESSION objects keep internal link information about the session cache list||||when being inserted into one SSL_CTX object 's session cache
Otherwise the total number of curves will be provided||||null
The function will populate the EC_get_builtin_curves_APIParam_1 array with information about the builtin curves||||null
The second form is those defined over a binary field F2 ^ m where the elements of the field are integers of length at most m bits||||null
The EC_builtin_curve structure is defined as follows||||null
EC_GROUP_set_curve_GFp_APIParam_2 EC_GROUP_new_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GFp_APIParam_2 EC_GROUP_new_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_2 represents the irreducible polybnomial - each bit represents a term in the polynomial||||null
EC_GROUP_free frees the memory associated with the EC_GROUP||||null
If EC_get_builtin_curves_APIParam_2 is less than the total number of curves available, the first EC_get_builtin_curves_APIParam_2 curves will be returned||||null
EC_get_builtin_curves returns the number of builtin curves that are available||||null
SSL_get1_session_APIName will increment the reference count , so that the session will not be implicitly removed by other operations but stays in memory||||If the data is to be kept
Passing a NULL EC_get_builtin_curves_APIParam_1, or setting EC_get_builtin_curves_APIParam_2 to 0 will do nothing other than return the total number of curves available||||null
EC_GROUP_set_curve_GFp, EC_GROUP_get_curve_GFp, EC_GROUP_set_curve_GF2m, EC_GROUP_get_curve_GF2m return 1 on success or 0 on error||||null
All EC_GROUP_new* functions return a pointer to the newly constructed group, or NULL on error||||null
EC_GROUP_clear_free destroys any sensitive data held within the EC_GROUP and frees its memory||||null
Whilst the library can be used to create any curve using the functions described above , there are also a number of predefined curves that are available||||null
The following descriptions apply in the case of the built-in procedure||||null
Exactly one of the SSL_CTX_set_verify_APIParam_2 SSL_set_verify_APIParam_2 flags SSL_VERIFY_NONE and SSL_VERIFY_PEER must be set at any time||||null
SSL_CTX_set_verify_depth_APIName sets the maximum SSL_CTX_set_verify_depth_APIParam_2 for the certificate chain verification that shall be allowed for SSL_CTX_set_verify_depth_APIParam_1||||null
In order to construct a builtin curve , use the function EC_GROUP_new_by_curve_name and provide the EC_GROUP_new_by_curve_name_APIParam_1 of the curve to be constructed||||null
Setting the maximum depth to 2 allows the levels 0 , 1 , and 2||||null
The verification of certificates can be controlled by a set of logically or ` ed SSL_CTX_set_verify_APIParam_2 SSL_set_verify_APIParam_2 flags||||null
The actual verification procedure is performed either using the built-in verification procedure or using another application provided verification function set with SSL_CTX_set_cert_verify_callback_APIName||||null
EC_GROUP_set_curve_GFp sets the curve parameters EC_GROUP_set_curve_GFp_APIParam_2 EC_GROUP_new_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GFp_APIParam_2 EC_GROUP_new_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_2 , EC_GROUP_set_curve_GFp_APIParam_3 EC_GROUP_new_curve_GF2m_APIParam_2 EC_GROUP_get_curve_GF2m_APIParam_3 EC_GROUP_get_curve_GFp_APIParam_3 EC_GROUP_new_curve_GF2m_APIParam_10 EC_GROUP_new_curve_GF2m_APIParam_11 and EC_GROUP_new_curve_GF2m_APIParam_12 EC_GROUP_new_curve_GF2m_APIParam_13 EC_GROUP_new_curve_GF2m_APIParam_14 EC_GROUP_new_curve_GF2m_APIParam_15 EC_GROUP_new_curve_GF2m_APIParam_16 EC_GROUP_new_curve_GF2m_APIParam_17 for a curve over Fp stored in EC_GROUP_new_curve_GF2m_APIParam_18 EC_GROUP_new_curve_GF2m_APIParam_19 EC_GROUP_get_curve_GF2m_APIParam_20 EC_GROUP_get_curve_GF2m_APIParam_1 EC_GROUP_get_curve_GFp_APIParam_1 EC_GROUP_set_curve_GF2m_APIParam_1||||null
eg if a fatal error occurs on the connection or SSL_shutdown_APIName is not called prior to SSL_free_APIName||||non-resumable if the connection is not closed down cleanly
A session will be automatically removed from the session cache and marked as||||null
the certificates above the limit are ignored||||If the certificate chain is longer than allowed
In client mode , it is not checked , but||||null
The default depth limit is 100 , allowing for the peer certificate and additional 100 CA certificates||||null
The depth count is `` level 0||||null
SSL_CTX_get_session_cache_mode_APIName returns the currently used cache mode||||null
peer certificate '' , `` level 1||||null
The SSL * _ set_verify * _ APIName functions do not provide diagnostic information||||null
An application provided procedure also has access to the verify depth information and the verify_callback_APIName function , but the way this information is used may be different||||null
CA certificate '' , `` level 2||||null
SSL_CTX_set_session_cache_mode_APIName enables/disables session caching by setting the operational mode for SSL_CTX_set_session_cache_mode_APIParam_1 to <mode>||||null
higher level CA certificate '' , and so on||||null
The OpenSSL library can store/retrieve SSL/TLS sessions for later reuse||||null
It can only send exactly one id||||null
A server will look up the session in its internal session storage||||null
The error message produced will be that of an incomplete certificate chain and not X509_V_ERR_CERT_CHAIN_TOO_LONG as may be expected||||null
a client must send the session id to the server||||null
The following session cache modes and modifiers are available||||null
a X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY will be issued||||if these certificates would not be present , most likely
No session caching for client or server takes place||||null
Error messages are generated as||||null
The server either agrees to reuse the session or it starts a full handshake||||null
Client sessions are added to the session cache||||null
This option is not activated by default||||null
Server sessions are added to the session cache||||null
This can lead to unexpected behaviour||||if the SSL_VERIFY_PEER and SSL_VERIFY_NONE are not used as required
This is the default||||null
depth certificates in a chain are used||||during the verification procedure
SSL_CTX_set_verify_depth_APIName and SSL_set_verify_depth_APIName set the limit up to which||||null
Enable both SSL_SESS_CACHE_CLIENT and SSL_SESS_CACHE_SERVER at the same time||||null
the session id context must be set by the server||||null
Normally the session cache is checked for expired sessions every 255 connections using the SSL_CTX_flush_sessions_APIName function||||null
This flag will prevent sessions being stored in the internal cache||||null
As automatic lookup only applies for SSL/TLS servers , the flag has no effect on clients||||null
Enable both SSL_SESS_CACHE_NO_INTERNAL_LOOKUP and SSL_SESS_CACHE_NO_INTERNAL_STORE at the same time||||null
The default mode is SSL_SESS_CACHE_SERVER||||null
SSL_CTX_set_session_cache_mode_APIName returns the previously set cache mode||||null
Depending on the presence of SSL_SESS_CACHE_CLIENT and/or SSL_SESS_CACHE_SERVER , sessions negotiated in an SSL/TLS handshake may be cached for possible reuse||||null
the server will try to reuse the session||||If the session is found
SSL_CTX_get_session_cache_mode_APIName returns the currently set cache mode||||null
the automatic flushing may be disabled and SSL_CTX_flush_sessions_APIName can be called explicitly by the application||||null
Normally a new session is added to the internal cache as well as any external session caching that is configured for the SSL_CTX||||null
These functions are implemented in C and for several platforms in assembly language||||null
the server will try the external storage if available||||If the session is not found in internal storage or lookups for the internal storage have been deactivated
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_mul_words_APIParam_20 bn_mul_words_APIParam_21 bn_mul_words_APIParam_22, and returns the high word||||null
By setting this flag , session-resume operations in an SSL/TLS server will not automatically look up sessions in the internal cache||||null
the sessions are unique for each SSL_CTX object||||if more than one SSL_CTX object is being maintained
The sessions can be held in memory for each SSL_CTX_set_session_cache_mode_APIParam_1 SSL_CTX_get_session_cache_mode_APIParam_1||||null
this flag guarantees that all lookups are directed to the external cache||||If external session caching callbacks are in use
the server looks for the corresponding session in the internal session cache , in the external cache if available||||When a client proposes a session to be reused
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 - bn_sub_words_APIParam_3 bn_add_words_APIParam_3, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_words_APIParam_20 bn_mul_words_APIParam_21, and returns the carry||||null
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 + bn_sub_words_APIParam_3 bn_add_words_APIParam_3, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_add_words_APIParam_1 bn_mul_words_APIParam_20 bn_mul_words_APIParam_21, and returns the high word||||null
The following functions are implemented in C||||null
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * mul_APIParam_3 mul_add_APIParam_3 bn_mul_words_APIParam_4 + bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_mul_words_APIParam_20 bn_mul_words_APIParam_21 bn_mul_words_APIParam_22, places the result in bn_sub_words_APIParam_1 bn_mul_words_APIParam_1 bn_mul_words_APIParam_20 bn_mul_words_APIParam_21 bn_mul_words_APIParam_22, and returns the high word||||null
As there is no reliable way for the OpenSSL library to know or which session to choose , the application must select the session to be reused by using the SSL_set_session_APIName function||||null
bn_print_APIName prints bn_print_APIParam_1 to stderr||||null
the 3 * 3*bn_sqr_recursive_APIParam_3 bn_mul_recursive_APIParam_4 word array bn_sqr_recursive_APIParam_4 bn_sqr_normal_APIParam_4||||null
bn_dump_APIName prints bn_dump_APIParam_2 words at bn_dump_APIParam_1 to stderr||||null
both macros return NULL on error, bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 otherwise||||null
It can add intermediate and optionally the root CA certificates using SSL_add1_chain_cert_APIName||||null
It computes bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 * bn_sub_words_APIParam_2 bn_mul_words_APIParam_2 bn_add_words_APIParam_2 bn_mul_add_words_APIParam_2 bn_sqr_words_APIParam_2 word-wise , and places the low and high bytes of the result in bn_mul_words_APIParam_20 bn_mul_words_APIParam_21 bn_mul_words_APIParam_22 bn_mul_words_APIParam_23 bn_mul_words_APIParam_24||||null
CMS_sign_receipt_APIName returns either a valid CMS_ContentInfo structure or NULL if an error occurred||||null
The error can be obtained from ERR_get_error_APIName||||null
Otherwise number of recorded values is returned||||null
bn_expand_APIName ensures that bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 has enough space for a bn_expand_APIParam_2 bit number||||null
An application will typically call SSL_use_certificate_APIName and SSL_use_PrivateKey_APIName to set the end entity certificate and private key||||null
A more advanced callback might examine the handshake parameters and set whatever chain is appropriate||||null
SSL_set_verify_result_APIName does not provide a return value||||null
SSL_set_verify_result_APIName overrides the verification result||||null
OPENSSL_instrument_bus performs OPENSSL_instrument_bus2_APIParam_2 OPENSSL_instrument_bus_APIParam_2 probes and records the number of oscillator cycles every probe took||||null
The valid codes for SSL_set_verify_result_APIParam_2 are documented in verify_APIName||||null
It only changes the verification result of the SSL_set_verify_result_APIParam_1 object||||null
For reference , on x86 ` flush cache line ' was introduced with the SSE2 extensions||||null
in any SSL/TLS servers where external caching is configured , any successful session lookups in the external cache would normally be copied into the local cache before processing continues - this flag prevents these additions to the internal cache as well||||null
It returns 1, 0 and -1 if bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 mul_APIParam_20 mul_APIParam_21 mul_APIParam_22 mul_APIParam_23 mul_APIParam_24 mul_APIParam_25 mul_APIParam_26 mul_APIParam_27 mul_APIParam_28 mul_APIParam_29 mul_add_APIParam_20 bn_mul_high_APIParam_2 bn_set_high_APIParam_2 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 is greater than, equal and less than mul_add_APIParam_25 bn_cmp_words_APIParam_2 mul_add_APIParam_27 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3||||null
bn_wexpand_APIName ensures that bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_mul_comba8_APIParam_3 bn_mul_low_recursive_APIParam_3 bn_mul_normal_APIParam_4 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 has enough space for an bn_mul_comba4_APIParam_30 bn_mul_comba4_APIParam_31 word number||||null
both macros call bn_expand2_APIName , which allocates a new bn_div_words_APIParam_3 bn_dump_APIParam_1 array and copies the data||||If the number has to be expanded
Return value of 0 indicates that CPU is not capable of performing the benchmark , either because oscillator counter or ` flush cache line ' is not available on current platform||||null
a legacy client supporting only TLS v1 .0 might receive a certificate chain signed using SHA1 whereas a TLS v1 .2 client which advertises support for SHA256 could receive a chain using SHA256||||null
the original value will reappear||||so if the session is to be reused later
It does not become part of the established session||||null
SSL_set_verify_result_APIName sets SSL_set_verify_result_APIParam_2 of the object SSL_set_verify_result_APIParam_1 to be the result of the verification of the X509 certificate presented by the peer||||if any
The function EVP_PKEY_CTX_get_cb_APIName returns the key or parameter generation callback||||null
The functions EVP_PKEY_paramgen_init_APIName and EVP_PKEY_paramgen_APIName are similar except parameters are generated||||null
The function EVP_PKEY_CTX_get_keygen_info_APIName returns parameters associated with the generation operation||||null
The EVP_PKEY_keygen_APIName function performs a key generation operation , the generated key is written to EVP_PKEY_keygen_APIParam_2||||null
If EVP_PKEY_CTX_get_keygen_info_APIParam_2 is -1 the total number of parameters available is returned||||null
The certificate verification depth set with SSL -LSB- _ CTX -RSB- _ verify_depth_APIName stops the verification at a certain depth||||null
The function EVP_PKEY_set_cb_APIName sets the key or parameter generation callback to EVP_PKEY_CTX_get_cb_APIParam_0||||null
It computes bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 mul_APIParam_22 mul_APIParam_23 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 mul_APIParam_27 mul_APIParam_28 sqr_APIParam_3 mul_add_APIParam_20 mul_add_APIParam_21 mul_add_APIParam_22 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 * bn_mul_comba4_APIParam_3 mul_add_APIParam_25 bn_mul_comba8_APIParam_3 mul_add_APIParam_27 mul_add_APIParam_28 mul_add_APIParam_29 bn_set_max_APIParam_10 bn_set_max_APIParam_11 bn_set_max_APIParam_12 and places the result in bn_sqr_comba4_APIParam_1 bn_set_max_APIParam_14 bn_set_max_APIParam_15 bn_set_max_APIParam_16 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_sqr_recursive_APIParam_23 bn_mul_recursive_APIParam_1 bn_sqr_recursive_APIParam_25 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1||||null
It computes bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_sqr_recursive_APIParam_2 bn_wexpand_APIParam_1 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_expand_APIParam_1 bn_print_APIParam_1 bn_sqr_normal_APIParam_2 mul_APIParam_22 mul_APIParam_23 bn_sqr_comba8_APIParam_2 bn_check_top_APIParam_1 bn_mul_part_recursive_APIParam_2 mul_APIParam_27 mul_APIParam_28 sqr_APIParam_3 mul_add_APIParam_20 mul_add_APIParam_21 mul_add_APIParam_22 bn_set_low_APIParam_2 bn_fix_top_APIParam_1 * bn_mul_comba4_APIParam_3 mul_add_APIParam_25 bn_mul_comba8_APIParam_3 mul_add_APIParam_27 mul_add_APIParam_28 mul_add_APIParam_29 bn_set_max_APIParam_10 bn_set_max_APIParam_11 bn_set_max_APIParam_12 and places the result in bn_sqr_comba4_APIParam_1 bn_set_max_APIParam_14 bn_set_max_APIParam_15 bn_set_max_APIParam_16 bn_mul_comba4_APIParam_1 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_sqr_recursive_APIParam_23 bn_mul_recursive_APIParam_1 bn_sqr_recursive_APIParam_25 bn_mul_high_APIParam_1 bn_set_high_APIParam_1 bn_set_low_APIParam_1||||null
It computes the bn_wexpand_APIParam_2 bn_cmp_words_APIParam_3 bn_sqr_normal_APIParam_3 bn_dump_APIParam_2 bn_mul_low_normal_APIParam_4 bn_expand2_APIParam_2 bn_set_high_APIParam_3 bn_set_low_APIParam_3 low words of bn_sqr_comba4_APIParam_2 mul_APIParam_2 mul_add_APIParam_2 bn_set_max_APIParam_1 bn_cmp_words_APIParam_32 bn_cmp_words_APIParam_33 bn_mul_comba4_APIParam_2 bn_cmp_words_APIParam_1 bn_mul_comba8_APIParam_2 bn_cmp_words_APIParam_37 bn_cmp_words_APIParam_38 bn_sqr_normal_APIParam_2 bn_sqr_normal_APIParam_30 bn_sqr_normal_APIParam_31 bn_sqr_normal_APIParam_32 bn_check_top_APIParam_1 bn_sqr_normal_APIParam_34 bn_sqr_normal_APIParam_35 bn_mul_low_normal_APIParam_2 bn_sqr_normal_APIParam_37 bn_sqr_normal_APIParam_38 bn_sqr_normal_APIParam_39 bn_dump_APIParam_20 bn_dump_APIParam_21 bn_fix_top_APIParam_1 * bn_mul_comba4_APIParam_3 bn_cmp_words_APIParam_2 bn_dump_APIParam_24 bn_dump_APIParam_25 bn_dump_APIParam_26 bn_mul_part_recursive_APIParam_3 bn_mul_recursive_APIParam_3 bn_mul_low_normal_APIParam_3 bn_mul_high_APIParam_3 and places the result in bn_sqr_comba4_APIParam_1 mul_APIParam_1 bn_mul_low_normal_APIParam_43 bn_sqr_recursive_APIParam_1 bn_mul_low_normal_APIParam_45 bn_mul_comba8_APIParam_1 bn_sqr_normal_APIParam_1 bn_mul_low_recursive_APIParam_1 bn_mul_normal_APIParam_1 bn_sqr_comba8_APIParam_1 bn_mul_part_recursive_APIParam_1 bn_mul_recursive_APIParam_1 bn_mul_low_normal_APIParam_1 bn_mul_high_APIParam_1 bn_expand2_APIParam_25 bn_expand2_APIParam_26||||null
Any non negative value returns the value of that parameter||||null
If the callback returns 0, the key genration operation is aborted and an error occurs||||null
The functions EVP_PKEY_CTX_set_app_data_APIName and EVP_PKEY_CTX_get_app_data_APIName set and retrieve an opaque pointer||||null
EVP_PKEY_CTX_gen_keygen_info_APIName with a non-negative value for EVP_PKEY_CTX_get_keygen_info_APIParam_2 should only be called within the generation callback||||null
Others might not even call the callback||||null
The operation performed by key or parameter generation depends on the algorithm used||||null
In some cases the `` generation '' option merely sets the appropriate fields in an EVP_PKEY structure||||null
After the call to EVP_PKEY_keygen_init_APIName or EVP_PKEY_paramgen_init_APIName algorithm specific control operations can be performed to set any appropriate parameters for the operation||||null
This might occur where a user clicks on a `` cancel '' button||||during a time consuming operation
In OpenSSL an EVP_PKEY structure containing a private key also contains the public key components and parameters||||null
Some might not give any useful information at all||||during key or parameter generation
An OpenSSL private key is equivalent to what some libraries call a `` key pair ''||||null
The meaning of the parameters passed to the callback will depend on the algorithm and the specifiic implementation of the algorithm||||null
This can be used to set some application defined value which can be retrieved in the callback||||null
a return value of -2 indicates the operation is not supported by the public key algorithm||||null
A private key can be used in functions which require the use of a public key or parameters||||null
a handle which is used to update a `` progress dialog ''||||null
The function SSL_CONF_cmd_argv_APIName processes at most two command line arguments from SSL_CONF_cmd_argv_APIParam_3 and SSL_CONF_cmd_argv_APIParam_2||||null
EVP_PKEY_keygen_init_APIName, EVP_PKEY_paramgen_init_APIName, EVP_PKEY_keygen_APIName and EVP_PKEY_paramgen_APIName return 1 for success and 0 or a negative value for failure||||null
The SSL_CONF_cmd_argv_APIParam_2 argument can be set to NULL is The SSL_CONF_cmd_argv_APIParam_2 argument is not used||||null
The functions EVP_PKEY_keygen_APIName and EVP_PKEY_paramgen_APIName can be called more than once on the same context||||if several operations are performed using the same parameters
If -2 is returned ,then an argument for a command is missing||||null
SSL_CONF_cmd_argv_APIName returns the number of command arguments processed||||null
The values of SSL_CONF_cmd_argv_APIParam_3 and SSL_CONF_cmd_argv_APIParam_2 are updated to reflect the number of command options processed||||null
The following return values can occur||||null
0 , 1 , 2 or a negative error code||||null
Pointer to the subject names of the successfully read certificates||||null
SSL_load_client_CA_file_APIName reads a file of PEM formatted certificates and extracts the X509_NAMES of the certificates found||||null
The operation failed , check out the error stack for the reason||||null
It is equivalent to calling RSA_new_method||||null
RSA_new_APIName allocates and initializes an RSA_new_APIParam_0 structure||||null
If -1 is returned ,the command is recognised but couldn't be processed due to an error||||null
RSA_free_APIName frees the RSA_free_APIParam_1 structure and its components||||null
The key is erased before the memory is returned to the system||||null
a syntax error in the argument||||null
RSA_free_APIName returns no value||||null
Otherwise it returns a pointer to the newly allocated structure||||null
If the allocation fails, RSA_new_APIName returns NULL and sets an error code that can be obtained by ERR_get_error_APIName||||null
BN_generate_prime_ex_APIName generates a pseudo-random prime number of bit length BN_generate_prime_ex_APIParam_2||||null
The prime may have to fulfill additional requirements for use in Diffie-Hellman key exchange||||null
The PRNG must be seeded prior to calling BN_generate_prime_ex_APIName||||null
The prime number generation has a negligible error probability||||null
it is not limited to CA certificates||||While the name suggests the specific usage as support function for SSL_CTX_set_client_CA_list_APIName
BN_generate_prime_ex_APIName return 1 on success or 0 on error||||null
to reach the 128 bit security level , BN_is_prime_ex_APIParam_2 BN_is_prime_fasttest_ex_APIParam_2 should be set to 64||||null
BN_generate_prime_ex_APIParam_1 will be used to store the number||||If BN_generate_prime_ex_APIParam_1 is not NULL
There are two types of BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 structure that are supported||||null
BN_generate_prime_APIName returns the prime number on success, NULL otherwise||||null
`` new '' style and `` old '' style||||null
The following tests are performed until one of them shows that BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 is composite||||null
Callback functions should return 1 on success or 0 on error||||null
The error codes can be obtained by ERR_get_error_APIName||||null
BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 is used as follows||||If BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 is not NULL
BN_GENCB_call calls the callback function held in the BN_is_prime_ex_APIParam_4 BN_GENCB_call_APIParam_1 structure and passes the ints BN_GENCB_call_APIParam_2 BN_is_prime_fasttest_APIParam_1 and BN_GENCB_call_APIParam_3 as arguments||||null
The length-prefix byte is not included in the length||||null
New programs should prefer the `` new '' style , whilst the `` old '' style is provided for backwards compatibility purposes||||null
Each string is limited to 255 bytes||||null
BN_generate_prime_ex_APIParam_3 will be a safe prime / 2 is also prime -RRB-||||If BN_generate_prime_ex_APIParam_3 is true
BN_is_prime_ex_APIName and BN_is_prime_fasttest_ex_APIName test||||if the number BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 is prime
A byte-string length of 0 is invalid||||null
A truncated byte-string is invalid||||null
SSL_select_next_proto_APIName returns one of the following||||null
these functions reverse the return value convention||||null
The protocol-lists must be in wire-format , which is defined as a vector of non-empty , 8-bit length-prefixed , byte strings||||null
SSL_CTX_set_alpn_protos_APIName and SSL_set_alpn_protos_APIName return 0 on success, and non-0 on failure||||null
it is considered prime||||if BN_is_prime_ex_APIParam_1 BN_is_prime_fasttest_ex_APIParam_1 passes all these tests
ALPN protocol selected||||null
A match was found and is returned in SSL_select_next_proto_APIParam_1, SSL_select_next_proto_APIParam_2||||null
ALPN protocol not selected||||null
The length of the vector is not in the vector itself , but in a separate variable||||null
SSL_state_string_long_APIName returns a string indicating the current state of the SSL object SSL_state_string_long_APIParam_1||||null
The ALPN callback is executed after the servername callback||||null
the ALPN callback is not invoked||||If there is no ALPN proposed in the ClientHello
as that servername callback may update the SSL_CTX , and subsequently , the ALPN callback||||null
SSL_state_string_APIName returns a 6 letter string indicating the current state of the SSL object SSL_state_string_APIParam_1||||null
The state is internally maintained||||null
the state information is not very informative before or||||when a connection has been established
Querying||||null
Detailed description of possible states to be included later||||null
The EVP signature verification routines are a high level interface to digital signatures||||null
EVP_VerifyInit_ex_APIName sets up verification context EVP_VerifyInit_ex_APIParam_1 to use digest EVP_VerifyInit_ex_APIParam_2 from ENGINE EVP_VerifyInit_ex_APIParam_3||||null
an SSL objects passes several states||||During its use
EVP_VerifyInit_ex_APIParam_1 must be initialized by calling EVP_MD_CTX_init_APIName before calling this function||||null
BN_is_prime_ex_APIName, BN_is_prime_fasttest_ex_APIName, BN_is_prime_APIName and BN_is_prime_fasttest_APIName return 0 if the number is composite, 1 if the number is prime with an error probability of less than 0.25^BN_is_prime_ex_APIParam_2 BN_is_prime_fasttest_ex_APIParam_2, and -1 on error||||null
EVP_VerifyUpdate_APIName hashes EVP_VerifyUpdate_APIParam_3 bytes of data at EVP_VerifyUpdate_APIParam_2 into the verification context EVP_VerifyUpdate_APIParam_1||||null
EVP_VerifyInit_ex_APIName and EVP_VerifyUpdate_APIName return 1 for success and 0 for failure||||null
the number of checks needs to be much higher to reach the same level of assurance||||When the source of the prime is not random or not trusted
the state information however can be of significant interest||||during the handshake
It should equal half of the targeted security level in bits||||null
This function can be called several times on the same EVP_VerifyUpdate_APIParam_1 to include additional data||||null
For both blocking or non-blocking sockets , the details state information can be used within the info_callback function set with the SSL_set_info_callback_APIName call||||null
EVP_VerifyInit_APIName initializes verification context EVP_VerifyInit_APIParam_1 to use the default implementation of digest EVP_VerifyInit_APIParam_2||||null
EVP_VerifyFinal_APIName returns 1 for a correct signature, 0 for failure and -1 if some other error occurred||||null
The error codes can be obtained by ERR_get_error_APIName||||null
EVP_VerifyFinal_APIName verifies the data in EVP_VerifyFinal_APIParam_1 using the public key EVP_VerifyFinal_APIParam_4 and against the EVP_VerifyFinal_APIParam_3 bytes at EVP_VerifyFinal_APIParam_2||||null
A list of algorithms and associated public key algorithms appears in EVP_DigestInit_APIName||||null
The call to EVP_VerifyFinal_APIName internally finalizes a copy of the digest context||||null
This is because the code becomes transparent to the algorithm used and much more flexible||||null
When using non-blocking sockets, the function call performing the handshake may return with SSL_ERROR_WANT_READ or SSL_ERROR_WANT_WRITE condition, so that SSL_state_string[_long]_APIName may be called||||null
The EVP_VerifyInit_APIParam_1 EVP_VerifyUpdate_APIParam_1 EVP_VerifyFinal_APIParam_1 EVP_VerifyInit_ex_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces||||null
This means that calls to EVP_VerifyUpdate_APIName and EVP_VerifyFinal_APIName can be called later to digest and verify additional data||||null
the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur||||null
It is not possible to change the signing parameters using these function||||null
Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type||||null
The previous two bugs are fixed in the newer EVP_VerifyDigest * _ APIName function||||null
Older versions of this documentation wrongly stated that calls to EVP_VerifyUpdate_APIName could not be made after calling EVP_VerifyFinal_APIName||||null
SSL_CTX_set_default_passwd_cb_userdata_APIName sets a pointer to pem_passwd_cb_APIParam_4 which will be provided to the password callback on invocation||||null
On invocation a pointer to pem_passwd_cb_APIParam_4 is provided||||null
SSL_CTX_set_default_passwd_cb_APIName sets the default password callback called||||when loading/storing a PEM certificate with encryption
The actual length of the password must be returned to the calling function||||null
pem_passwd_cb_APIParam_3 indicates whether the callback is used for reading/decryption or writing/encryption||||null
The way this password can be supplied may depend on the application||||null
The pem_passwd_cb must write the password into the provided buffer pem_passwd_cb_APIParam_1 which is of size pem_passwd_cb_APIParam_2||||null
SSL_CTX_set_default_passwd_cb_APIName and SSL_CTX_set_default_passwd_cb_userdata_APIName do not provide diagnostic information||||null
In the last case, the password could be stored into the pem_passwd_cb_APIParam_4 pem_passwd_cb_APIParam_4 storage and the pem_passwd_cb_APIName only returns the password already stored||||null
DSA_generate_parameters_ex_APIParam_2 DSA_generate_parameters_APIParam_1 is the length of the prime to be generated||||null
the DSS allows a maximum of 1024 bits||||null
DSA_generate_parameters_ex_APIName generates primes p and q and a generator g for use in the DSA and stores the result in DSA_generate_parameters_ex_APIParam_1||||null
any error relating to the private key will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate_APIName||||null
Refer to BN_generate_prime_APIName for further information||||null
the password to be used||||during decryption
The pem_passwd_cb_APIName , which must be provided by the application , hands back||||null
A callback function may be used to provide feedback about the progress of the key generation||||null
the password dialog may ask for the same password twice for comparison||||null
Other items in PEM formatting can also be encrypted , it is however not usual , as certificate information is considered public||||null
DSA_generate_parameters_ex_APIName returns a 1 on success, or 0 otherwise||||null
For information on the BN_GENCB structure and the BN_GENCB_call function discussed below , refer to BN_generate_prime_APIName||||null
Additionally `` old style '' callbacks are used instead of the newer BN_GENCB based approach||||null
it can be practical to have pem_passwd_cb_APIName handle the password dialog interactively||||If only one private key is handled
DSA_generate_parameters_APIName returns a pointer to the DSA structure, or NULL if the parameter generation fails||||null
The error codes can be obtained by ERR_get_error_APIName||||null
it can be practical to ask for the password once , keep it in memory and use it several times||||If several keys have to be handled
Seed lengths > 20 are not supported||||null
DSA_generate_parameters_APIName  works in much the same way as for DSA_generate_parameters_ex, except that no DSA_generate_parameters_ex_APIParam_1 parameter is passed and instead a newly allocated DSA_generate_parameters_APIParam_0 structure is returned||||null
DSA_generate_parameters_APIParam_0 will be called as shown below||||If DSA_generate_parameters_APIParam_0 is not NULL
These functions decode and encode PKCS # 3 DH parameters using the DHparameter structure described in PKCS # 3||||null
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
SSL_CTX_get0_chain_certs_APIName retrieves the chain associated with the current certificate of SSL_CTX_build_cert_chain_APIParam_1 SSL_CTX_clear_chain_certs_APIParam_1 SSL_CTX_add0_chain_cert_APIParam_1 SSL_CTX_add1_chain_cert_APIParam_1 SSL_CTX_set_current_cert_APIParam_1 SSL_CTX_select_current_cert_APIParam_1||||null
SSL structures will not be affected by any chains subsequently changed in the parent SSL_CTX||||null
One chain can be set for each key type supported by a server||||null
SSL_CTX_add0_chain_cert_APIName and SSL_CTX_add1_chain_cert_APIName append the single certificate SSL_CTX_add0_chain_cert_APIParam_2 SSL_CTX_add1_chain_cert_APIParam_2 to the chain associated with the current certificate of SSL_CTX_add0_chain_cert_APIParam_1 SSL_CTX_add1_chain_cert_APIParam_1||||null
So , , an RSA and a DSA certificate can have different chains||||null
Misconfigured applications sending incorrect certificate chains often cause problems with peers||||null
All other functions return 1 for success and 0 for failure||||null
Automatic chain building is performed on each new session||||null
A "serverinfo" extension is returned in response to an empty ClientHello Extension||||null
These functions load `` serverinfo '' TLS ServerHello Extensions into the SSL_CTX||||null
Calling SSL_CTX_build_cert_chain_APIName or SSL_build_cert_chain_APIName is more efficient than the automatic chain building as it is only performed once||||null
The functions SSL_CTX_build_cert_chain_APIName and SSL_build_cert_chain_APIName can be used to check application configuration and to ensure any necessary subordinate CAs are sent in the correct order||||null
The extensions must be concatenated into a sequence of bytes||||null
SSL_CTX_use_serverinfo_APIName loads one or more serverinfo extensions from a byte array into SSL_CTX_use_serverinfo_APIParam_1||||null
On success, the functions return 1||||null
The extensions must be in PEM format||||null
SSL_CTX_use_serverinfo_file_APIName loads one or more serverinfo extensions from SSL_CTX_use_serverinfo_file_APIParam_2 into SSL_CTX_use_serverinfo_file_APIParam_1||||null
an SSL_CTX structure are copied to any SSL structures||||when SSL_new_APIName is called
On failure, the functions return 0||||null
The chains associate with||||null
SSL_set0_chain_APIName , SSL_set1_chain_APIName , SSL_add0_chain_cert_APIName , SSL_add1_chain_cert_APIName , SSL_get0_chain_certs_APIName , SSL_clear_chain_certs_APIName , SSL_build_cert_chain_APIName , SSL_select_current_cert_APIName and SSL_set_current_cert_APIName are similar except they apply to SSL structure SSL_add0_chain_cert_APIParam_1 SSL_set1_chain_APIName0 SSL_set1_chain_APIName1 SSL_set1_chain_APIName2 SSL_set1_chain_APIName3 SSL_set1_chain_APIName4||||null
Each PEM extension name must begin with the phrase `` BEGIN SERVERINFO FOR ''||||null
Check out the error stack to find out the reason||||null
SMIME_write_CMS_APIParam_1 is the BIO to write the data to||||null
SMIME_write_CMS_APIParam_2 is the appropriate SMIME_write_CMS_APIParam_2 structure||||null
SMIME_write_CMS_APIName adds the appropriate MIME headers to a CMS structure to produce an S/MIME message||||null
Each extension must consist of a 2-byte Extension Type , a 2-byte length , and length bytes of extension_data||||null
SMIME_write_CMS_APIParam_4 is an optional set of flags||||null
SMIME_write_CMS_APIName returns 1 for success or 0 for failure||||null
The following flags can be passed in the SMIME_write_CMS_APIParam_4 parameter||||null
no certificates added using SSL_CTX_add_extra_chain_cert_APIName will be used||||If any certificates are added using these functions
SSL_CTX_select_current_cert_APIName selects SSL_CTX_select_current_cert_APIParam_2 as the current end entity certificate , but only||||if SSL_CTX_select_current_cert_APIParam_2 has already been loaded into SSL_CTX_select_current_cert_APIParam_1 using a function such as SSL_CTX_use_certificate_APIName
CMS_get0_type_APIName returns the content type of a CMS_ContentInfo structure as and ASN1_OBJECT pointer||||null
CMS_get0_type_APIName and CMS_get0_eContentType_APIName return and ASN1_OBJECT structure||||null
SMIME_write_CMS_APIName always base64 encodes CMS structures , there should be an option to disable this||||null
That means that||||null
CMS_get0_content_APIName returns a pointer to the CMS_get0_content_APIParam_0 pointer containing the embedded content||||null
An application can decide how to process the CMS_ContentInfo structure based on this value||||null
The return value of CMS_get0_content_APIName is a pointer to the CMS_get0_content_APIParam_0 content pointer||||null
Each extension must consist of a 2-byte Extension Type , a 2-byte length , and length bytes of extension_data||||null
CMS_set1_eContentType_APIName returns 1 for success or 0 if an error occurred||||null
The error can be obtained from ERR_get_error_APIName||||null
RAND_bytes_APIName puts RAND_bytes_APIParam_2 cryptographically strong pseudo-random bytes into RAND_bytes_APIParam_1||||null
The error code can be obtained by ERR_get_error_APIName||||null
SSL_use_psk_identity_hint_APIName sets the given NULL-terminated PSK identity hint SSL_CTX_use_psk_identity_hint_APIParam_2 SSL_use_psk_identity_hint_APIParam_2 to SSL connection object SSL_use_psk_identity_hint_APIParam_1||||null
PSK identity was not found||||null
SSL_CTX_use_psk_identity_hint_APIName and SSL_use_psk_identity_hint_APIName return 1 on success, 0 otherwise||||null
SSL_CTX_use_psk_identity_hint_APIName sets the given NULL-terminated PSK identity hint SSL_CTX_use_psk_identity_hint_APIParam_2 SSL_use_psk_identity_hint_APIParam_2 to SSL context object SSL_CTX_use_psk_identity_hint_APIParam_1||||null
RAND_bytes_APIName and RAND_priv_bytes_APIName return 1 on success, -1 if not supported by the current RAND method, or 0 on other failure||||null
BIO_s_accept_APIName returns the accept BIO method||||null
Return values from the server callback are interpreted as follows||||null
An `` unknown_psk_identity '' alert message will be sent and the connection setup fails||||null
Accept BIOs support BIO_puts_APIName but not BIO_gets_APIName||||null
This is a wrapper round the platform 's TCP/IP socket accept routines||||null
In the case where PSK identity hint is NULL , the server does not send the ServerKeyExchange message to the client||||null
In this way any platform specific operations are hidden by the BIO abstraction||||null
Using accept BIOs , TCP/IP connections can be accepted and data transferred using only BIO routines||||null
Always check the error return value of RAND_bytes_APIName and RAND_priv_bytes_APIName and do not take randomness for granted||||null
BIO_get_fd_APIName and BIO_set_fd_APIName can be called to retrieve or set the accept socket||||null
Read and write operations on an accept BIO will perform I/O on the underlying connection||||null
BIO_set_accept_port_APIName uses the string BIO_set_accept_port_APIParam_2 to set the accept port||||null
Calling BIO_reset_APIName on a accept BIO will close any active connection and reset the BIO into a state where it awaits another incoming connection||||null
BIO_new_accept_APIName combines BIO_new_APIName and BIO_set_accept_port_APIName into a single call||||null
BIO_set_bind_mode_APIName and BIO_get_bind_mode_APIName set and retrieve the current bind mode||||null
that is it creates a new accept BIO with port BIO_new_accept_APIParam_1||||null
The port is represented as a string of the form `` host||||null
the content is output in BER format using indefinite length constructed encoding except in the case of signed data with detached content where the content is absent and DER format is used||||If streaming is performed
an error occurs||||if the CSPRNG has not been seeded with enough randomness to ensure an unpredictable byte sequence
port '' , where `` host '' is the interface to use and `` port '' is the port||||null
This is useful||||if , , a buffering or SSL BIO is required for each connection
the accept socket to blocking mode||||if BIO_set_nbio_accept_APIParam_2 is 0 or non blocking mode if BIO_set_nbio_accept_APIParam_2 is 1
BIO_set_nbio_accept_APIName sets||||null
another socket can not be bound to the same port||||If BIO_BIND_NORMAL is set
will be duplicated and prepended to the chain||||when an incoming connection is received
BIO_set_accept_bios_APIName can be used to set a chain of BIOs which||||null
BIO_do_accept_APIName serves two functions||||null
That is the chain is now accept - > socket||||null
Second and subsequent calls to BIO_do_accept_APIName will await an incoming connection , or request a retry in non blocking mode||||null
This can be done by waiting for a connection and calling||||null
This is often undesirable however||||null
SSL_shutdown_APIName shuts down an active TLS/SSL connection||||null
This can be resolved by using BIO_pop_APIName and freeing up the accept BIO after the initial connection||||null
This effectively means that attempting I/O on an initial accept socket will await an incoming connection perform I/O on an incoming connection||||null
BIO_set_accept_port_APIName , BIO_get_accept_port_APIName , BIO_set_nbio_accept_APIName , BIO_set_accept_bios_APIName , BIO_set_bind_mode_APIName , BIO_get_bind_mode_APIName and BIO_do_accept_APIName are macros||||null
SSL_shutdown_APIName sends the `` close notify '' shutdown alert to the peer||||null
after this call , they will be automatically freed||||when the accept BIO is freed
The chain of BIOs must not be freed||||null
SSL_shutdown_APIName tries to send the `` close notify '' shutdown alert to the peer||||null
Note that SSL_shutdown_APIName must not be called if a previous fatal error has occurred on a connection ie if SSL_get_error_APIName has returned SSL_ERROR_SYSCALL or SSL_ERROR_SSL||||null
it will attempt to create the accept socket and bind an address to it||||When it is first called , after the accept BIO has been setup
the accept BIO must be made available for further incoming connections||||If a server wishes to process multiple connections
It is recommended, to check the return value of SSL_shutdown_APIName and call SSL_shutdown_APIName again, if the bidirectional shutdown is not yet complete||||null
it is possible to perform I/O using the accept BIO itself||||If only a single connection will be processed
The following return values can occur||||null
The behaviour of SSL_shutdown_APIName additionally depends on the underlying BIO||||null
When "quiet shutdown" is enabled, SSL_shutdown_APIName will always succeed and return 1||||null
a second attempt is made using BIO_BIND_REUSEADDR||||If BIO_BIND_REUSEADDR_IF_UNUSED is set , and attempt is first made to use BIO_BIN_NORMAL , if this fails and the port is not in use
the application should take appropriate action to wait until the underlying socket has accepted a connection and retry the call||||null
As the shutdown is not specially handled in the SSLv2 protocol , SSL_shutdown_APIName will succeed on the first call||||null
The shutdown procedure consists of 2 steps||||null
The shutdown is not yet finished||||null
it is possible for BIO_should_io_special_APIName with the reason BIO_RR_ACCEPT||||If the underlying accept socket is non-blocking and BIO_do_accept_APIName is called to await an incoming connection
the sending of the `` close notify '' shutdown alert and the reception of the peer 's `` close notify '' shutdown alert||||null
The shutdown was successfully completed||||null
According to the TLS standard , it is acceptable for an application to only send its shutdown alert and close the underlying connection without waiting for the peer 's response||||null
BN_RECP_CTX_set_APIParam_3 is a previously allocated BN_RECP_CTX_set_APIParam_3 used for temporary variables||||null
The `` close notify '' alert was sent and the peer 's `` close notify '' alert was received||||null
BN_RECP_CTX_new_APIName allocates and initializes a BN_RECP_CTX_init_APIParam_1 structure||||null
the SSL_SENT_SHUTDOWN flag is set and a currently open session is considered closed and good and will be kept in the session cache for further reuse||||null
The output of SSL_get_error_APIName may be misleading , as an erroneous SSL_ERROR_SYSCALL may be flagged even though no error occurred||||null
any additional BIOs are placed between the socket and the accept BIO , that is the chain will be accept - > otherbios - > socket||||If any additional BIOs have been set using BIO_set_accept_bios_APIName
It computes BN_mod_mul_reciprocal_APIParam_1 = % BN_RECP_CTX_set_APIParam_2 using BN_RECP_CTX_set_APIParam_1 BN_RECP_CTX_init_APIParam_1 BN_RECP_CTX_free_APIParam_1 BN_div_recp_APIParam_4=1/BN_RECP_CTX_set_APIParam_2 , which is set as described below||||null
BN_RECP_CTX_init_APIName initializes an existing uninitialized BN_RECP_CTX_init_APIParam_1||||null
the complete shutdown procedure must be performed , so that the peers stay synchronized||||When the underlying connection shall be used for more communications
BN_div_recp_APIName divides BN_div_recp_APIParam_3 by BN_RECP_CTX_set_APIParam_2 using BN_div_recp_APIParam_4||||null
It places the quotient in BN_div_recp_APIParam_1 and the remainder in BN_div_recp_APIParam_2||||null
SSL_shutdown_APIName can be modified to only set the connection to `` shutdown '' state but not actually send the `` close notify '' alert messages , see SSL_CTX_set_quiet_shutdown_APIName||||null
Call SSL_shutdown_APIName for a second time||||if a bidirectional shutdown shall be performed
The result and the number of bits it was shifted left will later be stored in BN_RECP_CTX_set_APIParam_1||||null
BN_RECP_CTX_new_APIName returns the newly allocated BN_RECP_CTX_new_APIParam_0, and NULL on error||||null
It can not be shared between threads||||null
The BN_RECP_CTX_set_APIParam_1 BN_div_recp_APIParam_4 BN_RECP_CTX_init_APIParam_1 BN_RECP_CTX_free_APIParam_1 structure is defined as follows||||null
BN_RECP_CTX_init_APIName and BN_RECP_CTX_free_APIName have no return values||||null
For the other functions, 1 is returned for success, 0 on error||||null
SSL_shutdown_APIName supports both uni - and bidirectional shutdown by SSL_shutdown_APIName 2 step behaviour||||null
BN_mod_mul_reciprocal_APIName can be used to perform an efficient BN_mod_mul_APIName operation||||when the operation will be performed repeatedly with the same modulus
The error codes can be obtained by ERR_get_error_APIName||||null
An application may need to securely establish the context within which this keying material will be used||||null
BN_RECP_CTX_free_APIName frees the components of the BN_RECP_CTX_free_APIParam_1 , and||||if it was created by BN_RECP_CTX_new_APIName , also the structure itself
Attempting to use this function in SSLv3 will result in an error||||null
SSL_export_keying_material_APIName returns 0 or -1 on failure or 1 on success||||null
CMS_encrypt_APIName returns either a CMS_ContentInfo structure or NULL if an error occurred||||null
The context value is left to the application but must be the same on both sides of the communication||||null
Only certificates carrying RSA , Diffie-Hellman or EC keys are supported by this function||||null
The function SSL_export_keying_material_APIName enables an application to use some of this keying material for The function SSL_export_keying_material_APIName own purposes in accordance with RFC5705||||null
Note that this function is only defined for TLSv1 .0 and above , and DTLSv1 .0 and above||||null
EVP_des_ede3_cbc_APIName is the algorithm of choice for S/MIME use||||null
The error can be obtained from ERR_get_error_APIName||||null
SSL_free_APIName does not provide diagnostic information||||null
this may include identifiers for the application session , application algorithms or parameters , or the lifetime of the context||||null
Many browsers implement a `` sign and encrypt '' option which is simply an S/MIME envelopedData containing an S/MIME signed message||||null
connection shared keying material is established between the two endpoints||||During the creation of a TLS or DTLS
BIO_new_CMS_APIName returns a streaming filter BIO chain based on BIO_new_CMS_APIParam_2||||null
SSL_new_APIName , SSL_clear_APIName , SSL_shutdown_APIName , SSL_set_shutdown_APIName , ssl_APIName||||null
This can be readily produced by storing the S/MIME signed message in a memory BIO and passing it to CMS_encrypt_APIName||||null
The output of the filter is written to BIO_new_CMS_APIParam_1||||null
The chain returned by this function behaves like a standard filter BIO||||null
It supports non blocking I/O||||null
The ssl session has reference counts from two users||||null
the SSL object||||null
After all content has been written through the chain BIO_flush_APIName must be called to finalise the structure||||null
Any content written through the filter is used verbatim||||null
no canonical translation is performed||||null
Any data written to the chain is automatically translated to a BER format CMS structure of the appropriate type||||null
Content is processed and streamed on the fly and not all held in memory at once||||null
Prepending a BIO_f_buffer_APIName buffering BIO will prevent this||||null
so it is possible to encode very large structures||||null
The error can be obtained from ERR_get_error_APIName||||null
BIO_new_CMS_APIName returns a BIO chain when successful or NULL if an error occurred||||null
There is currently no corresponding inverse BIO||||null
It is possible to chain multiple BIOs to , , create a triple wrapped signed , enveloped , signed structure||||null
ASN1_STRING_length_APIName returns the length of the content of ASN1_STRING_length_APIParam_1||||null
it is the applications responsibility to set the inner content type of any outer CMS_ContentInfo structures||||null
ASN1_STRING_dup_APIName returns a copy of the structure ASN1_STRING_dup_APIParam_1||||null
ie one which can decode a CMS structure on the fly||||null
ASN1_STRING_cmp_APIName compares ASN1_STRING_cmp_APIParam_1 and ASN1_STRING_cmp_APIParam_2 returning 0 if the two are identical||||null
The string types and content are compared||||null
Large numbers of small writes through the chain should be avoided as this will produce an output consisting of lots of OCTET STRING structures||||null
These functions allow an ASN1_STRING_to_UTF8_APIParam_2 ASN1_STRING_set_APIParam_1 ASN1_STRING_dup_APIParam_1 ASN1_STRING_data_APIParam_1 ASN1_STRING_length_APIParam_1 ASN1_STRING_type_APIParam_1 ASN1_STRING_cmp_APIParam_1 structure to be manipulated||||null
The supplied data is copied||||null
the SSL structure pointed to by SSL_free_APIParam_1 and frees up the allocated memory||||if the reference count has reached 0
SSL_free_APIName decrements the reference count of SSL_free_APIParam_1 , and removes||||null
ASN1_STRING_set_APIName sets the data of string ASN1_STRING_set_APIParam_1 to the buffer ASN1_STRING_set_APIParam_2 or length ASN1_STRING_set_APIParam_3||||null
the session will also be removed from the session cache as required by RFC2246||||If the session is considered bad
BIOs should be removed from the chain using BIO_pop_APIName and freed with BIO_free_APIName until BIO_new_CMS_APIParam_1 is reached||||If an application wishes to write additional data to BIO_new_CMS_APIParam_1
The host can be can be '' * '' which is interpreted as meaning any interface||||null
`` port '' has the same syntax as the port specified in BIO_set_conn_port_APIName for connect BIOs , that is it can be a numerical port string or a string to lookup using getservbyname_APIName and a string table||||null
The length of ASN1_STRING_to_UTF8_APIParam_1 is returned by ASN1_STRING_to_UTF8_APIName or a negative error code||||null
The buffer ASN1_STRING_to_UTF8_APIParam_1 should be free using OPENSSL_free_APIName||||null
In general it cannot be assumed that the data returned by ASN1_STRING_data_APIName is null terminated or does not contain embedded nulls||||null
BIO_read_APIName attempts to read BIO_read_APIParam_3 bytes from BIO BIO_read_APIParam_1 and places the data in BIO_read_APIParam_2||||null
BIO_gets_APIName performs the BIOs `` gets '' operation and places the data in BIO_gets_APIParam_2 BIO_gets_APIParam_2 BIO_gets_APIParam_2||||null
BIO_write_APIName attempts to write BIO_write_APIParam_3 bytes from BIO_write_APIParam_2 to BIO BIO_write_APIParam_1||||null
ASN1_STRING_to_UTF8_APIName converts the string ASN1_STRING_to_UTF8_APIParam_2 to UTF8 format , the converted data is allocated in a buffer in ASN1_STRING_to_UTF8_APIParam_1||||null
A 0 or -1 return is not necessarily an indication of an error||||null
BIO_puts_APIName attempts to write a null terminated string BIO_puts_APIParam_2 to BIO BIO_puts_APIParam_1||||null
If the return value is -2 the operation is not implemented in the specific BIO type||||null
Usually this operation will attempt to read a line of data from the BIO of maximum length BIO_write_APIParam_3 BIO_read_APIParam_3||||null
See BIO_should_retry_APIName for details of how to determine the cause of a retry and other I/O issues||||null
the data is in the correct format||||when calling ASN1_STRING_set_APIName
Similar care should be take to ensure||||null
DES_random_key_APIName generates a random key||||null
These functions are currently the only way to store encrypted private keys using DER format||||null
The PRNG must be seeded prior to using this function||||null
This library contains a fast implementation of the DES encryption algorithm||||null
All these functions return either the amount of data successfully read or written  or that no data was successfully read or written if the result is 0 or -1||||null
There are exceptions to this however||||null
If the PRNG could not generate a secure key, 0 is returned||||null
If the parity is wrong, -1 is returned||||null
If the key is a weak key, -2 is returned||||null
If an error is returned, the key schedule is not generated||||null
Before using these functions OpenSSL_add_all_algorithms_APIName should be called to initialize the internal algorithm lookup tables||||null
DES_set_odd_parity_APIName sets the parity of the passed DES_set_odd_parity_APIParam_1 to odd||||null
DES_is_weak_key_APIName returns 1 if the passed key is a weak key, 0 if it is ok||||null
The PKCS # 8 functions encode and decode private keys in PKCS # 8 format using both PKCS # 5 v1 .5 and PKCS # 5 v2 .0 password based encryption algorithms||||null
Kerberos v4 parameters are the same as DES_ncbc_encrypt_APIName||||null
DES_set_key_checked_APIName will check that the key passed is of odd parity and is not a weak or semi-weak key||||null
DES_cfb64_encrypt_APIName implements CFB mode of DES with 64bit feedback||||null
DES_pcbc_encrypt_APIName encrypt/decrypts using the propagating cipher block chaining mode used by Kerberos v4||||null
Why is this useful you ask ?||||null
Currently all the functions use BIOs or FILE pointers , there are no functions which work directly on memory||||null
Because this routine will allow you to encrypt an arbitrary number of bytes , no 8 byte padding||||null
DES_ede3_cfb64_encrypt_APIName and DES_ede2_cfb64_encrypt_APIName is the same as DES_cfb64_encrypt_APIName except that Triple-DES is used||||null
Each call to this routine will encrypt the input bytes to output and update ivec and num||||null
DES_ofb64_encrypt_APIName is the same as DES_cfb64_encrypt_APIName using Output Feed Back mode||||null
this can be readily worked around by converting the buffers to memory BIOs , see BIO_s_mem_APIName for details||||null
DES_ede3_ofb64_encrypt_APIName and DES_ede2_ofb64_encrypt_APIName is the same as DES_ofb64_encrypt_APIName , using Triple-DES||||null
DES_cbc_cksum_APIName produces an 8 byte checksum based on the input stream||||null
This function is used by Kerberos v4||||null
The following routines mostly operate on an input and output stream of DES_string_to_key_APIParam_2 DES_set_odd_parity_APIParam_1 DES_set_key_APIParam_1 DES_set_key_unchecked_APIParam_1 DES_key_sched_APIParam_1 DES_quad_cksum_APIParam_2 DES_string_to_2keys_APIParam_2 DES_cbc_cksum_APIParam_2 DES_ecb2_encrypt_APIParam_1 DES_ecb3_encrypt_APIParam_1 DES_set_odd_parity_APIParam_10 DES_set_odd_parity_APIParam_11 DES_set_odd_parity_APIParam_12 DES_set_odd_parity_APIParam_13s||||null
Other applications should use EVP_DigestInit_APIName etc instead||||null
The following are DES-based transformations||||null
The actual format of the data will depend on the actual string type itself||||null
num contains ` how far ' we are though ivec||||null
The last 4 bytes of the checksum are returned and the complete 8 bytes are placed in DES_cbc_cksum_APIParam_2||||null
The following functions are included in the DES library for compatibility with the MIT Kerberos library||||null
and that the application should retry the operation later||||when the source/sink is non-blocking or of a certain type the source/sink may merely be an indication that no data is currently available
DES_fcrypt_APIName is a fast version of the Unix crypt_APIName function||||null
It needs to be at least 14 bytes long||||null
This version takes only a small amount of space relative to other fast crypt_APIName implementations||||null
This function is thread safe , unlike the normal crypt||||null
ECB mode is not suitable for most applications||||null
read more about cfb mode of DES||||If this does not make much sense
see des_modes_APIName||||null
The evp_APIName library provides higher-level encryption functions||||null
Single-key DES is insecure due to Single-key DES short key size||||null
This is different to the normal crypt in that the third parameter is the buffer that the return value is written into||||null
DES_3cbc_encrypt_APIName is flawed and must not be used in applications||||null
DES_string_to_key_APIName is available for backward compatibility with the MIT library||||null
The same applies for DES_string_to_2key_APIName||||null
New applications should use a cryptographic hash function||||null
These functions decode and encode a PKCS # 10 certificate request||||null
for an IA5String the data will be ASCII , for a BMPString two bytes per character in big endian format , and for an UTF8String it will be in UTF8 format||||null
EC_GROUP_copy copies the curve EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 into EC_GROUP_copy_APIParam_1||||null
Both EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 and EC_GROUP_copy_APIParam_1 must use the same EC_METHOD||||null
Othewise these behave in a similar way to d2i_X509_APIName and i2d_X509_APIName described in the d2i_X509_APIName manual page||||null
EC_GROUP_set_generator sets curve paramaters that must be agreed by all participants using the curve||||null
These paramaters include the EC_GROUP_set_generator_APIParam_2 , the EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 and the EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4||||null
EC_GROUP_dup creates a new EC_GROUP object and copies the content from EC_GROUP_copy_APIParam_2 EC_GROUP_dup_APIParam_1 to the newly created EC_GROUP object||||null
The EC_GROUP_set_generator_APIParam_2 is a well defined point on the curve chosen for cryptographic operations||||null
EC_GROUP_method_of obtains the EC_METHOD of EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_curve_name_APIParam_1 EC_GROUP_get0_generator_APIParam_1 EC_GROUP_get_curve_name_APIParam_1 EC_GROUP_set_point_conversion_form_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_10 EC_GROUP_get_asn1_flag_APIParam_11 EC_GROUP_get_asn1_flag_APIParam_12||||null
If a curve does not have a NID associated with it, EC_GROUP_get_curve_name will return 0||||null
Integers used for point multiplications will be between 0 and n-1 where n is the EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3||||null
The EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 multipied by the EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4 gives the number of points on the curve||||null
The functions EC_GROUP_set_curve_name and EC_GROUP_get_curve_name , set and get the NID for the curve respectively||||null
point_conversion_form_t is an enum defined as follows||||null
EC_GROUP_get0_generator returns the generator for the identified EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_curve_name_APIParam_1 EC_GROUP_get0_generator_APIParam_1 EC_GROUP_get_curve_name_APIParam_1 EC_GROUP_set_point_conversion_form_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_10 EC_GROUP_get_asn1_flag_APIParam_11 EC_GROUP_get_asn1_flag_APIParam_12||||null
The functions EC_GROUP_get_asn1_flag and EC_GROUP_set_asn1_flag get and set the status of the asn1_flag for the curve||||null
The asn1_flag value on a curve is used to determine||||null
The functions EC_GROUP_set_point_conversion_form and EC_GROUP_get_point_conversion_form set and get the point_conversion_form for the curve respectively||||null
asn1_flag is 0||||If not
The point_coversion_form for a curve controls how EC_POINT data is encoded as ASN1 as defined in X9 .62||||null
ANSI X9 .62 defines a method of generating the curve parameter b from a random number||||null
this is a named curve with an associated ASN1 OID||||If the asn1_flag is 1
For any given x co-ordinate for a point on a curve it is possible to derive two possible y values||||null
The OpenSSL EC library does not use this seed value but does enable you to inspect it using EC_GROUP_get0_seed||||null
the curve_name must also be set||||If set
For POINT_CONVERSION_UNCOMPRESSED the point is encoded as an octet signifying the UNCOMPRESSED form has been used followed by the octets for x , followed by the octets for y||||null
The functions EC_GROUP_get_order and EC_GROUP_get_cofactor populate the provided EC_GROUP_get_order_APIParam_2 EC_GROUP_set_generator_APIParam_3 and EC_GROUP_get_cofactor_APIParam_2 EC_GROUP_set_generator_APIParam_4 parameters with the respective order and cofactors for the EC_GROUP_get_cofactor_APIParam_1 EC_GROUP_get_asn1_flag_APIParam_1 EC_GROUP_get_order_APIParam_1 EC_GROUP_check_APIParam_1 EC_GROUP_method_of_APIParam_1 EC_GROUP_check_discriminant_APIParam_1 EC_GROUP_set_generator_APIParam_30 EC_GROUP_set_generator_APIParam_31 EC_GROUP_set_generator_APIParam_32 EC_GROUP_set_generator_APIParam_33 EC_GROUP_set_generator_APIParam_34 EC_GROUP_set_generator_APIParam_35 EC_GROUP_set_generator_APIParam_36||||null
This returns a pointer to a memory block containing the seed that was used||||null
EC_GROUP_get_degree gets the degree of the field||||null
Again , the EC library will not use this seed value||||null
The length of the memory block can be obtained using EC_GROUP_get_seed_len||||null
A number of the builtin curves within the library provide seed values that can be obtained||||null
In either case for the curve to be valid the discriminant must be non zero||||null
The function EC_GROUP_check_discriminant calculates the discriminant for the curve and verifies that it is valid||||null
For Fp fields this will be the number of bits in p. For F2 ^ m fields this will be the value m||||null
This provides advantages in that a parameter obtained in this way is highly unlikely to be susceptible to special purpose attacks , or have any trapdoors in it||||null
For POINT_CONVERSION_COMPRESSED the point is encoded as an octet signifying that the COMPRESSED form has been used AND which of the two possible solutions for y has been used , followed by the octets for x||||null
the b parameter was generated in a verifiable fashion using that seed||||If the seed is present for a curve
For POINT_CONVERSION_HYBRID the point is encoded as an octet signifying the HYBRID form has been used AND which of the two possible solutions for y has been used , followed by the octets for x , followed by the octets for y||||null
EC_GROUP_cmp compares EC_GROUP_cmp_APIParam_1 and EC_GROUP_cmp_APIParam_2 to determine||||null
This function is either a trinomial of the form||||null
a pentanomial of the form||||null
Addition and multiplication operations within an F2 ^ m field are performed using an irreducible polynomial function f||||null
It is also possible to set a custom seed using EC_GROUP_set_seed and passing a pointer to a memory block , along with the length of the seed||||null
EC_GROUP_dup returns a pointer to the duplicated curve, or NULL on error||||null
EC_GROUP_get0_generator returns the generator for the given curve or NULL on error||||null
Checks performed include verifying that the discriminant is non zero||||null
EC_GROUP_method_of returns the EC_METHOD implementation in use for the given curve or NULL on error||||null
that a generator has been defined||||null
The functions EC_GROUP_get_basis_type , EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis should only be called for curves defined over an F2 ^ m field||||null
The function EC_GROUP_check performs a number of checks on a curve to verify that it is valid||||null
If there is no curve name associated with a curve ,then EC_GROUP_get_curve_name will return 0||||null
The following functions return 1 on success or 0 on error||||null
that the generator is on the curve and has the correct order||||null
EC_GROUP_set_seed returns the length of the seed that has been set||||null
On error 0 is returned||||null
EC_GROUP_copy , EC_GROUP_set_generator , EC_GROUP_check , EC_GROUP_check_discriminant , EC_GROUP_get_trinomial_basis and EC_GROUP_get_pentanomial_basis||||null
EC_GROUP_get_seed_len returns the length of the seed or 0 if the seed is not specified||||null
EC_GROUP_get_basis_type returns the values NID_X9_62_tpBasis or NID_X9_62_ppBasis  for a trinomial or pentanomial respectively||||null
If the supplied seed is NULL, or the supplied seed length is 0, the return value will be 1||||null
Alternatively in the event of an error a 0 is returned||||null
EC_GROUP_get_order, EC_GROUP_get_cofactor, EC_GROUP_get_curve_name, EC_GROUP_get_asn1_flag, EC_GROUP_get_point_conversion_form and EC_GROUP_get_degree return the order, cofactor, curve name , ASN1 flag, point_conversion_form and degree for the specified curve respectively||||null
A function must call BN_CTX_start_APIName first||||null
EC_GROUP_cmp returns 0 if the curves are equal, 1 if they are not equal, or -1 on error||||null
EC_GROUP_get0_seed returns a pointer to the seed that was used to generate the parameter b, or NULL if the seed is not specified||||null
Finally, BN_CTX_end_APIName must be called before returning from the function||||null
BN_CTX_get_APIName may be called repeatedly to obtain temporary BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0s||||null
BN_CTX_start_APIName and BN_CTX_end_APIName return no values||||null
For a curve defined over Fp the discriminant is given by the formula 4 * a ^ 3 + 27 * b ^ 2 whilst for F2 ^ m curves the discriminant is simply b||||null
BN_CTX_get_APIName returns a pointer to the BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0 BN_CTX_get_APIParam_0, or NULL on error||||null
RAND_get_default_method_APIName returns a pointer to the current RAND_METHOD||||null
RAND_set_rand_method_APIName returns no value||||null
Initially, the default RAND_METHOD is the OpenSSL internal implementation, as returned by RAND_SSLeay_APIName||||null
RAND_get_rand_method_APIName and RAND_SSLeay_APIName return pointers to the respective methods||||null
All BN_CTX_get_APIName calls must be made before calling any other functions that use the BN_CTX_start_APIParam_1 BN_CTX_get_APIParam_1 BN_CTX_get_APIParam_1 as an argument||||null
The error can be obtained from ERR_get_error_APIName||||null
CMS_get0_signers_APIName returns all signers or NULL if an error occurred||||null
This can be achieved by setting and verifying the signers certificates manually using the signed data utility functions||||null
CMS_verify_APIName returns 1 for a successful verification and zero if an error occurred||||null
the BN_CTX_get_APIParam_0 pointers obtained from BN_CTX_get_APIName become invalid||||When BN_CTX_end_APIName is called
However , the meaningfulness of this result is dependent on||||null
Once BN_CTX_get_APIName has failed, the subsequent calls will return NULL as well, so it is sufficient to check the return value of the last BN_CTX_get_APIName call||||null
In case of an error , an error code is set , which can be obtained by ERR_get_error_APIName||||null
However since the signing time is supplied by the signer it can not be trusted without additional evidence||||null
BIO_f_md_APIName returns the message digest BIO method||||null
Chain verification should arguably be performed using the signing time rather than the current time||||null
BIO_reset_APIName reinitialises a digest BIO||||null
These functions are used to obtain temporary BN_CTX_get_APIParam_0 variables from a BN_CTX_end_APIParam_1 BN_CTX_get_APIParam_1 BN_CTX_start_APIParam_1||||null
BIO_get_md_ctx_APIName returns the digest BIOs context into BIO_get_md_ctx_APIParam_2||||null
It is a BIO_ctrl_APIName macro||||null
Any data written or read through a digest BIO using BIO_read_APIName and BIO_write_APIName is digested||||null
The context returned by BIO_get_md_ctx_APIName is an internal context structure||||null
The context returned by BIO_get_md_ctx_APIName can be used in calls to EVP_DigestFinal_APIName and also the signature routines EVP_SignFinal_APIName and EVP_VerifyFinal_APIName||||null
BIO_set_md_APIName sets the message digest of BIO BIO_set_md_APIParam_1 to BIO_set_md_APIParam_2||||null
BIO_f_md_APIName returns the digest BIO method||||null
BIO_get_md_APIName places the a pointer to the digest BIOs digest method in BIO_get_md_APIParam_2 , it is a BIO_ctrl_APIName macro||||null
In some cases the standard techniques for looking up and validating certificates are not appropriate||||null
In OpenSSL 1.0.0 and later the context is always returned and the BIO is state is set to initialized||||null
BIO_set_md_APIName, BIO_get_md_APIName and BIO_md_ctx_APIName return 1 for success and 0 for failure||||null
this must be called to initialize a digest BIO before any data is passed through it||||null
This is a filter BIO that digests any data passed through it , it is a BIO wrapper for the digest routines EVP_DigestInit_APIName , EVP_DigestUpdate_APIName and EVP_DigestFinal_APIName||||null
an application may wish to lookup certificates in a database or perform customised verification||||null
This library implements type-checked dynamic hash tables||||null
The hash table entries can be arbitrary structures||||null
f = x ^ m + x ^ k + 1 with m > k > = 1||||null
After the digest has been retrieved from a digest BIO it must be reinitialized by calling BIO_reset_APIName , or BIO_set_md_APIName before any more data is passed through it||||null
Usually The hash table entries consist of key and value fields||||null
lh_<type>_insert_APIName inserts the structure pointed to by lh_retrieve_APIParam_2 into lh_retrieve_APIParam_1||||null
lh_<type>_delete_APIName deletes an entry from lh_retrieve_APIParam_1||||null
the signed content must all be held in memory||||if it is not detached
The lack of single pass processing means that||||null
lh_<type>_retrieve_APIName looks up an entry in lh_retrieve_APIParam_1||||null
The lack of support for BIO_puts_APIName and the non standard behaviour of BIO_gets_APIName could be regarded as anomalous||||null
Note that lh_<type>_insert_APIName stores pointers , the data are not copied||||null
lh_<type>_error_APIName is a macro||||null
the context pointer will become invalid||||when the digest BIO is freed
Changes made to this context will affect the digest BIO itself and||||null
NULL is returned on normal operation and on error||||null
When a hash table entry is replaced, lh_<type>_insert_APIName returns the value being replaced||||null
lh_<type>_error_APIName can be used to determine if an error occurred in the last operation||||null
lh_<type>_delete_APIName returns the entry being deleted||||null
lh_<type>_new_APIName returns NULL on error, otherwise a pointer to the new lh_retrieve_APIParam_1 structure||||null
The second best solution to this problem is to set hash - > down_load = 0 before you start||||null
Before OpenSSL 1.0.0 the call to BIO_get_md_ctx_APIName would only work||||if the BIO had been initialized by calling BIO_set_md_APIName
-RRB-||||null
The best solution is probably to avoid deleting items from the hash table inside a `` doall '' callback !||||null
NULL is returned if there is no such value in the hash table||||null
lh_<type>_free_APIName, lh_<type>_doall_APIName and lh_<type>_doall_arg_APIName return no values||||null
Normally , lh_retrieve_APIParam_2 is a structure with the key field set||||null
the function will return a pointer to a fully populated structure||||null
applications to initialize the context externally||||if the standard calls such as BIO_set_md_APIName are not sufficiently flexible
This allows||||null
lh_<type>_retrieve_APIName returns the hash table entry if lh_<type>_retrieve_APIName has been found, NULL otherwise||||null
lh_<type>_error_APIName returns 1 if an error occurred in the last operation, 0 otherwise||||null
It also , apparently , violates ANSI-C||||null
The LHASH code regards table entries as constant data||||null
It could be argued that BIO_gets_APIName and BIO_puts_APIName should be passed to the next BIO in the chain and digest the data passed through and that digests should be retrieved using a separate BIO_ctrl_APIName call||||null
the old value is replaced||||If there already is an entry with the same key
this can be done by prepending a buffering BIO||||If an application needs to call BIO_gets_APIName or BIO_puts_APIName through a chain containing digest BIOs
lh_<type>_insert_APIName returns NULL both for success and error||||null
Already created SSL objects are not affected||||null
As such , it internally represents lh_insert_APIName 'd items with a `` const void * '' pointer type||||null
SSL_CTX_set_tmp_rsa_APIName sets the temporary/ephemeral RSA key to be used to be SSL_CTX_set_tmp_rsa_APIParam_2||||null
However , as callers are themselves providing these pointers , they can choose||||null
SSL_set_tmp_rsa_callback_APIName sets the callback only for SSL_set_tmp_rsa_APIParam_1 SSL_need_tmp_rsa_APIParam_1||||null
SSL_set_tmp_rsa_APIName sets the key only for SSL_set_tmp_rsa_APIParam_1||||null
The various LHASH macros and callback types exist to make it possible to write type-checked code without resorting to function-prototype casting - an evil that makes application code much harder to audit/verify and also opens the window of opportunity for stack corruption and other hard-to-find bugs||||null
some entries to be skipped||||during the iteration
the table may decrease in size , moving the item that you are currently on down lower in the hash table - this could cause||||null
f = x ^ m + x ^ k3 + x ^ k2 + x ^ k1 + 1 with m > k3 > k2 > k1 > = 1||||null
These functions apply to SSL/TLS servers only||||null
The key is inherited by all SSL objects newly created from SSL_CTX_set_tmp_rsa_APIParam_1 with <SSL_new_APIName|SSL_new_APIName | <SSL_new_APIName|SSL_new_APIName >||||null
SSL_CTX_need_tmp_rsa_APIName returns 1, if a temporary/ephemeral RSA key is needed for RSA-based strength-limited 'exportable' ciphersuites because a RSA key with a keysize larger than 512 bits is installed||||null
SSL_need_tmp_rsa_APIName returns 1 , if a temporary/ephemeral RSA key is needed , for RSA-based strength-limited ` exportable ' ciphersuites||||null
The downside is that creating a RSA key is computationally expensive||||null
SSL_CTX_set_tmp_rsa_callback_APIName and SSL_set_tmp_rsa_callback_APIName do not return diagnostic output||||null
Under previous export restrictions , ciphers with RSA keys shorter than the usual key length of 1024 bits were created||||null
An application may either directly specify the key or can supply the key via a callback function||||null
Using ephemeral RSA key exchange for other purposes violates the standard and can break interoperability with clients||||null
SSL_CTX_set_tmp_rsa_APIName and SSL_set_tmp_rsa_APIName do return 1 on success and 0 on failure||||null
the session data are negotiated using the ephemeral/temporary RSA key and the RSA key supplied and certified by the certificate chain is only used for signing||||null
Callers that only have `` const '' access to data they 're indexing in a table , yet declare callbacks without constant types , are creating their own risks/bugs without being encouraged to do so by the API||||null
It is strongly recommended to not use ephemeral RSA key exchange and use DHE key exchange instead||||null
Check the error queue to find out the reason of failure||||null
SSL_CTX_need_tmp_rsa_APIName and SSL_need_tmp_rsa_APIName return 1 if a temporary RSA key is needed and 0 otherwise||||null
The error can be obtained from ERR_get_error_APIName||||null
CMS_verify_receipt_APIName returns 1 for a successful verification and zero if an error occurred||||null
As the generation of a RSA key is however costly , it will lead to a significant delay in the handshake procedure||||null
The callback approach has the advantage , that the callback may generate the key only in case it is actually needed||||null
To use these ciphers with RSA keys of usual length , an ephemeral key exchange must be performed , as the normal key can not be directly used||||null
The output lines are indented by RSA_print_fp_APIParam_3 DSA_print_APIParam_3 RSA_print_APIParam_3 DSA_print_fp_APIParam_3 spaces||||null
These functions return 1 on success, 0 on error||||null
The file can contain several CA certificates identified by||||null
The SSL_CTX_load_verify_locations_APIParam_2 is processed on execution of the SSL_CTX_load_verify_locations_APIName function||||null
Using ephemeral RSA key exchange yields forward secrecy , as the connection can only be decrypted||||when the RSA key is known
As an example , a hash table may be maintained by code that , for reasons of encapsulation , has only `` const '' access to the data being indexed in the hash table - the LHASH prototypes are appropriate as-is||||null
Before , between , and after the certificates text is allowed which can be used eg for descriptions of the certificates||||null
Make sure to not have expired certificates mixed with valid ones||||null
The following return values can occur||||null
The operation succeeded||||null
Conversely , , they may well wish to make modifications to table item passed back in the lh_doall_APIName or lh_doall_arg_APIName callbacks||||if the caller is responsible for the life-time of the data in question
The EVP signature routines are a high level interface to digital signatures||||null
EVP_SignInit_ex_APIName sets up signing context EVP_SignInit_ex_APIParam_1 to use digest EVP_SignInit_ex_APIParam_2 from ENGINE EVP_SignInit_ex_APIParam_3||||null
EVP_SignInit_ex_APIParam_1 must be initialized with EVP_MD_CTX_init_APIName before calling this function||||null
it points to a file of CA certificates in PEM format||||If SSL_CTX_load_verify_locations_APIParam_2 is not NULL
EVP_SignFinal_APIParam_2 must be at least EVP_PKEY_size bytes in size||||null
EVP_SignUpdate_APIName hashes EVP_SignUpdate_APIParam_3 bytes of data at EVP_SignUpdate_APIParam_2 into the signature context EVP_SignUpdate_APIParam_1||||null
no other certificate will be searched||||If a `` certificate expired '' verification error occurs
This function can be called several times on the same EVP_SignUpdate_APIParam_1 to include additional data||||null
EVP_PKEY_size_APIName returns the maximum size of a signature in bytes||||null
EVP_SignFinal_APIParam_3 is an OUT paramter , and not used as an IN parameter||||null
This may lead to unexpected results||||if the same CA certificate is available with different expiration dates
EVP_SignFinal_APIName signs the data in EVP_SignFinal_APIParam_1 using the private key EVP_SignFinal_APIParam_4 and places the signature in EVP_SignFinal_APIParam_2||||null
The actual signature returned by EVP_SignFinal_APIName may be smaller||||null
EVP_SignInit_APIName initializes a signing context EVP_SignInit_APIParam_1 to use the default implementation of digest EVP_SignInit_APIParam_2||||null
Additionally , the use of ephemeral RSA key exchange is only allowed in the TLS standard , , that is for export ciphers||||when the RSA key can be used for signing only
EVP_SignInit_ex_APIName, EVP_SignUpdate_APIName and EVP_SignFinal_APIName return 1 for success and 0 for failure||||null
EVP_PKEY_size_APIName returns the maximum size of a signature in bytes||||null
A human-readable hexadecimal output of the components of the RSA key , DSA parameters or key or DH parameters is printed to DHparams_print_APIParam_1 DSA_print_APIParam_1 RSA_print_APIParam_1 DSAparams_print_APIParam_1 or RSA_print_fp_APIParam_1 DSAparams_print_fp_APIParam_1 DHparams_print_fp_APIParam_1 DSA_print_fp_APIParam_1||||null
The error codes can be obtained by ERR_get_error_APIName||||null
only the first one will be examined||||If several CA certificates matching the name , key identifier , and serial number condition are available
The number of bytes of data written will be written to the integer at EVP_SignFinal_APIParam_3 , at most EVP_PKEY_size bytes will be written||||null
A list of algorithms and associated public key algorithms appears in EVP_DigestInit_APIName||||null
This is because the code becomes transparent to the algorithm used and much more flexible||||null
The EVP_SignInit_ex_APIParam_1 EVP_SignFinal_APIParam_1 EVP_PKEY_size_APIParam_1 EVP_SignInit_APIParam_1 EVP_SignUpdate_APIParam_1 interface to digital signatures should almost always be used in preference to the low level interfaces||||null
The random number generator does not need to be seeded for RSA signatures||||null
The call to EVP_SignFinal_APIName internally finalizes a copy of the digest context||||null
Due to the link between message digests and public key algorithms the correct digest algorithm must be used with the correct public key type||||null
It is not possible to change the signing parameters using these function||||null
This means that calls to EVP_SignUpdate_APIName and EVP_SignFinal_APIName can be called later to digest and sign additional data||||null
The previous two bugs are fixed in the newer EVP_SignDigest * _ APIName function||||null
MD2_Init_APIName initializes a MD2_Init_APIParam_1 structure||||null
This is why callbacks such as those used by lh_doall_APIName and lh_doall_arg_APIName declare their prototypes with `` const '' , even for the parameters that pass back the table items ' data pointers - for consistency , user-provided data is `` const '' at all times as far as the LHASH code is concerned||||null
Older versions of this documentation wrongly stated that calls to EVP_SignUpdate_APIName could not be made after calling EVP_SignFinal_APIName||||null
MD2 , MD4 , and MD5 are cryptographic hash functions with a 128 bit output||||null
the context must be cleaned up after use by calling EVP_MD_CTX_cleanup_APIName or a memory leak will occur||||null
Applications should use the higher level functions EVP_DigestInit_APIName etc instead of calling the hash functions directly||||null
MD2_APIName, MD4_APIName, and MD5_APIName return pointers to the hash value||||null
MD2 , MD4 , and MD5 are recommended only for compatibility with existing applications||||null
SSL_CTX_get_client_cert_cb_APIName returns a pointer to the currently set callback function||||null
In new applications , SHA-1 or RIPEMD-160 should be preferred||||null
MD2_Init_APIName, MD2_Update_APIName, MD2_Final_APIName, MD4_Init_APIName, MD4_Update_APIName, MD4_Final_APIName, MD5_Init_APIName, MD5_Update_APIName, and MD5_Final_APIName return 1 for success, 0 otherwise||||null
any error relating to the private key will not be indicated until after potentially large amounts of data have been passed through EVP_SignUpdate_APIName||||null
the digest is placed in a static array||||If MD2_Final_APIParam_1 MD4_Final_APIParam_1 MD5_Final_APIParam_1 is NULL
MD4_Init_APIName , MD4_Update_APIName , MD4_Final_APIName , MD5_Init_APIName , MD5_Update_APIName , and MD5_Final_APIName are analogous using an MD4_Init_APIParam_1 MD4_Update_APIParam_1 MD4_Final_APIParam_2 and MD5_Init_APIParam_1 MD4_Update_APIName0 MD4_Update_APIName1 structure||||null
The following functions may be used||||if the message is not completely stored in memory
This constraint is violated by the default behavior of the OpenSSL library||||null
MD2_Final_APIName places the message digest in MD2_Final_APIParam_1 , which must have space for MD2_DIGEST_LENGTH == 16 bytes of output , and erases the MD2_Final_APIParam_2||||null
Thus it will permanently install the certificate and key for this SSL object||||null
It will not be reset by calling SSL_clear_APIName||||null
is lost||||when the application is left
By generating a temporary RSA key inside the server application that , it becomes impossible for an attacker to decrypt past sessions||||null
If the callback function returns a certificate, the OpenSSL library will try to load the private key and certificate data into the SSL object using the SSL_use_certificate_APIName and SSL_use_private_key_APIName functions||||null
If the callback returns no certificate, the OpenSSL library will not send a certificate||||null
a server may request a certificate from the client||||During a handshake
The client_cert_cb_APIName cannot return a complete certificate chain, it can only return one client certificate||||null
For a longer chain , the client must send the complete chain||||null
It is mandatory to destroy the SSL object using SSL_free_APIName and create a new one to return to the previous state||||null
Using the callback function it is possible to implement a proper selection routine or to allow a user interaction to choose the certificate to be sent||||null
The session id context becomes part of the session||||null
The session id context is set by the SSL/TLS server||||null
A client certificate must only be sent||||when the server did send the request
OpenSSL clients will check the session id context returned by the server when reusing a session||||null
MD2_APIName , MD4_APIName , and MD5_APIName compute the MD2 , MD4 , and MD5 message digest of the MD2_APIParam_2 MD4_APIParam_2 MD5_APIParam_2 bytes at MD2_APIParam_1 MD4_APIParam_1 MD5_APIParam_1 and place it in MD2_Final_APIParam_1 MD4_APIName0 MD4_APIName1||||null
The SSL_CTX_set_session_id_context_APIName and SSL_set_session_id_context_APIName functions are only useful on the server side||||null
it will be sent to the server||||When a certificate was set using the SSL_CTX_use_certificate_APIName family of functions
the callback function will be called||||If a callback function is defined and no certificate was yet defined for the SSL object
only a certificate is sent||||if it matches the list of acceptable CAs sent by the server
The TLS standard requires that||||null
it can supply keys of different size and does give away key length if a longer key would be allowed||||while the explicit setting of the key is only useful for key size of 512 bits to satisfy the export restricted ciphers
Another advantage of the callback function is that||||null
On a related note , those auditing code should pay special attention to any instances of DECLARE/IMPLEMENT _ LHASH_DOALL _ -LSB- ARG _ -RSB- _ FN macros that provide types without any `` const '' qualifiers||||null
SSL_CTX_set_session_id_context_APIName and SSL_set_session_id_context_APIName return the following values||||null
The operation succeeded||||null
This function returns the RSA modulus size in bytes||||null
The size in bytes||||null
OpenSSL servers will always return the correct session id context, as an OpenSSL server checks the session id context itself before reusing a session as described above||||null
This function can be used to determine how much memory must be allocated for an RSA encrypted value||||null
If a server returns a different session id context to an OpenSSL client when reusing a session, an error will be flagged and the handshake will fail||||null
i2d_X509_APIName encodes the structure pointed to by i2d_X509_APIParam_1 into DER format||||null
If the return value is negative an error occurred, otherwise it returns the length of the encoded data||||null
Note , this is a non-standard OpenSSL-specific data format||||null
This is used by the PEM routines to write `` TRUSTED CERTIFICATE '' objects||||null
i2d_X509_APIParam_2 i2d_X509_AUX_APIParam_2 i2d_re_X509_tbs_APIParam_2 is not incremented and it points to the start of the data just written||||null
d2i_X509_AUX_APIParam_2 d2i_X509_APIParam_2 is incremented to the byte following the parsed data||||If the call is successful
i2d_X509_AUX_APIName is similar to i2d_X509_APIName , but the encoded output contains both the certificate and any auxiliary trust information||||null
The X509 encode and decode routines encode and parse an i2d_X509_APIParam_1 i2d_X509_AUX_APIParam_1 d2i_X509_fp_APIParam_2 d2i_X509_bio_APIParam_2 d2i_X509_AUX_APIParam_1 i2d_re_X509_tbs_APIParam_1 d2i_X509_APIParam_1 i2d_X509_bio_APIParam_2 i2d_X509_fp_APIParam_2 structure , which represents an X509 certificate||||null
d2i_X509_bio_APIName is similar to d2i_X509_APIName except d2i_X509_bio_APIName attempts to parse data from BIO d2i_X509_bio_APIParam_1||||null
d2i_X509_fp_APIName is similar to d2i_X509_APIName except d2i_X509_fp_APIName attempts to parse data from FILE pointer d2i_X509_fp_APIParam_1||||null
i2d_re_X509_tbs_APIName is similar to i2d_X509_APIName except it encodes only the TBSCertificate portion of the certificate||||null
The use of temporary variable is mandatory||||null
A common mistake is to attempt to use a buffer directly as follows||||null
The auto allocation feature only works on OpenSSL 0.9.7 and later||||null
i2d_X509_bio_APIName is similar to i2d_X509_APIName except i2d_X509_bio_APIName writes the encoding of the structure i2d_X509_bio_APIParam_2 i2d_X509_APIParam_1 to BIO i2d_X509_bio_APIParam_1 and i2d_X509_bio_APIName returns 1 for success and 0 for failure||||null
Attempts to use it on earlier versions will typically cause a segmentation violation||||null
the root CA certificate may be omitted according to the TLS standard and thus a standard conforming answer can be sent to the server||||If the chain only has a length of 2
i2d_X509_fp_APIName is similar to i2d_X509_APIName except it writes the encoding of the structure i2d_X509_fp_APIParam_2 i2d_X509_APIParam_1 to BIO d2i_X509_bio_APIParam_1 i2d_X509_bio_APIParam_1 and it returns 1 for success and 0 for failure||||null
Once the SSL object has been used in conjunction with the callback function , the certificate will be set for the SSL object and will not be cleared even||||when SSL_clear_APIName is being called
the DER encoded data to the buffer at i2d_X509_APIParam_2||||If i2d_X509_APIParam_2 is not NULL is writes
and increments it to point after the data just written||||null
will not be reused||||If the session id context is not set on an SSL/TLS server and client certificates are used , stored sessions
but a fatal error will be flagged and the handshake will fail||||null
The reason for the auto increment behaviour is to reflect a typical usage of ASN1 functions||||null
As a result the use of this `` reuse '' behaviour is strongly discouraged||||null
For OpenSSL 0.9.7 and later||||if i2d_X509_APIParam_2 i2d_X509_AUX_APIParam_2 i2d_re_X509_tbs_APIParam_2 is NULL memory will be allocated for a buffer and the encoded data written to it
This may be fixed in future so code should not assume that i2d_X509_APIName will always succeed||||null
after one structure is encoded or decoded another will processed after it||||null
d2i_X509_APIName, d2i_X509_bio_APIName and d2i_X509_fp_APIName return a valid d2i_X509_APIParam_1 d2i_X509_bio_APIParam_2 d2i_X509_fp_APIParam_2 structure or NULL if an error occurs||||null
The error code that can be obtained by ERR_get_error_APIName||||null
i2d_X509_APIName returns the number of bytes successfully encoded or a negative value if an error occurs||||null
The error code can be obtained by ERR_get_error_APIName||||null
Any function which encodes an X509 structure such as i2d_X509_APIName, i2d_X509_fp_APIName or i2d_X509_bio_APIName may return a stale encoding if the i2d_X509_APIParam_1 i2d_X509_fp_APIParam_2 i2d_X509_bio_APIParam_2 structure has been modified after deserialization or previous serialization||||null
The value returned by that TLS/SSL I/O function must be passed to SSL_get_error_APIName in parameter SSL_get_error_APIParam_2 SSL_get_error_APIParam_2||||null
i2d_X509_bio_APIName and i2d_X509_fp_APIName return 1 for success and 0 if an error occurs The error code can be obtained by ERR_get_error_APIName||||null
The following return values can currently occur||||null
Otherwise , the encoding of the TBSCertificate portion of the i2d_re_X509_tbs_APIParam_1 can be manually renewed by calling i2d_re_X509_tbs_APIName||||null
the encoding is automatically renewed||||If , after modification , the i2d_re_X509_tbs_APIParam_1 object is re-signed with X509_sign_APIName
SSL_get_error_APIName returns a result code  for a preceding call to SSL_connect_APIName, SSL_accept_APIName, SSL_do_handshake_APIName, SSL_read_APIName, SSL_peek_APIName, or SSL_write_APIName on SSL_get_error_APIParam_1 SSL_get_error_APIParam_1||||null
In addition to SSL_get_error_APIParam_1 SSL_get_error_APIParam_1 SSL_get_error_APIParam_1 and SSL_get_error_APIParam_2 SSL_get_error_APIParam_2 SSL_get_error_APIParam_2 , SSL_get_error_APIName inspects the current thread 's OpenSSL error queue||||null
The operation did not complete||||null
the same TLS/SSL I/O function should be called again later||||null
These messages can only appear with a BIO_s_connect_APIName or BIO_s_accept_APIName BIO , respectively||||null
The underlying BIO was not connected yet to the peer and the call would block in connect_APIName/accept_APIName||||null
The TLS/SSL I/O function should be called again later||||null
Thus , SSL_get_error_APIName must be used in the same thread that performed the TLS/SSL I/O operation , and no other OpenSSL function calls should appear in between||||null
The SSL function should be called again||||when the connection is established
The current thread 's error queue must be empty before the TLS/SSL I/O operation is attempted , or SSL_get_error_APIName will not work reliably||||null
Details depend on the application||||null
The operation did not complete||||null
The OpenSSL error queue contains more information on the error||||null
A non-recoverable , fatal error in the SSL library occurred , usually a protocol error||||null
i2d_X509_APIName will not return an error in many versions of OpenSSL, if mandatory fields are not initialized due to a programming error ,then the encoded structure may contain invalid data or omit the fields entirely and will not be parsed by d2i_X509_APIName||||null
These functions load the certificates and private keys into the SSL_CTX or SSL object , respectively||||null
The SSL _ * class of functions only loads certificates and keys into a specific SSL object||||null
select_APIName or poll_APIName for writing on the socket file descriptor can be used||||null
SSL_CTX_use_certificate_APIName loads the certificate SSL_CTX_use_certificate_APIParam_2 SSL_use_certificate_APIParam_2 into SSL_CTX_use_certificate_APIParam_1 , SSL_use_certificate_APIName loads SSL_CTX_use_certificate_APIParam_2 SSL_use_certificate_APIParam_2 into SSL_use_certificate_APIParam_1||||null
SSL_use_certificate_file_APIName loads the certificate from SSL_CTX_use_certificate_file_APIParam_2 SSL_use_certificate_file_APIParam_2 SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_use_certificate_file_APIParam_1||||null
The rest of the certificates needed to form the complete certificate chain can be specified using the SSL_CTX_add_extra_chain_cert_APIName function||||null
the `` reuse '' behaviour of d2i_X509_APIName is broken||||when d2i_X509_APIParam_1 is valid
In some versions of OpenSSL and some parts of the reused structure may persist if some parts of the reused structure are not present in the new one||||null
SSL_CTX_use_certificate_file_APIName loads the first certificate stored in SSL_CTX_use_certificate_file_APIParam_2 SSL_use_certificate_file_APIParam_2 SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1||||null
See the NOTES section on why SSL_CTX_use_certificate_chain_file_APIName should be preferred||||null
SSL_CTX_use_certificate_chain_file_APIName loads a certificate chain from SSL_CTX_use_certificate_chain_file_APIParam_2 into SSL_CTX_use_certificate_chain_file_APIParam_1||||null
no further I/O operations should be performed on the connection and SSL_shutdown_APIName must not be called||||If this error occurs
The formatting SSL_CTX_use_certificate_file_APIParam_3 SSL_use_certificate_file_APIParam_3 of the certificate must be specified from the known types SSL_FILETYPE_PEM , SSL_FILETYPE_ASN1||||null
The SSL_CTX _ * class of functions loads the certificates and keys into the SSL_CTX object SSL_CTX_check_private_key_APIParam_1 SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_certificate_file_APIParam_1 SSL_CTX_use_certificate_ASN1_APIParam_1 SSL_CTX_use_certificate_chain_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1 SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_APIParam_1||||null
The specific information is kept||||when SSL_clear_APIName is called for this SSL object
There is no corresponding function working on a single SSL object||||null
SSL_CTX_use_PrivateKey_APIName adds SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 as private key to SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1||||null
If a certificate has already been set and the private does not belong to the certificate an error is returned||||null
SSL_use_PrivateKey_ASN1_APIName and SSL_use_RSAPrivateKey_ASN1_APIName add the private key to SSL_use_PrivateKey_ASN1_APIParam_2 SSL_use_RSAPrivateKey_ASN1_APIParam_1||||null
SSL_CTX_use_RSAPrivateKey_APIName adds the private key SSL_CTX_use_RSAPrivateKey_APIParam_2 SSL_use_RSAPrivateKey_APIParam_2 of type RSA to SSL_CTX_use_PrivateKey_APIParam_1 SSL_CTX_use_RSAPrivateKey_APIParam_1 SSL_CTX_use_certificate_APIParam_1 SSL_CTX_use_PrivateKey_APIParam_1||||null
SSL_CTX_use_certificate_ASN1_APIName loads the ASN1 encoded certificate from the memory location SSL_CTX_use_certificate_ASN1_APIParam_3 SSL_use_certificate_ASN1_APIParam_2 into SSL_CTX_use_certificate_ASN1_APIParam_1 , SSL_use_certificate_ASN1_APIName loads the ASN1 encoded certificate into SSL_use_certificate_ASN1_APIParam_1||||null
The encoding of the TBSCertificate portion of a certificate is cached in the i2d_X509_APIParam_1 i2d_X509_AUX_APIParam_1 d2i_X509_fp_APIParam_2 d2i_X509_bio_APIParam_2 d2i_X509_AUX_APIParam_1 i2d_re_X509_tbs_APIParam_1 d2i_X509_APIParam_1 i2d_X509_bio_APIParam_2 i2d_X509_fp_APIParam_2 structure internally to improve encoding performance and to ensure certificate signatures are verified correctly in some certificates with broken encodings||||null
SSL_CTX_use_PrivateKey_ASN1_APIName adds the private key of type SSL_CTX_use_PrivateKey_ASN1_APIParam_1 SSL_use_PrivateKey_ASN1_APIParam_1 stored at memory location SSL_CTX_use_PrivateKey_ASN1_APIParam_3 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_2 SSL_use_PrivateKey_ASN1_APIParam_3 SSL_use_RSAPrivateKey_ASN1_APIParam_2 to SSL_CTX_use_PrivateKey_ASN1_APIParam_10 SSL_CTX_use_PrivateKey_ASN1_APIParam_11||||null
SSL_CTX_use_PrivateKey_file_APIName adds the first private key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1||||null
SSL_use_PrivateKey_APIName adds SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 SSL_CTX_use_PrivateKey_APIParam_2 SSL_use_PrivateKey_APIParam_2 as private key to SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_APIParam_1||||null
SSL_CTX_use_RSAPrivateKey_file_APIName adds the first private RSA key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_CTX_use_PrivateKey_file_APIParam_1 SSL_CTX_use_RSAPrivateKey_file_APIParam_1||||null
SSL_check_private_key_APIName performs the same check for SSL_check_private_key_APIParam_1||||null
SSL_CTX_use_RSAPrivateKey_ASN1_APIName adds the private key of type RSA stored at memory location SSL_CTX_use_PrivateKey_ASN1_APIParam_3 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_2 SSL_use_PrivateKey_ASN1_APIParam_3 SSL_use_RSAPrivateKey_ASN1_APIParam_2 to SSL_CTX_use_PrivateKey_ASN1_APIParam_2 SSL_CTX_use_RSAPrivateKey_ASN1_APIParam_1||||null
SSL_use_RSAPrivateKey_APIName adds SSL_CTX_use_PrivateKey_APIParam_20 SSL_CTX_use_PrivateKey_APIParam_21 as private key of type RSA to SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_APIParam_1||||null
The formatting SSL_CTX_use_PrivateKey_file_APIParam_3 SSL_CTX_use_RSAPrivateKey_file_APIParam_3 SSL_use_PrivateKey_file_APIParam_3 SSL_use_RSAPrivateKey_file_APIParam_3 of the certificate must be specified from the known types SSL_FILETYPE_PEM , SSL_FILETYPE_ASN1||||null
SSL_CTX_check_private_key_APIName checks the consistency of a private key with the corresponding certificate loaded into SSL_CTX_check_private_key_APIParam_1||||null
SSL_use_PrivateKey_file_APIName adds the first private key found in SSL_CTX_use_PrivateKey_file_APIParam_2 SSL_CTX_use_RSAPrivateKey_file_APIParam_2 SSL_use_PrivateKey_file_APIParam_2 SSL_use_RSAPrivateKey_file_APIParam_2 to SSL_use_PrivateKey_file_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1||||null
To change a certificate , private key pair the new certificate needs to be set with SSL_use_certificate_APIName or SSL_CTX_use_certificate_APIName before setting the private key with SSL_CTX_use_PrivateKey_APIName or SSL_use_PrivateKey_APIName||||null
SSL_use_RSAPrivateKey_file_APIName adds the first private RSA key found to SSL_use_PrivateKey_file_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1||||null
The internal certificate store of OpenSSL can hold several private key/certificate pairs at a time||||null
The certificate used depends on the cipher selected , see also SSL_CTX_set_cipher_list_APIName||||null
SSL_CTX_use_certificate_chain_file_APIName adds the first certificate found in the file to the certificate store||||null
a function returning the passphrase must have been supplied , see SSL_CTX_set_default_passwd_cb_APIName||||null
The private keys loaded from file can be encrypted||||null
The other certificates are added to the store of chain certificates using SSL_CTX_add1_chain_cert_APIName||||null
the last item installed will be checked||||If more than one key/certificate pair is installed
the RSA key/certificate pair will be checked||||If eg the last item was a RSA certificate or key
the last item added into SSL_CTX_check_private_key_APIParam_1 will be checked||||If no key/certificate was explicitly added for this SSL_check_private_key_APIParam_1
starting with the subject 's certificate , followed by intermediate CA certificates , and ending at the highest level CA||||if applicable
The certificates must be in PEM format and must be sorted||||null
This can only be accomplished by either adding the intermediate CA certificates into the trusted certificate store for the SSL_CTX object , or by adding the chain certificates using the SSL_CTX_add_extra_chain_cert_APIName function , which is only available for the SSL_CTX object as a whole and that probably can only apply for one client certificate , making the concept of the callback function questionable||||null
The information is passed to SSL objects SSL_use_certificate_APIParam_1 SSL_use_PrivateKey_file_APIParam_1 SSL_use_PrivateKey_APIParam_1 SSL_use_RSAPrivateKey_ASN1_APIParam_1 SSL_use_certificate_file_APIParam_1 SSL_use_certificate_ASN1_APIParam_1 SSL_check_private_key_APIParam_1 SSL_use_PrivateKey_ASN1_APIParam_2 SSL_use_RSAPrivateKey_APIParam_1 SSL_use_RSAPrivateKey_file_APIParam_1 created from SSL_use_PrivateKey_file_APIParam_10 SSL_use_PrivateKey_file_APIParam_11 SSL_use_PrivateKey_file_APIParam_12 SSL_use_PrivateKey_file_APIParam_13 SSL_use_PrivateKey_file_APIParam_14 SSL_use_PrivateKey_file_APIParam_15 SSL_use_PrivateKey_file_APIParam_16 SSL_use_PrivateKey_file_APIParam_17 SSL_use_PrivateKey_file_APIParam_18 SSL_use_PrivateKey_file_APIParam_19 SSL_use_PrivateKey_APIParam_10 with SSL_new_APIName by copying , so that changes applied to SSL_use_PrivateKey_file_APIParam_10 SSL_use_PrivateKey_file_APIParam_11 SSL_use_PrivateKey_file_APIParam_12 SSL_use_PrivateKey_file_APIParam_13 SSL_use_PrivateKey_file_APIParam_14 SSL_use_PrivateKey_file_APIParam_15 SSL_use_PrivateKey_file_APIParam_16 SSL_use_PrivateKey_file_APIParam_17 SSL_use_PrivateKey_file_APIParam_18 SSL_use_PrivateKey_file_APIParam_19 SSL_use_PrivateKey_APIParam_10 do not propagate to already existing SSL objects||||null
On success, the functions return 1||||null
Otherwise check out the error stack to find out the reason||||null
The Elliptic Curve library provides a number of different implementations through a single common interface||||null
For Fp curves the lowest common denominator implementation is the EC_GFp_simple_method implementation||||null
Similarly all of the functions to set a new private key will replace any private key that has already been set||||null
All other implementations are based on this one||||null
It is important that the correct implementation type for the form of curve selected is used||||null
For F2 ^ m curves there is only one implementation choice , ie EC_GF2_simple_method||||null
EC_GFp_mont_method builds on EC_GFp_simple_method but adds the use of montgomery multiplication||||null
All of the functions to set a new certificate will replace any existing certificate of the same type that has already been set||||null
The functions described here all return a const pointer to an EC_METHOD_get_field_type_APIParam_1 structure that can be passed to EC_GROUP_NEW||||null
versions of OpenSSL before 1.0.2 only had a single certificate chain store for all certificate types , OpenSSL 1.0.2 and later have a separate chain store for each type||||null
EC_GFp_nist_method offers an implementation optimised for use with NIST recommended curves||||null
All EC_GFp* functions and EC_GF2m_simple_method always return a const pointer to an EC_METHOD structure||||null
Applications should call SSL_CTX_check_private_key_APIName or SSL_check_private_key_APIName as appropriate after loading a new certificate and private key to confirm that the certificate and key match||||null
This function returns the size of an ASN.1 encoded DSA signature in bytes||||null
Note , however , that these implementations are not available on all platforms||||null
EC_METHOD_get_field_type returns an integer that identifies the type of field the EC_METHOD structure supports||||null
The size in bytes||||null
CA certificates are additionally looked up in the locations of trusted CA certificates||||If additional certificates are needed to complete the chain during the TLS negotiation
see SSL_CTX_load_verify_locations_APIName||||null
OPENSSL_no_config_APIName disables configuration||||null
The functions EC_GFp_nistp224_method , EC_GFp_nistp256_method and EC_GFp_nistp521_method offer 64 bit optimised implementations for the NIST P224 , P256 and P521 curves respectively||||null
new ENGINE functionality was added to OpenSSL 0.9.7||||null
Neither OPENSSL_config_APIName nor OPENSSL_no_config_APIName return a value||||null
This function can be used to determine how much memory must be allocated for a DSA signature||||null
There are several reasons why calling the OpenSSL configuration routines is advisable||||null
However very few applications currently support the control interface and so very few can load and use dynamic ENGINEs||||null
Equally in future more sophisticated ENGINEs will require certain control operations to customize them||||null
Applications should free up configuration at application closedown by calling CONF_modules_free_APIName||||null
PKCS7_sign_APIName returns either a valid PKCS7 structure or NULL if an error occurred||||null
Some advanced attributes such as counter signatures are not supported||||null
The error can be obtained from ERR_get_error_APIName||||null
In OpenSSL 0.9.7 control functions can be supported by ENGINEs , this can be used to load dynamic ENGINEs from shared libraries||||null
no trusted CA storage is used||||even when
SSL_CTX_use_certificate_chain_file_APIName should be used instead of the SSL_CTX_use_certificate_file_APIName function in order to allow the use of complete certificate chains or when the CA issuing the certificate shall not be added to the trusted CA storage||||null
CMS_decrypt_APIName extracts and decrypts the content from a CMS EnvelopedData structure||||null
The CMS_decrypt_APIParam_4 parameter will normally be set to NULL||||null
The CMS_decrypt_APIParam_4 parameter is used in the rare case where the encrypted content is detached||||null
OpenSSL_add_all_algorithms_APIName should be called before using this function or errors about unknown algorithms will occur||||null
The following flags can be passed in the CMS_decrypt_APIParam_6 parameter||||null
triple DES , 128 bit RC2 , 64 bit RC2 , DES and 40 bit RC2||||null
The error can be obtained from ERR_get_error_APIName||||null
CMS_decrypt_APIName returns either 1 for success or 0 for failure||||null
both CMS_decrypt_APIParam_3 and CMS_decrypt_APIParam_2 should be set to NULL||||null
it does not need to know or care about ENGINE control operations a configuration file||||If an application calls OPENSSL_config_APIName
The SSL_CTX object uses SSL_CTX_new_APIParam_1 as connection method||||null
the recipients certificate is needed to locate the appropriate recipients in the CMS structure||||null
SSL_CTX_new_APIParam_1 can be of the following types||||null
SSL_CTX_new_APIName creates a new SSL_CTX_new_APIParam_0 object as framework to establish TLS/SSL enabled connections||||null
A server will only understand TLSv1 .2 client hello messages||||null
A TLS/SSL connection established with these methods will only understand the TLSv1 .2 protocol||||null
To process KEKRecipientInfo types CMS_set1_key_APIName or CMS_RecipientInfo_set0_key_APIName and CMS_ReceipientInfo_decrypt_APIName should be called before CMS_decrypt_APIName and CMS_decrypt_APIParam_3 and CMS_decrypt_APIParam_2 set to NULL||||null
A server will only understand TLSv1 .1 client hello messages||||null
A TLS/SSL connection established with these methods will only understand the TLSv1 .1 protocol||||null
A client will send out TLSv1 .2 client hello messages and will also indicate that it only understand TLSv1 .2||||null
The lack of single pass processing and the need to hold all data in memory as mentioned in CMS_verify_APIName also applies to CMS_decrypt_APIName||||null
The methods exist in a generic type , a server only type , and a client only type||||null
A server will only understand TLSv1 client hello messages||||null
CMS_decrypt_APIParam_2 is the private key of the recipient , CMS_decrypt_APIParam_3 is the recipient 's certificate , CMS_decrypt_APIParam_5 is a BIO to write the content to and CMS_decrypt_APIParam_6 is an optional set of flags||||null
A client will send out TLSv1 .1 client hello messages and will also indicate that it only understand TLSv1 .1||||null
A TLS/SSL connection established with these methods will only understand the TLSv1 protocol||||null
A TLS/SSL connection established with these methods will only understand the SSLv3 protocol||||null
A client will send out TLSv1 client hello messages and will indicate that it only understands TLSv1||||null
A server will only understand SSLv3 client hello messages||||null
The SSLv3 protocol is deprecated and should not be used||||null
A client will send out SSLv3 client hello messages and will indicate that it only understands SSLv3||||null
A server will only understand SSLv2 client hello messages||||null
It is possible to determine the correct recipient key by other means and setting them in the CMS structure in advance using the CMS utility functions such as CMS_set1_pkey_APIName||||null
A TLS/SSL connection established with these methods will only understand the SSLv2 protocol||||null
The SSLv2 protocol offers little to no security and should not be used||||null
These are the version-flexible DTLS methods||||null
These are the version-specific methods for DTLSv1 .2||||null
The following return values can occur||||null
A client will send out SSLv2 client hello messages and will also indicate that it only understand SSLv2||||null
These are the version-specific methods for DTLSv1||||null
The return value points to an allocated SSL_CTX object||||null
As of OpenSSL 1.0.2 g , EXPORT ciphers and 56-bit DES are no longer available with SSLv2||||null
The creation of a new SSL_CTX object failed||||null
OCSP_resp_count_APIName returns the number of OCSP_single_get0_status_APIParam_1 structures in OCSP_resp_count_APIParam_1||||null
OCSP_resp_get0_APIName returns the OCSP_resp_get0_APIParam_0 structure in OCSP_resp_get0_APIParam_1 corresponding to index OCSP_resp_get0_APIParam_2||||null
Check the error stack to find out the reason||||null
Where OCSP_resp_get0_APIParam_2 runs from 0 to OCSP_resp_count - 1||||null
OCSP_resp_get0_signature_APIName returns the signature from OCSP_resp_get0_signature_APIParam_1||||null
OCSP_resp_count_APIName returns the total number of OCSP_single_get0_status_APIParam_1 fields in OCSP_resp_count_APIParam_1||||null
OCSP_resp_find_status_APIName returns 1 if OCSP_resp_find_status_APIParam_2 is found in OCSP_resp_find_status_APIParam_1 and 0 otherwise||||null
OCSP_resp_get0_certs_APIName returns any certificates included in OCSP_resp_get0_APIParam_1 OCSP_resp_get0_id_APIParam_1 OCSP_resp_get0_tbs_sigalg_APIParam_1 OCSP_resp_count_APIParam_1 OCSP_resp_get0_signature_APIParam_1 OCSP_resp_get0_signer_APIParam_1 OCSP_resp_find_status_APIParam_1 OCSP_resp_find_APIParam_1 OCSP_resp_get1_id_APIParam_1 OCSP_resp_get0_respdata_APIParam_1||||null
OCSP_resp_get0_APIName returns a pointer to an OCSP_resp_get0_APIParam_0 structure or NULL if OCSP_resp_get0_APIParam_2 is out of range||||null
OCSP_single_get0_status_APIName returns the status of OCSP_single_get0_status_APIParam_1 or -1 if an error occurred||||null
OCSP_resp_find_APIName returns the index of OCSP_resp_find_APIParam_2 in OCSP_resp_find_APIParam_1  or -1 if OCSP_resp_find_APIParam_2 was not found||||null
OCSP_resp_find_APIName searches OCSP_resp_find_APIParam_1 for OCSP_resp_find_APIParam_2 and returns the index of the first matching entry after OCSP_resp_find_APIParam_3 or starting from the beginning if OCSP_resp_find_APIParam_3 is -1||||null
OCSP_resp_get0_signer_APIName returns 1 if the signing certificate was located, or 0 on error||||null
SSL_CTX_new_APIName initializes the list of ciphers , the session cache setting , the callbacks , the keys and certificates and the options to SSL_CTX_new_APIName default values||||null
OCSP_basic_verify_APIName returns 1 on success, 0 on error, or -1 on fatal error such as malloc failure||||null
They can take appropriate action based on the status of the certificate||||null
Applications will typically call OCSP_resp_find_status_APIName using the certificate ID of interest and check its validity using OCSP_check_validity_APIName||||null
